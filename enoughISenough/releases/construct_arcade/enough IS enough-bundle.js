(()=>{var wr=Object.create,Re=Object.defineProperty;var Ar=Object.getOwnPropertyDescriptor;var Tr=Object.getOwnPropertyNames;var Sr=Object.getPrototypeOf,Or=Object.prototype.hasOwnProperty;var Rr=e=>Re(e,"__esModule",{value:!0});var $=(e,t)=>()=>(e&&(t=e(e=0)),t),H=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports);var Lr=(e,t,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Tr(t))!Or.call(e,n)&&n!=="default"&&Re(e,n,{get:()=>t[n],enumerable:!(r=Ar(t,n))||r.enumerable});return e},J=e=>Lr(Rr(Re(e!=null?wr(Sr(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var Z=H(G=>{"use strict";Object.defineProperty(G,"__esModule",{value:!0});G.setMatrixArrayType=Pr;G.toRadian=Ir;G.equals=Wr;G.RANDOM=G.ARRAY_TYPE=G.EPSILON=void 0;var Ye=1e-6;G.EPSILON=Ye;var He=typeof Float32Array!="undefined"?Float32Array:Array;G.ARRAY_TYPE=He;var qr=Math.random;G.RANDOM=qr;function Pr(e){G.ARRAY_TYPE=He=e}var Er=Math.PI/180;function Ir(e){return e*Er}function Wr(e,t){return Math.abs(e-t)<=Ye*Math.max(1,Math.abs(e),Math.abs(t))}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)})});var Be=H(j=>{"use strict";function ue(e){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?ue=function(r){return typeof r}:ue=function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},ue(e)}Object.defineProperty(j,"__esModule",{value:!0});j.create=Cr;j.clone=Dr;j.copy=Fr;j.identity=jr;j.fromValues=kr;j.set=zr;j.transpose=Yr;j.invert=Hr;j.adjoint=Vr;j.determinant=Nr;j.multiply=Ve;j.rotate=Xr;j.scale=Br;j.fromRotation=Gr;j.fromScaling=Qr;j.str=Ur;j.frob=Zr;j.LDU=$r;j.add=Jr;j.subtract=Ne;j.exactEquals=Kr;j.equals=en;j.multiplyScalar=tn;j.multiplyScalarAndAdd=rn;j.sub=j.mul=void 0;var se=nn(Z());function Xe(){if(typeof WeakMap!="function")return null;var e=new WeakMap;return Xe=function(){return e},e}function nn(e){if(e&&e.__esModule)return e;if(e===null||ue(e)!=="object"&&typeof e!="function")return{default:e};var t=Xe();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var s=n?Object.getOwnPropertyDescriptor(e,a):null;s&&(s.get||s.set)?Object.defineProperty(r,a,s):r[a]=e[a]}return r.default=e,t&&t.set(e,r),r}function Cr(){var e=new se.ARRAY_TYPE(4);return se.ARRAY_TYPE!=Float32Array&&(e[1]=0,e[2]=0),e[0]=1,e[3]=1,e}function Dr(e){var t=new se.ARRAY_TYPE(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function Fr(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function jr(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e}function kr(e,t,r,n){var a=new se.ARRAY_TYPE(4);return a[0]=e,a[1]=t,a[2]=r,a[3]=n,a}function zr(e,t,r,n,a){return e[0]=t,e[1]=r,e[2]=n,e[3]=a,e}function Yr(e,t){if(e===t){var r=t[1];e[1]=t[2],e[2]=r}else e[0]=t[0],e[1]=t[2],e[2]=t[1],e[3]=t[3];return e}function Hr(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=r*s-a*n;return c?(c=1/c,e[0]=s*c,e[1]=-n*c,e[2]=-a*c,e[3]=r*c,e):null}function Vr(e,t){var r=t[0];return e[0]=t[3],e[1]=-t[1],e[2]=-t[2],e[3]=r,e}function Nr(e){return e[0]*e[3]-e[2]*e[1]}function Ve(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=r[0],h=r[1],u=r[2],i=r[3];return e[0]=n*l+s*h,e[1]=a*l+c*h,e[2]=n*u+s*i,e[3]=a*u+c*i,e}function Xr(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=Math.sin(r),h=Math.cos(r);return e[0]=n*h+s*l,e[1]=a*h+c*l,e[2]=n*-l+s*h,e[3]=a*-l+c*h,e}function Br(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=r[0],h=r[1];return e[0]=n*l,e[1]=a*l,e[2]=s*h,e[3]=c*h,e}function Gr(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=-r,e[3]=n,e}function Qr(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=t[1],e}function Ur(e){return"mat2("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"}function Zr(e){return Math.hypot(e[0],e[1],e[2],e[3])}function $r(e,t,r,n){return e[2]=n[2]/n[0],r[0]=n[0],r[1]=n[1],r[3]=n[3]-e[2]*r[1],[e,t,r]}function Jr(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e}function Ne(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e}function Kr(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]}function en(e,t){var r=e[0],n=e[1],a=e[2],s=e[3],c=t[0],l=t[1],h=t[2],u=t[3];return Math.abs(r-c)<=se.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(n-l)<=se.EPSILON*Math.max(1,Math.abs(n),Math.abs(l))&&Math.abs(a-h)<=se.EPSILON*Math.max(1,Math.abs(a),Math.abs(h))&&Math.abs(s-u)<=se.EPSILON*Math.max(1,Math.abs(s),Math.abs(u))}function tn(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e}function rn(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e}var an=Ve;j.mul=an;var sn=Ne;j.sub=sn});var Ze=H(k=>{"use strict";function pe(e){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?pe=function(r){return typeof r}:pe=function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},pe(e)}Object.defineProperty(k,"__esModule",{value:!0});k.create=on;k.clone=cn;k.copy=ln;k.identity=fn;k.fromValues=hn;k.set=dn;k.invert=un;k.determinant=pn;k.multiply=Ge;k.rotate=vn;k.scale=_n;k.translate=mn;k.fromRotation=yn;k.fromScaling=gn;k.fromTranslation=Mn;k.str=bn;k.frob=xn;k.add=wn;k.subtract=Qe;k.multiplyScalar=An;k.multiplyScalarAndAdd=Tn;k.exactEquals=Sn;k.equals=On;k.sub=k.mul=void 0;var K=Rn(Z());function Ue(){if(typeof WeakMap!="function")return null;var e=new WeakMap;return Ue=function(){return e},e}function Rn(e){if(e&&e.__esModule)return e;if(e===null||pe(e)!=="object"&&typeof e!="function")return{default:e};var t=Ue();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var s=n?Object.getOwnPropertyDescriptor(e,a):null;s&&(s.get||s.set)?Object.defineProperty(r,a,s):r[a]=e[a]}return r.default=e,t&&t.set(e,r),r}function on(){var e=new K.ARRAY_TYPE(6);return K.ARRAY_TYPE!=Float32Array&&(e[1]=0,e[2]=0,e[4]=0,e[5]=0),e[0]=1,e[3]=1,e}function cn(e){var t=new K.ARRAY_TYPE(6);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t}function ln(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function fn(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e}function hn(e,t,r,n,a,s){var c=new K.ARRAY_TYPE(6);return c[0]=e,c[1]=t,c[2]=r,c[3]=n,c[4]=a,c[5]=s,c}function dn(e,t,r,n,a,s,c){return e[0]=t,e[1]=r,e[2]=n,e[3]=a,e[4]=s,e[5]=c,e}function un(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=t[4],l=t[5],h=r*s-n*a;return h?(h=1/h,e[0]=s*h,e[1]=-n*h,e[2]=-a*h,e[3]=r*h,e[4]=(a*l-s*c)*h,e[5]=(n*c-r*l)*h,e):null}function pn(e){return e[0]*e[3]-e[1]*e[2]}function Ge(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=t[4],h=t[5],u=r[0],i=r[1],o=r[2],f=r[3],d=r[4],v=r[5];return e[0]=n*u+s*i,e[1]=a*u+c*i,e[2]=n*o+s*f,e[3]=a*o+c*f,e[4]=n*d+s*v+l,e[5]=a*d+c*v+h,e}function vn(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=t[4],h=t[5],u=Math.sin(r),i=Math.cos(r);return e[0]=n*i+s*u,e[1]=a*i+c*u,e[2]=n*-u+s*i,e[3]=a*-u+c*i,e[4]=l,e[5]=h,e}function _n(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=t[4],h=t[5],u=r[0],i=r[1];return e[0]=n*u,e[1]=a*u,e[2]=s*i,e[3]=c*i,e[4]=l,e[5]=h,e}function mn(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=t[4],h=t[5],u=r[0],i=r[1];return e[0]=n,e[1]=a,e[2]=s,e[3]=c,e[4]=n*u+s*i+l,e[5]=a*u+c*i+h,e}function yn(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=-r,e[3]=n,e[4]=0,e[5]=0,e}function gn(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=t[1],e[4]=0,e[5]=0,e}function Mn(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=t[0],e[5]=t[1],e}function bn(e){return"mat2d("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+")"}function xn(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],1)}function wn(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e}function Qe(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e[4]=t[4]-r[4],e[5]=t[5]-r[5],e}function An(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*r,e[5]=t[5]*r,e}function Tn(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e[4]=t[4]+r[4]*n,e[5]=t[5]+r[5]*n,e}function Sn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function On(e,t){var r=e[0],n=e[1],a=e[2],s=e[3],c=e[4],l=e[5],h=t[0],u=t[1],i=t[2],o=t[3],f=t[4],d=t[5];return Math.abs(r-h)<=K.EPSILON*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(n-u)<=K.EPSILON*Math.max(1,Math.abs(n),Math.abs(u))&&Math.abs(a-i)<=K.EPSILON*Math.max(1,Math.abs(a),Math.abs(i))&&Math.abs(s-o)<=K.EPSILON*Math.max(1,Math.abs(s),Math.abs(o))&&Math.abs(c-f)<=K.EPSILON*Math.max(1,Math.abs(c),Math.abs(f))&&Math.abs(l-d)<=K.EPSILON*Math.max(1,Math.abs(l),Math.abs(d))}var Ln=Ge;k.mul=Ln;var Pn=Qe;k.sub=Pn});var Le=H(W=>{"use strict";function ve(e){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?ve=function(r){return typeof r}:ve=function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},ve(e)}Object.defineProperty(W,"__esModule",{value:!0});W.create=In;W.fromMat4=Wn;W.clone=qn;W.copy=En;W.fromValues=Cn;W.set=Dn;W.identity=Fn;W.transpose=jn;W.invert=kn;W.adjoint=zn;W.determinant=Yn;W.multiply=$e;W.translate=Hn;W.rotate=Vn;W.scale=Nn;W.fromTranslation=Xn;W.fromRotation=Bn;W.fromScaling=Gn;W.fromMat2d=Qn;W.fromQuat=Un;W.normalFromMat4=Zn;W.projection=$n;W.str=Jn;W.frob=Kn;W.add=ei;W.subtract=Je;W.multiplyScalar=ti;W.multiplyScalarAndAdd=ri;W.exactEquals=ni;W.equals=ii;W.sub=W.mul=void 0;var X=ai(Z());function Ke(){if(typeof WeakMap!="function")return null;var e=new WeakMap;return Ke=function(){return e},e}function ai(e){if(e&&e.__esModule)return e;if(e===null||ve(e)!=="object"&&typeof e!="function")return{default:e};var t=Ke();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var s=n?Object.getOwnPropertyDescriptor(e,a):null;s&&(s.get||s.set)?Object.defineProperty(r,a,s):r[a]=e[a]}return r.default=e,t&&t.set(e,r),r}function In(){var e=new X.ARRAY_TYPE(9);return X.ARRAY_TYPE!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function Wn(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function qn(e){var t=new X.ARRAY_TYPE(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function En(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function Cn(e,t,r,n,a,s,c,l,h){var u=new X.ARRAY_TYPE(9);return u[0]=e,u[1]=t,u[2]=r,u[3]=n,u[4]=a,u[5]=s,u[6]=c,u[7]=l,u[8]=h,u}function Dn(e,t,r,n,a,s,c,l,h,u){return e[0]=t,e[1]=r,e[2]=n,e[3]=a,e[4]=s,e[5]=c,e[6]=l,e[7]=h,e[8]=u,e}function Fn(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function jn(e,t){if(e===t){var r=t[1],n=t[2],a=t[5];e[1]=t[3],e[2]=t[6],e[3]=r,e[5]=t[7],e[6]=n,e[7]=a}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function kn(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=t[4],l=t[5],h=t[6],u=t[7],i=t[8],o=i*c-l*u,f=-i*s+l*h,d=u*s-c*h,v=r*o+n*f+a*d;return v?(v=1/v,e[0]=o*v,e[1]=(-i*n+a*u)*v,e[2]=(l*n-a*c)*v,e[3]=f*v,e[4]=(i*r-a*h)*v,e[5]=(-l*r+a*s)*v,e[6]=d*v,e[7]=(-u*r+n*h)*v,e[8]=(c*r-n*s)*v,e):null}function zn(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=t[4],l=t[5],h=t[6],u=t[7],i=t[8];return e[0]=c*i-l*u,e[1]=a*u-n*i,e[2]=n*l-a*c,e[3]=l*h-s*i,e[4]=r*i-a*h,e[5]=a*s-r*l,e[6]=s*u-c*h,e[7]=n*h-r*u,e[8]=r*c-n*s,e}function Yn(e){var t=e[0],r=e[1],n=e[2],a=e[3],s=e[4],c=e[5],l=e[6],h=e[7],u=e[8];return t*(u*s-c*h)+r*(-u*a+c*l)+n*(h*a-s*l)}function $e(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=t[4],h=t[5],u=t[6],i=t[7],o=t[8],f=r[0],d=r[1],v=r[2],_=r[3],p=r[4],m=r[5],y=r[6],g=r[7],M=r[8];return e[0]=f*n+d*c+v*u,e[1]=f*a+d*l+v*i,e[2]=f*s+d*h+v*o,e[3]=_*n+p*c+m*u,e[4]=_*a+p*l+m*i,e[5]=_*s+p*h+m*o,e[6]=y*n+g*c+M*u,e[7]=y*a+g*l+M*i,e[8]=y*s+g*h+M*o,e}function Hn(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=t[4],h=t[5],u=t[6],i=t[7],o=t[8],f=r[0],d=r[1];return e[0]=n,e[1]=a,e[2]=s,e[3]=c,e[4]=l,e[5]=h,e[6]=f*n+d*c+u,e[7]=f*a+d*l+i,e[8]=f*s+d*h+o,e}function Vn(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=t[4],h=t[5],u=t[6],i=t[7],o=t[8],f=Math.sin(r),d=Math.cos(r);return e[0]=d*n+f*c,e[1]=d*a+f*l,e[2]=d*s+f*h,e[3]=d*c-f*n,e[4]=d*l-f*a,e[5]=d*h-f*s,e[6]=u,e[7]=i,e[8]=o,e}function Nn(e,t,r){var n=r[0],a=r[1];return e[0]=n*t[0],e[1]=n*t[1],e[2]=n*t[2],e[3]=a*t[3],e[4]=a*t[4],e[5]=a*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function Xn(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Bn(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=0,e[3]=-r,e[4]=n,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Gn(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Qn(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Un(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=r+r,l=n+n,h=a+a,u=r*c,i=n*c,o=n*l,f=a*c,d=a*l,v=a*h,_=s*c,p=s*l,m=s*h;return e[0]=1-o-v,e[3]=i-m,e[6]=f+p,e[1]=i+m,e[4]=1-u-v,e[7]=d-_,e[2]=f-p,e[5]=d+_,e[8]=1-u-o,e}function Zn(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=t[4],l=t[5],h=t[6],u=t[7],i=t[8],o=t[9],f=t[10],d=t[11],v=t[12],_=t[13],p=t[14],m=t[15],y=r*l-n*c,g=r*h-a*c,M=r*u-s*c,b=n*h-a*l,x=n*u-s*l,q=a*u-s*h,S=i*_-o*v,D=i*p-f*v,C=i*m-d*v,z=o*p-f*_,F=o*m-d*_,E=f*m-d*p,P=y*E-g*F+M*z+b*C-x*D+q*S;return P?(P=1/P,e[0]=(l*E-h*F+u*z)*P,e[1]=(h*C-c*E-u*D)*P,e[2]=(c*F-l*C+u*S)*P,e[3]=(a*F-n*E-s*z)*P,e[4]=(r*E-a*C+s*D)*P,e[5]=(n*C-r*F-s*S)*P,e[6]=(_*q-p*x+m*b)*P,e[7]=(p*M-v*q-m*g)*P,e[8]=(v*x-_*M+m*y)*P,e):null}function $n(e,t,r){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/r,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Jn(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Kn(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function ei(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e[6]=t[6]+r[6],e[7]=t[7]+r[7],e[8]=t[8]+r[8],e}function Je(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e[4]=t[4]-r[4],e[5]=t[5]-r[5],e[6]=t[6]-r[6],e[7]=t[7]-r[7],e[8]=t[8]-r[8],e}function ti(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*r,e[5]=t[5]*r,e[6]=t[6]*r,e[7]=t[7]*r,e[8]=t[8]*r,e}function ri(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e[4]=t[4]+r[4]*n,e[5]=t[5]+r[5]*n,e[6]=t[6]+r[6]*n,e[7]=t[7]+r[7]*n,e[8]=t[8]+r[8]*n,e}function ni(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function ii(e,t){var r=e[0],n=e[1],a=e[2],s=e[3],c=e[4],l=e[5],h=e[6],u=e[7],i=e[8],o=t[0],f=t[1],d=t[2],v=t[3],_=t[4],p=t[5],m=t[6],y=t[7],g=t[8];return Math.abs(r-o)<=X.EPSILON*Math.max(1,Math.abs(r),Math.abs(o))&&Math.abs(n-f)<=X.EPSILON*Math.max(1,Math.abs(n),Math.abs(f))&&Math.abs(a-d)<=X.EPSILON*Math.max(1,Math.abs(a),Math.abs(d))&&Math.abs(s-v)<=X.EPSILON*Math.max(1,Math.abs(s),Math.abs(v))&&Math.abs(c-_)<=X.EPSILON*Math.max(1,Math.abs(c),Math.abs(_))&&Math.abs(l-p)<=X.EPSILON*Math.max(1,Math.abs(l),Math.abs(p))&&Math.abs(h-m)<=X.EPSILON*Math.max(1,Math.abs(h),Math.abs(m))&&Math.abs(u-y)<=X.EPSILON*Math.max(1,Math.abs(u),Math.abs(y))&&Math.abs(i-g)<=X.EPSILON*Math.max(1,Math.abs(i),Math.abs(g))}var si=$e;W.mul=si;var oi=Je;W.sub=oi});var Pe=H(O=>{"use strict";function _e(e){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?_e=function(r){return typeof r}:_e=function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},_e(e)}Object.defineProperty(O,"__esModule",{value:!0});O.create=ci;O.clone=li;O.copy=fi;O.fromValues=hi;O.set=di;O.identity=et;O.transpose=ui;O.invert=pi;O.adjoint=vi;O.determinant=_i;O.multiply=tt;O.translate=mi;O.scale=yi;O.rotate=gi;O.rotateX=Mi;O.rotateY=bi;O.rotateZ=xi;O.fromTranslation=wi;O.fromScaling=Ai;O.fromRotation=Ti;O.fromXRotation=Si;O.fromYRotation=Oi;O.fromZRotation=Ri;O.fromRotationTranslation=rt;O.fromQuat2=Li;O.getTranslation=Pi;O.getScaling=nt;O.getRotation=Ii;O.fromRotationTranslationScale=Wi;O.fromRotationTranslationScaleOrigin=qi;O.fromQuat=Ei;O.frustum=Ci;O.perspective=Di;O.perspectiveFromFieldOfView=Fi;O.ortho=ji;O.lookAt=ki;O.targetTo=zi;O.str=Yi;O.frob=Hi;O.add=Vi;O.subtract=it;O.multiplyScalar=Ni;O.multiplyScalarAndAdd=Xi;O.exactEquals=Bi;O.equals=Gi;O.sub=O.mul=void 0;var Y=Qi(Z());function at(){if(typeof WeakMap!="function")return null;var e=new WeakMap;return at=function(){return e},e}function Qi(e){if(e&&e.__esModule)return e;if(e===null||_e(e)!=="object"&&typeof e!="function")return{default:e};var t=at();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var s=n?Object.getOwnPropertyDescriptor(e,a):null;s&&(s.get||s.set)?Object.defineProperty(r,a,s):r[a]=e[a]}return r.default=e,t&&t.set(e,r),r}function ci(){var e=new Y.ARRAY_TYPE(16);return Y.ARRAY_TYPE!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function li(e){var t=new Y.ARRAY_TYPE(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function fi(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function hi(e,t,r,n,a,s,c,l,h,u,i,o,f,d,v,_){var p=new Y.ARRAY_TYPE(16);return p[0]=e,p[1]=t,p[2]=r,p[3]=n,p[4]=a,p[5]=s,p[6]=c,p[7]=l,p[8]=h,p[9]=u,p[10]=i,p[11]=o,p[12]=f,p[13]=d,p[14]=v,p[15]=_,p}function di(e,t,r,n,a,s,c,l,h,u,i,o,f,d,v,_,p){return e[0]=t,e[1]=r,e[2]=n,e[3]=a,e[4]=s,e[5]=c,e[6]=l,e[7]=h,e[8]=u,e[9]=i,e[10]=o,e[11]=f,e[12]=d,e[13]=v,e[14]=_,e[15]=p,e}function et(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function ui(e,t){if(e===t){var r=t[1],n=t[2],a=t[3],s=t[6],c=t[7],l=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=r,e[6]=t[9],e[7]=t[13],e[8]=n,e[9]=s,e[11]=t[14],e[12]=a,e[13]=c,e[14]=l}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function pi(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=t[4],l=t[5],h=t[6],u=t[7],i=t[8],o=t[9],f=t[10],d=t[11],v=t[12],_=t[13],p=t[14],m=t[15],y=r*l-n*c,g=r*h-a*c,M=r*u-s*c,b=n*h-a*l,x=n*u-s*l,q=a*u-s*h,S=i*_-o*v,D=i*p-f*v,C=i*m-d*v,z=o*p-f*_,F=o*m-d*_,E=f*m-d*p,P=y*E-g*F+M*z+b*C-x*D+q*S;return P?(P=1/P,e[0]=(l*E-h*F+u*z)*P,e[1]=(a*F-n*E-s*z)*P,e[2]=(_*q-p*x+m*b)*P,e[3]=(f*x-o*q-d*b)*P,e[4]=(h*C-c*E-u*D)*P,e[5]=(r*E-a*C+s*D)*P,e[6]=(p*M-v*q-m*g)*P,e[7]=(i*q-f*M+d*g)*P,e[8]=(c*F-l*C+u*S)*P,e[9]=(n*C-r*F-s*S)*P,e[10]=(v*x-_*M+m*y)*P,e[11]=(o*M-i*x-d*y)*P,e[12]=(l*D-c*z-h*S)*P,e[13]=(r*z-n*D+a*S)*P,e[14]=(_*g-v*b-p*y)*P,e[15]=(i*b-o*g+f*y)*P,e):null}function vi(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=t[4],l=t[5],h=t[6],u=t[7],i=t[8],o=t[9],f=t[10],d=t[11],v=t[12],_=t[13],p=t[14],m=t[15];return e[0]=l*(f*m-d*p)-o*(h*m-u*p)+_*(h*d-u*f),e[1]=-(n*(f*m-d*p)-o*(a*m-s*p)+_*(a*d-s*f)),e[2]=n*(h*m-u*p)-l*(a*m-s*p)+_*(a*u-s*h),e[3]=-(n*(h*d-u*f)-l*(a*d-s*f)+o*(a*u-s*h)),e[4]=-(c*(f*m-d*p)-i*(h*m-u*p)+v*(h*d-u*f)),e[5]=r*(f*m-d*p)-i*(a*m-s*p)+v*(a*d-s*f),e[6]=-(r*(h*m-u*p)-c*(a*m-s*p)+v*(a*u-s*h)),e[7]=r*(h*d-u*f)-c*(a*d-s*f)+i*(a*u-s*h),e[8]=c*(o*m-d*_)-i*(l*m-u*_)+v*(l*d-u*o),e[9]=-(r*(o*m-d*_)-i*(n*m-s*_)+v*(n*d-s*o)),e[10]=r*(l*m-u*_)-c*(n*m-s*_)+v*(n*u-s*l),e[11]=-(r*(l*d-u*o)-c*(n*d-s*o)+i*(n*u-s*l)),e[12]=-(c*(o*p-f*_)-i*(l*p-h*_)+v*(l*f-h*o)),e[13]=r*(o*p-f*_)-i*(n*p-a*_)+v*(n*f-a*o),e[14]=-(r*(l*p-h*_)-c*(n*p-a*_)+v*(n*h-a*l)),e[15]=r*(l*f-h*o)-c*(n*f-a*o)+i*(n*h-a*l),e}function _i(e){var t=e[0],r=e[1],n=e[2],a=e[3],s=e[4],c=e[5],l=e[6],h=e[7],u=e[8],i=e[9],o=e[10],f=e[11],d=e[12],v=e[13],_=e[14],p=e[15],m=t*c-r*s,y=t*l-n*s,g=t*h-a*s,M=r*l-n*c,b=r*h-a*c,x=n*h-a*l,q=u*v-i*d,S=u*_-o*d,D=u*p-f*d,C=i*_-o*v,z=i*p-f*v,F=o*p-f*_;return m*F-y*z+g*C+M*D-b*S+x*q}function tt(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=t[4],h=t[5],u=t[6],i=t[7],o=t[8],f=t[9],d=t[10],v=t[11],_=t[12],p=t[13],m=t[14],y=t[15],g=r[0],M=r[1],b=r[2],x=r[3];return e[0]=g*n+M*l+b*o+x*_,e[1]=g*a+M*h+b*f+x*p,e[2]=g*s+M*u+b*d+x*m,e[3]=g*c+M*i+b*v+x*y,g=r[4],M=r[5],b=r[6],x=r[7],e[4]=g*n+M*l+b*o+x*_,e[5]=g*a+M*h+b*f+x*p,e[6]=g*s+M*u+b*d+x*m,e[7]=g*c+M*i+b*v+x*y,g=r[8],M=r[9],b=r[10],x=r[11],e[8]=g*n+M*l+b*o+x*_,e[9]=g*a+M*h+b*f+x*p,e[10]=g*s+M*u+b*d+x*m,e[11]=g*c+M*i+b*v+x*y,g=r[12],M=r[13],b=r[14],x=r[15],e[12]=g*n+M*l+b*o+x*_,e[13]=g*a+M*h+b*f+x*p,e[14]=g*s+M*u+b*d+x*m,e[15]=g*c+M*i+b*v+x*y,e}function mi(e,t,r){var n=r[0],a=r[1],s=r[2],c,l,h,u,i,o,f,d,v,_,p,m;return t===e?(e[12]=t[0]*n+t[4]*a+t[8]*s+t[12],e[13]=t[1]*n+t[5]*a+t[9]*s+t[13],e[14]=t[2]*n+t[6]*a+t[10]*s+t[14],e[15]=t[3]*n+t[7]*a+t[11]*s+t[15]):(c=t[0],l=t[1],h=t[2],u=t[3],i=t[4],o=t[5],f=t[6],d=t[7],v=t[8],_=t[9],p=t[10],m=t[11],e[0]=c,e[1]=l,e[2]=h,e[3]=u,e[4]=i,e[5]=o,e[6]=f,e[7]=d,e[8]=v,e[9]=_,e[10]=p,e[11]=m,e[12]=c*n+i*a+v*s+t[12],e[13]=l*n+o*a+_*s+t[13],e[14]=h*n+f*a+p*s+t[14],e[15]=u*n+d*a+m*s+t[15]),e}function yi(e,t,r){var n=r[0],a=r[1],s=r[2];return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*a,e[5]=t[5]*a,e[6]=t[6]*a,e[7]=t[7]*a,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=t[11]*s,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function gi(e,t,r,n){var a=n[0],s=n[1],c=n[2],l=Math.hypot(a,s,c),h,u,i,o,f,d,v,_,p,m,y,g,M,b,x,q,S,D,C,z,F,E,P,U;return l<Y.EPSILON?null:(l=1/l,a*=l,s*=l,c*=l,h=Math.sin(r),u=Math.cos(r),i=1-u,o=t[0],f=t[1],d=t[2],v=t[3],_=t[4],p=t[5],m=t[6],y=t[7],g=t[8],M=t[9],b=t[10],x=t[11],q=a*a*i+u,S=s*a*i+c*h,D=c*a*i-s*h,C=a*s*i-c*h,z=s*s*i+u,F=c*s*i+a*h,E=a*c*i+s*h,P=s*c*i-a*h,U=c*c*i+u,e[0]=o*q+_*S+g*D,e[1]=f*q+p*S+M*D,e[2]=d*q+m*S+b*D,e[3]=v*q+y*S+x*D,e[4]=o*C+_*z+g*F,e[5]=f*C+p*z+M*F,e[6]=d*C+m*z+b*F,e[7]=v*C+y*z+x*F,e[8]=o*E+_*P+g*U,e[9]=f*E+p*P+M*U,e[10]=d*E+m*P+b*U,e[11]=v*E+y*P+x*U,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function Mi(e,t,r){var n=Math.sin(r),a=Math.cos(r),s=t[4],c=t[5],l=t[6],h=t[7],u=t[8],i=t[9],o=t[10],f=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*a+u*n,e[5]=c*a+i*n,e[6]=l*a+o*n,e[7]=h*a+f*n,e[8]=u*a-s*n,e[9]=i*a-c*n,e[10]=o*a-l*n,e[11]=f*a-h*n,e}function bi(e,t,r){var n=Math.sin(r),a=Math.cos(r),s=t[0],c=t[1],l=t[2],h=t[3],u=t[8],i=t[9],o=t[10],f=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*a-u*n,e[1]=c*a-i*n,e[2]=l*a-o*n,e[3]=h*a-f*n,e[8]=s*n+u*a,e[9]=c*n+i*a,e[10]=l*n+o*a,e[11]=h*n+f*a,e}function xi(e,t,r){var n=Math.sin(r),a=Math.cos(r),s=t[0],c=t[1],l=t[2],h=t[3],u=t[4],i=t[5],o=t[6],f=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*a+u*n,e[1]=c*a+i*n,e[2]=l*a+o*n,e[3]=h*a+f*n,e[4]=u*a-s*n,e[5]=i*a-c*n,e[6]=o*a-l*n,e[7]=f*a-h*n,e}function wi(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function Ai(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Ti(e,t,r){var n=r[0],a=r[1],s=r[2],c=Math.hypot(n,a,s),l,h,u;return c<Y.EPSILON?null:(c=1/c,n*=c,a*=c,s*=c,l=Math.sin(t),h=Math.cos(t),u=1-h,e[0]=n*n*u+h,e[1]=a*n*u+s*l,e[2]=s*n*u-a*l,e[3]=0,e[4]=n*a*u-s*l,e[5]=a*a*u+h,e[6]=s*a*u+n*l,e[7]=0,e[8]=n*s*u+a*l,e[9]=a*s*u-n*l,e[10]=s*s*u+h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function Si(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=r,e[7]=0,e[8]=0,e[9]=-r,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Oi(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=0,e[2]=-r,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=r,e[9]=0,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Ri(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=0,e[3]=0,e[4]=-r,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function rt(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=n+n,h=a+a,u=s+s,i=n*l,o=n*h,f=n*u,d=a*h,v=a*u,_=s*u,p=c*l,m=c*h,y=c*u;return e[0]=1-(d+_),e[1]=o+y,e[2]=f-m,e[3]=0,e[4]=o-y,e[5]=1-(i+_),e[6]=v+p,e[7]=0,e[8]=f+m,e[9]=v-p,e[10]=1-(i+d),e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function Li(e,t){var r=new Y.ARRAY_TYPE(3),n=-t[0],a=-t[1],s=-t[2],c=t[3],l=t[4],h=t[5],u=t[6],i=t[7],o=n*n+a*a+s*s+c*c;return o>0?(r[0]=(l*c+i*n+h*s-u*a)*2/o,r[1]=(h*c+i*a+u*n-l*s)*2/o,r[2]=(u*c+i*s+l*a-h*n)*2/o):(r[0]=(l*c+i*n+h*s-u*a)*2,r[1]=(h*c+i*a+u*n-l*s)*2,r[2]=(u*c+i*s+l*a-h*n)*2),rt(e,t,r),e}function Pi(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function nt(e,t){var r=t[0],n=t[1],a=t[2],s=t[4],c=t[5],l=t[6],h=t[8],u=t[9],i=t[10];return e[0]=Math.hypot(r,n,a),e[1]=Math.hypot(s,c,l),e[2]=Math.hypot(h,u,i),e}function Ii(e,t){var r=new Y.ARRAY_TYPE(3);nt(r,t);var n=1/r[0],a=1/r[1],s=1/r[2],c=t[0]*n,l=t[1]*a,h=t[2]*s,u=t[4]*n,i=t[5]*a,o=t[6]*s,f=t[8]*n,d=t[9]*a,v=t[10]*s,_=c+i+v,p=0;return _>0?(p=Math.sqrt(_+1)*2,e[3]=.25*p,e[0]=(o-d)/p,e[1]=(f-h)/p,e[2]=(l-u)/p):c>i&&c>v?(p=Math.sqrt(1+c-i-v)*2,e[3]=(o-d)/p,e[0]=.25*p,e[1]=(l+u)/p,e[2]=(f+h)/p):i>v?(p=Math.sqrt(1+i-c-v)*2,e[3]=(f-h)/p,e[0]=(l+u)/p,e[1]=.25*p,e[2]=(o+d)/p):(p=Math.sqrt(1+v-c-i)*2,e[3]=(l-u)/p,e[0]=(f+h)/p,e[1]=(o+d)/p,e[2]=.25*p),e}function Wi(e,t,r,n){var a=t[0],s=t[1],c=t[2],l=t[3],h=a+a,u=s+s,i=c+c,o=a*h,f=a*u,d=a*i,v=s*u,_=s*i,p=c*i,m=l*h,y=l*u,g=l*i,M=n[0],b=n[1],x=n[2];return e[0]=(1-(v+p))*M,e[1]=(f+g)*M,e[2]=(d-y)*M,e[3]=0,e[4]=(f-g)*b,e[5]=(1-(o+p))*b,e[6]=(_+m)*b,e[7]=0,e[8]=(d+y)*x,e[9]=(_-m)*x,e[10]=(1-(o+v))*x,e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function qi(e,t,r,n,a){var s=t[0],c=t[1],l=t[2],h=t[3],u=s+s,i=c+c,o=l+l,f=s*u,d=s*i,v=s*o,_=c*i,p=c*o,m=l*o,y=h*u,g=h*i,M=h*o,b=n[0],x=n[1],q=n[2],S=a[0],D=a[1],C=a[2],z=(1-(_+m))*b,F=(d+M)*b,E=(v-g)*b,P=(d-M)*x,U=(1-(f+m))*x,he=(p+y)*x,de=(v+g)*q,ke=(p-y)*q,ze=(1-(f+_))*q;return e[0]=z,e[1]=F,e[2]=E,e[3]=0,e[4]=P,e[5]=U,e[6]=he,e[7]=0,e[8]=de,e[9]=ke,e[10]=ze,e[11]=0,e[12]=r[0]+S-(z*S+P*D+de*C),e[13]=r[1]+D-(F*S+U*D+ke*C),e[14]=r[2]+C-(E*S+he*D+ze*C),e[15]=1,e}function Ei(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=r+r,l=n+n,h=a+a,u=r*c,i=n*c,o=n*l,f=a*c,d=a*l,v=a*h,_=s*c,p=s*l,m=s*h;return e[0]=1-o-v,e[1]=i+m,e[2]=f-p,e[3]=0,e[4]=i-m,e[5]=1-u-v,e[6]=d+_,e[7]=0,e[8]=f+p,e[9]=d-_,e[10]=1-u-o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Ci(e,t,r,n,a,s,c){var l=1/(r-t),h=1/(a-n),u=1/(s-c);return e[0]=s*2*l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s*2*h,e[6]=0,e[7]=0,e[8]=(r+t)*l,e[9]=(a+n)*h,e[10]=(c+s)*u,e[11]=-1,e[12]=0,e[13]=0,e[14]=c*s*2*u,e[15]=0,e}function Di(e,t,r,n,a){var s=1/Math.tan(t/2),c;return e[0]=s/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,a!=null&&a!==Infinity?(c=1/(n-a),e[10]=(a+n)*c,e[14]=2*a*n*c):(e[10]=-1,e[14]=-2*n),e}function Fi(e,t,r,n){var a=Math.tan(t.upDegrees*Math.PI/180),s=Math.tan(t.downDegrees*Math.PI/180),c=Math.tan(t.leftDegrees*Math.PI/180),l=Math.tan(t.rightDegrees*Math.PI/180),h=2/(c+l),u=2/(a+s);return e[0]=h,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=u,e[6]=0,e[7]=0,e[8]=-((c-l)*h*.5),e[9]=(a-s)*u*.5,e[10]=n/(r-n),e[11]=-1,e[12]=0,e[13]=0,e[14]=n*r/(r-n),e[15]=0,e}function ji(e,t,r,n,a,s,c){var l=1/(t-r),h=1/(n-a),u=1/(s-c);return e[0]=-2*l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*h,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*u,e[11]=0,e[12]=(t+r)*l,e[13]=(a+n)*h,e[14]=(c+s)*u,e[15]=1,e}function ki(e,t,r,n){var a,s,c,l,h,u,i,o,f,d,v=t[0],_=t[1],p=t[2],m=n[0],y=n[1],g=n[2],M=r[0],b=r[1],x=r[2];return Math.abs(v-M)<Y.EPSILON&&Math.abs(_-b)<Y.EPSILON&&Math.abs(p-x)<Y.EPSILON?et(e):(i=v-M,o=_-b,f=p-x,d=1/Math.hypot(i,o,f),i*=d,o*=d,f*=d,a=y*f-g*o,s=g*i-m*f,c=m*o-y*i,d=Math.hypot(a,s,c),d?(d=1/d,a*=d,s*=d,c*=d):(a=0,s=0,c=0),l=o*c-f*s,h=f*a-i*c,u=i*s-o*a,d=Math.hypot(l,h,u),d?(d=1/d,l*=d,h*=d,u*=d):(l=0,h=0,u=0),e[0]=a,e[1]=l,e[2]=i,e[3]=0,e[4]=s,e[5]=h,e[6]=o,e[7]=0,e[8]=c,e[9]=u,e[10]=f,e[11]=0,e[12]=-(a*v+s*_+c*p),e[13]=-(l*v+h*_+u*p),e[14]=-(i*v+o*_+f*p),e[15]=1,e)}function zi(e,t,r,n){var a=t[0],s=t[1],c=t[2],l=n[0],h=n[1],u=n[2],i=a-r[0],o=s-r[1],f=c-r[2],d=i*i+o*o+f*f;d>0&&(d=1/Math.sqrt(d),i*=d,o*=d,f*=d);var v=h*f-u*o,_=u*i-l*f,p=l*o-h*i;return d=v*v+_*_+p*p,d>0&&(d=1/Math.sqrt(d),v*=d,_*=d,p*=d),e[0]=v,e[1]=_,e[2]=p,e[3]=0,e[4]=o*p-f*_,e[5]=f*v-i*p,e[6]=i*_-o*v,e[7]=0,e[8]=i,e[9]=o,e[10]=f,e[11]=0,e[12]=a,e[13]=s,e[14]=c,e[15]=1,e}function Yi(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Hi(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Vi(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e[6]=t[6]+r[6],e[7]=t[7]+r[7],e[8]=t[8]+r[8],e[9]=t[9]+r[9],e[10]=t[10]+r[10],e[11]=t[11]+r[11],e[12]=t[12]+r[12],e[13]=t[13]+r[13],e[14]=t[14]+r[14],e[15]=t[15]+r[15],e}function it(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e[4]=t[4]-r[4],e[5]=t[5]-r[5],e[6]=t[6]-r[6],e[7]=t[7]-r[7],e[8]=t[8]-r[8],e[9]=t[9]-r[9],e[10]=t[10]-r[10],e[11]=t[11]-r[11],e[12]=t[12]-r[12],e[13]=t[13]-r[13],e[14]=t[14]-r[14],e[15]=t[15]-r[15],e}function Ni(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*r,e[5]=t[5]*r,e[6]=t[6]*r,e[7]=t[7]*r,e[8]=t[8]*r,e[9]=t[9]*r,e[10]=t[10]*r,e[11]=t[11]*r,e[12]=t[12]*r,e[13]=t[13]*r,e[14]=t[14]*r,e[15]=t[15]*r,e}function Xi(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e[4]=t[4]+r[4]*n,e[5]=t[5]+r[5]*n,e[6]=t[6]+r[6]*n,e[7]=t[7]+r[7]*n,e[8]=t[8]+r[8]*n,e[9]=t[9]+r[9]*n,e[10]=t[10]+r[10]*n,e[11]=t[11]+r[11]*n,e[12]=t[12]+r[12]*n,e[13]=t[13]+r[13]*n,e[14]=t[14]+r[14]*n,e[15]=t[15]+r[15]*n,e}function Bi(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function Gi(e,t){var r=e[0],n=e[1],a=e[2],s=e[3],c=e[4],l=e[5],h=e[6],u=e[7],i=e[8],o=e[9],f=e[10],d=e[11],v=e[12],_=e[13],p=e[14],m=e[15],y=t[0],g=t[1],M=t[2],b=t[3],x=t[4],q=t[5],S=t[6],D=t[7],C=t[8],z=t[9],F=t[10],E=t[11],P=t[12],U=t[13],he=t[14],de=t[15];return Math.abs(r-y)<=Y.EPSILON*Math.max(1,Math.abs(r),Math.abs(y))&&Math.abs(n-g)<=Y.EPSILON*Math.max(1,Math.abs(n),Math.abs(g))&&Math.abs(a-M)<=Y.EPSILON*Math.max(1,Math.abs(a),Math.abs(M))&&Math.abs(s-b)<=Y.EPSILON*Math.max(1,Math.abs(s),Math.abs(b))&&Math.abs(c-x)<=Y.EPSILON*Math.max(1,Math.abs(c),Math.abs(x))&&Math.abs(l-q)<=Y.EPSILON*Math.max(1,Math.abs(l),Math.abs(q))&&Math.abs(h-S)<=Y.EPSILON*Math.max(1,Math.abs(h),Math.abs(S))&&Math.abs(u-D)<=Y.EPSILON*Math.max(1,Math.abs(u),Math.abs(D))&&Math.abs(i-C)<=Y.EPSILON*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(o-z)<=Y.EPSILON*Math.max(1,Math.abs(o),Math.abs(z))&&Math.abs(f-F)<=Y.EPSILON*Math.max(1,Math.abs(f),Math.abs(F))&&Math.abs(d-E)<=Y.EPSILON*Math.max(1,Math.abs(d),Math.abs(E))&&Math.abs(v-P)<=Y.EPSILON*Math.max(1,Math.abs(v),Math.abs(P))&&Math.abs(_-U)<=Y.EPSILON*Math.max(1,Math.abs(_),Math.abs(U))&&Math.abs(p-he)<=Y.EPSILON*Math.max(1,Math.abs(p),Math.abs(he))&&Math.abs(m-de)<=Y.EPSILON*Math.max(1,Math.abs(m),Math.abs(de))}var Ui=tt;O.mul=Ui;var Zi=it;O.sub=Zi});var Ie=H(A=>{"use strict";function me(e){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?me=function(r){return typeof r}:me=function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},me(e)}Object.defineProperty(A,"__esModule",{value:!0});A.create=st;A.clone=$i;A.length=ot;A.fromValues=Ji;A.copy=Ki;A.set=ea;A.add=ta;A.subtract=ct;A.multiply=lt;A.divide=ft;A.ceil=ra;A.floor=na;A.min=ia;A.max=aa;A.round=sa;A.scale=oa;A.scaleAndAdd=ca;A.distance=ht;A.squaredDistance=dt;A.squaredLength=ut;A.negate=la;A.inverse=fa;A.normalize=ha;A.dot=pt;A.cross=da;A.lerp=ua;A.hermite=pa;A.bezier=va;A.random=_a;A.transformMat4=ma;A.transformMat3=ya;A.transformQuat=ga;A.rotateX=Ma;A.rotateY=ba;A.rotateZ=xa;A.angle=wa;A.zero=Aa;A.str=Ta;A.exactEquals=Sa;A.equals=Oa;A.forEach=A.sqrLen=A.len=A.sqrDist=A.dist=A.div=A.mul=A.sub=void 0;var re=Ra(Z());function vt(){if(typeof WeakMap!="function")return null;var e=new WeakMap;return vt=function(){return e},e}function Ra(e){if(e&&e.__esModule)return e;if(e===null||me(e)!=="object"&&typeof e!="function")return{default:e};var t=vt();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var s=n?Object.getOwnPropertyDescriptor(e,a):null;s&&(s.get||s.set)?Object.defineProperty(r,a,s):r[a]=e[a]}return r.default=e,t&&t.set(e,r),r}function st(){var e=new re.ARRAY_TYPE(3);return re.ARRAY_TYPE!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function $i(e){var t=new re.ARRAY_TYPE(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}function ot(e){var t=e[0],r=e[1],n=e[2];return Math.hypot(t,r,n)}function Ji(e,t,r){var n=new re.ARRAY_TYPE(3);return n[0]=e,n[1]=t,n[2]=r,n}function Ki(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function ea(e,t,r,n){return e[0]=t,e[1]=r,e[2]=n,e}function ta(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e}function ct(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e}function lt(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e}function ft(e,t,r){return e[0]=t[0]/r[0],e[1]=t[1]/r[1],e[2]=t[2]/r[2],e}function ra(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e}function na(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e}function ia(e,t,r){return e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e[2]=Math.min(t[2],r[2]),e}function aa(e,t,r){return e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e[2]=Math.max(t[2],r[2]),e}function sa(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e}function oa(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}function ca(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e}function ht(e,t){var r=t[0]-e[0],n=t[1]-e[1],a=t[2]-e[2];return Math.hypot(r,n,a)}function dt(e,t){var r=t[0]-e[0],n=t[1]-e[1],a=t[2]-e[2];return r*r+n*n+a*a}function ut(e){var t=e[0],r=e[1],n=e[2];return t*t+r*r+n*n}function la(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e}function fa(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function ha(e,t){var r=t[0],n=t[1],a=t[2],s=r*r+n*n+a*a;return s>0&&(s=1/Math.sqrt(s)),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s,e}function pt(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function da(e,t,r){var n=t[0],a=t[1],s=t[2],c=r[0],l=r[1],h=r[2];return e[0]=a*h-s*l,e[1]=s*c-n*h,e[2]=n*l-a*c,e}function ua(e,t,r,n){var a=t[0],s=t[1],c=t[2];return e[0]=a+n*(r[0]-a),e[1]=s+n*(r[1]-s),e[2]=c+n*(r[2]-c),e}function pa(e,t,r,n,a,s){var c=s*s,l=c*(2*s-3)+1,h=c*(s-2)+s,u=c*(s-1),i=c*(3-2*s);return e[0]=t[0]*l+r[0]*h+n[0]*u+a[0]*i,e[1]=t[1]*l+r[1]*h+n[1]*u+a[1]*i,e[2]=t[2]*l+r[2]*h+n[2]*u+a[2]*i,e}function va(e,t,r,n,a,s){var c=1-s,l=c*c,h=s*s,u=l*c,i=3*s*l,o=3*h*c,f=h*s;return e[0]=t[0]*u+r[0]*i+n[0]*o+a[0]*f,e[1]=t[1]*u+r[1]*i+n[1]*o+a[1]*f,e[2]=t[2]*u+r[2]*i+n[2]*o+a[2]*f,e}function _a(e,t){t=t||1;var r=re.RANDOM()*2*Math.PI,n=re.RANDOM()*2-1,a=Math.sqrt(1-n*n)*t;return e[0]=Math.cos(r)*a,e[1]=Math.sin(r)*a,e[2]=n*t,e}function ma(e,t,r){var n=t[0],a=t[1],s=t[2],c=r[3]*n+r[7]*a+r[11]*s+r[15];return c=c||1,e[0]=(r[0]*n+r[4]*a+r[8]*s+r[12])/c,e[1]=(r[1]*n+r[5]*a+r[9]*s+r[13])/c,e[2]=(r[2]*n+r[6]*a+r[10]*s+r[14])/c,e}function ya(e,t,r){var n=t[0],a=t[1],s=t[2];return e[0]=n*r[0]+a*r[3]+s*r[6],e[1]=n*r[1]+a*r[4]+s*r[7],e[2]=n*r[2]+a*r[5]+s*r[8],e}function ga(e,t,r){var n=r[0],a=r[1],s=r[2],c=r[3],l=t[0],h=t[1],u=t[2],i=a*u-s*h,o=s*l-n*u,f=n*h-a*l,d=a*f-s*o,v=s*i-n*f,_=n*o-a*i,p=c*2;return i*=p,o*=p,f*=p,d*=2,v*=2,_*=2,e[0]=l+i+d,e[1]=h+o+v,e[2]=u+f+_,e}function Ma(e,t,r,n){var a=[],s=[];return a[0]=t[0]-r[0],a[1]=t[1]-r[1],a[2]=t[2]-r[2],s[0]=a[0],s[1]=a[1]*Math.cos(n)-a[2]*Math.sin(n),s[2]=a[1]*Math.sin(n)+a[2]*Math.cos(n),e[0]=s[0]+r[0],e[1]=s[1]+r[1],e[2]=s[2]+r[2],e}function ba(e,t,r,n){var a=[],s=[];return a[0]=t[0]-r[0],a[1]=t[1]-r[1],a[2]=t[2]-r[2],s[0]=a[2]*Math.sin(n)+a[0]*Math.cos(n),s[1]=a[1],s[2]=a[2]*Math.cos(n)-a[0]*Math.sin(n),e[0]=s[0]+r[0],e[1]=s[1]+r[1],e[2]=s[2]+r[2],e}function xa(e,t,r,n){var a=[],s=[];return a[0]=t[0]-r[0],a[1]=t[1]-r[1],a[2]=t[2]-r[2],s[0]=a[0]*Math.cos(n)-a[1]*Math.sin(n),s[1]=a[0]*Math.sin(n)+a[1]*Math.cos(n),s[2]=a[2],e[0]=s[0]+r[0],e[1]=s[1]+r[1],e[2]=s[2]+r[2],e}function wa(e,t){var r=e[0],n=e[1],a=e[2],s=t[0],c=t[1],l=t[2],h=Math.sqrt(r*r+n*n+a*a),u=Math.sqrt(s*s+c*c+l*l),i=h*u,o=i&&pt(e,t)/i;return Math.acos(Math.min(Math.max(o,-1),1))}function Aa(e){return e[0]=0,e[1]=0,e[2]=0,e}function Ta(e){return"vec3("+e[0]+", "+e[1]+", "+e[2]+")"}function Sa(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Oa(e,t){var r=e[0],n=e[1],a=e[2],s=t[0],c=t[1],l=t[2];return Math.abs(r-s)<=re.EPSILON*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(n-c)<=re.EPSILON*Math.max(1,Math.abs(n),Math.abs(c))&&Math.abs(a-l)<=re.EPSILON*Math.max(1,Math.abs(a),Math.abs(l))}var La=ct;A.sub=La;var Pa=lt;A.mul=Pa;var Ia=ft;A.div=Ia;var Wa=ht;A.dist=Wa;var qa=dt;A.sqrDist=qa;var Ea=ot;A.len=Ea;var Ca=ut;A.sqrLen=Ca;var Da=function(){var e=st();return function(t,r,n,a,s,c){var l,h;for(r||(r=3),n||(n=0),a?h=Math.min(a*r+n,t.length):h=t.length,l=n;l<h;l+=r)e[0]=t[l],e[1]=t[l+1],e[2]=t[l+2],s(e,e,c),t[l]=e[0],t[l+1]=e[1],t[l+2]=e[2];return t}}();A.forEach=Da});var We=H(R=>{"use strict";function ye(e){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?ye=function(r){return typeof r}:ye=function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},ye(e)}Object.defineProperty(R,"__esModule",{value:!0});R.create=_t;R.clone=Fa;R.fromValues=ja;R.copy=ka;R.set=za;R.add=Ya;R.subtract=mt;R.multiply=yt;R.divide=gt;R.ceil=Ha;R.floor=Va;R.min=Na;R.max=Xa;R.round=Ba;R.scale=Ga;R.scaleAndAdd=Qa;R.distance=Mt;R.squaredDistance=bt;R.length=xt;R.squaredLength=wt;R.negate=Ua;R.inverse=Za;R.normalize=$a;R.dot=Ja;R.cross=Ka;R.lerp=es;R.random=ts;R.transformMat4=rs;R.transformQuat=ns;R.zero=is;R.str=as;R.exactEquals=ss;R.equals=os;R.forEach=R.sqrLen=R.len=R.sqrDist=R.dist=R.div=R.mul=R.sub=void 0;var Q=cs(Z());function At(){if(typeof WeakMap!="function")return null;var e=new WeakMap;return At=function(){return e},e}function cs(e){if(e&&e.__esModule)return e;if(e===null||ye(e)!=="object"&&typeof e!="function")return{default:e};var t=At();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var s=n?Object.getOwnPropertyDescriptor(e,a):null;s&&(s.get||s.set)?Object.defineProperty(r,a,s):r[a]=e[a]}return r.default=e,t&&t.set(e,r),r}function _t(){var e=new Q.ARRAY_TYPE(4);return Q.ARRAY_TYPE!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function Fa(e){var t=new Q.ARRAY_TYPE(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function ja(e,t,r,n){var a=new Q.ARRAY_TYPE(4);return a[0]=e,a[1]=t,a[2]=r,a[3]=n,a}function ka(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function za(e,t,r,n,a){return e[0]=t,e[1]=r,e[2]=n,e[3]=a,e}function Ya(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e}function mt(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e}function yt(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e[3]=t[3]*r[3],e}function gt(e,t,r){return e[0]=t[0]/r[0],e[1]=t[1]/r[1],e[2]=t[2]/r[2],e[3]=t[3]/r[3],e}function Ha(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e[3]=Math.ceil(t[3]),e}function Va(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e[3]=Math.floor(t[3]),e}function Na(e,t,r){return e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e[2]=Math.min(t[2],r[2]),e[3]=Math.min(t[3],r[3]),e}function Xa(e,t,r){return e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e[2]=Math.max(t[2],r[2]),e[3]=Math.max(t[3],r[3]),e}function Ba(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e[3]=Math.round(t[3]),e}function Ga(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e}function Qa(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e}function Mt(e,t){var r=t[0]-e[0],n=t[1]-e[1],a=t[2]-e[2],s=t[3]-e[3];return Math.hypot(r,n,a,s)}function bt(e,t){var r=t[0]-e[0],n=t[1]-e[1],a=t[2]-e[2],s=t[3]-e[3];return r*r+n*n+a*a+s*s}function xt(e){var t=e[0],r=e[1],n=e[2],a=e[3];return Math.hypot(t,r,n,a)}function wt(e){var t=e[0],r=e[1],n=e[2],a=e[3];return t*t+r*r+n*n+a*a}function Ua(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e}function Za(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e[3]=1/t[3],e}function $a(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=r*r+n*n+a*a+s*s;return c>0&&(c=1/Math.sqrt(c)),e[0]=r*c,e[1]=n*c,e[2]=a*c,e[3]=s*c,e}function Ja(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function Ka(e,t,r,n){var a=r[0]*n[1]-r[1]*n[0],s=r[0]*n[2]-r[2]*n[0],c=r[0]*n[3]-r[3]*n[0],l=r[1]*n[2]-r[2]*n[1],h=r[1]*n[3]-r[3]*n[1],u=r[2]*n[3]-r[3]*n[2],i=t[0],o=t[1],f=t[2],d=t[3];return e[0]=o*u-f*h+d*l,e[1]=-(i*u)+f*c-d*s,e[2]=i*h-o*c+d*a,e[3]=-(i*l)+o*s-f*a,e}function es(e,t,r,n){var a=t[0],s=t[1],c=t[2],l=t[3];return e[0]=a+n*(r[0]-a),e[1]=s+n*(r[1]-s),e[2]=c+n*(r[2]-c),e[3]=l+n*(r[3]-l),e}function ts(e,t){t=t||1;var r,n,a,s,c,l;do r=Q.RANDOM()*2-1,n=Q.RANDOM()*2-1,c=r*r+n*n;while(c>=1);do a=Q.RANDOM()*2-1,s=Q.RANDOM()*2-1,l=a*a+s*s;while(l>=1);var h=Math.sqrt((1-c)/l);return e[0]=t*r,e[1]=t*n,e[2]=t*a*h,e[3]=t*s*h,e}function rs(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3];return e[0]=r[0]*n+r[4]*a+r[8]*s+r[12]*c,e[1]=r[1]*n+r[5]*a+r[9]*s+r[13]*c,e[2]=r[2]*n+r[6]*a+r[10]*s+r[14]*c,e[3]=r[3]*n+r[7]*a+r[11]*s+r[15]*c,e}function ns(e,t,r){var n=t[0],a=t[1],s=t[2],c=r[0],l=r[1],h=r[2],u=r[3],i=u*n+l*s-h*a,o=u*a+h*n-c*s,f=u*s+c*a-l*n,d=-c*n-l*a-h*s;return e[0]=i*u+d*-c+o*-h-f*-l,e[1]=o*u+d*-l+f*-c-i*-h,e[2]=f*u+d*-h+i*-l-o*-c,e[3]=t[3],e}function is(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e}function as(e){return"vec4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"}function ss(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]}function os(e,t){var r=e[0],n=e[1],a=e[2],s=e[3],c=t[0],l=t[1],h=t[2],u=t[3];return Math.abs(r-c)<=Q.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(n-l)<=Q.EPSILON*Math.max(1,Math.abs(n),Math.abs(l))&&Math.abs(a-h)<=Q.EPSILON*Math.max(1,Math.abs(a),Math.abs(h))&&Math.abs(s-u)<=Q.EPSILON*Math.max(1,Math.abs(s),Math.abs(u))}var ls=mt;R.sub=ls;var fs=yt;R.mul=fs;var hs=gt;R.div=hs;var ds=Mt;R.dist=ds;var us=bt;R.sqrDist=us;var ps=xt;R.len=ps;var vs=wt;R.sqrLen=vs;var _s=function(){var e=_t();return function(t,r,n,a,s,c){var l,h;for(r||(r=4),n||(n=0),a?h=Math.min(a*r+n,t.length):h=t.length,l=n;l<h;l+=r)e[0]=t[l],e[1]=t[l+1],e[2]=t[l+2],e[3]=t[l+3],s(e,e,c),t[l]=e[0],t[l+1]=e[1],t[l+2]=e[2],t[l+3]=e[3];return t}}();R.forEach=_s});var Ce=H(w=>{"use strict";function ge(e){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?ge=function(r){return typeof r}:ge=function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},ge(e)}Object.defineProperty(w,"__esModule",{value:!0});w.create=qe;w.identity=ms;w.setAxisAngle=Tt;w.getAxisAngle=ys;w.getAngle=gs;w.multiply=St;w.rotateX=Ms;w.rotateY=bs;w.rotateZ=xs;w.calculateW=ws;w.exp=Ot;w.ln=Rt;w.pow=As;w.slerp=Me;w.random=Ts;w.invert=Ss;w.conjugate=Os;w.fromMat3=Lt;w.fromEuler=Rs;w.str=Ls;w.setAxes=w.sqlerp=w.rotationTo=w.equals=w.exactEquals=w.normalize=w.sqrLen=w.squaredLength=w.len=w.length=w.lerp=w.dot=w.scale=w.mul=w.add=w.set=w.copy=w.fromValues=w.clone=void 0;var ce=be(Z()),Ps=be(Le()),ne=be(Ie()),B=be(We());function Pt(){if(typeof WeakMap!="function")return null;var e=new WeakMap;return Pt=function(){return e},e}function be(e){if(e&&e.__esModule)return e;if(e===null||ge(e)!=="object"&&typeof e!="function")return{default:e};var t=Pt();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var s=n?Object.getOwnPropertyDescriptor(e,a):null;s&&(s.get||s.set)?Object.defineProperty(r,a,s):r[a]=e[a]}return r.default=e,t&&t.set(e,r),r}function qe(){var e=new ce.ARRAY_TYPE(4);return ce.ARRAY_TYPE!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function ms(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e}function Tt(e,t,r){r=r*.5;var n=Math.sin(r);return e[0]=n*t[0],e[1]=n*t[1],e[2]=n*t[2],e[3]=Math.cos(r),e}function ys(e,t){var r=Math.acos(t[3])*2,n=Math.sin(r/2);return n>ce.EPSILON?(e[0]=t[0]/n,e[1]=t[1]/n,e[2]=t[2]/n):(e[0]=1,e[1]=0,e[2]=0),r}function gs(e,t){var r=It(e,t);return Math.acos(2*r*r-1)}function St(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=r[0],h=r[1],u=r[2],i=r[3];return e[0]=n*i+c*l+a*u-s*h,e[1]=a*i+c*h+s*l-n*u,e[2]=s*i+c*u+n*h-a*l,e[3]=c*i-n*l-a*h-s*u,e}function Ms(e,t,r){r*=.5;var n=t[0],a=t[1],s=t[2],c=t[3],l=Math.sin(r),h=Math.cos(r);return e[0]=n*h+c*l,e[1]=a*h+s*l,e[2]=s*h-a*l,e[3]=c*h-n*l,e}function bs(e,t,r){r*=.5;var n=t[0],a=t[1],s=t[2],c=t[3],l=Math.sin(r),h=Math.cos(r);return e[0]=n*h-s*l,e[1]=a*h+c*l,e[2]=s*h+n*l,e[3]=c*h-a*l,e}function xs(e,t,r){r*=.5;var n=t[0],a=t[1],s=t[2],c=t[3],l=Math.sin(r),h=Math.cos(r);return e[0]=n*h+a*l,e[1]=a*h-n*l,e[2]=s*h+c*l,e[3]=c*h-s*l,e}function ws(e,t){var r=t[0],n=t[1],a=t[2];return e[0]=r,e[1]=n,e[2]=a,e[3]=Math.sqrt(Math.abs(1-r*r-n*n-a*a)),e}function Ot(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=Math.sqrt(r*r+n*n+a*a),l=Math.exp(s),h=c>0?l*Math.sin(c)/c:0;return e[0]=r*h,e[1]=n*h,e[2]=a*h,e[3]=l*Math.cos(c),e}function Rt(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=Math.sqrt(r*r+n*n+a*a),l=c>0?Math.atan2(c,s)/c:0;return e[0]=r*l,e[1]=n*l,e[2]=a*l,e[3]=.5*Math.log(r*r+n*n+a*a+s*s),e}function As(e,t,r){return Rt(e,t),Wt(e,e,r),Ot(e,e),e}function Me(e,t,r,n){var a=t[0],s=t[1],c=t[2],l=t[3],h=r[0],u=r[1],i=r[2],o=r[3],f,d,v,_,p;return d=a*h+s*u+c*i+l*o,d<0&&(d=-d,h=-h,u=-u,i=-i,o=-o),1-d>ce.EPSILON?(f=Math.acos(d),v=Math.sin(f),_=Math.sin((1-n)*f)/v,p=Math.sin(n*f)/v):(_=1-n,p=n),e[0]=_*a+p*h,e[1]=_*s+p*u,e[2]=_*c+p*i,e[3]=_*l+p*o,e}function Ts(e){var t=ce.RANDOM(),r=ce.RANDOM(),n=ce.RANDOM(),a=Math.sqrt(1-t),s=Math.sqrt(t);return e[0]=a*Math.sin(2*Math.PI*r),e[1]=a*Math.cos(2*Math.PI*r),e[2]=s*Math.sin(2*Math.PI*n),e[3]=s*Math.cos(2*Math.PI*n),e}function Ss(e,t){var r=t[0],n=t[1],a=t[2],s=t[3],c=r*r+n*n+a*a+s*s,l=c?1/c:0;return e[0]=-r*l,e[1]=-n*l,e[2]=-a*l,e[3]=s*l,e}function Os(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e}function Lt(e,t){var r=t[0]+t[4]+t[8],n;if(r>0)n=Math.sqrt(r+1),e[3]=.5*n,n=.5/n,e[0]=(t[5]-t[7])*n,e[1]=(t[6]-t[2])*n,e[2]=(t[1]-t[3])*n;else{var a=0;t[4]>t[0]&&(a=1),t[8]>t[a*3+a]&&(a=2);var s=(a+1)%3,c=(a+2)%3;n=Math.sqrt(t[a*3+a]-t[s*3+s]-t[c*3+c]+1),e[a]=.5*n,n=.5/n,e[3]=(t[s*3+c]-t[c*3+s])*n,e[s]=(t[s*3+a]+t[a*3+s])*n,e[c]=(t[c*3+a]+t[a*3+c])*n}return e}function Rs(e,t,r,n){var a=.5*Math.PI/180;t*=a,r*=a,n*=a;var s=Math.sin(t),c=Math.cos(t),l=Math.sin(r),h=Math.cos(r),u=Math.sin(n),i=Math.cos(n);return e[0]=s*h*i-c*l*u,e[1]=c*l*i+s*h*u,e[2]=c*h*u-s*l*i,e[3]=c*h*i+s*l*u,e}function Ls(e){return"quat("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"}var Is=B.clone;w.clone=Is;var Ws=B.fromValues;w.fromValues=Ws;var qs=B.copy;w.copy=qs;var Es=B.set;w.set=Es;var Cs=B.add;w.add=Cs;var Ds=St;w.mul=Ds;var Wt=B.scale;w.scale=Wt;var It=B.dot;w.dot=It;var Fs=B.lerp;w.lerp=Fs;var qt=B.length;w.length=qt;var js=qt;w.len=js;var Et=B.squaredLength;w.squaredLength=Et;var ks=Et;w.sqrLen=ks;var Ee=B.normalize;w.normalize=Ee;var zs=B.exactEquals;w.exactEquals=zs;var Ys=B.equals;w.equals=Ys;var Hs=function(){var e=ne.create(),t=ne.fromValues(1,0,0),r=ne.fromValues(0,1,0);return function(n,a,s){var c=ne.dot(a,s);return c<-.999999?(ne.cross(e,t,a),ne.len(e)<1e-6&&ne.cross(e,r,a),ne.normalize(e,e),Tt(n,e,Math.PI),n):c>.999999?(n[0]=0,n[1]=0,n[2]=0,n[3]=1,n):(ne.cross(e,a,s),n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=1+c,Ee(n,n))}}();w.rotationTo=Hs;var Vs=function(){var e=qe(),t=qe();return function(r,n,a,s,c,l){return Me(e,n,c,l),Me(t,a,s,l),Me(r,e,t,2*l*(1-l)),r}}();w.sqlerp=Vs;var Ns=function(){var e=Ps.create();return function(t,r,n,a){return e[0]=n[0],e[3]=n[1],e[6]=n[2],e[1]=a[0],e[4]=a[1],e[7]=a[2],e[2]=-r[0],e[5]=-r[1],e[8]=-r[2],Ee(t,Lt(t,e))}}();w.setAxes=Ns});var Ht=H(L=>{"use strict";function xe(e){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?xe=function(r){return typeof r}:xe=function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},xe(e)}Object.defineProperty(L,"__esModule",{value:!0});L.create=Xs;L.clone=Bs;L.fromValues=Gs;L.fromRotationTranslationValues=Qs;L.fromRotationTranslation=Ct;L.fromTranslation=Us;L.fromRotation=Zs;L.fromMat4=$s;L.copy=Dt;L.identity=Js;L.set=Ks;L.getDual=eo;L.setDual=to;L.getTranslation=ro;L.translate=no;L.rotateX=io;L.rotateY=ao;L.rotateZ=so;L.rotateByQuatAppend=oo;L.rotateByQuatPrepend=co;L.rotateAroundAxis=lo;L.add=fo;L.multiply=Ft;L.scale=ho;L.lerp=uo;L.invert=po;L.conjugate=vo;L.normalize=_o;L.str=mo;L.exactEquals=yo;L.equals=go;L.sqrLen=L.squaredLength=L.len=L.length=L.dot=L.mul=L.setReal=L.getReal=void 0;var N=De(Z()),ie=De(Ce()),jt=De(Pe());function kt(){if(typeof WeakMap!="function")return null;var e=new WeakMap;return kt=function(){return e},e}function De(e){if(e&&e.__esModule)return e;if(e===null||xe(e)!=="object"&&typeof e!="function")return{default:e};var t=kt();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var s=n?Object.getOwnPropertyDescriptor(e,a):null;s&&(s.get||s.set)?Object.defineProperty(r,a,s):r[a]=e[a]}return r.default=e,t&&t.set(e,r),r}function Xs(){var e=new N.ARRAY_TYPE(8);return N.ARRAY_TYPE!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0),e[3]=1,e}function Bs(e){var t=new N.ARRAY_TYPE(8);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t}function Gs(e,t,r,n,a,s,c,l){var h=new N.ARRAY_TYPE(8);return h[0]=e,h[1]=t,h[2]=r,h[3]=n,h[4]=a,h[5]=s,h[6]=c,h[7]=l,h}function Qs(e,t,r,n,a,s,c){var l=new N.ARRAY_TYPE(8);l[0]=e,l[1]=t,l[2]=r,l[3]=n;var h=a*.5,u=s*.5,i=c*.5;return l[4]=h*n+u*r-i*t,l[5]=u*n+i*e-h*r,l[6]=i*n+h*t-u*e,l[7]=-h*e-u*t-i*r,l}function Ct(e,t,r){var n=r[0]*.5,a=r[1]*.5,s=r[2]*.5,c=t[0],l=t[1],h=t[2],u=t[3];return e[0]=c,e[1]=l,e[2]=h,e[3]=u,e[4]=n*u+a*h-s*l,e[5]=a*u+s*c-n*h,e[6]=s*u+n*l-a*c,e[7]=-n*c-a*l-s*h,e}function Us(e,t){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e[4]=t[0]*.5,e[5]=t[1]*.5,e[6]=t[2]*.5,e[7]=0,e}function Zs(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=0,e[5]=0,e[6]=0,e[7]=0,e}function $s(e,t){var r=ie.create();jt.getRotation(r,t);var n=new N.ARRAY_TYPE(3);return jt.getTranslation(n,t),Ct(e,r,n),e}function Dt(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e}function Js(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e}function Ks(e,t,r,n,a,s,c,l,h){return e[0]=t,e[1]=r,e[2]=n,e[3]=a,e[4]=s,e[5]=c,e[6]=l,e[7]=h,e}var Mo=ie.copy;L.getReal=Mo;function eo(e,t){return e[0]=t[4],e[1]=t[5],e[2]=t[6],e[3]=t[7],e}var bo=ie.copy;L.setReal=bo;function to(e,t){return e[4]=t[0],e[5]=t[1],e[6]=t[2],e[7]=t[3],e}function ro(e,t){var r=t[4],n=t[5],a=t[6],s=t[7],c=-t[0],l=-t[1],h=-t[2],u=t[3];return e[0]=(r*u+s*c+n*h-a*l)*2,e[1]=(n*u+s*l+a*c-r*h)*2,e[2]=(a*u+s*h+r*l-n*c)*2,e}function no(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=r[0]*.5,h=r[1]*.5,u=r[2]*.5,i=t[4],o=t[5],f=t[6],d=t[7];return e[0]=n,e[1]=a,e[2]=s,e[3]=c,e[4]=c*l+a*u-s*h+i,e[5]=c*h+s*l-n*u+o,e[6]=c*u+n*h-a*l+f,e[7]=-n*l-a*h-s*u+d,e}function io(e,t,r){var n=-t[0],a=-t[1],s=-t[2],c=t[3],l=t[4],h=t[5],u=t[6],i=t[7],o=l*c+i*n+h*s-u*a,f=h*c+i*a+u*n-l*s,d=u*c+i*s+l*a-h*n,v=i*c-l*n-h*a-u*s;return ie.rotateX(e,t,r),n=e[0],a=e[1],s=e[2],c=e[3],e[4]=o*c+v*n+f*s-d*a,e[5]=f*c+v*a+d*n-o*s,e[6]=d*c+v*s+o*a-f*n,e[7]=v*c-o*n-f*a-d*s,e}function ao(e,t,r){var n=-t[0],a=-t[1],s=-t[2],c=t[3],l=t[4],h=t[5],u=t[6],i=t[7],o=l*c+i*n+h*s-u*a,f=h*c+i*a+u*n-l*s,d=u*c+i*s+l*a-h*n,v=i*c-l*n-h*a-u*s;return ie.rotateY(e,t,r),n=e[0],a=e[1],s=e[2],c=e[3],e[4]=o*c+v*n+f*s-d*a,e[5]=f*c+v*a+d*n-o*s,e[6]=d*c+v*s+o*a-f*n,e[7]=v*c-o*n-f*a-d*s,e}function so(e,t,r){var n=-t[0],a=-t[1],s=-t[2],c=t[3],l=t[4],h=t[5],u=t[6],i=t[7],o=l*c+i*n+h*s-u*a,f=h*c+i*a+u*n-l*s,d=u*c+i*s+l*a-h*n,v=i*c-l*n-h*a-u*s;return ie.rotateZ(e,t,r),n=e[0],a=e[1],s=e[2],c=e[3],e[4]=o*c+v*n+f*s-d*a,e[5]=f*c+v*a+d*n-o*s,e[6]=d*c+v*s+o*a-f*n,e[7]=v*c-o*n-f*a-d*s,e}function oo(e,t,r){var n=r[0],a=r[1],s=r[2],c=r[3],l=t[0],h=t[1],u=t[2],i=t[3];return e[0]=l*c+i*n+h*s-u*a,e[1]=h*c+i*a+u*n-l*s,e[2]=u*c+i*s+l*a-h*n,e[3]=i*c-l*n-h*a-u*s,l=t[4],h=t[5],u=t[6],i=t[7],e[4]=l*c+i*n+h*s-u*a,e[5]=h*c+i*a+u*n-l*s,e[6]=u*c+i*s+l*a-h*n,e[7]=i*c-l*n-h*a-u*s,e}function co(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=r[0],h=r[1],u=r[2],i=r[3];return e[0]=n*i+c*l+a*u-s*h,e[1]=a*i+c*h+s*l-n*u,e[2]=s*i+c*u+n*h-a*l,e[3]=c*i-n*l-a*h-s*u,l=r[4],h=r[5],u=r[6],i=r[7],e[4]=n*i+c*l+a*u-s*h,e[5]=a*i+c*h+s*l-n*u,e[6]=s*i+c*u+n*h-a*l,e[7]=c*i-n*l-a*h-s*u,e}function lo(e,t,r,n){if(Math.abs(n)<N.EPSILON)return Dt(e,t);var a=Math.hypot(r[0],r[1],r[2]);n=n*.5;var s=Math.sin(n),c=s*r[0]/a,l=s*r[1]/a,h=s*r[2]/a,u=Math.cos(n),i=t[0],o=t[1],f=t[2],d=t[3];e[0]=i*u+d*c+o*h-f*l,e[1]=o*u+d*l+f*c-i*h,e[2]=f*u+d*h+i*l-o*c,e[3]=d*u-i*c-o*l-f*h;var v=t[4],_=t[5],p=t[6],m=t[7];return e[4]=v*u+m*c+_*h-p*l,e[5]=_*u+m*l+p*c-v*h,e[6]=p*u+m*h+v*l-_*c,e[7]=m*u-v*c-_*l-p*h,e}function fo(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e[6]=t[6]+r[6],e[7]=t[7]+r[7],e}function Ft(e,t,r){var n=t[0],a=t[1],s=t[2],c=t[3],l=r[4],h=r[5],u=r[6],i=r[7],o=t[4],f=t[5],d=t[6],v=t[7],_=r[0],p=r[1],m=r[2],y=r[3];return e[0]=n*y+c*_+a*m-s*p,e[1]=a*y+c*p+s*_-n*m,e[2]=s*y+c*m+n*p-a*_,e[3]=c*y-n*_-a*p-s*m,e[4]=n*i+c*l+a*u-s*h+o*y+v*_+f*m-d*p,e[5]=a*i+c*h+s*l-n*u+f*y+v*p+d*_-o*m,e[6]=s*i+c*u+n*h-a*l+d*y+v*m+o*p-f*_,e[7]=c*i-n*l-a*h-s*u+v*y-o*_-f*p-d*m,e}var xo=Ft;L.mul=xo;function ho(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*r,e[5]=t[5]*r,e[6]=t[6]*r,e[7]=t[7]*r,e}var zt=ie.dot;L.dot=zt;function uo(e,t,r,n){var a=1-n;return zt(t,r)<0&&(n=-n),e[0]=t[0]*a+r[0]*n,e[1]=t[1]*a+r[1]*n,e[2]=t[2]*a+r[2]*n,e[3]=t[3]*a+r[3]*n,e[4]=t[4]*a+r[4]*n,e[5]=t[5]*a+r[5]*n,e[6]=t[6]*a+r[6]*n,e[7]=t[7]*a+r[7]*n,e}function po(e,t){var r=we(t);return e[0]=-t[0]/r,e[1]=-t[1]/r,e[2]=-t[2]/r,e[3]=t[3]/r,e[4]=-t[4]/r,e[5]=-t[5]/r,e[6]=-t[6]/r,e[7]=t[7]/r,e}function vo(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e[4]=-t[4],e[5]=-t[5],e[6]=-t[6],e[7]=t[7],e}var Yt=ie.length;L.length=Yt;var wo=Yt;L.len=wo;var we=ie.squaredLength;L.squaredLength=we;var Ao=we;L.sqrLen=Ao;function _o(e,t){var r=we(t);if(r>0){r=Math.sqrt(r);var n=t[0]/r,a=t[1]/r,s=t[2]/r,c=t[3]/r,l=t[4],h=t[5],u=t[6],i=t[7],o=n*l+a*h+s*u+c*i;e[0]=n,e[1]=a,e[2]=s,e[3]=c,e[4]=(l-n*o)/r,e[5]=(h-a*o)/r,e[6]=(u-s*o)/r,e[7]=(i-c*o)/r}return e}function mo(e){return"quat2("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+")"}function yo(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]}function go(e,t){var r=e[0],n=e[1],a=e[2],s=e[3],c=e[4],l=e[5],h=e[6],u=e[7],i=t[0],o=t[1],f=t[2],d=t[3],v=t[4],_=t[5],p=t[6],m=t[7];return Math.abs(r-i)<=N.EPSILON*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(n-o)<=N.EPSILON*Math.max(1,Math.abs(n),Math.abs(o))&&Math.abs(a-f)<=N.EPSILON*Math.max(1,Math.abs(a),Math.abs(f))&&Math.abs(s-d)<=N.EPSILON*Math.max(1,Math.abs(s),Math.abs(d))&&Math.abs(c-v)<=N.EPSILON*Math.max(1,Math.abs(c),Math.abs(v))&&Math.abs(l-_)<=N.EPSILON*Math.max(1,Math.abs(l),Math.abs(_))&&Math.abs(h-p)<=N.EPSILON*Math.max(1,Math.abs(h),Math.abs(p))&&Math.abs(u-m)<=N.EPSILON*Math.max(1,Math.abs(u),Math.abs(m))}});var Jt=H(T=>{"use strict";function Ae(e){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?Ae=function(r){return typeof r}:Ae=function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},Ae(e)}Object.defineProperty(T,"__esModule",{value:!0});T.create=Vt;T.clone=To;T.fromValues=So;T.copy=Oo;T.set=Ro;T.add=Lo;T.subtract=Nt;T.multiply=Xt;T.divide=Bt;T.ceil=Po;T.floor=Io;T.min=Wo;T.max=qo;T.round=Eo;T.scale=Co;T.scaleAndAdd=Do;T.distance=Gt;T.squaredDistance=Qt;T.length=Ut;T.squaredLength=Zt;T.negate=Fo;T.inverse=jo;T.normalize=ko;T.dot=zo;T.cross=Yo;T.lerp=Ho;T.random=Vo;T.transformMat2=No;T.transformMat2d=Xo;T.transformMat3=Bo;T.transformMat4=Go;T.rotate=Qo;T.angle=Uo;T.zero=Zo;T.str=$o;T.exactEquals=Jo;T.equals=Ko;T.forEach=T.sqrLen=T.sqrDist=T.dist=T.div=T.mul=T.sub=T.len=void 0;var le=ec(Z());function $t(){if(typeof WeakMap!="function")return null;var e=new WeakMap;return $t=function(){return e},e}function ec(e){if(e&&e.__esModule)return e;if(e===null||Ae(e)!=="object"&&typeof e!="function")return{default:e};var t=$t();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var s=n?Object.getOwnPropertyDescriptor(e,a):null;s&&(s.get||s.set)?Object.defineProperty(r,a,s):r[a]=e[a]}return r.default=e,t&&t.set(e,r),r}function Vt(){var e=new le.ARRAY_TYPE(2);return le.ARRAY_TYPE!=Float32Array&&(e[0]=0,e[1]=0),e}function To(e){var t=new le.ARRAY_TYPE(2);return t[0]=e[0],t[1]=e[1],t}function So(e,t){var r=new le.ARRAY_TYPE(2);return r[0]=e,r[1]=t,r}function Oo(e,t){return e[0]=t[0],e[1]=t[1],e}function Ro(e,t,r){return e[0]=t,e[1]=r,e}function Lo(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e}function Nt(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e}function Xt(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e}function Bt(e,t,r){return e[0]=t[0]/r[0],e[1]=t[1]/r[1],e}function Po(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e}function Io(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e}function Wo(e,t,r){return e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e}function qo(e,t,r){return e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e}function Eo(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e}function Co(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e}function Do(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e}function Gt(e,t){var r=t[0]-e[0],n=t[1]-e[1];return Math.hypot(r,n)}function Qt(e,t){var r=t[0]-e[0],n=t[1]-e[1];return r*r+n*n}function Ut(e){var t=e[0],r=e[1];return Math.hypot(t,r)}function Zt(e){var t=e[0],r=e[1];return t*t+r*r}function Fo(e,t){return e[0]=-t[0],e[1]=-t[1],e}function jo(e,t){return e[0]=1/t[0],e[1]=1/t[1],e}function ko(e,t){var r=t[0],n=t[1],a=r*r+n*n;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e}function zo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t,r){var n=t[0]*r[1]-t[1]*r[0];return e[0]=e[1]=0,e[2]=n,e}function Ho(e,t,r,n){var a=t[0],s=t[1];return e[0]=a+n*(r[0]-a),e[1]=s+n*(r[1]-s),e}function Vo(e,t){t=t||1;var r=le.RANDOM()*2*Math.PI;return e[0]=Math.cos(r)*t,e[1]=Math.sin(r)*t,e}function No(e,t,r){var n=t[0],a=t[1];return e[0]=r[0]*n+r[2]*a,e[1]=r[1]*n+r[3]*a,e}function Xo(e,t,r){var n=t[0],a=t[1];return e[0]=r[0]*n+r[2]*a+r[4],e[1]=r[1]*n+r[3]*a+r[5],e}function Bo(e,t,r){var n=t[0],a=t[1];return e[0]=r[0]*n+r[3]*a+r[6],e[1]=r[1]*n+r[4]*a+r[7],e}function Go(e,t,r){var n=t[0],a=t[1];return e[0]=r[0]*n+r[4]*a+r[12],e[1]=r[1]*n+r[5]*a+r[13],e}function Qo(e,t,r,n){var a=t[0]-r[0],s=t[1]-r[1],c=Math.sin(n),l=Math.cos(n);return e[0]=a*l-s*c+r[0],e[1]=a*c+s*l+r[1],e}function Uo(e,t){var r=e[0],n=e[1],a=t[0],s=t[1],c=Math.sqrt(r*r+n*n)*Math.sqrt(a*a+s*s),l=c&&(r*a+n*s)/c;return Math.acos(Math.min(Math.max(l,-1),1))}function Zo(e){return e[0]=0,e[1]=0,e}function $o(e){return"vec2("+e[0]+", "+e[1]+")"}function Jo(e,t){return e[0]===t[0]&&e[1]===t[1]}function Ko(e,t){var r=e[0],n=e[1],a=t[0],s=t[1];return Math.abs(r-a)<=le.EPSILON*Math.max(1,Math.abs(r),Math.abs(a))&&Math.abs(n-s)<=le.EPSILON*Math.max(1,Math.abs(n),Math.abs(s))}var tc=Ut;T.len=tc;var rc=Nt;T.sub=rc;var nc=Xt;T.mul=nc;var ic=Bt;T.div=ic;var ac=Gt;T.dist=ac;var sc=Qt;T.sqrDist=sc;var oc=Zt;T.sqrLen=oc;var cc=function(){var e=Vt();return function(t,r,n,a,s,c){var l,h;for(r||(r=2),n||(n=0),a?h=Math.min(a*r+n,t.length):h=t.length,l=n;l<h;l+=r)e[0]=t[l],e[1]=t[l+1],s(e,e,c),t[l]=e[0],t[l+1]=e[1];return t}}();T.forEach=cc});var te=H(V=>{"use strict";function Te(e){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?Te=function(r){return typeof r}:Te=function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},Te(e)}Object.defineProperty(V,"__esModule",{value:!0});V.vec4=V.vec3=V.vec2=V.quat2=V.quat=V.mat4=V.mat3=V.mat2d=V.mat2=V.glMatrix=void 0;var lc=ee(Z());V.glMatrix=lc;var fc=ee(Be());V.mat2=fc;var hc=ee(Ze());V.mat2d=hc;var dc=ee(Le());V.mat3=dc;var uc=ee(Pe());V.mat4=uc;var pc=ee(Ce());V.quat=pc;var vc=ee(Ht());V.quat2=vc;var _c=ee(Jt());V.vec2=_c;var mc=ee(Ie());V.vec3=mc;var yc=ee(We());V.vec4=yc;function Kt(){if(typeof WeakMap!="function")return null;var e=new WeakMap;return Kt=function(){return e},e}function ee(e){if(e&&e.__esModule)return e;if(e===null||Te(e)!=="object"&&typeof e!="function")return{default:e};var t=Kt();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var s=n?Object.getOwnPropertyDescriptor(e,a):null;s&&(s.get||s.set)?Object.defineProperty(r,a,s):r[a]=e[a]}return r.default=e,t&&t.set(e,r),r}});var er=H(()=>{WL.registerComponent("8thwall-camera",{camera:{type:WL.Type.Enum,values:["auto","back","front"],default:"auto"}},{name:"wonderland-engine",init:function(){this.position=[0,0,0,0],this.rotation=[0,0,0,0],this.started=!1;let e=["auto","back","front"];this.camera=e[this.camera],this.camera=="auto"&&(this.camera="back"),this.onStart=this.onStart.bind(this),this.onUpdate=this.onUpdate.bind(this),XR8.addCameraPipelineModules([XR8.GlTextureRenderer.pipelineModule(),XR8.XrController.pipelineModule(),this]),this.camera=="back"?XR8.run({canvas:Module.canvas,ownRunLoop:!1}):this.camera=="back"?(XR8.XrController.configure({disableWorldTracking:!0}),XR8.run({canvas:Module.canvas,ownRunLoop:!1,cameraConfig:{direction:XR8.XrConfig.camera().FRONT}})):console.error("[8thwall-camera] Invalid camera setting:",this.camera)},update:function(){if(this.started){if(WL.scene.onPostRender.length==0&&(WL.scene.onPreRender.push(function(){XR8.runPreRender(Date.now()),_wl_reset_context()}),WL.scene.onPostRender.push(function(){XR8.runPostRender(Date.now())})),this.rotation[0]==0&&this.rotation[1]==0&&this.rotation[2]==0&&this.rotation[3]==0)return;this.object.resetTransform(),this.object.rotate(this.rotation),this.object.translate(this.position)}},onUpdate:function(e){if(!e.processCpuResult.reality)return;let t=e.processCpuResult.reality.rotation;this.rotation[0]=t.x,this.rotation[1]=t.y,this.rotation[2]=t.z,this.rotation[3]=t.w;let r=e.processCpuResult.reality.position;this.position[0]=r.x,this.position[1]=r.y,this.position[2]=r.z},onStart:function(){this.started=!0}})});var tr=H(()=>{WL.registerComponent("cursor-target",{},{init:function(){this.hoverFunctions=[],this.unHoverFunctions=[],this.clickFunctions=[],this.moveFunctions=[],this.downFunctions=[],this.upFunctions=[]},onHover:function(e,t){for(let r of this.hoverFunctions)r(e,t)},onUnhover:function(e,t){for(let r of this.unHoverFunctions)r(e,t)},onClick:function(e,t){for(let r of this.clickFunctions)r(e,t)},onMove:function(e,t){for(let r of this.moveFunctions)r(e,t)},onDown:function(e,t){for(let r of this.downFunctions)r(e,t)},onUp:function(e,t){for(let r of this.upFunctions)r(e,t)},addHoverFunction:function(e){this._validateCallback(e),this.hoverFunctions.push(e)},removeHoverFunction:function(e){this._validateCallback(e),this._removeItemOnce(this.hoverFunctions,e)},addUnHoverFunction:function(e){this._validateCallback(e),this.unHoverFunctions.push(e)},removeUnHoverFunction:function(e){this._validateCallback(e),this._removeItemOnce(this.unHoverFunctions,e)},addClickFunction:function(e){this._validateCallback(e),this.clickFunctions.push(e)},removeClickFunction:function(e){this._validateCallback(e),this._removeItemOnce(this.clickFunctions,e)},addMoveFunction:function(e){this._validateCallback(e),this.moveFunctions.push(e)},removeMoveFunction:function(e){this._validateCallback(e),this._removeItemOnce(this.moveFunctions,e)},addDownFunction:function(e){this._validateCallback(e),this.downFunctions.push(e)},removeDownFunction:function(e){this._validateCallback(e),this._removeItemOnce(this.downFunctions,e)},addUpFunction:function(e){this._validateCallback(e),this.upFunctions.push(e)},removeUpFunction:function(e){this._validateCallback(e),this._removeItemOnce(this.upFunctions,e)},_removeItemOnce:function(e,t){var r=e.indexOf(t);return r>-1&&e.splice(r,1),e},_validateCallback:function(e){if(typeof e!="function")throw new TypeError(this.object.name+".cursor-target: Argument needs to be a function")}})});var gc={};var oe,rr=$(()=>{oe=J(te());WL.registerComponent("cursor",{collisionGroup:{type:WL.Type.Int,default:1},cursorRayObject:{type:WL.Type.Object},cursorRayScalingAxis:{type:WL.Type.Enum,values:["x","y","z","none"],default:"z"},cursorObject:{type:WL.Type.Object},handedness:{type:WL.Type.Enum,values:["input component","left","right","none"],default:"input component"},rayCastMode:{type:WL.Type.Enum,values:["collision","physx"],default:"collision"},styleCursor:{type:WL.Type.Bool,default:!0}},{init:function(){this.session=null,this.collisionMask=1<<this.collisionGroup,this.maxDistance=100},start:function(){if(this.handedness==0){let e=this.object.getComponent("input");e?(this.handedness=e.handedness,this.input=e):console.warn("cursor component on object",this.object.name,'was configured with handedness "input component", but object has no input component.')}else this.handedness=["left","right"][this.handedness-1];this.globalTarget=this.object.addComponent("cursor-target"),this.origin=new Float32Array(3),this.cursorObjScale=new Float32Array(3),this.direction=[0,0,0],this.tempQuat=new Float32Array(4),this.viewComponent=this.object.getComponent("view"),this.viewComponent!=null&&(WL.canvas.addEventListener("click",this.onClick.bind(this)),WL.canvas.addEventListener("pointermove",this.onPointerMove.bind(this)),WL.canvas.addEventListener("pointerdown",this.onPointerDown.bind(this)),WL.canvas.addEventListener("pointerup",this.onPointerUp.bind(this)),this.projectionMatrix=new Float32Array(16),oe.mat4.invert(this.projectionMatrix,this.viewComponent.projectionMatrix),window.addEventListener("resize",this.onViewportResize.bind(this))),this.isHovering=!1,this.visible=!0,this.isDown=!1,this.lastIsDown=!1,this.cursorPos=new Float32Array(3),this.hoveringObject=null,WL.onXRSessionStart.push(this.setupVREvents.bind(this)),this.cursorRayObject&&(this.cursorRayScale=new Float32Array(3),this.cursorRayScale.set(this.cursorRayObject.scalingLocal),this.object.getTranslationWorld(this.origin),this.object.getForward(this.direction),this._setCursorRayTransform([this.origin[0]+this.direction[0],this.origin[1]+this.direction[1],this.origin[2]+this.direction[2]]))},onViewportResize:function(){!this.viewComponent||oe.mat4.invert(this.projectionMatrix,this.viewComponent.projectionMatrix)},_setCursorRayTransform:function(e){if(!this.cursorRayObject)return;let t=oe.vec3.dist(this.origin,e);this.cursorRayObject.setTranslationLocal([0,0,-t/2]),this.cursorRayScalingAxis!=4&&(this.cursorRayObject.resetScaling(),this.cursorRayScale[this.cursorRayScalingAxis]=t/2,this.cursorRayObject.scale(this.cursorRayScale))},_setCursorVisibility:function(e){this.visible!=e&&(this.visible=e,!!this.cursorObject&&(e?(this.cursorObject.resetScaling(),this.cursorObject.scale(this.cursorObjScale)):(this.cursorObjScale.set(this.cursorObject.scalingLocal),this.cursorObject.scale([0,0,0]))))},update:function(){this.doUpdate(!1)},doUpdate:function(e){if(this.session){if(this.arTouchDown&&this.input&&WL.xrSession.inputSources[0].handedness==="none"&&WL.xrSession.inputSources[0].gamepad){let r=WL.xrSession.inputSources[0].gamepad.axes;this.direction=[r[0],-r[1],-1],this.updateDirection()}else this.object.getTranslationWorld(this.origin),this.object.getForward(this.direction);let t=this.rayHit=this.rayCastMode==0?WL.scene.rayCast(this.origin,this.direction,this.collisionMask):WL.physics.rayCast(this.origin,this.direction,this.collisionMask,this.maxDistance);t.hitCount>0?this.cursorPos.set(t.locations[0]):this.cursorPos.fill(0),this.hoverBehaviour(t,e)}this.cursorObject&&(this.hoveringObject&&(this.cursorPos[0]!=0||this.cursorPos[1]!=0||this.cursorPos[2]!=0)?(this._setCursorVisibility(!0),this.cursorObject.setTranslationWorld(this.cursorPos),this._setCursorRayTransform(this.cursorPos)):this._setCursorVisibility(!1))},hoverBehaviour:function(e,t){if(e.hitCount>0){if(!this.hoveringObject||!this.hoveringObject.equals(e.objects[0])){if(this.hoveringObject){let a=this.hoveringObject.getComponent("cursor-target");a&&a.onUnhover(this.hoveringObject,this),this.globalTarget.onUnhover(this.hoveringObject,this)}this.hoveringObject=e.objects[0],this.styleCursor&&(WL.canvas.style.cursor="pointer");let n=this.hoveringObject.getComponent("cursor-target");n&&(this.hoveringObjectTarget=n,n.onHover(this.hoveringObject,this)),this.globalTarget.onHover(this.hoveringObject,this)}this.hoveringObjectTarget&&this.hoveringObjectTarget.onMove(this.hoveringObject,this);let r=this.hoveringObject.getComponent("cursor-target");this.isDown!==this.lastIsDown&&(this.isDown?(r&&r.onDown(this.hoveringObject,this),this.globalTarget.onDown(this.hoveringObject,this)):(r&&r.onUp(this.hoveringObject,this),this.globalTarget.onUp(this.hoveringObject,this))),t&&(r&&r.onClick(this.hoveringObject,this),this.globalTarget.onClick(this.hoveringObject,this))}else if(this.hoveringObject&&e.hitCount==0){let r=this.hoveringObject.getComponent("cursor-target");r&&r.onUnhover(this.hoveringObject,this),this.globalTarget.onUnhover(this.hoveringObject,this),this.hoveringObject=null,this.hoveringObjectTarget=null,this.styleCursor&&(WL.canvas.style.cursor="default")}this.lastIsDown=this.isDown},setupVREvents:function(e){this.session=e,e.addEventListener("end",function(t){this.session=null}.bind(this)),e.addEventListener("select",this.onSelect.bind(this)),e.addEventListener("selectstart",this.onSelectStart.bind(this)),e.addEventListener("selectend",this.onSelectEnd.bind(this)),this.onViewportResize()},onSelect:function(e){e.inputSource.handedness==this.handedness&&this.doUpdate(!0)},onSelectStart:function(e){this.arTouchDown=!0,e.inputSource.handedness==this.handedness&&(this.isDown=!0)},onSelectEnd:function(e){this.arTouchDown=!1,e.inputSource.handedness==this.handedness&&(this.isDown=!1)},onPointerMove:function(e){if(!e.isPrimary)return;let t=e.target.getBoundingClientRect(),r=this.updateMousePos(e.clientX,e.clientY,t.width,t.height);this.hoverBehaviour(r,!1)},onClick:function(e){let t=e.target.getBoundingClientRect(),r=this.updateMousePos(e.clientX,e.clientY,t.width,t.height);this.hoverBehaviour(r,!0)},onPointerDown:function(e){if(!e.isPrimary||e.button!==0)return;let t=e.target.getBoundingClientRect(),r=this.updateMousePos(e.clientX,e.clientY,t.width,t.height);this.isDown=!0,this.hoverBehaviour(r,!1)},onPointerUp:function(e){if(!e.isPrimary||e.button!==0)return;let t=e.target.getBoundingClientRect(),r=this.updateMousePos(e.clientX,e.clientY,t.width,t.height);this.isDown=!1,this.hoverBehaviour(r,!1)},updateMousePos:function(e,t,r,n){let a=e/r,s=t/n;return this.direction=[a*2-1,-s*2+1,-1],this.updateDirection()},updateDirection:function(){this.object.getTranslationWorld(this.origin),oe.vec3.transformMat4(this.direction,this.direction,this.projectionMatrix),oe.vec3.normalize(this.direction,this.direction),oe.vec3.transformQuat(this.direction,this.direction,this.object.transformWorld);let e=this.rayHit=this.rayCastMode==0?WL.scene.rayCast(this.origin,this.direction,this.collisionMask):WL.physics.rayCast(this.origin,this.direction,this.collisionMask,this.maxDistance);return e.hitCount>0?this.cursorPos.set(e.locations[0]):this.cursorPos.fill(0),e},onDeactivate:function(){if(this._setCursorVisibility(!1),this.hoveringObject){let e=this.hoveringObject.getComponent("cursor-target");e&&e.onUnhover(this.hoveringObject,this),this.globalTarget.onUnhover(this.hoveringObject,this)}this.cursorRayObject&&this.cursorRayObject.scale([0,0,0])},onActivate:function(){this._setCursorVisibility(!0)}})});var nr=H(()=>{WL.registerComponent("debug-object",{obj:{type:WL.Type.Object}},{start:function(){},init:function(){let e=[0,0,0];glMatrix.quat2.getTranslation(e,this.object.transformWorld),console.log("Debug Object:",this.object.name),console.log("Other object:",this.obj.name),console.log("	translation",e),console.log("	transformWorld",this.object.transformWorld),console.log("	transformLocal",this.object.transformLocal)},update:function(){}})});var ir=H(()=>{function Mc(e,t,r,n){let a=Math.cos(t/2),s=Math.cos(r/2),c=Math.cos(n/2),l=Math.sin(t/2),h=Math.sin(r/2),u=Math.sin(n/2);e[0]=l*s*c+a*h*u,e[1]=a*h*c-l*s*u,e[2]=a*s*u-l*h*c,e[3]=a*s*c+l*h*u}WL.registerComponent("device-orientation-look",{},{start:function(){this.rotationX=0,this.rotationY=0,this.lastClientX=-1,this.lastClientY=-1},init:function(){this.deviceOrientation=[0,0,0,1],this.screenOrientation=0,this._origin=[0,0,0],window.addEventListener("deviceorientation",function(e){let t=e.alpha||0,r=e.beta||0,n=e.gamma||0,a=Math.PI/180;Mc(this.deviceOrientation,r*a,t*a,-n*a)}.bind(this)),window.addEventListener("orientationchange",function(e){this.screenOrientation=window.orientation||0}.bind(this),!1)},update:function(){Module.webxr_session==null&&(glMatrix.quat2.getTranslation(this._origin,this.object.transformLocal),this.object.resetTransform(),this.screenOrientation!=0&&this.object.rotateAxisAngleDeg([0,0,1],this.screenOrientation),this.object.rotate([-Math.sqrt(.5),0,0,Math.sqrt(.5)]),this.object.rotate(this.deviceOrientation),this.object.translate(this._origin))}})});var ar=H(()=>{WL.registerComponent("finger-cursor",{},{init:function(){this.lastTarget=null},start:function(){this.tip=this.object.getComponent("collision")},update:function(){let e=this.tip.queryOverlaps(),t=null;for(let r=0;r<e.length;++r){let n=e[r].object,a=n.getComponent("cursor-target");if(a){a.equals(this.lastTarget)||(a.onHover(n,this),a.onClick(n,this)),t=a;break}}if(t)this.lastTarget=t;else{this.lastTarget&&this.lastTarget.onUnhover(this.lastTarget.object,this),this.lastTarget=null;return}}})});var sr=H(()=>{WL.registerComponent("fixed-foveation",{fixedFoveation:{type:WL.Type.Float,default:.5}},{start:function(){WL.xrSession?this.setFixedFoveation():WL.onXRSessionStart.push(this.setFixedFoveation.bind(this))},setFixedFoveation:function(){"webxr_baseLayer"in Module&&(Module.webxr_baseLayer.fixedFoveation=this.fixedFoveation)}})});var bc={};var fe,or=$(()=>{fe=J(te());WL.registerComponent("hand-tracking",{handedness:{type:WL.Type.Enum,default:"left",values:["left","right"]},jointMesh:{type:WL.Type.Mesh,default:null},jointMaterial:{type:WL.Type.Material,default:null},handSkin:{type:WL.Type.Skin,default:null},deactivateChildrenWithoutPose:{type:WL.Type.Bool,default:!0},controllerToDeactivate:{type:WL.Type.Object}},{ORDERED_JOINTS:["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"],init:function(){this.handedness=["left","right"][this.handedness]},start:function(){if(this.joints=[],this.session=null,this.hasPose=!1,this._childrenActive=!0,!("XRHand"in window)){console.warn("WebXR Hand Tracking not supported by this browser."),this.active=!1;return}if(this.handSkin){let t=this.handSkin.jointIds;this.joints[this.ORDERED_JOINTS[0]]=new WL.Object(t[0]);for(let r=0;r<t.length;++r){let n=new WL.Object(t[r]);this.joints[n.name]=n}return}for(let e=0;e<=this.ORDERED_JOINTS.length;++e){let t=WL.scene.addObject(this.object.parent),r=t.addComponent("mesh");r.mesh=this.jointMesh,r.material=this.jointMaterial,this.joints[this.ORDERED_JOINTS[e]]=t}},update:function(e){if(this.session||WL.xrSession&&this.setupVREvents(WL.xrSession),!!this.session){if(this.hasPose=!1,this.session&&this.session.inputSources)for(let t=0;t<=this.session.inputSources.length;++t){let r=this.session.inputSources[t];if(!r||!r.hand||r.handedness!=this.handedness)continue;if(this.hasPose=!0,r.hand.get("wrist")!==null){let s=Module.webxr_frame.getJointPose(r.hand.get("wrist"),WebXR.refSpaces[WebXR.refSpace]);s&&(this.object.resetTranslationRotation(),this.object.transformLocal.set([s.transform.orientation.x,s.transform.orientation.y,s.transform.orientation.z,s.transform.orientation.w]),this.object.translate([s.transform.position.x,s.transform.position.y,s.transform.position.z]))}let n=new Float32Array(3),a=new Float32Array(4);fe.quat.invert(a,this.object.transformLocal),this.object.getTranslationLocal(n);for(let s=0;s<this.ORDERED_JOINTS.length;++s){let c=this.ORDERED_JOINTS[s],l=this.joints[c];if(l==null)continue;let h=null;if(r.hand.get(c)!==null&&(h=Module.webxr_frame.getJointPose(r.hand.get(c),WebXR.refSpaces[WebXR.refSpace])),h!==null)if(this.handSkin)l.resetTranslationRotation(),l.translate([h.transform.position.x-n[0],h.transform.position.y-n[1],h.transform.position.z-n[2]]),l.rotate(a),l.rotateObject([h.transform.orientation.x,h.transform.orientation.y,h.transform.orientation.z,h.transform.orientation.w]);else{l.resetTransform(),l.transformLocal.set([h.transform.orientation.x,h.transform.orientation.y,h.transform.orientation.z,h.transform.orientation.w]),l.translate([h.transform.position.x,h.transform.position.y,h.transform.position.z]);let u=h.radius||.007;l.scale([u,u,u])}else this.handSkin||l.scale([0,0,0])}}!this.hasPose&&this._childrenActive?(this._childrenActive=!1,this.deactivateChildrenWithoutPose&&this.setChildrenActive(!1),this.controllerToDeactivate&&(this.controllerToDeactivate.active=!0,this.setChildrenActive(!0,this.controllerToDeactivate))):this.hasPose&&!this._childrenActive&&(this._childrenActive=!0,this.deactivateChildrenWithoutPose&&this.setChildrenActive(!0),this.controllerToDeactivate&&(this.controllerToDeactivate.active=!1,this.setChildrenActive(!1,this.controllerToDeactivate)))}},setChildrenActive:function(e,t){t=t||this.object;let r=t.children;for(let n of r)n.active=e,this.setChildrenActive(e,n)},isGrabbing:function(){let e=[0,0,0];fe.quat2.getTranslation(e,this.joints["index-finger-tip"].transformLocal);let t=[0,0,0];return fe.quat2.getTranslation(t,this.joints["thumb-tip"].transformLocal),fe.vec3.sqrDist(t,e)<.001},setupVREvents:function(e){this.session=e}})});var xc={};var cr,lr=$(()=>{cr=J(te());WL.registerComponent("hit-test-location",{},{init:function(){WL.onXRSessionStart.push(this.xrSessionStart.bind(this)),WL.onXRSessionStart.push(this.xrSessionEnd.bind(this)),this.tempScaling=new Float32Array(3),this.tempScaling.set(this.object.scalingLocal),this.visible=!1,this.object.scale([0,0,0])},update:function(e){let t=this.visible;if(this.xrHitTestSource){let r=Module.webxr_frame;if(!r)return;let n=r.getHitTestResults(this.xrHitTestSource);if(n.length>0){let a=n[0].getPose(this.xrViewerSpace);this.visible=!0,cr.quat2.fromMat4(this.object.transformLocal,a.transform.matrix),this.object.setDirty()}else this.visible=!1}this.visible!=t&&(this.visible?(this.object.scalingLocal.set(this.tempScaling),this.object.setDirty()):(this.tempScaling.set(this.object.scalingLocal),this.object.scale([0,0,0])))},xrSessionStart:function(e){e.requestReferenceSpace("viewer").then(function(t){this.xrViewerSpace=t,e.requestHitTestSource({space:this.xrViewerSpace}).then(function(r){this.xrHitTestSource=r}.bind(this)).catch(console.error)}.bind(this)).catch(console.error)},xrSessionEnd:function(){!this.xrHitTestSource||(this.xrHitTestSource.cancel(),this.xrHitTestSource=null)}})});var Fe=H(Se=>{(function(){"use strict";var e=function(){this.init()};e.prototype={init:function(){var i=this||t;return i._counter=1e3,i._html5AudioPool=[],i.html5PoolSize=10,i._codecs={},i._howls=[],i._muted=!1,i._volume=1,i._canPlayEvent="canplaythrough",i._navigator=typeof window!="undefined"&&window.navigator?window.navigator:null,i.masterGain=null,i.noAudio=!1,i.usingWebAudio=!0,i.autoSuspend=!0,i.ctx=null,i.autoUnlock=!0,i._setup(),i},volume:function(i){var o=this||t;if(i=parseFloat(i),o.ctx||u(),typeof i!="undefined"&&i>=0&&i<=1){if(o._volume=i,o._muted)return o;o.usingWebAudio&&o.masterGain.gain.setValueAtTime(i,t.ctx.currentTime);for(var f=0;f<o._howls.length;f++)if(!o._howls[f]._webAudio)for(var d=o._howls[f]._getSoundIds(),v=0;v<d.length;v++){var _=o._howls[f]._soundById(d[v]);_&&_._node&&(_._node.volume=_._volume*i)}return o}return o._volume},mute:function(i){var o=this||t;o.ctx||u(),o._muted=i,o.usingWebAudio&&o.masterGain.gain.setValueAtTime(i?0:o._volume,t.ctx.currentTime);for(var f=0;f<o._howls.length;f++)if(!o._howls[f]._webAudio)for(var d=o._howls[f]._getSoundIds(),v=0;v<d.length;v++){var _=o._howls[f]._soundById(d[v]);_&&_._node&&(_._node.muted=i?!0:_._muted)}return o},stop:function(){for(var i=this||t,o=0;o<i._howls.length;o++)i._howls[o].stop();return i},unload:function(){for(var i=this||t,o=i._howls.length-1;o>=0;o--)i._howls[o].unload();return i.usingWebAudio&&i.ctx&&typeof i.ctx.close!="undefined"&&(i.ctx.close(),i.ctx=null,u()),i},codecs:function(i){return(this||t)._codecs[i.replace(/^x-/,"")]},_setup:function(){var i=this||t;if(i.state=i.ctx&&i.ctx.state||"suspended",i._autoSuspend(),!i.usingWebAudio)if(typeof Audio!="undefined")try{var o=new Audio;typeof o.oncanplaythrough=="undefined"&&(i._canPlayEvent="canplay")}catch(f){i.noAudio=!0}else i.noAudio=!0;try{var o=new Audio;o.muted&&(i.noAudio=!0)}catch(f){}return i.noAudio||i._setupCodecs(),i},_setupCodecs:function(){var i=this||t,o=null;try{o=typeof Audio!="undefined"?new Audio:null}catch(_){return i}if(!o||typeof o.canPlayType!="function")return i;var f=o.canPlayType("audio/mpeg;").replace(/^no$/,""),d=i._navigator&&i._navigator.userAgent.match(/OPR\/([0-6].)/g),v=d&&parseInt(d[0].split("/")[1],10)<33;return i._codecs={mp3:!!(!v&&(f||o.canPlayType("audio/mp3;").replace(/^no$/,""))),mpeg:!!f,opus:!!o.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/,""),ogg:!!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),oga:!!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),wav:!!(o.canPlayType('audio/wav; codecs="1"')||o.canPlayType("audio/wav")).replace(/^no$/,""),aac:!!o.canPlayType("audio/aac;").replace(/^no$/,""),caf:!!o.canPlayType("audio/x-caf;").replace(/^no$/,""),m4a:!!(o.canPlayType("audio/x-m4a;")||o.canPlayType("audio/m4a;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),m4b:!!(o.canPlayType("audio/x-m4b;")||o.canPlayType("audio/m4b;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),mp4:!!(o.canPlayType("audio/x-mp4;")||o.canPlayType("audio/mp4;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),weba:!!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,""),webm:!!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,""),dolby:!!o.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/,""),flac:!!(o.canPlayType("audio/x-flac;")||o.canPlayType("audio/flac;")).replace(/^no$/,"")},i},_unlockAudio:function(){var i=this||t;if(!(i._audioUnlocked||!i.ctx)){i._audioUnlocked=!1,i.autoUnlock=!1,!i._mobileUnloaded&&i.ctx.sampleRate!==44100&&(i._mobileUnloaded=!0,i.unload()),i._scratchBuffer=i.ctx.createBuffer(1,1,22050);var o=function(f){for(;i._html5AudioPool.length<i.html5PoolSize;)try{var d=new Audio;d._unlocked=!0,i._releaseHtml5Audio(d)}catch(g){i.noAudio=!0;break}for(var v=0;v<i._howls.length;v++)if(!i._howls[v]._webAudio)for(var _=i._howls[v]._getSoundIds(),p=0;p<_.length;p++){var m=i._howls[v]._soundById(_[p]);m&&m._node&&!m._node._unlocked&&(m._node._unlocked=!0,m._node.load())}i._autoResume();var y=i.ctx.createBufferSource();y.buffer=i._scratchBuffer,y.connect(i.ctx.destination),typeof y.start=="undefined"?y.noteOn(0):y.start(0),typeof i.ctx.resume=="function"&&i.ctx.resume(),y.onended=function(){y.disconnect(0),i._audioUnlocked=!0,document.removeEventListener("touchstart",o,!0),document.removeEventListener("touchend",o,!0),document.removeEventListener("click",o,!0);for(var g=0;g<i._howls.length;g++)i._howls[g]._emit("unlock")}};return document.addEventListener("touchstart",o,!0),document.addEventListener("touchend",o,!0),document.addEventListener("click",o,!0),i}},_obtainHtml5Audio:function(){var i=this||t;if(i._html5AudioPool.length)return i._html5AudioPool.pop();var o=new Audio().play();return o&&typeof Promise!="undefined"&&(o instanceof Promise||typeof o.then=="function")&&o.catch(function(){console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")}),new Audio},_releaseHtml5Audio:function(i){var o=this||t;return i._unlocked&&o._html5AudioPool.push(i),o},_autoSuspend:function(){var i=this;if(!(!i.autoSuspend||!i.ctx||typeof i.ctx.suspend=="undefined"||!t.usingWebAudio)){for(var o=0;o<i._howls.length;o++)if(i._howls[o]._webAudio){for(var f=0;f<i._howls[o]._sounds.length;f++)if(!i._howls[o]._sounds[f]._paused)return i}return i._suspendTimer&&clearTimeout(i._suspendTimer),i._suspendTimer=setTimeout(function(){if(!!i.autoSuspend){i._suspendTimer=null,i.state="suspending";var d=function(){i.state="suspended",i._resumeAfterSuspend&&(delete i._resumeAfterSuspend,i._autoResume())};i.ctx.suspend().then(d,d)}},3e4),i}},_autoResume:function(){var i=this;if(!(!i.ctx||typeof i.ctx.resume=="undefined"||!t.usingWebAudio))return i.state==="running"&&i.ctx.state!=="interrupted"&&i._suspendTimer?(clearTimeout(i._suspendTimer),i._suspendTimer=null):i.state==="suspended"||i.state==="running"&&i.ctx.state==="interrupted"?(i.ctx.resume().then(function(){i.state="running";for(var o=0;o<i._howls.length;o++)i._howls[o]._emit("resume")}),i._suspendTimer&&(clearTimeout(i._suspendTimer),i._suspendTimer=null)):i.state==="suspending"&&(i._resumeAfterSuspend=!0),i}};var t=new e,r=function(i){var o=this;if(!i.src||i.src.length===0){console.error("An array of source files must be passed with any new Howl.");return}o.init(i)};r.prototype={init:function(i){var o=this;return t.ctx||u(),o._autoplay=i.autoplay||!1,o._format=typeof i.format!="string"?i.format:[i.format],o._html5=i.html5||!1,o._muted=i.mute||!1,o._loop=i.loop||!1,o._pool=i.pool||5,o._preload=typeof i.preload=="boolean"||i.preload==="metadata"?i.preload:!0,o._rate=i.rate||1,o._sprite=i.sprite||{},o._src=typeof i.src!="string"?i.src:[i.src],o._volume=i.volume!==void 0?i.volume:1,o._xhr={method:i.xhr&&i.xhr.method?i.xhr.method:"GET",headers:i.xhr&&i.xhr.headers?i.xhr.headers:null,withCredentials:i.xhr&&i.xhr.withCredentials?i.xhr.withCredentials:!1},o._duration=0,o._state="unloaded",o._sounds=[],o._endTimers={},o._queue=[],o._playLock=!1,o._onend=i.onend?[{fn:i.onend}]:[],o._onfade=i.onfade?[{fn:i.onfade}]:[],o._onload=i.onload?[{fn:i.onload}]:[],o._onloaderror=i.onloaderror?[{fn:i.onloaderror}]:[],o._onplayerror=i.onplayerror?[{fn:i.onplayerror}]:[],o._onpause=i.onpause?[{fn:i.onpause}]:[],o._onplay=i.onplay?[{fn:i.onplay}]:[],o._onstop=i.onstop?[{fn:i.onstop}]:[],o._onmute=i.onmute?[{fn:i.onmute}]:[],o._onvolume=i.onvolume?[{fn:i.onvolume}]:[],o._onrate=i.onrate?[{fn:i.onrate}]:[],o._onseek=i.onseek?[{fn:i.onseek}]:[],o._onunlock=i.onunlock?[{fn:i.onunlock}]:[],o._onresume=[],o._webAudio=t.usingWebAudio&&!o._html5,typeof t.ctx!="undefined"&&t.ctx&&t.autoUnlock&&t._unlockAudio(),t._howls.push(o),o._autoplay&&o._queue.push({event:"play",action:function(){o.play()}}),o._preload&&o._preload!=="none"&&o.load(),o},load:function(){var i=this,o=null;if(t.noAudio){i._emit("loaderror",null,"No audio support.");return}typeof i._src=="string"&&(i._src=[i._src]);for(var f=0;f<i._src.length;f++){var d,v;if(i._format&&i._format[f])d=i._format[f];else{if(v=i._src[f],typeof v!="string"){i._emit("loaderror",null,"Non-string found in selected audio sources - ignoring.");continue}d=/^data:audio\/([^;,]+);/i.exec(v),d||(d=/\.([^.]+)$/.exec(v.split("?",1)[0])),d&&(d=d[1].toLowerCase())}if(d||console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),d&&t.codecs(d)){o=i._src[f];break}}if(!o){i._emit("loaderror",null,"No codec support for selected audio sources.");return}return i._src=o,i._state="loading",window.location.protocol==="https:"&&o.slice(0,5)==="http:"&&(i._html5=!0,i._webAudio=!1),new n(i),i._webAudio&&s(i),i},play:function(i,o){var f=this,d=null;if(typeof i=="number")d=i,i=null;else{if(typeof i=="string"&&f._state==="loaded"&&!f._sprite[i])return null;if(typeof i=="undefined"&&(i="__default",!f._playLock)){for(var v=0,_=0;_<f._sounds.length;_++)f._sounds[_]._paused&&!f._sounds[_]._ended&&(v++,d=f._sounds[_]._id);v===1?i=null:d=null}}var p=d?f._soundById(d):f._inactiveSound();if(!p)return null;if(d&&!i&&(i=p._sprite||"__default"),f._state!=="loaded"){p._sprite=i,p._ended=!1;var m=p._id;return f._queue.push({event:"play",action:function(){f.play(m)}}),m}if(d&&!p._paused)return o||f._loadQueue("play"),p._id;f._webAudio&&t._autoResume();var y=Math.max(0,p._seek>0?p._seek:f._sprite[i][0]/1e3),g=Math.max(0,(f._sprite[i][0]+f._sprite[i][1])/1e3-y),M=g*1e3/Math.abs(p._rate),b=f._sprite[i][0]/1e3,x=(f._sprite[i][0]+f._sprite[i][1])/1e3;p._sprite=i,p._ended=!1;var q=function(){p._paused=!1,p._seek=y,p._start=b,p._stop=x,p._loop=!!(p._loop||f._sprite[i][2])};if(y>=x){f._ended(p);return}var S=p._node;if(f._webAudio){var D=function(){f._playLock=!1,q(),f._refreshBuffer(p);var E=p._muted||f._muted?0:p._volume;S.gain.setValueAtTime(E,t.ctx.currentTime),p._playStart=t.ctx.currentTime,typeof S.bufferSource.start=="undefined"?p._loop?S.bufferSource.noteGrainOn(0,y,86400):S.bufferSource.noteGrainOn(0,y,g):p._loop?S.bufferSource.start(0,y,86400):S.bufferSource.start(0,y,g),M!==Infinity&&(f._endTimers[p._id]=setTimeout(f._ended.bind(f,p),M)),o||setTimeout(function(){f._emit("play",p._id),f._loadQueue()},0)};t.state==="running"&&t.ctx.state!=="interrupted"?D():(f._playLock=!0,f.once("resume",D),f._clearTimer(p._id))}else{var C=function(){S.currentTime=y,S.muted=p._muted||f._muted||t._muted||S.muted,S.volume=p._volume*t.volume(),S.playbackRate=p._rate;try{var E=S.play();if(E&&typeof Promise!="undefined"&&(E instanceof Promise||typeof E.then=="function")?(f._playLock=!0,q(),E.then(function(){f._playLock=!1,S._unlocked=!0,o||(f._emit("play",p._id),f._loadQueue())}).catch(function(){f._playLock=!1,f._emit("playerror",p._id,"Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."),p._ended=!0,p._paused=!0})):o||(f._playLock=!1,q(),f._emit("play",p._id),f._loadQueue()),S.playbackRate=p._rate,S.paused){f._emit("playerror",p._id,"Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");return}i!=="__default"||p._loop?f._endTimers[p._id]=setTimeout(f._ended.bind(f,p),M):(f._endTimers[p._id]=function(){f._ended(p),S.removeEventListener("ended",f._endTimers[p._id],!1)},S.addEventListener("ended",f._endTimers[p._id],!1))}catch(P){f._emit("playerror",p._id,P)}};S.src==="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"&&(S.src=f._src,S.load());var z=window&&window.ejecta||!S.readyState&&t._navigator.isCocoonJS;if(S.readyState>=3||z)C();else{f._playLock=!0;var F=function(){C(),S.removeEventListener(t._canPlayEvent,F,!1)};S.addEventListener(t._canPlayEvent,F,!1),f._clearTimer(p._id)}}return p._id},pause:function(i){var o=this;if(o._state!=="loaded"||o._playLock)return o._queue.push({event:"pause",action:function(){o.pause(i)}}),o;for(var f=o._getSoundIds(i),d=0;d<f.length;d++){o._clearTimer(f[d]);var v=o._soundById(f[d]);if(v&&!v._paused&&(v._seek=o.seek(f[d]),v._rateSeek=0,v._paused=!0,o._stopFade(f[d]),v._node))if(o._webAudio){if(!v._node.bufferSource)continue;typeof v._node.bufferSource.stop=="undefined"?v._node.bufferSource.noteOff(0):v._node.bufferSource.stop(0),o._cleanBuffer(v._node)}else(!isNaN(v._node.duration)||v._node.duration===Infinity)&&v._node.pause();arguments[1]||o._emit("pause",v?v._id:null)}return o},stop:function(i,o){var f=this;if(f._state!=="loaded"||f._playLock)return f._queue.push({event:"stop",action:function(){f.stop(i)}}),f;for(var d=f._getSoundIds(i),v=0;v<d.length;v++){f._clearTimer(d[v]);var _=f._soundById(d[v]);_&&(_._seek=_._start||0,_._rateSeek=0,_._paused=!0,_._ended=!0,f._stopFade(d[v]),_._node&&(f._webAudio?_._node.bufferSource&&(typeof _._node.bufferSource.stop=="undefined"?_._node.bufferSource.noteOff(0):_._node.bufferSource.stop(0),f._cleanBuffer(_._node)):(!isNaN(_._node.duration)||_._node.duration===Infinity)&&(_._node.currentTime=_._start||0,_._node.pause(),_._node.duration===Infinity&&f._clearSound(_._node))),o||f._emit("stop",_._id))}return f},mute:function(i,o){var f=this;if(f._state!=="loaded"||f._playLock)return f._queue.push({event:"mute",action:function(){f.mute(i,o)}}),f;if(typeof o=="undefined")if(typeof i=="boolean")f._muted=i;else return f._muted;for(var d=f._getSoundIds(o),v=0;v<d.length;v++){var _=f._soundById(d[v]);_&&(_._muted=i,_._interval&&f._stopFade(_._id),f._webAudio&&_._node?_._node.gain.setValueAtTime(i?0:_._volume,t.ctx.currentTime):_._node&&(_._node.muted=t._muted?!0:i),f._emit("mute",_._id))}return f},volume:function(){var i=this,o=arguments,f,d;if(o.length===0)return i._volume;if(o.length===1||o.length===2&&typeof o[1]=="undefined"){var v=i._getSoundIds(),_=v.indexOf(o[0]);_>=0?d=parseInt(o[0],10):f=parseFloat(o[0])}else o.length>=2&&(f=parseFloat(o[0]),d=parseInt(o[1],10));var p;if(typeof f!="undefined"&&f>=0&&f<=1){if(i._state!=="loaded"||i._playLock)return i._queue.push({event:"volume",action:function(){i.volume.apply(i,o)}}),i;typeof d=="undefined"&&(i._volume=f),d=i._getSoundIds(d);for(var m=0;m<d.length;m++)p=i._soundById(d[m]),p&&(p._volume=f,o[2]||i._stopFade(d[m]),i._webAudio&&p._node&&!p._muted?p._node.gain.setValueAtTime(f,t.ctx.currentTime):p._node&&!p._muted&&(p._node.volume=f*t.volume()),i._emit("volume",p._id))}else return p=d?i._soundById(d):i._sounds[0],p?p._volume:0;return i},fade:function(i,o,f,d){var v=this;if(v._state!=="loaded"||v._playLock)return v._queue.push({event:"fade",action:function(){v.fade(i,o,f,d)}}),v;i=Math.min(Math.max(0,parseFloat(i)),1),o=Math.min(Math.max(0,parseFloat(o)),1),f=parseFloat(f),v.volume(i,d);for(var _=v._getSoundIds(d),p=0;p<_.length;p++){var m=v._soundById(_[p]);if(m){if(d||v._stopFade(_[p]),v._webAudio&&!m._muted){var y=t.ctx.currentTime,g=y+f/1e3;m._volume=i,m._node.gain.setValueAtTime(i,y),m._node.gain.linearRampToValueAtTime(o,g)}v._startFadeInterval(m,i,o,f,_[p],typeof d=="undefined")}}return v},_startFadeInterval:function(i,o,f,d,v,_){var p=this,m=o,y=f-o,g=Math.abs(y/.01),M=Math.max(4,g>0?d/g:d),b=Date.now();i._fadeTo=f,i._interval=setInterval(function(){var x=(Date.now()-b)/d;b=Date.now(),m+=y*x,m=Math.round(m*100)/100,y<0?m=Math.max(f,m):m=Math.min(f,m),p._webAudio?i._volume=m:p.volume(m,i._id,!0),_&&(p._volume=m),(f<o&&m<=f||f>o&&m>=f)&&(clearInterval(i._interval),i._interval=null,i._fadeTo=null,p.volume(f,i._id),p._emit("fade",i._id))},M)},_stopFade:function(i){var o=this,f=o._soundById(i);return f&&f._interval&&(o._webAudio&&f._node.gain.cancelScheduledValues(t.ctx.currentTime),clearInterval(f._interval),f._interval=null,o.volume(f._fadeTo,i),f._fadeTo=null,o._emit("fade",i)),o},loop:function(){var i=this,o=arguments,f,d,v;if(o.length===0)return i._loop;if(o.length===1)if(typeof o[0]=="boolean")f=o[0],i._loop=f;else return v=i._soundById(parseInt(o[0],10)),v?v._loop:!1;else o.length===2&&(f=o[0],d=parseInt(o[1],10));for(var _=i._getSoundIds(d),p=0;p<_.length;p++)v=i._soundById(_[p]),v&&(v._loop=f,i._webAudio&&v._node&&v._node.bufferSource&&(v._node.bufferSource.loop=f,f&&(v._node.bufferSource.loopStart=v._start||0,v._node.bufferSource.loopEnd=v._stop)));return i},rate:function(){var i=this,o=arguments,f,d;if(o.length===0)d=i._sounds[0]._id;else if(o.length===1){var v=i._getSoundIds(),_=v.indexOf(o[0]);_>=0?d=parseInt(o[0],10):f=parseFloat(o[0])}else o.length===2&&(f=parseFloat(o[0]),d=parseInt(o[1],10));var p;if(typeof f=="number"){if(i._state!=="loaded"||i._playLock)return i._queue.push({event:"rate",action:function(){i.rate.apply(i,o)}}),i;typeof d=="undefined"&&(i._rate=f),d=i._getSoundIds(d);for(var m=0;m<d.length;m++)if(p=i._soundById(d[m]),p){i.playing(d[m])&&(p._rateSeek=i.seek(d[m]),p._playStart=i._webAudio?t.ctx.currentTime:p._playStart),p._rate=f,i._webAudio&&p._node&&p._node.bufferSource?p._node.bufferSource.playbackRate.setValueAtTime(f,t.ctx.currentTime):p._node&&(p._node.playbackRate=f);var y=i.seek(d[m]),g=(i._sprite[p._sprite][0]+i._sprite[p._sprite][1])/1e3-y,M=g*1e3/Math.abs(p._rate);(i._endTimers[d[m]]||!p._paused)&&(i._clearTimer(d[m]),i._endTimers[d[m]]=setTimeout(i._ended.bind(i,p),M)),i._emit("rate",p._id)}}else return p=i._soundById(d),p?p._rate:i._rate;return i},seek:function(){var i=this,o=arguments,f,d;if(o.length===0)d=i._sounds[0]._id;else if(o.length===1){var v=i._getSoundIds(),_=v.indexOf(o[0]);_>=0?d=parseInt(o[0],10):i._sounds.length&&(d=i._sounds[0]._id,f=parseFloat(o[0]))}else o.length===2&&(f=parseFloat(o[0]),d=parseInt(o[1],10));if(typeof d=="undefined")return i;if(typeof f=="number"&&(i._state!=="loaded"||i._playLock))return i._queue.push({event:"seek",action:function(){i.seek.apply(i,o)}}),i;var p=i._soundById(d);if(p)if(typeof f=="number"&&f>=0){var m=i.playing(d);m&&i.pause(d,!0),p._seek=f,p._ended=!1,i._clearTimer(d),!i._webAudio&&p._node&&!isNaN(p._node.duration)&&(p._node.currentTime=f);var y=function(){i._emit("seek",d),m&&i.play(d,!0)};if(m&&!i._webAudio){var g=function(){i._playLock?setTimeout(g,0):y()};setTimeout(g,0)}else y()}else if(i._webAudio){var M=i.playing(d)?t.ctx.currentTime-p._playStart:0,b=p._rateSeek?p._rateSeek-p._seek:0;return p._seek+(b+M*Math.abs(p._rate))}else return p._node.currentTime;return i},playing:function(i){var o=this;if(typeof i=="number"){var f=o._soundById(i);return f?!f._paused:!1}for(var d=0;d<o._sounds.length;d++)if(!o._sounds[d]._paused)return!0;return!1},duration:function(i){var o=this,f=o._duration,d=o._soundById(i);return d&&(f=o._sprite[d._sprite][1]/1e3),f},state:function(){return this._state},unload:function(){for(var i=this,o=i._sounds,f=0;f<o.length;f++)o[f]._paused||i.stop(o[f]._id),i._webAudio||(i._clearSound(o[f]._node),o[f]._node.removeEventListener("error",o[f]._errorFn,!1),o[f]._node.removeEventListener(t._canPlayEvent,o[f]._loadFn,!1),o[f]._node.removeEventListener("ended",o[f]._endFn,!1),t._releaseHtml5Audio(o[f]._node)),delete o[f]._node,i._clearTimer(o[f]._id);var d=t._howls.indexOf(i);d>=0&&t._howls.splice(d,1);var v=!0;for(f=0;f<t._howls.length;f++)if(t._howls[f]._src===i._src||i._src.indexOf(t._howls[f]._src)>=0){v=!1;break}return a&&v&&delete a[i._src],t.noAudio=!1,i._state="unloaded",i._sounds=[],i=null,null},on:function(i,o,f,d){var v=this,_=v["_on"+i];return typeof o=="function"&&_.push(d?{id:f,fn:o,once:d}:{id:f,fn:o}),v},off:function(i,o,f){var d=this,v=d["_on"+i],_=0;if(typeof o=="number"&&(f=o,o=null),o||f)for(_=0;_<v.length;_++){var p=f===v[_].id;if(o===v[_].fn&&p||!o&&p){v.splice(_,1);break}}else if(i)d["_on"+i]=[];else{var m=Object.keys(d);for(_=0;_<m.length;_++)m[_].indexOf("_on")===0&&Array.isArray(d[m[_]])&&(d[m[_]]=[])}return d},once:function(i,o,f){var d=this;return d.on(i,o,f,1),d},_emit:function(i,o,f){for(var d=this,v=d["_on"+i],_=v.length-1;_>=0;_--)(!v[_].id||v[_].id===o||i==="load")&&(setTimeout(function(p){p.call(this,o,f)}.bind(d,v[_].fn),0),v[_].once&&d.off(i,v[_].fn,v[_].id));return d._loadQueue(i),d},_loadQueue:function(i){var o=this;if(o._queue.length>0){var f=o._queue[0];f.event===i&&(o._queue.shift(),o._loadQueue()),i||f.action()}return o},_ended:function(i){var o=this,f=i._sprite;if(!o._webAudio&&i._node&&!i._node.paused&&!i._node.ended&&i._node.currentTime<i._stop)return setTimeout(o._ended.bind(o,i),100),o;var d=!!(i._loop||o._sprite[f][2]);if(o._emit("end",i._id),!o._webAudio&&d&&o.stop(i._id,!0).play(i._id),o._webAudio&&d){o._emit("play",i._id),i._seek=i._start||0,i._rateSeek=0,i._playStart=t.ctx.currentTime;var v=(i._stop-i._start)*1e3/Math.abs(i._rate);o._endTimers[i._id]=setTimeout(o._ended.bind(o,i),v)}return o._webAudio&&!d&&(i._paused=!0,i._ended=!0,i._seek=i._start||0,i._rateSeek=0,o._clearTimer(i._id),o._cleanBuffer(i._node),t._autoSuspend()),!o._webAudio&&!d&&o.stop(i._id,!0),o},_clearTimer:function(i){var o=this;if(o._endTimers[i]){if(typeof o._endTimers[i]!="function")clearTimeout(o._endTimers[i]);else{var f=o._soundById(i);f&&f._node&&f._node.removeEventListener("ended",o._endTimers[i],!1)}delete o._endTimers[i]}return o},_soundById:function(i){for(var o=this,f=0;f<o._sounds.length;f++)if(i===o._sounds[f]._id)return o._sounds[f];return null},_inactiveSound:function(){var i=this;i._drain();for(var o=0;o<i._sounds.length;o++)if(i._sounds[o]._ended)return i._sounds[o].reset();return new n(i)},_drain:function(){var i=this,o=i._pool,f=0,d=0;if(!(i._sounds.length<o)){for(d=0;d<i._sounds.length;d++)i._sounds[d]._ended&&f++;for(d=i._sounds.length-1;d>=0;d--){if(f<=o)return;i._sounds[d]._ended&&(i._webAudio&&i._sounds[d]._node&&i._sounds[d]._node.disconnect(0),i._sounds.splice(d,1),f--)}}},_getSoundIds:function(i){var o=this;if(typeof i=="undefined"){for(var f=[],d=0;d<o._sounds.length;d++)f.push(o._sounds[d]._id);return f}else return[i]},_refreshBuffer:function(i){var o=this;return i._node.bufferSource=t.ctx.createBufferSource(),i._node.bufferSource.buffer=a[o._src],i._panner?i._node.bufferSource.connect(i._panner):i._node.bufferSource.connect(i._node),i._node.bufferSource.loop=i._loop,i._loop&&(i._node.bufferSource.loopStart=i._start||0,i._node.bufferSource.loopEnd=i._stop||0),i._node.bufferSource.playbackRate.setValueAtTime(i._rate,t.ctx.currentTime),o},_cleanBuffer:function(i){var o=this,f=t._navigator&&t._navigator.vendor.indexOf("Apple")>=0;if(t._scratchBuffer&&i.bufferSource&&(i.bufferSource.onended=null,i.bufferSource.disconnect(0),f))try{i.bufferSource.buffer=t._scratchBuffer}catch(d){}return i.bufferSource=null,o},_clearSound:function(i){var o=/MSIE |Trident\//.test(t._navigator&&t._navigator.userAgent);o||(i.src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")}};var n=function(i){this._parent=i,this.init()};n.prototype={init:function(){var i=this,o=i._parent;return i._muted=o._muted,i._loop=o._loop,i._volume=o._volume,i._rate=o._rate,i._seek=0,i._paused=!0,i._ended=!0,i._sprite="__default",i._id=++t._counter,o._sounds.push(i),i.create(),i},create:function(){var i=this,o=i._parent,f=t._muted||i._muted||i._parent._muted?0:i._volume;return o._webAudio?(i._node=typeof t.ctx.createGain=="undefined"?t.ctx.createGainNode():t.ctx.createGain(),i._node.gain.setValueAtTime(f,t.ctx.currentTime),i._node.paused=!0,i._node.connect(t.masterGain)):t.noAudio||(i._node=t._obtainHtml5Audio(),i._errorFn=i._errorListener.bind(i),i._node.addEventListener("error",i._errorFn,!1),i._loadFn=i._loadListener.bind(i),i._node.addEventListener(t._canPlayEvent,i._loadFn,!1),i._endFn=i._endListener.bind(i),i._node.addEventListener("ended",i._endFn,!1),i._node.src=o._src,i._node.preload=o._preload===!0?"auto":o._preload,i._node.volume=f*t.volume(),i._node.load()),i},reset:function(){var i=this,o=i._parent;return i._muted=o._muted,i._loop=o._loop,i._volume=o._volume,i._rate=o._rate,i._seek=0,i._rateSeek=0,i._paused=!0,i._ended=!0,i._sprite="__default",i._id=++t._counter,i},_errorListener:function(){var i=this;i._parent._emit("loaderror",i._id,i._node.error?i._node.error.code:0),i._node.removeEventListener("error",i._errorFn,!1)},_loadListener:function(){var i=this,o=i._parent;o._duration=Math.ceil(i._node.duration*10)/10,Object.keys(o._sprite).length===0&&(o._sprite={__default:[0,o._duration*1e3]}),o._state!=="loaded"&&(o._state="loaded",o._emit("load"),o._loadQueue()),i._node.removeEventListener(t._canPlayEvent,i._loadFn,!1)},_endListener:function(){var i=this,o=i._parent;o._duration===Infinity&&(o._duration=Math.ceil(i._node.duration*10)/10,o._sprite.__default[1]===Infinity&&(o._sprite.__default[1]=o._duration*1e3),o._ended(i)),i._node.removeEventListener("ended",i._endFn,!1)}};var a={},s=function(i){var o=i._src;if(a[o]){i._duration=a[o].duration,h(i);return}if(/^data:[^;]+;base64,/.test(o)){for(var f=atob(o.split(",")[1]),d=new Uint8Array(f.length),v=0;v<f.length;++v)d[v]=f.charCodeAt(v);l(d.buffer,i)}else{var _=new XMLHttpRequest;_.open(i._xhr.method,o,!0),_.withCredentials=i._xhr.withCredentials,_.responseType="arraybuffer",i._xhr.headers&&Object.keys(i._xhr.headers).forEach(function(p){_.setRequestHeader(p,i._xhr.headers[p])}),_.onload=function(){var p=(_.status+"")[0];if(p!=="0"&&p!=="2"&&p!=="3"){i._emit("loaderror",null,"Failed loading audio file with status: "+_.status+".");return}l(_.response,i)},_.onerror=function(){i._webAudio&&(i._html5=!0,i._webAudio=!1,i._sounds=[],delete a[o],i.load())},c(_)}},c=function(i){try{i.send()}catch(o){i.onerror()}},l=function(i,o){var f=function(){o._emit("loaderror",null,"Decoding audio data failed.")},d=function(v){v&&o._sounds.length>0?(a[o._src]=v,h(o,v)):f()};typeof Promise!="undefined"&&t.ctx.decodeAudioData.length===1?t.ctx.decodeAudioData(i).then(d).catch(f):t.ctx.decodeAudioData(i,d,f)},h=function(i,o){o&&!i._duration&&(i._duration=o.duration),Object.keys(i._sprite).length===0&&(i._sprite={__default:[0,i._duration*1e3]}),i._state!=="loaded"&&(i._state="loaded",i._emit("load"),i._loadQueue())},u=function(){if(!!t.usingWebAudio){try{typeof AudioContext!="undefined"?t.ctx=new AudioContext:typeof webkitAudioContext!="undefined"?t.ctx=new webkitAudioContext:t.usingWebAudio=!1}catch(v){t.usingWebAudio=!1}t.ctx||(t.usingWebAudio=!1);var i=/iP(hone|od|ad)/.test(t._navigator&&t._navigator.platform),o=t._navigator&&t._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),f=o?parseInt(o[1],10):null;if(i&&f&&f<9){var d=/safari/.test(t._navigator&&t._navigator.userAgent.toLowerCase());t._navigator&&!d&&(t.usingWebAudio=!1)}t.usingWebAudio&&(t.masterGain=typeof t.ctx.createGain=="undefined"?t.ctx.createGainNode():t.ctx.createGain(),t.masterGain.gain.setValueAtTime(t._muted?0:t._volume,t.ctx.currentTime),t.masterGain.connect(t.ctx.destination)),t._setup()}};typeof define=="function"&&define.amd&&define([],function(){return{Howler:t,Howl:r}}),typeof Se!="undefined"&&(Se.Howler=t,Se.Howl=r),typeof global!="undefined"?(global.HowlerGlobal=e,global.Howler=t,global.Howl=r,global.Sound=n):typeof window!="undefined"&&(window.HowlerGlobal=e,window.Howler=t,window.Howl=r,window.Sound=n)})();(function(){"use strict";HowlerGlobal.prototype._pos=[0,0,0],HowlerGlobal.prototype._orientation=[0,0,-1,0,1,0],HowlerGlobal.prototype.stereo=function(t){var r=this;if(!r.ctx||!r.ctx.listener)return r;for(var n=r._howls.length-1;n>=0;n--)r._howls[n].stereo(t);return r},HowlerGlobal.prototype.pos=function(t,r,n){var a=this;if(!a.ctx||!a.ctx.listener)return a;if(r=typeof r!="number"?a._pos[1]:r,n=typeof n!="number"?a._pos[2]:n,typeof t=="number")a._pos=[t,r,n],typeof a.ctx.listener.positionX!="undefined"?(a.ctx.listener.positionX.setTargetAtTime(a._pos[0],Howler.ctx.currentTime,.1),a.ctx.listener.positionY.setTargetAtTime(a._pos[1],Howler.ctx.currentTime,.1),a.ctx.listener.positionZ.setTargetAtTime(a._pos[2],Howler.ctx.currentTime,.1)):a.ctx.listener.setPosition(a._pos[0],a._pos[1],a._pos[2]);else return a._pos;return a},HowlerGlobal.prototype.orientation=function(t,r,n,a,s,c){var l=this;if(!l.ctx||!l.ctx.listener)return l;var h=l._orientation;if(r=typeof r!="number"?h[1]:r,n=typeof n!="number"?h[2]:n,a=typeof a!="number"?h[3]:a,s=typeof s!="number"?h[4]:s,c=typeof c!="number"?h[5]:c,typeof t=="number")l._orientation=[t,r,n,a,s,c],typeof l.ctx.listener.forwardX!="undefined"?(l.ctx.listener.forwardX.setTargetAtTime(t,Howler.ctx.currentTime,.1),l.ctx.listener.forwardY.setTargetAtTime(r,Howler.ctx.currentTime,.1),l.ctx.listener.forwardZ.setTargetAtTime(n,Howler.ctx.currentTime,.1),l.ctx.listener.upX.setTargetAtTime(a,Howler.ctx.currentTime,.1),l.ctx.listener.upY.setTargetAtTime(s,Howler.ctx.currentTime,.1),l.ctx.listener.upZ.setTargetAtTime(c,Howler.ctx.currentTime,.1)):l.ctx.listener.setOrientation(t,r,n,a,s,c);else return h;return l},Howl.prototype.init=function(t){return function(r){var n=this;return n._orientation=r.orientation||[1,0,0],n._stereo=r.stereo||null,n._pos=r.pos||null,n._pannerAttr={coneInnerAngle:typeof r.coneInnerAngle!="undefined"?r.coneInnerAngle:360,coneOuterAngle:typeof r.coneOuterAngle!="undefined"?r.coneOuterAngle:360,coneOuterGain:typeof r.coneOuterGain!="undefined"?r.coneOuterGain:0,distanceModel:typeof r.distanceModel!="undefined"?r.distanceModel:"inverse",maxDistance:typeof r.maxDistance!="undefined"?r.maxDistance:1e4,panningModel:typeof r.panningModel!="undefined"?r.panningModel:"HRTF",refDistance:typeof r.refDistance!="undefined"?r.refDistance:1,rolloffFactor:typeof r.rolloffFactor!="undefined"?r.rolloffFactor:1},n._onstereo=r.onstereo?[{fn:r.onstereo}]:[],n._onpos=r.onpos?[{fn:r.onpos}]:[],n._onorientation=r.onorientation?[{fn:r.onorientation}]:[],t.call(this,r)}}(Howl.prototype.init),Howl.prototype.stereo=function(t,r){var n=this;if(!n._webAudio)return n;if(n._state!=="loaded")return n._queue.push({event:"stereo",action:function(){n.stereo(t,r)}}),n;var a=typeof Howler.ctx.createStereoPanner=="undefined"?"spatial":"stereo";if(typeof r=="undefined")if(typeof t=="number")n._stereo=t,n._pos=[t,0,0];else return n._stereo;for(var s=n._getSoundIds(r),c=0;c<s.length;c++){var l=n._soundById(s[c]);if(l)if(typeof t=="number")l._stereo=t,l._pos=[t,0,0],l._node&&(l._pannerAttr.panningModel="equalpower",(!l._panner||!l._panner.pan)&&e(l,a),a==="spatial"?typeof l._panner.positionX!="undefined"?(l._panner.positionX.setValueAtTime(t,Howler.ctx.currentTime),l._panner.positionY.setValueAtTime(0,Howler.ctx.currentTime),l._panner.positionZ.setValueAtTime(0,Howler.ctx.currentTime)):l._panner.setPosition(t,0,0):l._panner.pan.setValueAtTime(t,Howler.ctx.currentTime)),n._emit("stereo",l._id);else return l._stereo}return n},Howl.prototype.pos=function(t,r,n,a){var s=this;if(!s._webAudio)return s;if(s._state!=="loaded")return s._queue.push({event:"pos",action:function(){s.pos(t,r,n,a)}}),s;if(r=typeof r!="number"?0:r,n=typeof n!="number"?-.5:n,typeof a=="undefined")if(typeof t=="number")s._pos=[t,r,n];else return s._pos;for(var c=s._getSoundIds(a),l=0;l<c.length;l++){var h=s._soundById(c[l]);if(h)if(typeof t=="number")h._pos=[t,r,n],h._node&&((!h._panner||h._panner.pan)&&e(h,"spatial"),typeof h._panner.positionX!="undefined"?(h._panner.positionX.setValueAtTime(t,Howler.ctx.currentTime),h._panner.positionY.setValueAtTime(r,Howler.ctx.currentTime),h._panner.positionZ.setValueAtTime(n,Howler.ctx.currentTime)):h._panner.setPosition(t,r,n)),s._emit("pos",h._id);else return h._pos}return s},Howl.prototype.orientation=function(t,r,n,a){var s=this;if(!s._webAudio)return s;if(s._state!=="loaded")return s._queue.push({event:"orientation",action:function(){s.orientation(t,r,n,a)}}),s;if(r=typeof r!="number"?s._orientation[1]:r,n=typeof n!="number"?s._orientation[2]:n,typeof a=="undefined")if(typeof t=="number")s._orientation=[t,r,n];else return s._orientation;for(var c=s._getSoundIds(a),l=0;l<c.length;l++){var h=s._soundById(c[l]);if(h)if(typeof t=="number")h._orientation=[t,r,n],h._node&&(h._panner||(h._pos||(h._pos=s._pos||[0,0,-.5]),e(h,"spatial")),typeof h._panner.orientationX!="undefined"?(h._panner.orientationX.setValueAtTime(t,Howler.ctx.currentTime),h._panner.orientationY.setValueAtTime(r,Howler.ctx.currentTime),h._panner.orientationZ.setValueAtTime(n,Howler.ctx.currentTime)):h._panner.setOrientation(t,r,n)),s._emit("orientation",h._id);else return h._orientation}return s},Howl.prototype.pannerAttr=function(){var t=this,r=arguments,n,a,s;if(!t._webAudio)return t;if(r.length===0)return t._pannerAttr;if(r.length===1)if(typeof r[0]=="object")n=r[0],typeof a=="undefined"&&(n.pannerAttr||(n.pannerAttr={coneInnerAngle:n.coneInnerAngle,coneOuterAngle:n.coneOuterAngle,coneOuterGain:n.coneOuterGain,distanceModel:n.distanceModel,maxDistance:n.maxDistance,refDistance:n.refDistance,rolloffFactor:n.rolloffFactor,panningModel:n.panningModel}),t._pannerAttr={coneInnerAngle:typeof n.pannerAttr.coneInnerAngle!="undefined"?n.pannerAttr.coneInnerAngle:t._coneInnerAngle,coneOuterAngle:typeof n.pannerAttr.coneOuterAngle!="undefined"?n.pannerAttr.coneOuterAngle:t._coneOuterAngle,coneOuterGain:typeof n.pannerAttr.coneOuterGain!="undefined"?n.pannerAttr.coneOuterGain:t._coneOuterGain,distanceModel:typeof n.pannerAttr.distanceModel!="undefined"?n.pannerAttr.distanceModel:t._distanceModel,maxDistance:typeof n.pannerAttr.maxDistance!="undefined"?n.pannerAttr.maxDistance:t._maxDistance,refDistance:typeof n.pannerAttr.refDistance!="undefined"?n.pannerAttr.refDistance:t._refDistance,rolloffFactor:typeof n.pannerAttr.rolloffFactor!="undefined"?n.pannerAttr.rolloffFactor:t._rolloffFactor,panningModel:typeof n.pannerAttr.panningModel!="undefined"?n.pannerAttr.panningModel:t._panningModel});else return s=t._soundById(parseInt(r[0],10)),s?s._pannerAttr:t._pannerAttr;else r.length===2&&(n=r[0],a=parseInt(r[1],10));for(var c=t._getSoundIds(a),l=0;l<c.length;l++)if(s=t._soundById(c[l]),s){var h=s._pannerAttr;h={coneInnerAngle:typeof n.coneInnerAngle!="undefined"?n.coneInnerAngle:h.coneInnerAngle,coneOuterAngle:typeof n.coneOuterAngle!="undefined"?n.coneOuterAngle:h.coneOuterAngle,coneOuterGain:typeof n.coneOuterGain!="undefined"?n.coneOuterGain:h.coneOuterGain,distanceModel:typeof n.distanceModel!="undefined"?n.distanceModel:h.distanceModel,maxDistance:typeof n.maxDistance!="undefined"?n.maxDistance:h.maxDistance,refDistance:typeof n.refDistance!="undefined"?n.refDistance:h.refDistance,rolloffFactor:typeof n.rolloffFactor!="undefined"?n.rolloffFactor:h.rolloffFactor,panningModel:typeof n.panningModel!="undefined"?n.panningModel:h.panningModel};var u=s._panner;u?(u.coneInnerAngle=h.coneInnerAngle,u.coneOuterAngle=h.coneOuterAngle,u.coneOuterGain=h.coneOuterGain,u.distanceModel=h.distanceModel,u.maxDistance=h.maxDistance,u.refDistance=h.refDistance,u.rolloffFactor=h.rolloffFactor,u.panningModel=h.panningModel):(s._pos||(s._pos=t._pos||[0,0,-.5]),e(s,"spatial"))}return t},Sound.prototype.init=function(t){return function(){var r=this,n=r._parent;r._orientation=n._orientation,r._stereo=n._stereo,r._pos=n._pos,r._pannerAttr=n._pannerAttr,t.call(this),r._stereo?n.stereo(r._stereo):r._pos&&n.pos(r._pos[0],r._pos[1],r._pos[2],r._id)}}(Sound.prototype.init),Sound.prototype.reset=function(t){return function(){var r=this,n=r._parent;return r._orientation=n._orientation,r._stereo=n._stereo,r._pos=n._pos,r._pannerAttr=n._pannerAttr,r._stereo?n.stereo(r._stereo):r._pos?n.pos(r._pos[0],r._pos[1],r._pos[2],r._id):r._panner&&(r._panner.disconnect(0),r._panner=void 0,n._refreshBuffer(r)),t.call(this)}}(Sound.prototype.reset);var e=function(t,r){r=r||"spatial",r==="spatial"?(t._panner=Howler.ctx.createPanner(),t._panner.coneInnerAngle=t._pannerAttr.coneInnerAngle,t._panner.coneOuterAngle=t._pannerAttr.coneOuterAngle,t._panner.coneOuterGain=t._pannerAttr.coneOuterGain,t._panner.distanceModel=t._pannerAttr.distanceModel,t._panner.maxDistance=t._pannerAttr.maxDistance,t._panner.refDistance=t._pannerAttr.refDistance,t._panner.rolloffFactor=t._pannerAttr.rolloffFactor,t._panner.panningModel=t._pannerAttr.panningModel,typeof t._panner.positionX!="undefined"?(t._panner.positionX.setValueAtTime(t._pos[0],Howler.ctx.currentTime),t._panner.positionY.setValueAtTime(t._pos[1],Howler.ctx.currentTime),t._panner.positionZ.setValueAtTime(t._pos[2],Howler.ctx.currentTime)):t._panner.setPosition(t._pos[0],t._pos[1],t._pos[2]),typeof t._panner.orientationX!="undefined"?(t._panner.orientationX.setValueAtTime(t._orientation[0],Howler.ctx.currentTime),t._panner.orientationY.setValueAtTime(t._orientation[1],Howler.ctx.currentTime),t._panner.orientationZ.setValueAtTime(t._orientation[2],Howler.ctx.currentTime)):t._panner.setOrientation(t._orientation[0],t._orientation[1],t._orientation[2])):(t._panner=Howler.ctx.createStereoPanner(),t._panner.pan.setValueAtTime(t._stereo,Howler.ctx.currentTime)),t._panner.connect(t._node),t._paused||t._parent.pause(t._id,!0).play(t._id,!0)}})()});var wc={};var rl,fr=$(()=>{rl=J(Fe());WL.registerComponent("howler-audio-listener",{spatial:{type:WL.Type.Bool,default:!0}},{init:function(){this.origin=new Float32Array(3),this.fwd=new Float32Array(3),this.up=new Float32Array(3)},update:function(){!this.spatial||(this.object.getTranslationWorld(this.origin),this.object.getForward(this.fwd),this.object.getUp(this.up),Howler.pos(this.origin[0],this.origin[1],this.origin[2]),Howler.orientation(this.fwd[0],this.fwd[1],this.fwd[2],this.up[0],this.up[1],this.up[2]))}})});var Ac={};var hr,dr=$(()=>{hr=J(Fe());WL.registerComponent("howler-audio-source",{volume:{type:WL.Type.Float,default:1},spatial:{type:WL.Type.Bool,default:!0},loop:{type:WL.Type.Bool,default:!1},autoplay:{type:WL.Type.Bool,default:!1},src:{type:WL.Type.String,default:""}},{start:function(){this.audio=new hr.Howl({src:[this.src],loop:this.loop,volume:this.volume,autoplay:this.autoplay}),this.lastPlayedAudioId=null,this.origin=new Float32Array(3),this.lastOrigin=new Float32Array(3),this.spatial&&this.autoplay&&(this.updatePosition(),this.play());let e=()=>{this.stop();let t=WL.onSceneLoaded.indexOf(e);t>=0&&WL.onSceneLoaded.splice(t,1)};WL.onSceneLoaded.push(e)},update:function(){!this.spatial||!this.lastPlayedAudioId||(this.object.getTranslationWorld(this.origin),(Math.abs(this.lastOrigin[0]-this.origin[0])>.005||Math.abs(this.lastOrigin[1]-this.origin[1])>.005||Math.abs(this.lastOrigin[2]-this.origin[2])>.005)&&this.updatePosition())},updatePosition:function(){this.audio.pos(this.origin[0],this.origin[1],this.origin[2],this.lastPlayedAudioId),this.lastOrigin.set(this.origin)},play:function(){this.lastPlayedAudioId&&this.audio.stop(this.lastPlayedAudioId),this.lastPlayedAudioId=this.audio.play(),this.spatial&&this.updatePosition()},stop:function(){!this.lastPlayedAudioId||(this.audio.stop(this.lastPlayedAudioId),this.lastPlayedAudioId=null)}})});var ur=H(()=>{WL.registerComponent("image-texture",{url:{type:WL.Type.String,default:""},meshIndex:{type:WL.Type.Int,default:0}},{init:function(){let e=this.object;WL.textures.load(this.url,"anonymous").then(function(t){let r=e.getComponent("mesh",this.meshIndex).material;r.shader=="Flat Opaque Textured"?r.flatTexture=t:r.shader=="Phong Opaque Textured"?r.diffuseTexture=t:console.error("Shader",r.shader,"not supported by image-texture")}).catch(console.err)}})});var Tc={};var pr,vr=$(()=>{pr=J(te());WL.registerComponent("mouse-look",{sensitity:{type:WL.Type.Float,default:.25},requireMouseDown:{type:WL.Type.Bool,default:!0},mouseButtonIndex:{type:WL.Type.Int,default:0}},{init:function(){this.currentRotationY=0,this.currentRotationX=0,this.origin=new Float32Array(3),this.parentOrigin=new Float32Array(3),document.addEventListener("mousemove",function(e){this.active&&(this.mouseDown||!this.requireMouseDown)&&(this.rotationY=-this.sensitity*e.movementX/100,this.rotationX=-this.sensitity*e.movementY/100,this.currentRotationX+=this.rotationX,this.currentRotationY+=this.rotationY,this.currentRotationX=Math.min(1.507,this.currentRotationX),this.currentRotationX=Math.max(-1.507,this.currentRotationX),this.object.getTranslationWorld(this.origin),this.object.parent.getTranslationWorld(this.parentOrigin),pr.vec3.sub(this.origin,this.origin,this.parentOrigin),this.object.resetTranslationRotation(),this.object.rotateAxisAngleRad([1,0,0],this.currentRotationX),this.object.rotateAxisAngleRad([0,1,0],this.currentRotationY),this.object.translate(this.origin))}.bind(this)),this.requireMouseDown&&(this.mouseButtonIndex==2&&WL.canvas.addEventListener("contextmenu",function(e){e.preventDefault()},!1),WL.canvas.addEventListener("mousedown",function(e){if(e.button==this.mouseButtonIndex&&(this.mouseDown=!0,document.body.style.cursor="grabbing",e.button==1))return e.preventDefault(),!1}.bind(this)),WL.canvas.addEventListener("mouseup",function(e){e.button==this.mouseButtonIndex&&(this.mouseDown=!1,document.body.style.cursor="initial")}.bind(this)))},start:function(){this.rotationX=0,this.rotationY=0}})});var _r=H(()=>{WL.registerComponent("target-framerate",{framerate:{type:WL.Type.Float,default:90}},{start:function(){WL.xrSession?this.setTargetFramerate(WL.xrSession):WL.onXRSessionStart.push(this.setTargetFramerate.bind(this))},setTargetFramerate:function(e){if(e.supportedFrameRates&&e.updateTargetFrameRate){let t=WL.xrSession.supportedFrameRates;t.sort((r,n)=>Math.abs(r-this.framerate)-Math.abs(n-this.framerate)),WL.xrSession.updateTargetFrameRate(t[0])}}})});var Sc={};var ae,mr=$(()=>{ae=J(te());WL.registerComponent("teleport",{teleportIndicatorMeshObject:{type:WL.Type.Object},camRoot:{type:WL.Type.Object},cam:{type:WL.Type.Object},eyeLeft:{type:WL.Type.Object},eyeRight:{type:WL.Type.Object},handedness:{type:WL.Type.Enum,values:["input component","left","right","none"],default:"input component"},floorGroup:{type:WL.Type.Int,default:1},thumbstickActivationThreshhold:{type:WL.Type.Float,default:-.7},thumbstickDeactivationThreshhold:{type:WL.Type.Float,default:.3},indicatorYOffset:{type:WL.Type.Float,default:.01},rayCastMode:{type:WL.Type.Enum,values:["collision","physx"],default:"collision"},maxDistance:{type:WL.Type.Float,default:100}},{init:function(){if(this._prevThumbstickAxis=new Float32Array(2),this._tempVec=new Float32Array(3),this._tempVec0=new Float32Array(3),this._currentIndicatorRotation=0,this.input=this.object.getComponent("input"),!this.input){console.error(this.object.name,"generic-teleport-component.js: input component is required on the object");return}if(!this.teleportIndicatorMeshObject){console.error(this.object.name,"generic-teleport-component.js: Teleport indicator mesh is missing");return}if(!this.camRoot){console.error(this.object.name,"generic-teleport-component.js: camRoot not set");return}this.isIndicating=!1,this.cam&&(this.isMouseIndicating=!1,WL.canvas.addEventListener("mousedown",this.onMouseDown.bind(this)),WL.canvas.addEventListener("mouseup",this.onMouseUp.bind(this))),this.indicatorHidden=!0,this.hitSpot=new Float32Array(3),this._hasHit=!1,this._extraRotation=0,this._currentStickAxes=new Float32Array(2)},start:function(){if(this.handedness==0){let e=this.object.getComponent("input");e?(this.handedness=e.handedness,this.input=e):console.warn("teleport component on object",this.object.name,'was configured with handedness "input component", but object has no input component.')}else this.handedness=["left","right"][this.handedness-1];WL.onXRSessionStart.push(this.setupVREvents.bind(this)),this.teleportIndicatorMeshObject.active=!1},_getCamRotation:function(){return this.eyeLeft.getForward(this._tempVec),this._tempVec[1]=0,ae.vec3.normalize(this._tempVec,this._tempVec),Math.atan2(this._tempVec[0],this._tempVec[2])},update:function(){let e=0;if(this.gamepad&&this.gamepad.axes&&(this._currentStickAxes[0]=this.gamepad.axes[2],this._currentStickAxes[1]=this.gamepad.axes[3],e=Math.abs(this._currentStickAxes[0])+Math.abs(this._currentStickAxes[1])),!this.isIndicating&&this._prevThumbstickAxis[1]>=this.thumbstickActivationThreshhold&&this._currentStickAxes[1]<this.thumbstickActivationThreshhold?this.isIndicating=!0:this.isIndicating&&e<this.thumbstickDeactivationThreshhold&&(this.isIndicating=!1,this.teleportIndicatorMeshObject.active=!1,this._hasHit&&this._teleportPlayer(this.hitSpot,this._extraRotation)),this.isIndicating&&this.teleportIndicatorMeshObject&&this.input){let t=this._tempVec0;ae.quat2.getTranslation(t,this.object.transformWorld);let r=this.object.getForward(this._tempVec),n=this.rayHit=this.rayCastMode==0?WL.scene.rayCast(t,r,1<<this.floorGroup):WL.physics.rayCast(t,r,1<<this.floorGroup,this.maxDistance);n.hitCount>0?(this.indicatorHidden=!1,this._extraRotation=Math.PI+Math.atan2(this._currentStickAxes[0],this._currentStickAxes[1]),this._currentIndicatorRotation=this._getCamRotation()+(this._extraRotation-Math.PI),this.teleportIndicatorMeshObject.resetTranslationRotation(),this.teleportIndicatorMeshObject.rotateAxisAngleRad([0,1,0],this._currentIndicatorRotation),this.teleportIndicatorMeshObject.translate(n.locations[0]),this.teleportIndicatorMeshObject.translate([0,this.indicatorYOffset,0]),this.teleportIndicatorMeshObject.active=!0,this.hitSpot.set(n.locations[0]),this._hasHit=!0):(this.indicatorHidden||(this.teleportIndicatorMeshObject.active=!1,this.indicatorHidden=!0),this._hasHit=!1)}else this.teleportIndicatorMeshObject&&this.isMouseIndicating&&this.onMousePressed();this._prevThumbstickAxis.set(this._currentStickAxes)},setupVREvents:function(e){if(this.session=e,e.addEventListener("end",function(){this.gamepad=null,this.session=null}.bind(this)),e.inputSources&&e.inputSources.length)for(let t=0;t<e.inputSources.length;t++){let r=e.inputSources[t];r.handedness==this.handedness&&(this.gamepad=r.gamepad)}e.addEventListener("inputsourceschange",function(t){if(t.added&&t.added.length)for(let r=0;r<t.added.length;r++){let n=t.added[r];n.handedness==this.handedness&&(this.gamepad=n.gamepad)}}.bind(this))},onMouseDown:function(){this.isMouseIndicating=!0},onMouseUp:function(){this.isMouseIndicating=!1,this.teleportIndicatorMeshObject.active=!1,this._hasHit&&this._teleportPlayer(this.hitSpot,0)},onMousePressed:function(){let e=[0,0,0];ae.quat2.getTranslation(e,this.cam.transformWorld);let t=this.cam.getForward(this._tempVec),r=this.rayHit=this.rayCastMode==0?WL.scene.rayCast(e,t,1<<this.floorGroup):WL.physics.rayCast(e,t,1<<this.floorGroup,this.maxDistance);r.hitCount>0?(this.indicatorHidden=!1,t[1]=0,ae.vec3.normalize(t,t),this._currentIndicatorRotation=-Math.sign(t[2])*Math.acos(t[0])-Math.PI*.5,this.teleportIndicatorMeshObject.resetTranslationRotation(),this.teleportIndicatorMeshObject.rotateAxisAngleRad([0,1,0],this._currentIndicatorRotation),this.teleportIndicatorMeshObject.translate(r.locations[0]),this.teleportIndicatorMeshObject.active=!0,this.hitSpot=r.locations[0],this._hasHit=!0):(this.indicatorHidden||(this.teleportIndicatorMeshObject.active=!1,this.indicatorHidden=!0),this._hasHit=!1)},_teleportPlayer:function(e,t){this.camRoot.rotateAxisAngleRad([0,1,0],t);let r=this._tempVec,n=this._tempVec0;this.session?(this.eyeLeft.getTranslationWorld(r),this.eyeRight.getTranslationWorld(n),ae.vec3.add(r,r,n),ae.vec3.scale(r,r,.5)):this.cam.getTranslationWorld(r),this.camRoot.getTranslationWorld(n),ae.vec3.sub(r,n,r),r[0]+=e[0],r[1]=e[1],r[2]+=e[2],this.camRoot.setTranslationWorld(r)}});WL.registerComponent("player-height",{height:{type:WL.Type.Float,default:1.75}},{init:function(){WL.onXRSessionStart.push(this.onXRSessionStart.bind(this)),WL.onXRSessionEnd.push(this.onXRSessionEnd.bind(this))},start:function(){this.object.resetTranslationRotation(),this.object.translate([0,this.height,0])},onXRSessionStart:function(){["local","viewer"].includes(WebXR.refSpace)||this.object.resetTranslationRotation()},onXRSessionEnd:function(){["local","viewer"].includes(WebXR.refSpace)||(this.object.resetTranslationRotation(),this.object.translate([0,this.height,0]))}})});var Rc={};var I,Oc,yr=$(()=>{I=J(te());Math.clamp=function(e,t,r){return Math.max(t,Math.min(e,r))};Oc=function(){let e=new Float32Array(3),t=new Float32Array(3),r=new Float32Array(3),n=new Float32Array(3),a=new Float32Array(3),s=new Float32Array(3),c=new Float32Array(3),l=new Float32Array(4),h=new Float32Array(4),u=new Float32Array(4),i=new Float32Array(4);return function(o,f,d,v,_,p,m,y,g,M){I.vec3.sub(r,v,d);let b=I.vec3.length(r);I.vec3.sub(e,v,_);let x=I.vec3.length(e);I.vec3.sub(e,p,d);let q=Math.clamp(I.vec3.length(e),m,b+x-m);I.vec3.sub(t,_,d),I.vec3.sub(n,d,v),I.vec3.sub(a,_,v),I.vec3.normalize(t,t),I.vec3.normalize(r,r),I.vec3.normalize(n,n),I.vec3.normalize(a,a),I.vec3.normalize(e,e);let S=Math.acos(Math.clamp(I.vec3.dot(t,r),-1,1)),D=Math.acos(Math.clamp(I.vec3.dot(n,a),-1,1)),C=Math.acos(Math.clamp(I.vec3.dot(t,e),-1,1)),z=Math.acos(Math.clamp((x*x-b*b-q*q)/(-2*b*q),-1,1)),F=Math.acos(Math.clamp((q*q-b*b-x*x)/(-2*b*x),-1,1));I.vec3.sub(t,_,d),I.vec3.sub(r,v,d),I.vec3.sub(e,p,d),I.vec3.cross(s,t,r),I.vec3.cross(c,t,e),M?(I.vec3.sub(r,M,v),I.vec3.transformQuat(r,[0,0,-1],g)):I.vec3.sub(r,v,d);let E=I.vec3.length(s);E==0?s.set([1,0,0]):I.vec3.scale(s,s,1/E),I.vec3.normalize(c,c),I.quat.conjugate(y,y),I.quat.setAxisAngle(h,I.vec3.transformQuat(l,s,y),z-S),I.quat.setAxisAngle(i,I.vec3.transformQuat(l,c,y),C),I.quat.mul(o,o,I.quat.mul(l,h,i)),I.quat.normalize(o,o),I.quat.conjugate(g,g),I.quat.setAxisAngle(u,I.vec3.transformQuat(l,s,g),F-D),I.quat.mul(f,f,u),I.quat.normalize(f,f)}}();WL.registerComponent("two-joint-ik-solver",{root:{type:WL.Type.Object},middle:{type:WL.Type.Object},end:{type:WL.Type.Object},target:{type:WL.Type.Object},helper:{type:WL.Type.Object}},{init:function(){this.pos=new Float32Array(3*7),this.p=[this.pos.subarray(0,3),this.pos.subarray(3,6),this.pos.subarray(6,9),this.pos.subarray(9,12),this.pos.subarray(12,15),this.pos.subarray(15,18),this.pos.subarray(18,21)]},update:function(){let e=this.p;this.root.getTranslationWorld(e[0]),this.middle.getTranslationWorld(e[1]),this.end.getTranslationWorld(e[2]),this.target.getTranslationWorld(e[3]);let t=e[4],r=e[5];this.root.getTranslationLocal(t),this.middle.getTranslationLocal(r),this.helper&&this.helper.getTranslationWorld(e[6]),Oc(this.root.transformLocal,this.middle.transformLocal,e[0],e[1],e[2],e[3],.01,this.root.transformWorld.subarray(0,4),this.middle.transformWorld.subarray(0,4),this.helper?e[6]:null),this.root.setTranslationLocal(t),this.middle.setTranslationLocal(r),this.root.setDirty(),this.middle.setDirty()}})});var gr=H(()=>{WL.registerComponent("video-texture",{url:{type:WL.Type.String,default:""},material:{type:WL.Type.Material},loop:{type:WL.Type.Bool,default:!0},autoplay:{type:WL.Type.Bool,default:!0},muted:{type:WL.Type.Bool,default:!0}},{init:function(){if(!this.material){console.error("video-texture: material property not set");return}this.loaded=!1,this.frameUpdateRequested=!0,this.video=document.createElement("video"),this.video.src=this.url,this.video.crossorigin="anonymous",this.video.autoplay=this.autoplay,this.video.loop=this.loop,this.video.muted=this.muted,this.video.addEventListener("playing",function(){this.loaded=!0}.bind(this)),this.video.play()},applyTexture:function(){let e=this.material;this.texture=new WL.Texture(this.video),e.shader=="Flat Opaque Textured"?e.flatTexture=this.texture:e.shader=="Phong Opaque Textured"?e.diffuseTexture=this.texture:console.error("Shader",e.shader,"not supported by video-texture"),"requestVideoFrameCallback"in this.video?this.video.requestVideoFrameCallback(this.updateVideo.bind(this)):this.video.addEventListener("timeupdate",function(){this.frameUpdateRequested=!0}.bind(this))},update:function(e){this.loaded&&this.frameUpdateRequested&&(this.texture?this.texture.update():this.applyTexture(),this.frameUpdateRequested=!1)},updateVideo:function(){this.frameUpdateRequested=!0,this.video.requestVideoFrameCallback(this.updateVideo.bind(this))}})});var Mr=H(()=>{WL.registerComponent("vr-mode-active-switch",{activateComponents:{type:WL.Type.Enum,values:["in VR","in non-VR"],default:"in VR"},affectChildren:{type:WL.Type.Bool,default:!0}},{start:function(){this.components=[],this.getComponents(this.object),this.onXRSessionEnd(),WL.onXRSessionStart.push(this.onXRSessionStart.bind(this)),WL.onXRSessionEnd.push(this.onXRSessionEnd.bind(this))},getComponents:function(e){let t=e.getComponents().filter(r=>r.type!="vr-mode-active-switch");if(this.components=this.components.concat(t),this.affectChildren){let r=e.children;for(let n=0;n<r.length;++n)this.getComponents(r[n])}},setComponentsActive:function(e){let t=this.components;for(let r=0;r<t.length;++r)t[r].active=e},onXRSessionStart:function(){!this.active||this.setComponentsActive(this.activateComponents==0)},onXRSessionEnd:function(){!this.active||this.setComponentsActive(this.activateComponents!=0)}})});var Lc={};var je,br=$(()=>{je=J(te());WL.registerComponent("wasd-controls",{speed:{type:WL.Type.Float,default:.1},headObject:{type:WL.Type.Object}},{init:function(){this.up=!1,this.right=!1,this.down=!1,this.left=!1,window.addEventListener("keydown",this.press.bind(this)),window.addEventListener("keyup",this.release.bind(this))},start:function(){this.headObject=this.headObject||this.object},update:function(){let e=[0,0,0];this.up&&(e[2]-=1),this.down&&(e[2]+=1),this.left&&(e[0]-=1),this.right&&(e[0]+=1),je.vec3.normalize(e,e),e[0]*=this.speed,e[2]*=this.speed,je.vec3.transformQuat(e,e,this.headObject.transformWorld),this.object.translate(e)},press:function(e){e.keyCode===38||e.keyCode===87||e.keyCode===90?this.up=!0:e.keyCode===39||e.keyCode===68?this.right=!0:e.keyCode===40||e.keyCode===83?this.down=!0:(e.keyCode===37||e.keyCode===65||e.keyCode===81)&&(this.left=!0)},release:function(e){e.keyCode===38||e.keyCode===87||e.keyCode===90?this.up=!1:e.keyCode===39||e.keyCode===68?this.right=!1:e.keyCode===40||e.keyCode===83?this.down=!1:(e.keyCode===37||e.keyCode===65||e.keyCode===81)&&(this.left=!1)}})});var Pc={};var Oe,xr=$(()=>{Oe=J(te());WL.registerComponent("wonderleap-ad",{auId:{type:WL.Type.String,default:"ce6f68fc-4809-4409-8f57-c631283ce5a3"},adId:{type:WL.Type.String}},{init:function(){this.mesh=this.object.getComponent("mesh",0),this.collision=this.object.addComponent("collision"),this.collision.collider=WL.Collider.Box,this.collision.group=2,this.cursorTarget=this.object.addComponent("cursor-target"),this.timeSinceLastVizCheck=0,this.visibleDuration=0,this.durationThreshold=10},start:function(){Wonderleap.fetchAd(this.auId).then(function(e){this.ad=e,WL.textures.load(e.asset,"").then(function(t){let r=WL._images[t._imageIndex];this.collision.extents=[r.width/r.height,1,.1],this.object.scale([r.width/r.height,1,1]),this.mesh.material.shader=="Phong Textured"?this.mesh.material.diffuseTexture=t:this.mesh.material.flatTexture=t}.bind(this)).catch(console.err)}.bind(this)),this.cursorTarget.addClickFunction(this.click.bind(this))},update:function(e){if(this.timeSinceLastVizCheck+=e,this.timeSinceLastVizCheck>.5){let t=this.isVisible();t&&(this.visibleDuration+=this.timeSinceLastVizCheck),this.timeSinceLastVizCheck=0,(!t&&this.visibleDuration>0||this.visibleDuration>this.durationThreshold)&&(Wonderleap.sendMetric("gaze",this.visibleDuration,this.ad.adId,this.ad.auId),this.visibleDuration=0)}},isVisible:function(){let e=WL.scene.activeViews[0];if(!e||!e.active)return console.warn("wonderleap-ad: camera object does not have an active view"),!1;let t=e.object.transformWorld,r=[0,0,0];Oe.quat2.getTranslation(r,t);let n=[0,0,-1];Oe.vec3.transformQuat(n,n,t);let a=WL.scene.rayCast(r,n,2);for(let s=0;s<a.hitCount;++s)if(a.objects[s].objectId==this.object.objectId)return!0;return!1},click:function(){let e=Module.webxr_session;if(e){e.end().then(this.click.bind(this));return}Wonderleap.sendMetric("click",0,this.ad.adId,this.ad.auId),this.ad.url&&window.open(this.ad.url,"_blank")}})});window.glMatrix=te();er();tr();rr();nr();ir();ar();sr();or();lr();fr();dr();ur();vr();_r();mr();yr();gr();Mr();br();xr();})();
/*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.2.1
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
/*!
 *  howler.js v2.2.1
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
//# sourceMappingURL=editor-components-bundle.js.map

if (!PP) {
    var PP = {};
}
WL.registerComponent('pp-grabbable', {
    _myThrowLinearVelocityMultiplier: { type: WL.Type.Float, default: 1 },
    _myThrowAngularVelocityMultiplier: { type: WL.Type.Float, default: 1 },
    _myKinematicValueOnRelease: { type: WL.Type.Enum, values: ['true', 'false', 'keep'], default: 'false' },
}, {
    init: function () {
        this._myIsGrabbed = false;

        this._myGrabber = null;

        this._myGrabCallbacks = new Map();      // Signature: callback(grabber, grabbable)
        this._myThrowCallbacks = new Map();     // Signature: callback(grabber, grabbable)
        this._myReleaseCallbacks = new Map();   // Signature: callback(grabber, grabbable, isThrow)
    },
    start: function () {
        this._myOldParent = this.object.parent;
        this._myPhysX = this.object.pp_getComponent('physx');
        this._myOldKinematicValue = null;
    },
    onDeactivate: function () {
        this.release();
    },
    grab: function (grabber) {
        if (!this.isGrabbed()) {
            this._myOldKinematicValue = this._myPhysX.kinematic;
        }

        this.release();

        this._myPhysX.kinematic = true;

        this._myOldParent = this.object.parent;
        this.object.pp_setParent(grabber);

        this._myIsGrabbed = true;

        this._myGrabCallbacks.forEach(function (callback) { callback(grabber, this); }.bind(this));
    },
    throw: function (linearVelocity, angularVelocity) {
        if (this._myIsGrabbed) {
            let grabber = this._myGrabber;

            this._release();

            //#TODO for now kinematic is not updated instantly, add the if as soon as it is
            //if (!this._myPhysX.kinematic) {
            this._myPhysX.linearVelocity = linearVelocity.vec3_scale(this._myThrowLinearVelocityMultiplier);
            this._myPhysX.angularVelocity = angularVelocity.vec3_scale(this._myThrowAngularVelocityMultiplier);
            //}

            this._myThrowCallbacks.forEach(function (callback) { callback(grabber, this); }.bind(this));
            this._myReleaseCallbacks.forEach(function (callback) { callback(grabber, this, true); }.bind(this));
        }
    },
    release() {
        if (this._myIsGrabbed) {
            let grabber = this._myGrabber;

            this._release();

            this._myReleaseCallbacks.forEach(function (callback) { callback(grabber, this, false); }.bind(this));
        }
    },
    getLinearVelocity() {
        let linearVelocity = vec3_create();

        this._myPhysX.linearVelocity.vec3_clone(linearVelocity);

        return linearVelocity;
    },
    getAngularVelocity() {
        return this.getAngularVelocityDegrees();
    },
    getAngularVelocityDegrees() {
        let angularVelocityDegrees = vec3_create();

        this._myPhysX.angularVelocity.vec3_toDegrees(angularVelocityDegrees);

        return angularVelocityDegrees;
    },
    getAngularVelocityRadians() {
        let angularVelocityRadians = vec3_create();

        this._myPhysX.angularVelocity.vec3_clone(angularVelocityRadians);

        return angularVelocityRadians;
    },
    isGrabbed() {
        return this._myIsGrabbed;
    },
    getGrabber() {
        return this._myGrabber;
    },
    registerGrabEventListener(id, callback) {
        this._myGrabCallbacks.set(id, callback);
    },
    unregisterGrabEventListener(id) {
        this._myGrabCallbacks.delete(id);
    },
    registerThrowEventListener(id, callback) {
        this._myThrowCallbacks.set(id, callback);
    },
    unregisterThrowEventListener(id) {
        this._myThrowCallbacks.delete(id);
    },
    registerReleaseEventListener(id, callback) {
        this._myReleaseCallbacks.set(id, callback);
    },
    unregisterReleaseEventListener(id) {
        this._myReleaseCallbacks.delete(id);
    },
    _release() {
        this.object.pp_setParent(this._myOldParent);
        this._myIsGrabbed = false;
        this._myGrabber = null;

        if (this._myKinematicValueOnRelease == 0) {
            this._myPhysX.kinematic = true;
        } else if (this._myKinematicValueOnRelease == 1) {
            this._myPhysX.kinematic = false;
        } else if (this._myOldKinematicValue != null) {
            this._myPhysX.kinematic = this._myOldKinematicValue;
        }

        if (this._myPhysX.kinematic) {
            this._myPhysX.linearVelocity = [0, 0, 0];
            this._myPhysX.angularVelocity = [0, 0, 0];
        }
    }
});
WL.registerComponent('pp-grabber-hand', {
    _myHandedness: { type: WL.Type.Enum, values: ['left', 'right'], default: 'left' },
    _myGrabButton: { type: WL.Type.Enum, values: ['select', 'squeeze', 'both', 'both_exclusive'], default: 'squeeze' }, // both_exclusive means u can use both buttons but you have to use the same button you grabbed with to throw
    _mySnapOnPivot: { type: WL.Type.Bool, default: false },
    _myMaxNumberOfObjects: { type: WL.Type.Int, default: 1 }, // how many objects you can grab at the same time
    // ADVANCED SETTINGS
    _myThrowVelocitySource: { type: WL.Type.Enum, values: ['hand', 'grabbable'], default: 'hand' },
    _myThrowLinearVelocityMultiplier: { type: WL.Type.Float, default: 1 }, // multiply the overall throw speed, so slow throws will be multiplied too
    _myThrowMaxLinearSpeed: { type: WL.Type.Float, default: 15 },
    _myThrowAngularVelocityMultiplier: { type: WL.Type.Float, default: 0.5 },
    _myThrowMaxAngularSpeed: { type: WL.Type.Float, default: 1080 }, // degrees
    _myThrowLinearVelocityBoost: { type: WL.Type.Float, default: 1.75 },   // this boost is applied from 0% to 100% based on how fast you throw, so slow throws are not affected
    _myThrowLinearVelocityBoostMinSpeedThreshold: { type: WL.Type.Float, default: 0.6 },   // 0% boost is applied if plain throw speed is under this value
    _myThrowLinearVelocityBoostMaxSpeedThreshold: { type: WL.Type.Float, default: 2.5 },   // 100% boost is applied if plain throw speed is over this value
}, {
    init: function () {
        this._myHandPose = new PP.HandPose(PP.InputUtils.getHandednessByIndex(this._myHandedness));

        this._myGrabbables = [];

        this._myGamepad = null;

        this._myActiveGrabButton = null;

        this._myLinearVelocityHistorySize = 5;
        this._myLinearVelocityHistorySpeedAverageSamplesFromStart = 1;
        this._myLinearVelocityHistoryDirectionAverageSamplesFromStart = 3;
        this._myLinearVelocityHistoryDirectionAverageSkipFromStart = 0;

        this._myHandLinearVelocityHistory = new Array(this._myLinearVelocityHistorySize);
        this._myHandLinearVelocityHistory.fill([0, 0, 0]);

        this._myAngularVelocityHistorySize = 1;
        this._myHandAngularVelocityHistory = new Array(this._myAngularVelocityHistorySize);
        this._myHandAngularVelocityHistory.fill([0, 0, 0]);

        this._myThrowMaxAngularSpeedRadians = Math.pp_toRadians(this._myThrowMaxAngularSpeed);

        this._myGrabCallbacks = new Map();      // Signature: callback(grabber, grabbable)
        this._myThrowCallbacks = new Map();     // Signature: callback(grabber, grabbable)

        this._myDebugActive = false;
    },
    start: function () {
        if (this._myHandedness == PP.HandednessIndex.LEFT) {
            this._myGamepad = PP.myLeftGamepad;
        } else {
            this._myGamepad = PP.myRightGamepad;
        }

        this._myPhysX = this.object.pp_getComponent('physx');
        this._myCollisionsCollector = new PP.PhysXCollisionCollector(this._myPhysX, true);

        this._myHandPose.start();

        if (this._myDebugActive) {
            this._myDebugLines = [];
            for (let i = 0; i < this._myLinearVelocityHistorySize; i++) {
                let line = new PP.DebugLine();
                line.setVisible(false);
                this._myDebugLines.push(line);
            }
        }
    },
    update: function (dt) {
        this._myCollisionsCollector.update(dt);
        this._myHandPose.update(dt);

        if (this._myGrabbables.length > 0) {
            this._updateLinearVelocityHistory();
            this._updateAngularVelocityHistory();
        }
    },
    grab: function (grabButton = null) {
        this._grab(grabButton);
    },
    throw: function (throwButton = null) {
        this._throw(throwButton);
    },
    registerGrabEventListener(id, callback) {
        this._myGrabCallbacks.set(id, callback);
    },
    unregisterGrabEventListener(id) {
        this._myGrabCallbacks.delete(id);
    },
    registerThrowEventListener(id, callback) {
        this._myThrowCallbacks.set(id, callback);
    },
    unregisterThrowEventListener(id) {
        this._myThrowCallbacks.delete(id);
    },
    onActivate() {
        if (this._myGrabButton == 0) {
            this._myGamepad.registerButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.PRESS_START, this, this._grab.bind(this, PP.ButtonType.SELECT));
            this._myGamepad.registerButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.PRESS_END, this, this._throw.bind(this, PP.ButtonType.SELECT));
        } else if (this._myGrabButton == 1) {
            this._myGamepad.registerButtonEventListener(PP.ButtonType.SQUEEZE, PP.ButtonEvent.PRESS_START, this, this._grab.bind(this, PP.ButtonType.SQUEEZE));
            this._myGamepad.registerButtonEventListener(PP.ButtonType.SQUEEZE, PP.ButtonEvent.PRESS_END, this, this._throw.bind(this, PP.ButtonType.SQUEEZE));
        } else {
            this._myGamepad.registerButtonEventListener(PP.ButtonType.SQUEEZE, PP.ButtonEvent.PRESS_START, this, this._grab.bind(this, PP.ButtonType.SQUEEZE));
            this._myGamepad.registerButtonEventListener(PP.ButtonType.SQUEEZE, PP.ButtonEvent.PRESS_END, this, this._throw.bind(this, PP.ButtonType.SQUEEZE));

            this._myGamepad.registerButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.PRESS_START, this, this._grab.bind(this, PP.ButtonType.SELECT));
            this._myGamepad.registerButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.PRESS_END, this, this._throw.bind(this, PP.ButtonType.SELECT));
        }
    },
    onDeactivate() {
        if (this._myGrabButton == 0) {
            this._myGamepad.unregisterButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.PRESS_START, this);
            this._myGamepad.unregisterButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.PRESS_END, this);
        } else if (this._myGrabButton == 1) {
            this._myGamepad.unregisterButtonEventListener(PP.ButtonType.SQUEEZE, PP.ButtonEvent.PRESS_START, this);
            this._myGamepad.unregisterButtonEventListener(PP.ButtonType.SQUEEZE, PP.ButtonEvent.PRESS_END, this);
        } else {
            this._myGamepad.unregisterButtonEventListener(PP.ButtonType.SQUEEZE, PP.ButtonEvent.PRESS_START, this);
            this._myGamepad.unregisterButtonEventListener(PP.ButtonType.SQUEEZE, PP.ButtonEvent.PRESS_END, this);

            this._myGamepad.unregisterButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.PRESS_START, this);
            this._myGamepad.unregisterButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.PRESS_END, this);
        }
    },
    _grab: function (grabButton) {
        if (this._myGrabbables.length >= this._myMaxNumberOfObjects) {
            return;
        }

        if (this._myGrabButton == 2 || this._myActiveGrabButton == null || this._myActiveGrabButton == grabButton || grabButton == null) {
            let grabbablesToGrab = [];

            let collisions = this._myCollisionsCollector.getCollisions();
            for (let i = 0; i < collisions.length; i++) {
                let grabbable = collisions[i].getComponent("pp-grabbable");
                if (grabbable && grabbable.active) {
                    grabbablesToGrab.push(grabbable);
                }
            }

            for (let grabbableToGrab of grabbablesToGrab) {
                if (!this._isAlreadyGrabbed(grabbableToGrab)) {
                    let grabbableData = new PP.GrabberHandGrabbableData(grabbableToGrab, this._myThrowVelocitySource == 1, this._myLinearVelocityHistorySize, this._myAngularVelocityHistorySize);
                    this._myGrabbables.push(grabbableData);
                    grabbableToGrab.grab(this.object);
                    grabbableToGrab.registerReleaseEventListener(this, this._onRelease.bind(this));

                    if (this._mySnapOnPivot) {
                        grabbableToGrab.object.resetTranslation();
                    }

                    this._myGrabCallbacks.forEach(function (callback) { callback(this, grabbableToGrab); }.bind(this));
                }

                if (this._myGrabbables.length >= this._myMaxNumberOfObjects) {
                    break;
                }
            }

            if (this._myGrabbables.length > 0) {
                if (this._myActiveGrabButton == null) {
                    this._myActiveGrabButton = grabButton;
                }
            }
        }
    },
    _throw: function (throwButton) {
        if (this._myGrabButton == 2 || this._myActiveGrabButton == null || this._myActiveGrabButton == throwButton || throwButton == null) {
            if (this._myGrabbables.length > 0) {
                let linearVelocity = null;
                let angularVelocity = null;

                if (this._myThrowVelocitySource == 0) {
                    linearVelocity = this._computeReleaseLinearVelocity(this._myHandLinearVelocityHistory);
                    angularVelocity = this._computeReleaseAngularVelocity(this._myHandAngularVelocityHistory);
                }

                for (let grabbableData of this._myGrabbables) {
                    let grabbable = grabbableData.getGrabbable();

                    grabbable.unregisterReleaseEventListener(this);

                    if (this._myThrowVelocitySource == 1) {
                        linearVelocity = this._computeReleaseLinearVelocity(grabbableData.getLinearVelocityHistory());
                        angularVelocity = this._computeReleaseAngularVelocity(grabbableData.getAngularVelocityHistory());
                    }

                    grabbable.throw(linearVelocity, angularVelocity);

                    this._myThrowCallbacks.forEach(function (callback) { callback(this, grabbable); }.bind(this));
                }

                this._myGrabbables = [];
            }

            this._myActiveGrabButton = null;
        }
    },
    _onRelease(grabber, grabbable) {
        grabbable.unregisterReleaseEventListener(this);
        this._myGrabbables.pp_remove(element => element.getGrabbable() == grabbable);

        if (this._myGrabbables.length <= 0) {
            this._myActiveGrabButton = null;
        }
    },
    _updateLinearVelocityHistory() {
        this._myHandLinearVelocityHistory.unshift(this._myHandPose.getLinearVelocity());
        this._myHandLinearVelocityHistory.pop();

        for (let grabbable of this._myGrabbables) {
            grabbable.updateLinearVelocityHistory();
        }
    },
    _updateAngularVelocityHistory() {
        this._myHandAngularVelocityHistory.unshift(this._myHandPose.getAngularVelocityRadians());
        this._myHandAngularVelocityHistory.pop();

        for (let grabbable of this._myGrabbables) {
            grabbable.updateAngularVelocityHistory();
        }
    },
    _computeReleaseLinearVelocity(linearVelocityHistory) {
        //speed
        let speed = glMatrix.vec3.length(linearVelocityHistory[0]);
        for (let i = 1; i < this._myLinearVelocityHistorySpeedAverageSamplesFromStart; i++) {
            speed += glMatrix.vec3.length(linearVelocityHistory[i]);
        }
        speed /= this._myLinearVelocityHistorySpeedAverageSamplesFromStart;

        // This way I give an increasing and smooth boost to the throw so that when u want to perform a weak throw, the value is not changed, but if u put more speed
        // it will be boosted to make it easier and still feel good and natural (value does not increase suddenly)
        let speedEaseMultiplier = Math.pp_mapToRange(speed, this._myThrowLinearVelocityBoostMinSpeedThreshold, this._myThrowLinearVelocityBoostMaxSpeedThreshold, 0, 1);
        speedEaseMultiplier = PP.EasingFunction.easeIn(speedEaseMultiplier);

        // Add the boost to the speed
        let extraSpeed = speed * (speedEaseMultiplier * this._myThrowLinearVelocityBoost);
        speed += extraSpeed;
        speed *= this._myThrowLinearVelocityMultiplier;
        speed = Math.pp_clamp(speed, 0, this._myThrowMaxLinearSpeed);

        if (this._myDebugActive) {
            this._debugDirectionLines(linearVelocityHistory);
        }

        //direction
        let directionCurrentWeight = this._myLinearVelocityHistoryDirectionAverageSamplesFromStart;
        let lastDirectionIndex = this._myLinearVelocityHistoryDirectionAverageSkipFromStart + this._myLinearVelocityHistoryDirectionAverageSamplesFromStart;
        let direction = [0, 0, 0];
        for (let i = this._myLinearVelocityHistoryDirectionAverageSkipFromStart; i < lastDirectionIndex; i++) {
            let currentDirection = linearVelocityHistory[i];
            glMatrix.vec3.scale(currentDirection, currentDirection, directionCurrentWeight);
            glMatrix.vec3.add(direction, direction, currentDirection);

            directionCurrentWeight--;
        }
        glMatrix.vec3.normalize(direction, direction);

        glMatrix.vec3.scale(direction, direction, speed);

        return direction;
    },
    _computeReleaseAngularVelocity(angularVelocityHistory) {
        let angularVelocity = angularVelocityHistory[0];

        //speed
        let speed = glMatrix.vec3.length(angularVelocity);

        speed = Math.pp_clamp(speed * this._myThrowAngularVelocityMultiplier, 0, this._myThrowMaxAngularSpeedRadians);

        //direction
        let direction = angularVelocity;
        glMatrix.vec3.normalize(direction, direction);

        glMatrix.vec3.scale(direction, direction, speed);

        return direction;
    },
    _debugDirectionLines(linearVelocityHistory) {
        for (let j = this._myLinearVelocityHistoryDirectionAverageSkipFromStart + this._myLinearVelocityHistoryDirectionAverageSamplesFromStart; j > this._myLinearVelocityHistoryDirectionAverageSkipFromStart; j--) {

            let directionCurrentWeight = j - this._myLinearVelocityHistoryDirectionAverageSkipFromStart;
            let lastDirectionIndex = j - this._myLinearVelocityHistoryDirectionAverageSkipFromStart;
            let direction = [0, 0, 0];
            for (let i = this._myLinearVelocityHistoryDirectionAverageSkipFromStart; i < lastDirectionIndex; i++) {
                let currentDirection = linearVelocityHistory[i].pp_clone();
                glMatrix.vec3.scale(currentDirection, currentDirection, directionCurrentWeight);
                glMatrix.vec3.add(direction, direction, currentDirection);

                directionCurrentWeight--;
            }
            glMatrix.vec3.normalize(direction, direction);

            this._myDebugLines[j - 1].setStartDirectionLength(this.object.pp_getPosition(), direction, 0.2);
            let color = 1 / j;
            this._myDebugLines[j - 1].setColor([color, color, color, 1]);
            this._myDebugLines[j - 1].setVisible(true);
        }
    },
    _isAlreadyGrabbed(grabbable) {
        let found = this._myGrabbables.pp_find(element => element.getGrabbable() == grabbable);
        return found != null;
    }
});

PP.GrabberHandGrabbableData = class GrabberHandGrabbableData {
    constructor(grabbable, useGrabbableAsVelocitySource, linearVelocityHistorySize, angularVelocityHistorySize) {
        this._myGrabbable = grabbable;
        this._myUseGrabbableAsVelocitySource = useGrabbableAsVelocitySource;

        if (this._myUseGrabbableAsVelocitySource) {
            this._myLinearVelocityHistory = new Array(linearVelocityHistorySize);
            this._myLinearVelocityHistory.fill([0, 0, 0]);

            this._myAngularVelocityHistory = new Array(angularVelocityHistorySize);
            this._myAngularVelocityHistory.fill([0, 0, 0]);
        }
    }

    getGrabbable() {
        return this._myGrabbable;
    }

    getLinearVelocityHistory() {
        return this._myLinearVelocityHistory;
    }

    getAngularVelocityHistory() {
        return this._myAngularVelocityHistory;
    }

    updateLinearVelocityHistory() {
        if (this._myUseGrabbableAsVelocitySource) {
            this._myLinearVelocityHistory.unshift(this._myGrabbable.getLinearVelocity());
            this._myLinearVelocityHistory.pop();
        }
    }

    updateAngularVelocityHistory() {
        if (this._myUseGrabbableAsVelocitySource) {
            this._myAngularVelocityHistory.unshift(this._myGrabbable.getAngularVelocityRadians());
            this._myAngularVelocityHistory.pop();
        }
    }
};
WL.registerComponent('pp-finger-cursor', {
    _myHandedness: { type: WL.Type.Enum, values: ['left', 'right'], default: 'left' },
    _myEnableMultipleClicks: { type: WL.Type.Bool, default: true },
    _myCollisionGroup: { type: WL.Type.Int, default: 1 },
    _myCursorMesh: { type: WL.Type.Mesh, default: null },
    _myCursorMaterial: { type: WL.Type.Material, default: null },
    _myCursorSize: { type: WL.Type.Float, default: 0.0125 }
}, {
    init: function () {
        this._myLastTarget = null;
        this._myReferenceSpace = null;
        this._myHandInputSource = null;
        this._myHandednessString = ['left', 'right'][this._myHandedness];

        this._myDoubleClickTimer = 0;
        this._myTripleClickTimer = 0;
        this._myMultipleClickObject = null;
        this._myMultipleClickDelay = 0.3;
    },
    start: function () {
        this._myCursorObject = WL.scene.addObject(this.object.parent);
        this._myCursorObject.scale([this._myCursorSize, this._myCursorSize, this._myCursorSize]);

        if (this._myCursorMesh) {
            this._myCursorMeshComponent = this._myCursorObject.addComponent("mesh");
            this._myCursorMeshComponent.mesh = this._myCursorMesh;
            this._myCursorMeshComponent.material = this._myCursorMaterial.clone();
        }

        this._myCollisionComponent = this._myCursorObject.addComponent('collision');
        this._myCollisionComponent.collider = 0; //sphere
        this._myCollisionComponent.group = 1 << this._myCollisionGroup;
        this._myCollisionComponent.extents = [this._myCursorSize, this._myCursorSize, this._myCursorSize];

        if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
        }
        WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
        WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
    },
    update: function (dt) {
        if (this._myDoubleClickTimer > 0) {
            this._myDoubleClickTimer -= dt;
        }

        if (this._myTripleClickTimer > 0) {
            this._myTripleClickTimer -= dt;
        }

        this._updateHand();

        if (this._myHandInputSource) {
            let overlaps = this._myCollisionComponent.queryOverlaps();
            let overlapTarget = null;
            for (let i = 0; i < overlaps.length; ++i) {
                let object = overlaps[i].object;
                let target = object.getComponent('cursor-target');
                if (target) {
                    overlapTarget = target;
                    break;
                }
            }

            if (!overlapTarget) {
                this._targetTouchEnd();
            } else if (!overlapTarget.equals(this._myLastTarget)) {
                this._targetTouchEnd();

                this._myLastTarget = overlapTarget;

                this._targetTouchStart();
            }
        } else {
            this._targetTouchEnd();
        }
    },
    _targetTouchStart: function () {
        this._myLastTarget.onHover(this._myLastTarget.object, this);
        this._myLastTarget.onDown(this._myLastTarget.object, this);
    },
    _targetTouchEnd: function () {
        if (this._myLastTarget) {
            if (this._myEnableMultipleClicks && this._myTripleClickTimer > 0 && this._myMultipleClickObject && this._myMultipleClickObject.equals(this._myLastTarget.object)) {
                this._myLastTarget.onTripleClick(this._myLastTarget.object, this);

                this._myTripleClickTimer = 0;
            } else if (this._myEnableMultipleClicks && this._myDoubleClickTimer > 0 && this._myMultipleClickObject && this._myMultipleClickObject.equals(this._myLastTarget.object)) {
                this._myLastTarget.onDoubleClick(this._myLastTarget.object, this);

                this._myTripleClickTimer = this._myMultipleClickDelay;
                this._myDoubleClickTimer = 0;
            } else {
                this._myLastTarget.onClick(this._myLastTarget.object, this);

                this._myTripleClickTimer = 0;
                this._myDoubleClickTimer = this._myMultipleClickDelay;
                this._myMultipleClickObject = this._myLastTarget.object;
            }

            this._myLastTarget.onUp(this._myLastTarget.object, this);
            this._myLastTarget.onUnhover(this._myLastTarget.object, this);

            this._myLastTarget = null;
        }
    },
    setActive: function (active) {
        this._myCursorObject.pp_setActiveHierarchy(active);
        this.active = active;
    },
    _updateHand() {
        this._myHandInputSource = PP.InputUtils.getInputSource(this._myHandednessString, PP.InputSourceType.HAND);

        if (this._myHandInputSource) {
            let tip = Module['webxr_frame'].getJointPose(this._myHandInputSource.hand.get("index-finger-tip"), this._myReferenceSpace);

            if (tip) {
                this._myCursorObject.resetTransform();
                this._myCursorObject.transformLocal.set([
                    tip.transform.orientation.x,
                    tip.transform.orientation.y,
                    tip.transform.orientation.z,
                    tip.transform.orientation.w]);
                this._myCursorObject.translate([
                    tip.transform.position.x,
                    tip.transform.position.y,
                    tip.transform.position.z]);
                this._myCursorObject.scale([this._myCursorSize, this._myCursorSize, this._myCursorSize]);
            }
        }
    },
    _onXRSessionStart: function (session) {
        session.requestReferenceSpace(WebXR.refSpace).then(function (referenceSpace) { this._myReferenceSpace = referenceSpace; }.bind(this));
    },
    _onXRSessionEnd: function (session) {
        this._myReferenceSpace = null;
    }


});
PP.HandPose = class HandPose {

    constructor(handedness, fixForward = true, forceEmulatedVelocities = false) {
        this._myInputSource = null;

        this._myHandedness = handedness;
        this._myFixForward = fixForward;
        this._myForceEmulatedVelocities = forceEmulatedVelocities;

        this._myReferenceSpace = null;

        this._myPosition = [0, 0, 0];
        this._myRotation = [0, 0, 0, 1];

        this._myPrevPosition = [0, 0, 0];
        this._myPrevRotation = [0, 0, 0, 1];

        this._myLinearVelocity = [0, 0, 0];
        this._myAngularVelocity = [0, 0, 0]; // Radians
    }

    getReferenceSpace() {
        return this._myReferenceSpace;
    }

    getPosition() {
        return this._myPosition.slice(0);
    }

    getRotation() {
        return this.getRotationDegrees();
    }

    getRotationDegrees() {
        return this.getRotationQuat().quat_toDegrees();
    }

    getRotationRadians() {
        return this.getRotationQuat().quat_toRadians();
    }

    getRotationQuat() {
        let out = this._myRotation.slice(0);

        if (this._myFixForward) {
            out = glMatrix.quat.rotateY(out, out, Math.PI);
        }

        return out;
    }

    getTransform() {
        return this.getTransformMatrix();
    }

    getTransformMatrix() {
        return mat4_fromPositionRotationQuat(this._myPosition, this.getRotationQuat());
    }

    getTransformQuat() {
        return quat2_fromPositionRotationQuat(this._myPosition, this.getRotationQuat());
    }

    getLinearVelocity() {
        return this._myLinearVelocity.slice(0);
    }

    getAngularVelocity() {
        return this.getAngularVelocityDegrees();
    }

    getAngularVelocityDegrees() {
        return this._myAngularVelocity.vec3_toDegrees();
    }

    getAngularVelocityRadians() {
        return this._myAngularVelocity.slice(0);
    }

    setFixForward(fixForward) {
        this._myFixForward = fixForward;
    }

    setForceEmulatedVelocities(forceEmulatedVelocities) {
        this._myForceEmulatedVelocities = forceEmulatedVelocities;
    }

    start() {
        if (WL.xrSession) {
            this._onXRSessionStart(true, WL.xrSession);
        }
        WL.onXRSessionStart.push(this._onXRSessionStart.bind(this, false));
        WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
    }

    update(dt) {
        glMatrix.vec3.copy(this._myPrevPosition, this._myPosition);
        glMatrix.quat.copy(this._myPrevRotation, this._myRotation);

        let xrFrame = Module['webxr_frame'];
        if (xrFrame && this._myInputSource) {
            let xrPose = null;
            try {
                xrPose = xrFrame.getPose(this._myInputSource.gripSpace, this._myReferenceSpace);
            } catch (error) {
            }

            if (xrPose) {
                this._myPosition[0] = xrPose.transform.position.x;
                this._myPosition[1] = xrPose.transform.position.y;
                this._myPosition[2] = xrPose.transform.position.z;

                this._myRotation[0] = xrPose.transform.orientation.x;
                this._myRotation[1] = xrPose.transform.orientation.y;
                this._myRotation[2] = xrPose.transform.orientation.z;
                this._myRotation[3] = xrPose.transform.orientation.w;

                if (xrPose.linearVelocity && !this._myForceEmulatedVelocities) {
                    this._myLinearVelocity[0] = xrPose.linearVelocity.x;
                    this._myLinearVelocity[1] = xrPose.linearVelocity.y;
                    this._myLinearVelocity[2] = xrPose.linearVelocity.z;
                } else {
                    this._computeEmulatedLinearVelocity(dt);
                }

                if (xrPose.angularVelocity && !this._myForceEmulatedVelocities) {
                    this._myAngularVelocity[0] = xrPose.angularVelocity.x;
                    this._myAngularVelocity[1] = xrPose.angularVelocity.y;
                    this._myAngularVelocity[2] = xrPose.angularVelocity.z;
                } else {
                    this._computeEmulatedAngularVelocity(dt);
                }
            } else {
                //keep previous position and rotation but reset velocity because reasons

                this._myLinearVelocity[0] = 0;
                this._myLinearVelocity[1] = 0;
                this._myLinearVelocity[2] = 0;

                this._myAngularVelocity[0] = 0;
                this._myAngularVelocity[1] = 0;
                this._myAngularVelocity[2] = 0;
            }
        } else {
            //keep previous position and rotation but reset velocity because reasons

            this._myLinearVelocity[0] = 0;
            this._myLinearVelocity[1] = 0;
            this._myLinearVelocity[2] = 0;

            this._myAngularVelocity[0] = 0;
            this._myAngularVelocity[1] = 0;
            this._myAngularVelocity[2] = 0;
        }
    }

    _computeEmulatedLinearVelocity(dt) {
        if (dt > 0) {
            glMatrix.vec3.subtract(this._myLinearVelocity, this._myPosition, this._myPrevPosition);
            glMatrix.vec3.scale(this._myLinearVelocity, this._myLinearVelocity, 1 / dt);
        } else {
            this._myLinearVelocity[0] = 0;
            this._myLinearVelocity[1] = 0;
            this._myLinearVelocity[2] = 0;
        }
    }

    _computeEmulatedAngularVelocity(dt) {
        if (dt > 0) {
            glMatrix.vec3.subtract(this._myAngularVelocity, this._myRotation.quat_toRadians(), this._myPrevRotation.quat_toRadians());
            glMatrix.vec3.scale(this._myAngularVelocity, this._myAngularVelocity, 1 / dt);
        } else {
            this._myAngularVelocity[0] = 0;
            this._myAngularVelocity[1] = 0;
            this._myAngularVelocity[2] = 0;
        }
    }

    _onXRSessionStart(manualStart, session) {
        session.requestReferenceSpace(WebXR.refSpace).then(function (referenceSpace) { this._myReferenceSpace = referenceSpace; }.bind(this));

        session.addEventListener('inputsourceschange', function (event) {
            if (event.removed) {
                for (let item of event.removed) {
                    if (item == this._myInputSource) {
                        this._myInputSource = null;
                    }
                }
            }

            if (event.added) {
                for (let item of event.added) {
                    if (item.handedness == this._myHandedness) {
                        this._myInputSource = item;
                    }
                }
            }
        }.bind(this));

        if (manualStart && this._myInputSource == null && session.inputSources) {
            for (let item of session.inputSources) {
                if (item.handedness == this._myHandedness) {
                    this._myInputSource = item;
                }
            }
        }
    }

    _onXRSessionEnd(session) {
        this._myReferenceSpace = null;
        this._myInputSource = null;
    }
};
PP.HeadPose = class HeadPose {

    constructor(fixForward = true, forceEmulatedVelocities = false) {
        this._myFixForward = fixForward;
        this._myForceEmulatedVelocities = forceEmulatedVelocities;

        this._myReferenceSpace = null;

        this._myPosition = [0, 0, 0];
        this._myRotation = [0, 0, 0, 1];

        this._myPrevPosition = [0, 0, 0];
        this._myPrevRotation = [0, 0, 0, 1];

        this._myLinearVelocity = [0, 0, 0];
        this._myAngularVelocity = [0, 0, 0]; // Radians
    }

    getReferenceSpace() {
        return this._myReferenceSpace;
    }

    getPosition() {
        return this._myPosition.slice(0);
    }

    getRotation() {
        return this.getRotationDegrees();
    }

    getRotationDegrees() {
        return this.getRotationQuat().quat_toDegrees();
    }

    getRotationRadians() {
        return this.getRotationQuat().quat_toRadians();
    }

    getRotationQuat() {
        let out = this._myRotation.slice(0);

        if (this._myFixForward) {
            out = glMatrix.quat.rotateY(out, out, Math.PI);
        }

        return out;
    }

    getTransform() {
        return this.getTransformMatrix();
    }

    getTransformMatrix() {
        return mat4_fromPositionRotationQuat(this._myPosition, this.getRotationQuat());
    }

    getTransformQuat() {
        return quat2_fromPositionRotationQuat(this._myPosition, this.getRotationQuat());
    }

    getLinearVelocity() {
        return this._myLinearVelocity.slice(0);
    }

    getAngularVelocity() {
        return this.getAngularVelocityDegrees();
    }

    getAngularVelocityDegrees() {
        return this._myAngularVelocity.vec3_toDegrees();
    }

    getAngularVelocityRadians() {
        return this._myAngularVelocity.slice(0);
    }

    setFixForward(fixForward) {
        this._myFixForward = fixForward;
    }

    setForceEmulatedVelocities(forceEmulatedVelocities) {
        this._myForceEmulatedVelocities = forceEmulatedVelocities;
    }

    start() {
        if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
        }
        WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
        WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
    }

    update(dt) {
        glMatrix.vec3.copy(this._myPrevPosition, this._myPosition);
        glMatrix.quat.copy(this._myPrevRotation, this._myRotation);

        let xrFrame = Module['webxr_frame'];
        if (xrFrame) {
            let xrPose = null;
            try {
                xrPose = xrFrame.getViewerPose(this._myReferenceSpace);
            } catch (error) {
            }

            if (xrPose) {
                this._myPosition[0] = xrPose.transform.position.x;
                this._myPosition[1] = xrPose.transform.position.y;
                this._myPosition[2] = xrPose.transform.position.z;

                this._myRotation[0] = xrPose.transform.orientation.x;
                this._myRotation[1] = xrPose.transform.orientation.y;
                this._myRotation[2] = xrPose.transform.orientation.z;
                this._myRotation[3] = xrPose.transform.orientation.w;

                if (xrPose.linearVelocity && !this._myForceEmulatedVelocities) {
                    this._myLinearVelocity[0] = xrPose.linearVelocity.x;
                    this._myLinearVelocity[1] = xrPose.linearVelocity.y;
                    this._myLinearVelocity[2] = xrPose.linearVelocity.z;
                } else {
                    this._computeEmulatedLinearVelocity(dt);
                }

                if (xrPose.angularVelocity && !this._myForceEmulatedVelocities) {
                    this._myAngularVelocity[0] = xrPose.angularVelocity.x;
                    this._myAngularVelocity[1] = xrPose.angularVelocity.y;
                    this._myAngularVelocity[2] = xrPose.angularVelocity.z;
                } else {
                    this._computeEmulatedAngularVelocity(dt);
                }
            } else {
                //keep previous position and rotation but reset velocity because reasons

                this._myLinearVelocity[0] = 0;
                this._myLinearVelocity[1] = 0;
                this._myLinearVelocity[2] = 0;

                this._myAngularVelocity[0] = 0;
                this._myAngularVelocity[1] = 0;
                this._myAngularVelocity[2] = 0;
            }
        } else {
            //keep previous position and rotation but reset velocity because reasons

            this._myLinearVelocity[0] = 0;
            this._myLinearVelocity[1] = 0;
            this._myLinearVelocity[2] = 0;

            this._myAngularVelocity[0] = 0;
            this._myAngularVelocity[1] = 0;
            this._myAngularVelocity[2] = 0;
        }
    }

    _computeEmulatedLinearVelocity(dt) {
        if (dt > 0) {
            glMatrix.vec3.subtract(this._myLinearVelocity, this._myPosition, this._myPrevPosition);
            glMatrix.vec3.scale(this._myLinearVelocity, this._myLinearVelocity, 1 / dt);
        } else {
            this._myLinearVelocity[0] = 0;
            this._myLinearVelocity[1] = 0;
            this._myLinearVelocity[2] = 0;
        }
    }

    _computeEmulatedAngularVelocity(dt) {
        if (dt > 0) {
            glMatrix.vec3.subtract(this._myAngularVelocity, this._myRotation.quat_toRadians(), this._myPrevRotation.quat_toRadians());
            glMatrix.vec3.scale(this._myAngularVelocity, this._myAngularVelocity, 1 / dt);
        } else {
            this._myAngularVelocity[0] = 0;
            this._myAngularVelocity[1] = 0;
            this._myAngularVelocity[2] = 0;
        }
    }

    _onXRSessionStart(session) {
        session.requestReferenceSpace(WebXR.refSpace).then(function (referenceSpace) { this._myReferenceSpace = referenceSpace; }.bind(this));
    }

    _onXRSessionEnd(session) {
        this._myReferenceSpace = null;
    }
};

PP.Handedness = {
    LEFT: "left",
    RIGHT: "right"
};

PP.HandednessIndex = {
    LEFT: 0,
    RIGHT: 1
};

PP.InputSourceType = {
    GAMEPAD: 0,
    HAND: 1
};
PP.InputUtils = {
    getHandednessByIndex: function (index) {
        let handedness = null;

        switch (index) {
            case PP.HandednessIndex.LEFT:
                handedness = PP.Handedness.LEFT;
                break;
            case PP.HandednessIndex.RIGHT:
                handedness = PP.Handedness.RIGHT;
                break;
        }

        return handedness;
    },
    getInputSource: function (handedness, inputSourceType) {
        let inputSource = null;

        if (WL.xrSession && WL.xrSession.inputSources) {
            for (let i = 0; i < WL.xrSession.inputSources.length; i++) {
                let input = WL.xrSession.inputSources[i];

                let isCorrectType = (!inputSourceType) || (inputSourceType == PP.InputSourceType.GAMEPAD && !input.hand) || (inputSourceType == PP.InputSourceType.HAND && input.hand);
                if (isCorrectType && input.handedness == handedness) {
                    inputSource = input;
                    break;
                }
            }
        }

        return inputSource;
    },
    getInputSourceType: function (handedness) {
        let inputSourceType = null;

        let inputSource = PP.InputUtils.getInputSource(handedness);
        if (inputSource) {
            if (inputSource.hand) {
                inputSourceType = PP.InputSourceType.HAND;
            } else {
                inputSourceType = PP.InputSourceType.GAMEPAD;
            }
        }

        return inputSourceType;
    }
};
//If you don't want the PP "namespace" just search and replace PP. with empty string
//you must also add var in front of the enums (like var Handedness = {}) since now they are no longer child of PP
//and also remove the class assignment to the same name (like ButtonInfo = class ButtonInfo{}) since now they can be global

PP.ButtonType = {
    SELECT: 0,  //Trigger
    SQUEEZE: 1, //Grip
    THUMBSTICK: 3,
    BOTTOM_BUTTON: 4, // A or X button on oculus quest controller, also triggered for "touchpad" press on other controllers
    TOP_BUTTON: 5  // B or Y button
};

PP.ButtonEvent = {
    PRESS_START: 0,
    PRESS_END: 1,
    PRESSED: 2, //Every frame that it is pressed
    NOT_PRESSED: 3, //Every frame that it is not pressed
    TOUCH_START: 4,
    TOUCH_END: 5,
    TOUCHED: 6, //Every frame that it is touched
    NOT_TOUCHED: 7, //Every frame that it is not touched
    VALUE_CHANGED: 8,
    ALWAYS: 9, //callback every frame for this button
};

PP.ButtonInfo = class ButtonInfo {
    constructor() {
        this.myIsPressed = false;
        this.myPrevIsPressed = false;

        this.myIsTouched = false;
        this.myPrevIsTouched = false;

        this.myValue = 0.0;
        this.myPrevValue = 0.0;

        this.myTimePressed = 0;
        this.myPrevTimePressed = 0;

        this.myTimeNotPressed = 0;
        this.myPrevTimeNotPressed = 0;

        this.myTimeTouched = 0;
        this.myPrevTimeTouched = 0;

        this.myTimeNotTouched = 0;
        this.myPrevTimeNotTouched = 0;

        this.myMultiplePressStartCount = 0;
        this.myPrevMultiplePressStartCount = 0;
        this.myMultiplePressEndCount = 0;
        this.myPrevMultiplePressEndCount = 0;

        this.myMultipleTouchStartCount = 0;
        this.myPrevMultipleTouchStartCount = 0;
        this.myMultipleTouchEndCount = 0;
        this.myPrevMultipleTouchEndCount = 0;
    }

    getValue() {
        return this.myValue;
    }

    isPressed() {
        return this.myIsPressed;
    }

    isTouched() {
        return this.myIsTouched;
    }

    isPressStart(multiplePressCount = null) {
        return (this.myIsPressed && !this.myPrevIsPressed) && (multiplePressCount == null || this.myMultiplePressStartCount == multiplePressCount);
    }

    isPressEnd(multiplePressCount = null) {
        return (!this.myIsPressed && this.myPrevIsPressed) && (multiplePressCount == null || this.myMultiplePressEndCount == multiplePressCount);
    }

    isTouchStart(multipleTouchCount = null) {
        return (this.myIsTouched && !this.myPrevIsTouched) && (multipleTouchCount == null || this.myMultipleTouchStartCount == multipleTouchCount);
    }

    isTouchEnd(multipleTouchCount = null) {
        return (!this.myIsTouched && this.myPrevIsTouched) && (multipleTouchCount == null || this.myMultipleTouchEndCount == multipleTouchCount);
    }

    clone() {
        let value = new ButtonInfo();
        value.myIsPressed = this.myIsPressed;
        value.myPrevIsPressed = this.myPrevIsPressed;
        value.myIsTouched = this.myIsTouched;
        value.myPrevIsTouched = this.myPrevIsTouched;
        value.myValue = this.myValue;
        value.myPrevValue = this.myPrevValue;

        value.myTimePressed = this.myTimePressed;
        value.myPrevTimePressed = this.myPrevTimePressed;
        value.myTimeNotPressed = this.myTimeNotPressed;
        value.myPrevTimeNotPressed = this.myPrevTimeNotPressed;

        value.myTimeTouched = this.myTimeTouched;
        value.myPrevTimeTouched = this.myPrevTimeTouched;
        value.myTimeNotTouched = this.myTimeNotTouched;
        value.myPrevTimeNotTouched = this.myPrevTimeNotTouched;

        value.myMultiplePressStartCount = this.myMultiplePressStartCount;
        value.myPrevMultiplePressStartCount = this.myPrevMultiplePressStartCount;
        value.myMultiplePressEndCount = this.myMultiplePressEndCount;
        value.myPrevMultiplePressEndCount = this.myPrevMultiplePressEndCount;

        value.myMultipleTouchStartCount = this.myMultipleTouchStartCount;
        value.myPrevMultipleTouchStartCount = this.myPrevMultipleTouchStartCount;
        value.myMultipleTouchEndCount = this.myMultipleTouchEndCount;
        value.myPrevMultipleTouchEndCount = this.myPrevMultipleTouchEndCount;

        return value;
    }
};

PP.AxesEvent = {
    X_CHANGED: 0,
    Y_CHANGED: 1,
    AXES_CHANGED: 2,
    ALWAYS: 3
};

//index 0 is x, index 1 is y
PP.AxesInfo = class AxesInfo {
    constructor() {
        this.myAxes = new Float32Array(2);
        this.myAxes.fill(0.0);

        this.myPrevAxes = new Float32Array(2);
        this.myPrevAxes.fill(0.0);
    }

    clone() {
        let value = new AxesInfo();
        value.myAxes = this.myAxes;
        value.myPrevAxes = this.myPrevAxes;

        return value;
    }
};

PP.PulseInfo = class PulseInfo {
    constructor() {
        this.myIntensity = 0.0;
        this.myDuration = 0.0;

        this.myIsDevicePulsing = false; // true if the gamepad actually sent a request to pulse to the device
    }

    clone() {
        let value = new PulseInfo();
        value.myIntensity = this.myIntensity;
        value.myDuration = this.myDuration;
        value.myIsDevicePulsing = this.myIsDevicePulsing;

        return value;
    }
};

/**
 * Lets you easily retrieve the current state of a gamepad and register to events
 * 
 * xr-standard mapping is assumed for gamepad
 */
PP.Gamepad = class Gamepad {

    /**
     * @param {PP.Handedness} handedness specifies which controller this gamepad will represent, left or right
     */
    constructor(handedness) {
        this._myHandedness = handedness;

        this._myButtonInfos = [];
        for (let key in PP.ButtonType) {
            this._myButtonInfos[PP.ButtonType[key]] = new PP.ButtonInfo();
        }

        this._myAxesInfo = new PP.AxesInfo();

        this._mySelectStart = false;
        this._mySelectEnd = false;
        this._mySqueezeStart = false;
        this._mySqueezeEnd = false;

        this._myIsXRSessionActive = false;
        this._myInputSource = null;
        this._myGamepad = null;

        this._myButtonCallbacks = [];
        for (let typeKey in PP.ButtonType) {
            this._myButtonCallbacks[PP.ButtonType[typeKey]] = [];
            for (let eventKey in PP.ButtonEvent) {
                this._myButtonCallbacks[PP.ButtonType[typeKey]][PP.ButtonEvent[eventKey]] = new Map(); //keys = object, item = callback
            }
        }

        this._myAxesCallbacks = [];
        for (let eventKey in PP.AxesEvent) {
            this._myAxesCallbacks[PP.AxesEvent[eventKey]] = new Map(); //keys = object, item = callback
        }

        this._myPulseInfo = new PP.PulseInfo();

        //Setup
        this._myMultiplePressMaxDelay = 0.3;
        this._myMultipleTouchMaxDelay = 0.3;
    }

    /**
     * @returns {PP.Handedness}
     */
    getHandedness() {
        return this._myHandedness;
    }

    /**
     * @param {PP.ButtonType} buttonType
     * @returns {PP.ButtonInfo}
     */
    getButtonInfo(buttonType) {
        return this._myButtonInfos[buttonType].clone();
    }

    /**
     * @param {PP.ButtonType} buttonType 
     * @param {PP.ButtonEvent} buttonEvent 
     * @param id 
     * @param callback callback params are (PP.ButtonInfo, PP.Gamepad)
     */
    registerButtonEventListener(buttonType, buttonEvent, id, callback) {
        this._myButtonCallbacks[buttonType][buttonEvent].set(id, callback);
    }

    /**
     * @param {PP.ButtonType} buttonType 
     * @param {PP.ButtonEvent} buttonEvent 
     * @param id 
     */
    unregisterButtonEventListener(buttonType, buttonEvent, id) {
        this._myButtonCallbacks[buttonType][buttonEvent].delete(id);
    }

    /**
     * @returns {PP.AxesInfo}
     */
    getAxesInfo() {
        return this._myAxesInfo.clone();
    }

    /**
     * @param {PP.AxesEvent} axesEvent 
     * @param id 
     * @param callback callback parameters are (AxesInfo, Gamepad)
     */
    registerAxesEventListener(axesEvent, id, callback) {
        this._myAxesCallbacks[axesEvent].set(id, callback);
    }

    /**
     * @param {PP.AxesEvent} axesEvent 
     * @param id 
     */
    unregisterAxesEventListener(axesEvent, id) {
        this._myAxesCallbacks[axesEvent].delete(id);
    }

    /**
     * @returns {boolean}
     */
    isGamepadActive() {
        //connected == null is to fix webxr emulator that leaves that field undefined
        return this._myIsXRSessionActive && this._myGamepad != null && (this._myGamepad.connected == null || this._myGamepad.connected);
    }

    /**
     * pulse, rumble, vibration, whatever
     * @param {number} intensity range from 0 to 1
     * @param {number} duration specified in seconds, 0 means 1 frame
     */
    pulse(intensity, duration = 0) {
        this._myPulseInfo.myIntensity = Math.min(Math.max(intensity, 0), 1); //clamp 
        this._myPulseInfo.myDuration = Math.max(duration, 0);
    }

    stopPulse() {
        this._myPulseInfo.myIntensity = 0;
        this._myPulseInfo.myDuration = 0;
    }

    isPulsing() {
        return this._myPulseInfo.myIntensity > 0 || this._myPulseInfo.myDuration > 0;
    }

    getPulseInfo() {
        return this._myPulseInfo.clone();
    }

    getMultiplePressMaxDelay() {
        return this._myMultiplePressMaxDelay;
    }

    setMultiplePressMaxDelay(maxDelay) {
        this._myMultiplePressMaxDelay = maxDelay;
    }

    getMultipleTouchMaxDelay() {
        return this._myMultipleTouchMaxDelay;
    }

    setMultipleTouchMaxDelay(maxDelay) {
        this._myMultipleTouchMaxDelay = maxDelay;
    }

    start() {
        if (WL.xrSession) {
            this._onXRSessionStart(true, WL.xrSession);
        }
        WL.onXRSessionStart.push(this._onXRSessionStart.bind(this, false));
        WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
    }

    update(dt) {
        this._preUpdateButtonInfos();
        this._updateButtonInfos();
        this._postUpdateButtonInfos(dt);

        this._preUpdateAxesInfos();
        this._updateAxesInfos();
        this._postUpdateAxesInfos();

        this._updatePulse(dt);
    }

    _preUpdateButtonInfos() {
        this._myButtonInfos.forEach(function (item) {
            item.myPrevIsPressed = item.myIsPressed;
            item.myPrevIsTouched = item.myIsTouched;
            item.myPrevValue = item.myValue;
        });
    }

    _updateButtonInfos() {
        this._updateSelectAndSqueezePressed();
        this._updateSingleButtonInfo(PP.ButtonType.SELECT, false);
        this._updateSingleButtonInfo(PP.ButtonType.SQUEEZE, false);
        this._updateSingleButtonInfo(PP.ButtonType.THUMBSTICK, true);
        this._updateSingleButtonInfo(PP.ButtonType.BOTTOM_BUTTON, true);
        this._updateSingleButtonInfo(PP.ButtonType.TOP_BUTTON, true);
    }

    //This sadly must be done this way to be the most compatible
    _updateSelectAndSqueezePressed() {
        let buttonSelect = this._myButtonInfos[PP.ButtonType.SELECT];

        if (this._mySelectStart) {
            buttonSelect.myIsPressed = true;
        }
        if (this._mySelectEnd) {
            buttonSelect.myIsPressed = false;
        }

        let buttonSqueeze = this._myButtonInfos[PP.ButtonType.SQUEEZE];
        if (this._mySqueezeStart) {
            buttonSqueeze.myIsPressed = true;
        }

        if (this._mySqueezeEnd) {
            buttonSqueeze.myIsPressed = false;
        }

        if (!this.isGamepadActive()) {
            buttonSelect.myIsPressed = false;
            buttonSqueeze.myIsPressed = false;
        }
    }

    _updateSingleButtonInfo(buttonType, updatePressed) {
        let button = this._myButtonInfos[buttonType];
        let internalButton = this._getInternalButton(buttonType);

        if (updatePressed) {
            button.myIsPressed = internalButton.pressed;
        }

        button.myIsTouched = internalButton.touched;
        button.myValue = internalButton.value;
    }

    _postUpdateButtonInfos(dt) {
        this._myButtonInfos.forEach(function (item) {
            if (item.myIsPressed) {
                item.myTimePressed += dt;
                if (!item.myPrevIsPressed) {
                    item.myMultiplePressStartCount += 1;

                    item.myPrevTimeNotPressed = item.myTimeNotPressed;
                    item.myTimeNotPressed = 0;
                }

                if (item.myPrevTimeNotPressed + item.myTimePressed > this._myMultiplePressMaxDelay && item.myMultiplePressEndCount > 0) {
                    item.myPrevMultiplePressEndCount = item.myMultiplePressEndCount;
                    item.myMultiplePressEndCount = 0;
                }

                if (item.myTimePressed > this._myMultiplePressMaxDelay && item.myMultiplePressStartCount > 0) {
                    item.myPrevMultiplePressStartCount = item.myMultiplePressStartCount;
                    item.myMultiplePressStartCount = 0;
                }
            } else {
                item.myTimeNotPressed += dt;
                if (item.myPrevIsPressed) {
                    item.myMultiplePressEndCount += 1;

                    item.myPrevTimePressed = item.myTimePressed;
                    item.myTimePressed = 0;
                }

                if (item.myPrevTimePressed + item.myTimeNotPressed > this._myMultiplePressMaxDelay && item.myMultiplePressStartCount > 0) {
                    item.myPrevMultiplePressStartCount = item.myMultiplePressStartCount;
                    item.myMultiplePressStartCount = 0;
                }

                if (item.myTimeNotPressed > this._myMultiplePressMaxDelay && item.myMultiplePressEndCount > 0) {
                    item.myPrevMultiplePressEndCount = item.myMultiplePressEndCount;
                    item.myMultiplePressEndCount = 0;
                }
            }

            if (item.myIsTouched) {
                item.myTimeTouched += dt;
                if (!item.myPrevIsTouched) {
                    item.myMultipleTouchStartCount += 1;

                    item.myPrevTimeNotTouched = item.myTimeNotTouched;
                    item.myTimeNotTouched = 0;
                }

                if (item.myPrevTimeNotTouched + item.myTimeTouched > this._myMultipleTouchMaxDelay && item.myMultipleTouchEndCount > 0) {
                    item.myPrevMultipleTouchEndCount = item.myMultipleTouchEndCount;
                    item.myMultipleTouchEndCount = 0;
                }

                if (item.myTimeTouched > this._myMultipleTouchMaxDelay && item.myMultipleTouchStartCount > 0) {
                    item.myPrevMultipleTouchStartCount = item.myMultipleTouchStartCount;
                    item.myMultipleTouchStartCount = 0;
                }
            } else {
                item.myTimeNotTouched += dt;
                if (item.myPrevIsTouched) {
                    item.myMultipleTouchEndCount += 1;

                    item.myPrevTimeTouched = item.myTimeTouched;
                    item.myTimeTouched = 0;
                }

                if (item.myPrevTimeTouched + item.myTimeNotTouched > this._myMultipleTouchMaxDelay && item.myMultipleTouchStartCount > 0) {
                    item.myPrevMultipleTouchStartCount = item.myMultipleTouchStartCount;
                    item.myMultipleTouchStartCount = 0;
                }

                if (item.myTimeNotTouched > this._myMultipleTouchMaxDelay && item.myMultipleTouchEndCount > 0) {
                    item.myPrevMultipleTouchEndCount = item.myMultipleTouchEndCount;
                    item.myMultipleTouchEndCount = 0;
                }
            }
        }.bind(this));

        for (let typeKey in PP.ButtonType) {
            let buttonInfo = this._myButtonInfos[PP.ButtonType[typeKey]];
            let buttonCallbacks = this._myButtonCallbacks[PP.ButtonType[typeKey]];

            //PRESSED
            if (buttonInfo.myIsPressed && !buttonInfo.myPrevIsPressed) {
                let callbacksMap = buttonCallbacks[PP.ButtonEvent.PRESS_START];
                this._triggerCallbacks(callbacksMap, buttonInfo);
            }

            if (!buttonInfo.myIsPressed && buttonInfo.myPrevIsPressed) {
                let callbacksMap = buttonCallbacks[PP.ButtonEvent.PRESS_END];
                this._triggerCallbacks(callbacksMap, buttonInfo);
            }

            if (buttonInfo.myIsPressed) {
                let callbacksMap = buttonCallbacks[PP.ButtonEvent.PRESSED];
                this._triggerCallbacks(callbacksMap, buttonInfo);
            } else {
                let callbacksMap = buttonCallbacks[PP.ButtonEvent.NOT_PRESSED];
                this._triggerCallbacks(callbacksMap, buttonInfo);
            }

            //TOUCHED
            if (buttonInfo.myIsTouched && !buttonInfo.myPrevIsTouched) {
                let callbacksMap = buttonCallbacks[PP.ButtonEvent.TOUCH_START];
                this._triggerCallbacks(callbacksMap, buttonInfo);
            }

            if (!buttonInfo.myIsTouched && buttonInfo.myPrevIsTouched) {
                let callbacksMap = buttonCallbacks[PP.ButtonEvent.TOUCH_END];
                this._triggerCallbacks(callbacksMap, buttonInfo);
            }

            if (buttonInfo.myIsTouched) {
                let callbacksMap = buttonCallbacks[PP.ButtonEvent.TOUCHED];
                this._triggerCallbacks(callbacksMap, buttonInfo);
            } else {
                let callbacksMap = buttonCallbacks[PP.ButtonEvent.NOT_TOUCHED];
                this._triggerCallbacks(callbacksMap, buttonInfo);
            }

            //VALUE
            if (buttonInfo.myValue != buttonInfo.myPrevValue) {
                let callbacksMap = buttonCallbacks[PP.ButtonEvent.VALUE_CHANGED];
                this._triggerCallbacks(callbacksMap, buttonInfo);
            }

            //ALWAYS
            let callbacksMap = buttonCallbacks[PP.ButtonEvent.ALWAYS];
            this._triggerCallbacks(callbacksMap, buttonInfo);
        }

        this._mySelectStart = false;
        this._mySelectEnd = false;
        this._mySqueezeStart = false;
        this._mySqueezeEnd = false;
    }

    _preUpdateAxesInfos() {
        this._myAxesInfo.myPrevAxes = this._myAxesInfo.myAxes;
    }

    _updateAxesInfos() {
        this._myAxesInfo.myAxes = this._getInternalAxes();
    }

    _postUpdateAxesInfos() {
        //X CHANGED
        if (this._myAxesInfo.myAxes[0] != this._myAxesInfo.myPrevAxes[0]) {
            let callbacksMap = this._myAxesCallbacks[PP.AxesEvent.X_CHANGED];
            this._triggerCallbacks(callbacksMap, this._myAxesInfo);
        }

        //Y CHANGED
        if (this._myAxesInfo.myAxes[1] != this._myAxesInfo.myPrevAxes[1]) {
            let callbacksMap = this._myAxesCallbacks[PP.AxesEvent.Y_CHANGED];
            this._triggerCallbacks(callbacksMap, this._myAxesInfo);
        }

        //AXES CHANGED
        if (!glMatrix.vec2.exactEquals(this._myAxesInfo.myAxes, this._myAxesInfo.myPrevAxes)) {
            let callbacksMap = this._myAxesCallbacks[PP.AxesEvent.AXES_CHANGED];
            this._triggerCallbacks(callbacksMap, this._myAxesInfo);
        }

        //ALWAYS        
        let callbacksMap = this._myAxesCallbacks[PP.AxesEvent.ALWAYS];
        this._triggerCallbacks(callbacksMap, this._myAxesInfo);
    }

    _getInternalButton(buttonType) {
        let buttonData = { pressed: false, touched: false, value: 0 };
        if (this.isGamepadActive()) {
            if (buttonType < this._myGamepad.buttons.length) {
                let gamepadButton = this._myGamepad.buttons[buttonType];
                buttonData.pressed = gamepadButton.pressed;
                buttonData.touched = gamepadButton.touched;
                buttonData.value = gamepadButton.value;
            } else if (buttonType == PP.ButtonType.BOTTOM_BUTTON && this._myGamepad.buttons.length >= 3) {
                //This way if you are using a basic touch controller bottom button will work anyway
                let touchButton = this._myGamepad.buttons[2];
                buttonData.pressed = touchButton.pressed;
                buttonData.touched = touchButton.touched;
                buttonData.value = touchButton.value;
            }
        }

        return buttonData;
    }

    _getInternalAxes() {
        let axes = [0.0, 0.0];
        if (this.isGamepadActive()) {
            let internalAxes = this._myGamepad.axes;
            if (internalAxes.length == 4) {
                //in this case it could be both touch axes or thumbstick axes, that depends on the controller
                //to support both I simply choose the absolute max value (unused axes will always be 0)

                //X
                if (Math.abs(internalAxes[0]) > Math.abs(internalAxes[2])) {
                    axes[0] = internalAxes[0];
                } else {
                    axes[0] = internalAxes[2];
                }

                //Y
                if (Math.abs(internalAxes[1]) > Math.abs(internalAxes[3])) {
                    axes[1] = internalAxes[1];
                } else {
                    axes[1] = internalAxes[3];
                }

            } else if (internalAxes.length == 2) {
                axes[0] = internalAxes[0];
                axes[1] = internalAxes[1];
            }

            //y axis is recorder negative when thumbstick is pressed forward for weird reasons
            axes[1] = -axes[1];
        }

        return axes;
    }

    _updatePulse(dt) {
        let hapticActuator = this._getHapticActuator();
        if (hapticActuator) {
            if (this._myPulseInfo.myIntensity > 0) {
                hapticActuator.pulse(this._myPulseInfo.myIntensity, 1000); //duration is managed by this class
                this._myPulseInfo.myIsDevicePulsing = true;
            } else if (this._myPulseInfo.myIsDevicePulsing) {
                hapticActuator.reset();
                this._myPulseInfo.myIsDevicePulsing = false;
            }
        }

        this._myPulseInfo.myDuration -= dt;
        if (this._myPulseInfo.myDuration <= 0) {
            this._myPulseInfo.myIntensity = 0;
            this._myPulseInfo.myDuration = 0;
        }
    }

    _getHapticActuator() {
        let hapticActuator = null;

        if (this.isGamepadActive()) {
            if (this._myGamepad.hapticActuators && this._myGamepad.hapticActuators.length > 0) {
                hapticActuator = this._myGamepad.hapticActuators[0];
            } else {
                hapticActuator = this._myGamepad.vibrationActuator;
            }
        }

        return hapticActuator;
    }

    _onXRSessionStart(manualStart, session) {
        session.addEventListener("inputsourceschange", function (event) {
            if (event.removed) {
                for (let item of event.removed) {
                    if (item.gamepad == this._myGamepad) {
                        this._myInputSource = null;
                        this._myGamepad = null;
                    }
                }
            }

            if (event.added) {
                for (let item of event.added) {
                    if (item.handedness == this._myHandedness) {
                        this._myInputSource = item;
                        this._myGamepad = item.gamepad;
                    }
                }
            }
        }.bind(this));

        if (manualStart && this._myInputSource == null && session.inputSources) {
            for (let item of session.inputSources) {
                if (item.handedness == this._myHandedness) {
                    this._myInputSource = item;
                    this._myGamepad = item.gamepad;
                }
            }
        }

        session.addEventListener("selectstart", this._selectStart.bind(this));
        session.addEventListener("selectend", this._selectEnd.bind(this));

        session.addEventListener("squeezestart", this._squeezeStart.bind(this));
        session.addEventListener("squeezeend", this._squeezeEnd.bind(this));

        this._myIsXRSessionActive = true;
    }

    _onXRSessionEnd(session) {
        this._myInputSource = null;
        this._myGamepad = null;

        this._myIsXRSessionActive = false;
    }

    //Select and Squeeze are managed this way to be more compatible
    _selectStart(event) {
        if (event.inputSource.handedness == this._myHandedness) {
            this._mySelectStart = true;
        }
    }

    _selectEnd(event) {
        if (event.inputSource.handedness == this._myHandedness) {
            this._mySelectEnd = true;
        }
    }

    _squeezeStart(event) {
        if (event.inputSource.handedness == this._myHandedness) {
            this._mySqueezeStart = true;
        }
    }

    _squeezeEnd(event) {
        if (event.inputSource.handedness == this._myHandedness) {
            this._mySqueezeEnd = true;
        }
    }

    _triggerCallbacks(callbacksMap, info) {
        for (let callback of callbacksMap.values()) {
            callback(info, this);
        }
    }
};
/**
 * Animate the buttons of a gamepad, like pressing, thumbstick tilting and so on
 */
WL.registerComponent('pp-gamepad-animator', {
    _myHandedness: { type: WL.Type.Enum, values: ['left', 'right'], default: 'left' },
    _mySelect: { type: WL.Type.Object, default: null },
    _mySqueeze: { type: WL.Type.Object, default: null },
    _myThumbstick: { type: WL.Type.Object, default: null },
    _myBottomButton: { type: WL.Type.Object, default: null },
    _myTopButton: { type: WL.Type.Object, default: null }
}, {
    init: function () {
        this._myGamepad = null;

        this._myNormalDiffuseButtonColor = null; //@EDIT with the color you want, or leave null to keep the material color, set all color variables or none
        this._myNormalAmbientButtonColor = null; // set them like this [x/255, y/255, z/255, w/255]
        this._myIsTouchedDiffuseButtonColor = null;
        this._myIsTouchedAmbientButtonColor = null;

        this._myThumbstickInitialLocalForward = this._getLocalAxis(this._myThumbstick, [0, 0, 1]);
        this._myThumbstickForward = [0, 0, 1];
        this._mySelectForward = [0, 0, 1];

        this._myIsMeshEnabled = false;
    },
    start: function () {
        if (this._myHandedness == 0) {
            this._myGamepad = PP.myLeftGamepad; //@EDIT get gamepad LEFT here based on how you store it in your game
        } else {
            this._myGamepad = PP.myRightGamepad; //@EDIT get gamepad RIGHT here based on how you store it in your game
        }

        this._mySelectMaterial = this._mySelect.getComponent("mesh").material.clone();
        this._mySelect.getComponent("mesh").material = this._mySelectMaterial;
        this._mySelectPosition = new Float32Array(3);
        this._mySelect.getTranslationLocal(this._mySelectPosition);
        if (this._myNormalDiffuseButtonColor) {
            this._mySelectMaterial.diffuseColor = this._myNormalDiffuseButtonColor;
            this._mySelectMaterial.ambientColor = this._myNormalAmbientButtonColor;
        }

        this._mySqueezeMaterial = this._mySqueeze.getComponent("mesh").material.clone();
        this._mySqueeze.getComponent("mesh").material = this._mySqueezeMaterial;
        this._mySqueezePosition = new Float32Array(3);
        this._mySqueeze.getTranslationLocal(this._mySqueezePosition);
        if (this._myNormalDiffuseButtonColor) {
            this._mySqueezeMaterial.diffuseColor = this._myNormalDiffuseButtonColor;
            this._mySqueezeMaterial.ambientColor = this._myNormalAmbientButtonColor;
        }

        this._myThumbstickMaterial = this._myThumbstick.getComponent("mesh").material.clone();
        this._myThumbstick.getComponent("mesh").material = this._myThumbstickMaterial;
        this._myThumbstickPosition = new Float32Array(3);
        this._myThumbstick.getTranslationLocal(this._myThumbstickPosition);
        if (this._myNormalDiffuseButtonColor) {
            this._myThumbstickMaterial.diffuseColor = this._myNormalDiffuseButtonColor;
            this._myThumbstickMaterial.ambientColor = this._myNormalAmbientButtonColor;
        }

        this._myBottomButtonMaterial = this._myBottomButton.getComponent("mesh").material.clone();
        this._myBottomButton.getComponent("mesh").material = this._myBottomButtonMaterial;
        this._myBottomButtonPosition = new Float32Array(3);
        this._myBottomButton.getTranslationLocal(this._myBottomButtonPosition);
        if (this._myNormalDiffuseButtonColor) {
            this._myBottomButtonMaterial.diffuseColor = this._myNormalDiffuseButtonColor;
            this._myBottomButtonMaterial.ambientColor = this._myNormalAmbientButtonColor;
        }

        this._myTopButtonMaterial = this._myTopButton.getComponent("mesh").material.clone();
        this._myTopButton.getComponent("mesh").material = this._myTopButtonMaterial;
        this._myTopButtonPosition = new Float32Array(3);
        this._myTopButton.getTranslationLocal(this._myTopButtonPosition);
        if (this._myNormalDiffuseButtonColor) {
            this._myTopButtonMaterial.diffuseColor = this._myNormalDiffuseButtonColor;
            this._myTopButtonMaterial.ambientColor = this._myNormalAmbientButtonColor;
        }

        //PRESSED
        this._myGamepad.registerButtonEventListener(PP.ButtonType.THUMBSTICK, PP.ButtonEvent.PRESS_START, this, this._thumbstickPressedStart.bind(this));
        this._myGamepad.registerButtonEventListener(PP.ButtonType.THUMBSTICK, PP.ButtonEvent.PRESS_END, this, this._thumbstickPressedEnd.bind(this));

        this._myGamepad.registerButtonEventListener(PP.ButtonType.BOTTOM_BUTTON, PP.ButtonEvent.PRESS_START, this, this._bottomButtonPressedStart.bind(this));
        this._myGamepad.registerButtonEventListener(PP.ButtonType.BOTTOM_BUTTON, PP.ButtonEvent.PRESS_END, this, this._bottomButtonPressedEnd.bind(this));

        this._myGamepad.registerButtonEventListener(PP.ButtonType.TOP_BUTTON, PP.ButtonEvent.PRESS_START, this, this._topButtonPressedStart.bind(this));
        this._myGamepad.registerButtonEventListener(PP.ButtonType.TOP_BUTTON, PP.ButtonEvent.PRESS_END, this, this._topButtonPressedEnd.bind(this));

        //TOUCHED
        this._myGamepad.registerButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.TOUCH_START, this, this._selectTouchedStart.bind(this));
        this._myGamepad.registerButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.TOUCH_END, this, this._selectTouchedEnd.bind(this));

        this._myGamepad.registerButtonEventListener(PP.ButtonType.SQUEEZE, PP.ButtonEvent.TOUCH_START, this, this._squeezeTouchedStart.bind(this));
        this._myGamepad.registerButtonEventListener(PP.ButtonType.SQUEEZE, PP.ButtonEvent.TOUCH_END, this, this._squeezeTouchedEnd.bind(this));

        this._myGamepad.registerButtonEventListener(PP.ButtonType.THUMBSTICK, PP.ButtonEvent.TOUCH_START, this, this._thumbstickTouchedStart.bind(this));
        this._myGamepad.registerButtonEventListener(PP.ButtonType.THUMBSTICK, PP.ButtonEvent.TOUCH_END, this, this._thumbstickTouchedEnd.bind(this));

        this._myGamepad.registerButtonEventListener(PP.ButtonType.BOTTOM_BUTTON, PP.ButtonEvent.TOUCH_START, this, this._bottomButtonTouchedStart.bind(this));
        this._myGamepad.registerButtonEventListener(PP.ButtonType.BOTTOM_BUTTON, PP.ButtonEvent.TOUCH_END, this, this._bottomButtonTouchedEnd.bind(this));

        this._myGamepad.registerButtonEventListener(PP.ButtonType.TOP_BUTTON, PP.ButtonEvent.TOUCH_START, this, this._topButtonTouchedStart.bind(this));
        this._myGamepad.registerButtonEventListener(PP.ButtonType.TOP_BUTTON, PP.ButtonEvent.TOUCH_END, this, this._topButtonTouchedEnd.bind(this));

        //VALUE CHANGED
        this._myGamepad.registerButtonEventListener(PP.ButtonType.SQUEEZE, PP.ButtonEvent.VALUE_CHANGED, this, this._squeezeValueChanged.bind(this));
        this._myGamepad.registerButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.VALUE_CHANGED, this, this._selectValueChanged.bind(this));

        //AXES CHANGED
        this._myGamepad.registerAxesEventListener(PP.AxesEvent.AXES_CHANGED, this, this._axesValueChanged.bind(this));

        this.object.scale([0, 0, 0]);
    },
    update: function (dt) {
        this._enableMeshInSession();
    },
    _thumbstickPressedStart: function (buttonInfo, gamepad) {
        //since thumbstick object rotate I need to specifically use its initial forward
        let tempVector = glMatrix.vec3.create();
        glMatrix.vec3.scale(tempVector, this._myThumbstickInitialLocalForward, 0.0015);
        this._myThumbstick.translate(tempVector);
    },
    _thumbstickPressedEnd: function (buttonInfo, gamepad) {
        let tempVector = glMatrix.vec3.create();
        glMatrix.vec3.scale(tempVector, this._myThumbstickInitialLocalForward, -0.0015);
        this._myThumbstick.translate(tempVector);
    },
    _bottomButtonPressedStart: function (buttonInfo, gamepad) {
        this._translateLocalAxis(this._myBottomButton, [0, 0, 1], 0.002);
    },
    _bottomButtonPressedEnd: function (buttonInfo, gamepad) {
        this._translateLocalAxis(this._myBottomButton, [0, 0, 1], -0.002);
    },
    _topButtonPressedStart: function (buttonInfo, gamepad) {
        this._translateLocalAxis(this._myTopButton, [0, 0, 1], 0.002);
    },
    _topButtonPressedEnd: function (buttonInfo, gamepad) {
        this._translateLocalAxis(this._myTopButton, [0, 0, 1], -0.002);
    },
    //TOUCHED
    _selectTouchedStart: function (buttonInfo, gamepad) {
        if (this._myNormalDiffuseButtonColor) {
            this._mySelectMaterial.diffuseColor = this._myIsTouchedDiffuseButtonColor;
            this._mySelectMaterial.ambientColor = this._myIsTouchedAmbientButtonColor;
        }
    },
    _selectTouchedEnd: function (buttonInfo, gamepad) {
        if (this._myNormalDiffuseButtonColor) {
            this._mySelectMaterial.diffuseColor = this._myNormalDiffuseButtonColor;
            this._mySelectMaterial.ambientColor = this._myNormalAmbientButtonColor;
        }
    },
    _squeezeTouchedStart: function (buttonInfo, gamepad) {
        if (this._myNormalDiffuseButtonColor) {
            this._mySqueezeMaterial.diffuseColor = this._myIsTouchedDiffuseButtonColor;
            this._mySqueezeMaterial.ambientColor = this._myIsTouchedAmbientButtonColor;
        }
    },
    _squeezeTouchedEnd: function (buttonInfo, gamepad) {
        if (this._myNormalDiffuseButtonColor) {
            this._mySqueezeMaterial.diffuseColor = this._myNormalDiffuseButtonColor;
            this._mySqueezeMaterial.ambientColor = this._myNormalAmbientButtonColor;
        }
    },
    _thumbstickTouchedStart: function (buttonInfo, gamepad) {
        if (this._myNormalDiffuseButtonColor) {
            this._myThumbstickMaterial.diffuseColor = this._myIsTouchedDiffuseButtonColor;
            this._myThumbstickMaterial.ambientColor = this._myIsTouchedAmbientButtonColor;
        }
    },
    _thumbstickTouchedEnd: function (buttonInfo, gamepad) {
        if (this._myNormalDiffuseButtonColor) {
            this._myThumbstickMaterial.diffuseColor = this._myNormalDiffuseButtonColor;
            this._myThumbstickMaterial.ambientColor = this._myNormalAmbientButtonColor;
        }
    },
    _bottomButtonTouchedStart: function (buttonInfo, gamepad) {
        if (this._myNormalDiffuseButtonColor) {
            this._myBottomButtonMaterial.diffuseColor = this._myIsTouchedDiffuseButtonColor;
            this._myBottomButtonMaterial.ambientColor = this._myIsTouchedAmbientButtonColor;
        }
    },
    _bottomButtonTouchedEnd: function (buttonInfo, gamepad) {
        if (this._myNormalDiffuseButtonColor) {
            this._myBottomButtonMaterial.diffuseColor = this._myNormalDiffuseButtonColor;
            this._myBottomButtonMaterial.ambientColor = this._myNormalAmbientButtonColor;
        }
    },
    _topButtonTouchedStart: function (buttonInfo, gamepad) {
        if (this._myNormalDiffuseButtonColor) {
            this._myTopButtonMaterial.diffuseColor = this._myIsTouchedDiffuseButtonColor;
            this._myTopButtonMaterial.ambientColor = this._myIsTouchedAmbientButtonColor;
        }
    },
    _topButtonTouchedEnd: function (buttonInfo, gamepad) {
        if (this._myNormalDiffuseButtonColor) {
            this._myTopButtonMaterial.diffuseColor = this._myNormalDiffuseButtonColor;
            this._myTopButtonMaterial.ambientColor = this._myNormalAmbientButtonColor;
        }
    },
    _selectValueChanged: function (buttonInfo, gamepad) {
        //first reset rotation to start position
        this._copyAlignRotation(this._mySelect, this._mySelectForward, [0, 0, 1]);

        let angleToRotate = glMatrix.glMatrix.toRadian(15 * buttonInfo.myValue);
        let tiltDirection = [0, 0, 1];
        glMatrix.vec3.rotateX(tiltDirection, tiltDirection, [0, 0, 0], angleToRotate);
        glMatrix.vec3.normalize(tiltDirection, tiltDirection);

        this._copyAlignRotation(this._mySelect, [0, 0, 1], tiltDirection);

        this._mySelectForward = tiltDirection;
    },
    _squeezeValueChanged: function (buttonInfo, gamepad) {
        this._mySqueeze.setTranslationLocal(this._mySqueezePosition);
        let translation = 0.0015;
        if (this._myHandedness == 1) {
            translation *= -1;
        }
        this._translateLocalAxis(this._mySqueeze, [1, 0, 0], translation * buttonInfo.myValue);
    },
    _axesValueChanged: function (axesInfo, gamepad) {
        //first reset rotation to start position
        this._copyAlignRotation(this._myThumbstick, this._myThumbstickForward, [0, 0, 1]);

        let tiltDirection = new Float32Array(3);
        glMatrix.vec3.add(tiltDirection, [0, 0, 1], [axesInfo.myAxes[0], -axesInfo.myAxes[1], 0.0]);
        glMatrix.vec3.normalize(tiltDirection, tiltDirection);

        this._copyAlignRotation(this._myThumbstick, [0, 0, 1], tiltDirection);

        this._myThumbstickForward = tiltDirection;
    },
    //Couldn't find a better name, basically find the rotation to align start axis to end, and apply that to object
    _copyAlignRotation: function (object, startAxis, endAxis) {
        let rotationAxis = new Float32Array(3);
        glMatrix.vec3.cross(rotationAxis, startAxis, endAxis);
        glMatrix.vec3.normalize(rotationAxis, rotationAxis);

        let angleToRotate = glMatrix.vec3.angle(startAxis, endAxis);

        if (angleToRotate > 0.0001) {
            object.rotateAxisAngleRadObject(rotationAxis, angleToRotate);
        }
    },
    _translateLocalAxis(object, axis, amount) {
        let tempVector = this._getLocalAxis(object, axis);
        glMatrix.vec3.scale(tempVector, tempVector, amount);
        object.translate(tempVector);
    },
    _getLocalAxis(object, axis) {
        let tempVector = glMatrix.vec3.create();
        glMatrix.vec3.transformQuat(tempVector, axis, object.transformLocal);
        glMatrix.vec3.normalize(tempVector, tempVector);
        return tempVector;
    },
    _enableMeshInSession: function () {
        if (!this._myIsMeshEnabled) {
            if (WL.xrSession) {
                this.object.resetScaling();
                this._myIsMeshEnabled = true;
            }
        } else {
            if (!WL.xrSession) {
                this.object.scale([0, 0, 0]);
                this._myIsMeshEnabled = false;
            }
        }
    }
});
PP.GamepadManager = class GamepadManager {
    constructor() {
        this._myLeftGamepad = new PP.Gamepad(PP.Handedness.LEFT);
        this._myRightGamepad = new PP.Gamepad(PP.Handedness.RIGHT);
    }

    start() {
        this._myLeftGamepad.start();
        this._myRightGamepad.start();
    }

    update(dt) {
        this._myLeftGamepad.update(dt);
        this._myRightGamepad.update(dt);
    }

    getLeftGamepad() {
        return this._myLeftGamepad;
    }

    getRightGamepad() {
        return this._myRightGamepad;
    }

    getGamepad(handedness) {
        let gamepad = null;

        switch (handedness) {
            case PP.Handedness.LEFT:
                gamepad = this._myLeftGamepad;
                break;
            case PP.Handedness.RIGHT:
                gamepad = this._myRightGamepad;
                break;
            default:
                gamepad = null;
        }

        return gamepad;
    }

    getGamepads() {
        let gamepads = [];

        gamepads[PP.Handedness.LEFT] = this._myLeftGamepad;
        gamepads[PP.Handedness.RIGHT] = this._myRightGamepad;

        return gamepads;
    }
};
/**
 * A quick and simple way to have the gamepads up and running
 * Add this manager to an object that will never be destroyed (like the Player object)
 * otherwise the gamepads will not be updated anymore
 */
WL.registerComponent('pp-gamepad-manager', {
}, {
    init: function () {
        this._myGamepadManager = new PP.GamepadManager();

        PP.myLeftGamepad = this._myGamepadManager.getLeftGamepad();
        PP.myRightGamepad = this._myGamepadManager.getRightGamepad();
        PP.myGamepads = this._myGamepadManager.getGamepads();
    },
    start: function () {
        this._myGamepadManager.start();
    },
    update: function (dt) {
        this._myGamepadManager.update(dt);
    },
});

PP.myLeftGamepad = null;
PP.myRightGamepad = null;
PP.myGamepads = null;
PP.GamepadUtils = {
    _myPressTogetherMaxDelay: 0.15,
    _myTouchTogetherMaxDelay: 0.15,

    // gamepadButtonTypesList is a sequence of a gamepad and a list of buttonTypes like this ([gamepad1, squeeze, top, select], [gamepad2, bottom, squeeze, select], ...)
    // if the first paramter is a number it's used as multiplePressCount
    areButtonsPressStart: function (...gamepadButtonTypesList) {
        let multiplePressCount = null;
        let argumentsToForward = gamepadButtonTypesList;
        if (!isNaN(gamepadButtonTypesList[0])) {
            multiplePressCount = gamepadButtonTypesList[0];
            argumentsToForward = gamepadButtonTypesList.slice(1);
        }
        return PP.GamepadUtils.areButtonsMultiplePressStart(multiplePressCount, ...argumentsToForward);
    },

    areButtonsMultiplePressStart: function (multiplePressCount, ...gamepadButtonTypesList) {
        let areButtonPressedRecently = true;
        let isOnePressStart = false;
        for (let gamepadButtonTypes of gamepadButtonTypesList) {
            let gamepad = gamepadButtonTypes[0];
            for (let i = 1; i < gamepadButtonTypes.length; i++) {
                let buttonType = gamepadButtonTypes[i];
                let button = gamepad.getButtonInfo(buttonType);

                if (!(button.myIsPressed && (multiplePressCount == null || button.myMultiplePressStartCount == multiplePressCount) && button.myTimePressed < PP.GamepadUtils._myPressTogetherMaxDelay)) {
                    areButtonPressedRecently = false;
                    break;
                }

                if (button.isPressStart(multiplePressCount)) {
                    isOnePressStart = true;
                }
            }

            if (!areButtonPressedRecently) {
                break;
            }
        }

        return areButtonPressedRecently && isOnePressStart;
    },

    areButtonsPressEnd: function (...gamepadButtonTypesList) {
        let multiplePressCount = null;
        let argumentsToForward = gamepadButtonTypesList;
        if (!isNaN(gamepadButtonTypesList[0])) {
            multiplePressCount = gamepadButtonTypesList[0];
            argumentsToForward = gamepadButtonTypesList.slice(1);
        }
        return PP.GamepadUtils.areButtonsMultiplePressEnd(multiplePressCount, ...argumentsToForward);
    },

    areButtonsMultiplePressEnd: function (multiplePressCount, ...gamepadButtonTypesList) {
        let areButtonNotPressedRecently = true;
        let isOnePressEnd = false;
        for (let gamepadButtonTypes of gamepadButtonTypesList) {
            let gamepad = gamepadButtonTypes[0];
            for (let i = 1; i < gamepadButtonTypes.length; i++) {
                let buttonType = gamepadButtonTypes[i];
                let button = gamepad.getButtonInfo(buttonType);

                if (!(!button.myIsPressed && (multiplePressCount == null || button.myMultiplePressEndCount == multiplePressCount) && button.myTimeNotPressed < PP.GamepadUtils._myPressTogetherMaxDelay)) {
                    areButtonNotPressedRecently = false;
                    break;
                }

                if (button.isPressEnd(multiplePressCount)) {
                    isOnePressEnd = true;
                }
            }

            if (!areButtonNotPressedRecently) {
                break;
            }
        }

        return areButtonNotPressedRecently && isOnePressEnd;
    },

    areButtonsTouchStart: function (...gamepadButtonTypesList) {
        let multipleTouchCount = null;
        let argumentsToForward = gamepadButtonTypesList;
        if (!isNaN(gamepadButtonTypesList[0])) {
            multipleTouchCount = gamepadButtonTypesList[0];
            argumentsToForward = gamepadButtonTypesList.slice(1);
        }
        return PP.GamepadUtils.areButtonsMultipleTouchStart(multipleTouchCount, ...argumentsToForward);
    },

    areButtonsMultipleTouchStart: function (multipleTouchCount, ...gamepadButtonTypesList) {
        let areButtonTouchedRecently = true;
        let isOneTouchStart = false;
        for (let gamepadButtonTypes of gamepadButtonTypesList) {
            let gamepad = gamepadButtonTypes[0];
            for (let i = 1; i < gamepadButtonTypes.length; i++) {
                let buttonType = gamepadButtonTypes[i];
                let button = gamepad.getButtonInfo(buttonType);

                if (!(button.myIsTouched && (multipleTouchCount == null || button.myMultipleTouchStartCount == multipleTouchCount) && button.myTimeTouched < PP.GamepadUtils._myTouchTogetherMaxDelay)) {
                    areButtonTouchedRecently = false;
                    break;
                }

                if (button.isTouchStart(multipleTouchCount)) {
                    isOneTouchStart = true;
                }
            }

            if (!areButtonTouchedRecently) {
                break;
            }
        }

        return areButtonTouchedRecently && isOneTouchStart;
    },

    areButtonsTouchEnd: function (...gamepadButtonTypesList) {
        let multipleTouchCount = null;
        let argumentsToForward = gamepadButtonTypesList;
        if (!isNaN(gamepadButtonTypesList[0])) {
            multipleTouchCount = gamepadButtonTypesList[0];
            argumentsToForward = gamepadButtonTypesList.slice(1);
        }
        return PP.GamepadUtils.areButtonsMultipleTouchEnd(multipleTouchCount, ...argumentsToForward);
    },

    areButtonsMultipleTouchEnd: function (multipleTouchCount, ...gamepadButtonTypesList) {
        let areButtonNotTouchedRecently = true;
        let isOneTouchEnd = false;
        for (let gamepadButtonTypes of gamepadButtonTypesList) {
            let gamepad = gamepadButtonTypes[0];
            for (let i = 1; i < gamepadButtonTypes.length; i++) {
                let buttonType = gamepadButtonTypes[i];
                let button = gamepad.getButtonInfo(buttonType);

                if (!(!button.myIsTouched && (multipleTouchCount == null || button.myMultipleTouchEndCount == multipleTouchCount) && button.myTimeNotTouched < PP.GamepadUtils._myTouchTogetherMaxDelay)) {
                    areButtonNotTouchedRecently = false;
                    break;
                }

                if (button.isTouchEnd(multipleTouchCount)) {
                    isOneTouchEnd = true;
                }
            }

            if (!areButtonNotTouchedRecently) {
                break;
            }
        }

        return areButtonNotTouchedRecently && isOneTouchEnd;
    },
};
WL.registerComponent('test-add-rotation', {
    _myAddRotation: { type: WL.Type.Bool, default: false },
    _myRotateSeparately: { type: WL.Type.Bool, default: false },
}, {
    init: function () {
    },
    start: function () {
        let vec = [0, 0, 45];
        let vec2 = [0, 180, 0];
        let quat = vec.vec3_toQuat();
        let quat2 = vec2.vec3_toQuat();
        let quat3 = quat;
        if (this._myAddRotation) {
            quat3 = quat.quat_addRotationQuat(quat2);
        }

        if (this._myRotateSeparately) {
            this.object.pp_rotateObjectQuat(quat);
            this.object.pp_rotateObjectQuat(quat2);
        } else {
            this.object.pp_rotateObjectQuat(quat3);
        }
    },
    update: function (dt) {
    }
});
WL.registerComponent('test-audio', {
}, {
    init: function () {
    },
    start: function () {
        this.timer = new PP.Timer(1.2);
    },
    update: function (dt) {
        this.timer.update(dt);
        if (this.timer.isDone()) {
            this.timer.reset();

            let player = Global.myAudioManager.createAudioPlayer(SfxID.NOT_ENOUGH);
            player.play();
            player.registerAudioEventListener(PP.AudioEvent.END, this, function (id) { console.log(id); });
        }
    }
});
WL.registerComponent('test-clone-mesh', {
    objectToClone: { type: WL.Type.Object }
}, {
    init: function () {
    },
    start: function () {
        /*
        this.mesh = this.object.pp_addComponent("mesh");
        let otherMesh = this.objectToClone.pp_getComponent("mesh");
        this.mesh.material = otherMesh.material;
        this.mesh.mesh = otherMesh.mesh;
        this.mesh.skin = otherMesh.skin;
        */

        let params = new PP.CloneParams();
        //params.myIgnoreChildren = true;
        //params.myComponentsToIgnore.push("mesh");
        this.cloned = this.objectToClone.pp_clone(params);
        this.cloned.pp_getPositionWorld();
        this.cloned.pp_translate([0.5, 0, 0]);
        //console.log(this.cloned.pp_getPositionWorld());

    },
    update: function (dt) {
        let a = 2;
        a += 2;
    }
});
WL.registerComponent('test-print-axes', {
}, {
    init: function () {
        this._myCounter = 70;

        /*
        let parent = WL.scene.addObject(null);
        let child = WL.scene.addObject(parent);
        parent.scalingWorld = [2, 5, 4];
        //parent.scalingWorld = [1, 1, 1];
        child.scalingWorld = [4, 3, 7];
        //child.scalingWorld = [1, 1, 1];
        let transform = [0.5354, 0.5714, 0.1685, -0.5986, 5.3222, -4.4403, 6.6770, 2.4017];
        let transformParent = [0.1110, 0.1936, -0.0633, 0.9727, 0.4864, 0.0317, 0.0968, -0.0555];
        glMatrix.quat2.normalize(transform, transform);
        glMatrix.quat2.normalize(transformParent, transformParent);
        parent.transformWorld = transformParent;
        child.transformWorld = transform;

        let parentMatrixWorld = glMatrix.mat4.fromRotationTranslationScale([], parent.rotationWorld, parent.getTranslationWorld([]), parent.scalingWorld);
        let childMatrixLocal = glMatrix.mat4.fromRotationTranslationScale([], child.rotationLocal, child.getTranslationLocal([]), child.scalingLocal);
        let childMatrixWorld = glMatrix.mat4.fromRotationTranslationScale([], child.rotationWorld, child.getTranslationWorld([]), child.scalingWorld);

        this.consoleWarnFixed(child.pp_getTransformWorldQuat());
        this.consoleWarnFixed(parent.pp_convertTransformObjectToWorldQuat(child.pp_getTransformLocalQuat()));
        this.consoleWarnFixed(glMatrix.mat4.sub([], child.pp_getTransformWorldQuat(), parent.pp_convertTransformObjectToWorldQuat(child.pp_getTransformLocalQuat())));

        this.consoleWarnFixed(child.pp_getTransformLocalQuat());
        this.consoleWarnFixed(parent.pp_convertTransformWorldToObjectQuat(child.pp_getTransformWorldQuat()));
        this.consoleWarnFixed(glMatrix.mat4.sub([], child.pp_getTransformLocalQuat(), parent.pp_convertTransformWorldToObjectQuat(child.pp_getTransformWorldQuat())));

        //this.consoleWarnMatrix4Fixed(child.pp_getTransformLocalMatrix());
        //this.consoleWarnMatrix4Fixed(parent.pp_convertTransformWorldToObjectMatrix(child.pp_getTransformWorldMatrix()));
        //this.consoleWarnMatrix4Fixed(glMatrix.mat4.sub([], child.pp_getTransformLocalMatrix(), parent.pp_convertTransformWorldToObjectMatrix(child.pp_getTransformWorldMatrix())));

        //this.consoleWarnMatrix4Fixed(child.pp_getTransformWorldMatrix());
        //this.consoleWarnMatrix4Fixed(parent.pp_convertTransformObjectToWorldMatrix(child.pp_getTransformLocalMatrix()));
        //this.consoleWarnMatrix4Fixed(glMatrix.mat4.sub([], child.pp_getTransformWorldMatrix(), parent.pp_convertTransformObjectToWorldMatrix(child.pp_getTransformLocalMatrix())));

        //this.consoleWarnFixed(child.rotationWorld);
        //this.consoleWarnFixed(child.getTranslationWorld([]));
        //this.consoleWarnFixed(child.scalingWorld);

        let computedChildMatrixLocal = glMatrix.mat4.mul([], glMatrix.mat4.invert([], parentMatrixWorld), childMatrixWorld);
        child.pp_setTransformLocalMatrix(computedChildMatrixLocal);
        this.consoleWarnMatrix4Fixed(computedChildMatrixLocal);
        this.consoleWarnMatrix4Fixed(child.pp_getTransformLocalMatrix());

        this.consoleWarnFixed(child.rotationWorld);
        this.consoleWarnFixed(child.getTranslationWorld([]));
        this.consoleWarnFixed(child.scalingWorld);

        this.consoleWarnMatrix4Fixed(parent.pp_getTransformWorldMatrix());
        this.consoleWarnMatrix4Fixed(parent.pp_getTransformLocalMatrix());
        this.consoleWarnMatrix4Fixed(parentMatrixWorld);

        this.consoleWarnFixed(child.transformWorld);
        this.consoleWarnFixed(parent.toWorldSpaceTransform([], child.transformLocal));
        console.warn(childMatrixLocal);
        let computedChildMatrixWorld = glMatrix.mat4.mul([], parentMatrixWorld, childMatrixLocal);

        {
            let print = [[], [], [], []];
            for (let i = 0; i < childMatrixWorld.length; i++) {
                print[Math.floor(i / 4)].push(childMatrixWorld[i].toFixed(4));
            }
            console.warn(print);

            print = [[], [], [], []];
            for (let i = 0; i < computedChildMatrixWorld.length; i++) {
                print[Math.floor(i / 4)].push(computedChildMatrixWorld[i].toFixed(4));
            }
            console.warn(print);

            let difference = glMatrix.mat4.sub([], computedChildMatrixWorld, childMatrixWorld);

            print = [[], [], [], []];
            for (let i = 0; i < difference.length; i++) {
                print[Math.floor(i / 4)].push(difference[i].toFixed(4));
            }
            console.warn(print);
        }

        {
            let quat = [0.4911, 0.6793, 0.2719, -0.4727];
            quat.quat_normalize(quat);
            this.consoleWarnFixed(quat);

            let mat = glMatrix.mat4.fromRotationTranslationScale([], quat, [2, 3, 4], [3, 1, 2]);
            let mat2 = glMatrix.mat4.fromRotationTranslationScale([], quat, [2, 3, 4], [1, 1, 1]);
            let mat3 = mat.mat4_setScale([1, 1, 1]);
            let mat4 = computedChildMatrixWorld;
            let mat5 = computedChildMatrixWorld.mat4_clone().mat4_setScale([1, 1, 1]);

            let rotation = glMatrix.mat4.getRotation([], mat);
            let rotation2 = glMatrix.mat4.getRotation([], mat2);
            let rotation3 = glMatrix.mat4.getRotation([], mat3);
            let rotation4 = glMatrix.mat4.getRotation([], mat4);
            let rotation5 = glMatrix.mat4.getRotation([], mat5);

            this.consoleWarnFixed(rotation);
            this.consoleWarnFixed(rotation.quat_normalize());
            this.consoleWarnFixed(rotation2);
            this.consoleWarnFixed(rotation3);
            this.consoleWarnFixed(rotation3.quat_normalize());
            this.consoleWarnFixed(rotation4);
            this.consoleWarnFixed(rotation5);
            this.consoleWarnFixed(rotation5.quat_normalize());

            console.warn(glMatrix.mat4.mul([], parentMatrixWorld, childMatrixWorld).mat4_getScale());

            let axes = glMatrix.mat4.mul([], parentMatrixWorld, childMatrixWorld).mat4_getAxes();
            let angle1 = axes[0].vec3_angleRadians(axes[1]);
            let angle2 = axes[2].vec3_angleRadians(axes[1]);
            let angle3 = axes[2].vec3_angleRadians(axes[0]);
            console.warn(angle1 - Math.PI / 2, angle2 - Math.PI / 2, angle3 - Math.PI / 2);


        }
        */
    },
    consoleWarnFixed(vector) {
        let result = [];
        for (let value of vector) {
            result.push(value.toFixed(4));
        }
        console.warn(result);
    },
    consoleWarnMatrix4Fixed(vector) {
        let result = [[], [], [], []];
        for (let i = 0; i < vector.length; i++) {
            result[Math.floor(i / 4)].push(vector[i].toFixed(4));
        }
        console.warn(result);
    },
    consoleWarnMatrix3Fixed(vector) {
        let result = [[], [], []];
        for (let i = 0; i < vector.length; i++) {
            result[Math.floor(i / 3)].push(vector[i].toFixed(4));
        }
        console.warn(result);
    },
    start: function () {
        this._myDebugAxes = new PP.DebugAxes();
        this._myDebugAxes.setPositionOffset([0, 0, 0]);
    },
    update: function (dt) {
        if (this._myCounter >= 0) {
            this._myCounter--;
            if (this._myCounter == 0) {
                this._myCounter = 70;
                /*
                console.log(this.object.pp_getRight()[0].toFixed(4), this.object.pp_getRight()[1].toFixed(4), this.object.pp_getRight()[2].toFixed(4));
                console.log(this.object.pp_getUp()[0].toFixed(4), this.object.pp_getUp()[1].toFixed(4), this.object.pp_getUp()[2].toFixed(4));
                console.log(this.object.pp_getForward()[0].toFixed(4), this.object.pp_getForward()[1].toFixed(4), this.object.pp_getForward()[2].toFixed(4));
                */
                /* 
                let right = [];
                let up = [];
                let forward = [];

                this.object.getRight(right);
                this.object.getUp(up);
                this.object.getForward(forward);

                console.log(right[0].toFixed(4), right[1].toFixed(4), right[2].toFixed(4));
                console.log(up[0].toFixed(4), up[1].toFixed(4), up[2].toFixed(4));
                console.log(forward[0].toFixed(4), forward[1].toFixed(4), forward[2].toFixed(4));
                */

                //console.log("   ");
            }
        }

        /*
        let right = [];
        let up = [];
        let forward = [];

        this.object.getRight(right);
        this.object.getUp(up);
        this.object.getForward(forward);

        this._myDebugForward.setStartDirectionLength(this.object.pp_getPosition(), forward, 0.1);
        this._myDebugForward.update(dt);

        this._myDebugUp.setStartDirectionLength(this.object.pp_getPosition(), up, 0.1);
        this._myDebugUp.update(dt);

        this._myDebugRight.setStartDirectionLength(this.object.pp_getPosition(), right, 0.1);
        this._myDebugRight.update(dt);
        */

        this._myDebugAxes.setTransform(this.object.transformWorld);
    }
});
WL.registerComponent('test-prototype', {
}, {
    init: function () {
        this._myCounter = 3;
    },
    start: function () {
    },
    update: function (dt) {
        if (this._myCounter >= 0) {
            this._myCounter--;
            if (this._myCounter == 0) {
                this.test();
            }
        }
    },
    test() {
        let initParentTransform = [2.7510, -0.2407, -1.1722, 0.0000, 0.1662, 0.9674, 0.1914, 0.0000, 0.7252, -0.4809, 1.8008, 0.0000, 1.0000, -0.0000, -0.0000, 1.0000];
        let initTransform = [5.5891, 0.7359, -2.0544, 0.0000, 0.3699, 1.3017, 1.4727, 0.0000, 0.6263, -1.4985, 1.1672, 0.0000, 1.3324, 1.9347, 0.3828, 1.0000];
        this.object.pp_getParent().pp_setTransformWorldMatrix(initParentTransform);
        this.object.pp_setTransformWorldMatrix(initTransform);
        this.object.pp_getParent().pp_setParent(null);

        console.warn("TEST START\n");

        console.warn("\nPOSITION\n");
        this.object.pp_setPosition([1, 2, 3]);
        this.consoleWarnFixed(this.object.pp_getPosition());
        this.object.pp_setPositionWorld([3, 1, 2]);
        this.consoleWarnFixed(this.object.pp_getPositionWorld());
        this.object.pp_setPositionLocal([4, 5, 7]);
        this.consoleWarnFixed(this.object.pp_getPositionLocal());

        console.warn("\nROTATION\n");
        this.object.pp_setRotation([20, 50, 120]);
        this.consoleWarnFixed(this.object.pp_getRotation());
        this.object.pp_setRotationDegrees([21, 54, 123]);
        this.consoleWarnFixed(this.object.pp_getRotationDegrees());
        this.object.pp_setRotationRadians([-2.9116, -1.1416, 1.7416]);
        this.consoleWarnFixed(this.object.pp_getRotationRadians());
        this.object.pp_setRotationMatrix([-0.0707, 0.4101, 0.9093, 0.9243, 0.3698, -0.0949, -0.3751, 0.8337, -0.4052]);
        this.consoleWarnMatrix3Fixed(this.object.pp_getRotationMatrix());
        this.object.pp_setRotationQuat([0, 0, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getRotationQuat());

        console.warn("\nROTATION WORLD\n");
        this.object.pp_setRotationWorld([-20, 50, 120]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_setRotationWorldDegrees([-20, -37, 12]);
        this.consoleWarnFixed(this.object.pp_getRotationWorldDegrees());
        this.object.pp_setRotationWorldRadians([-2.9116, -1.1416, 1.7416]);
        this.consoleWarnFixed(this.object.pp_getRotationWorldRadians());
        this.object.pp_setRotationWorldMatrix([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        this.consoleWarnMatrix3Fixed(this.object.pp_getRotationWorldMatrix());
        this.object.pp_setRotationWorldQuat([0.4911, 0.6793, 0.2719, -0.4727]);
        this.consoleWarnFixed(this.object.pp_getRotationWorldQuat());

        console.warn("\nROTATION LOCAL\n");
        this.object.pp_setRotationLocal([22, 45, 163]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_setRotationLocalDegrees([22, -45, 163]);
        this.consoleWarnFixed(this.object.pp_getRotationLocalDegrees());
        this.object.pp_setRotationLocalRadians([-2.9116, -1.1416, 1.7416]);
        this.consoleWarnFixed(this.object.pp_getRotationLocalRadians());
        this.object.pp_setRotationLocalMatrix([-0.0707, 0.4101, 0.9093, 0.9243, 0.3698, -0.0949, -0.3751, 0.8337, -0.4052]);
        this.consoleWarnMatrix3Fixed(this.object.pp_getRotationLocalMatrix());
        this.object.pp_setRotationLocalQuat([0.4911, 0.6793, 0.2719, -0.4727]);
        this.consoleWarnFixed(this.object.pp_getRotationLocalQuat());

        console.warn("\nSCALE\n");
        this.object.pp_setScale([2, 5, 4]);
        this.consoleWarnFixed(this.object.pp_getScale());
        this.object.pp_setScale(6.32);
        this.consoleWarnFixed(this.object.pp_getScale());
        this.object.pp_setScaleWorld([3.2, 1.65, 4.4]);
        this.consoleWarnFixed(this.object.pp_getScaleWorld());
        this.object.pp_setScaleWorld(5);
        this.consoleWarnFixed(this.object.pp_getScaleWorld());
        this.object.pp_setScaleLocal([5.2, 3.1, 9.1]);
        this.consoleWarnFixed(this.object.pp_getScaleLocal());
        this.object.pp_setScaleLocal(1.3);
        this.consoleWarnFixed(this.object.pp_getScaleLocal());

        console.warn("\nTRANSFORM\n");
        this.object.pp_setTransformMatrix([1, 0, 0, 0, 0, 2.4, 0, 0, 0, 0, 3.2, 0, 4, 2, 3, 1]);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransform());
        this.object.pp_setTransformMatrix([3, 0, 0, 0, 0, 2.4, 0, 0, 0, 0, 1.2, 0, 1, 2, 3, 1]);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformMatrix());
        this.object.pp_setTransformQuat([0.5354, 0.5714, 0.1685, -0.5986, 5.3222, -4.4403, 6.6770, 2.4017]);
        this.consoleWarnFixed(this.object.pp_getTransformQuat());

        console.warn("\nTRANSFORM WORLD\n");
        this.object.pp_setTransformMatrix([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorld());
        this.object.pp_setTransformWorldMatrix([-0.2458, 1.3998, 1.4071, 0.0000, 2.7900, 3.1750, -2.6712, 0.0000, -2.4621, 0.9808, -1.4058, 0.0000, 0.1834, -2.7853, -19.6426, 1.0000]);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorldMatrix());
        this.object.pp_setTransformWorldMatrix([-0.1229, 0.6999, 0.7036, 0.0000, 0.5580, 0.6350, -0.5342, 0.0000, -0.8207, 0.3270, -0.4686, 0.0000, 0.1834, -2.7853, -19.6426, 1.0000]);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorldMatrix());
        this.object.pp_setTransformWorldQuat([0.5354, 0.5714, 0.1685, -0.5986, 5.3222, -4.4403, 6.6770, 2.4017]);
        this.consoleWarnFixed(this.object.pp_getTransformWorldQuat());

        console.warn("\nTRANSFORM LOCAL\n");
        this.object.pp_setTransformLocal([-0.2458, 1.3998, 1.4071, 0.0000, 2.7900, 3.1750, -2.6712, 0.0000, -2.4621, 0.9808, -1.4058, 0.0000, 0.1834, -2.7853, -19.6426, 1.0000]);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformLocal());
        this.object.pp_setTransformLocalMatrix([0.9706, 4.1994, 4.1739, 0.0000, 1.5245, 3.1750, -3.5490, 0.0000, -5.6314, 1.9616, -0.6641, 0.0000, -13.8437, -2.7853, -36.3777, 1.0000]);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformLocalMatrix());
        this.object.pp_setTransformLocalQuat([-0.4215, -0.7461, 0.0695, 0.5108, -7.3773, 3.4221, -5.6718, -0.3181]);
        this.consoleWarnFixed(this.object.pp_getTransformLocalQuat());

        console.warn("\nFORWARD\n");
        this.consoleWarnFixed(this.object.pp_getForward());
        this.consoleWarnFixed(this.object.pp_getForwardWorld());
        this.consoleWarnFixed(this.object.pp_getForwardLocal());

        console.warn("\nBACKWARD\n");
        this.consoleWarnFixed(this.object.pp_getBackward());
        this.consoleWarnFixed(this.object.pp_getBackwardWorld());
        this.consoleWarnFixed(this.object.pp_getBackwardLocal());

        console.warn("\nUP\n");
        this.consoleWarnFixed(this.object.pp_getUp());
        this.consoleWarnFixed(this.object.pp_getUpWorld());
        this.consoleWarnFixed(this.object.pp_getUpLocal());

        console.warn("\nDOWN\n");
        this.consoleWarnFixed(this.object.pp_getDown());
        this.consoleWarnFixed(this.object.pp_getDownWorld());
        this.consoleWarnFixed(this.object.pp_getDownLocal());

        console.warn("\nLEFT\n");
        this.consoleWarnFixed(this.object.pp_getLeft());
        this.consoleWarnFixed(this.object.pp_getLeftWorld());
        this.consoleWarnFixed(this.object.pp_getLeftLocal());

        console.warn("\nRIGHT\n");
        this.consoleWarnFixed(this.object.pp_getRight());
        this.consoleWarnFixed(this.object.pp_getRightWorld());
        this.consoleWarnFixed(this.object.pp_getRightLocal());

        this.object.pp_getParent().pp_setTransformMatrix(initParentTransform);
        this.object.pp_setTransformMatrix(initTransform);

        console.warn("\nLOOK AT\n");
        this.object.pp_lookAt([0.7071, 0.7071, 0]);
        this.object.pp_lookAtWorld([0.7071, 0.7071, 0]);
        this.object.pp_lookAtLocal([0.7071, 0.7071, 0]);

        console.warn("\nLOOK TO\n");
        this.consoleWarnFixed(this.object.pp_getPosition());
        this.object.pp_lookTo([0.7071, 0.7071, 0]);
        this.consoleWarnFixed(this.object.pp_getForward());
        this.object.pp_lookTo([0.4472, -0.8944, 0]);
        this.consoleWarnFixed(this.object.pp_getForward());
        this.object.pp_lookTo([0, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getRight());
        this.consoleWarnFixed(this.object.pp_getUp());
        this.consoleWarnFixed(this.object.pp_getForward());
        this.object.pp_lookTo([0, 0, 1], [0, 1, 0]);
        this.consoleWarnFixed(this.object.pp_getRight());
        this.consoleWarnFixed(this.object.pp_getUp());
        this.consoleWarnFixed(this.object.pp_getForward());
        this.object.pp_lookTo([0, 1, 0]);
        this.consoleWarnFixed(this.object.pp_getRight());
        this.consoleWarnFixed(this.object.pp_getUp());
        this.consoleWarnFixed(this.object.pp_getForward());

        console.warn("\nLOOK TO WORLD\n");
        this.object.pp_lookToWorld([0, 0, 1], [0, 1, 0]);
        this.object.pp_lookToWorld([0, -1, 0]);
        this.consoleWarnFixed(this.object.pp_getRight());
        this.consoleWarnFixed(this.object.pp_getUp());
        this.consoleWarnFixed(this.object.pp_getForward());
        this.object.pp_lookToWorld([0, 0, 1], [0, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getRight());
        this.consoleWarnFixed(this.object.pp_getUp());
        this.consoleWarnFixed(this.object.pp_getForward());
        this.object.pp_lookToWorld([1, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getRight());
        this.consoleWarnFixed(this.object.pp_getUp());
        this.consoleWarnFixed(this.object.pp_getForward());
        this.object.pp_lookToWorld([0, 0, 1], [0, 1, 0]);
        this.object.pp_lookToWorld([1, -1, 1]);
        this.consoleWarnFixed(this.object.pp_getRight());
        this.consoleWarnFixed(this.object.pp_getUp());
        this.consoleWarnFixed(this.object.pp_getForward());
        this.object.pp_lookToWorld([0, 0, 1], [0, 1, 0]);
        this.object.pp_lookToWorld([2, -1, 3], [2, 1, 4]);
        this.consoleWarnFixed(this.object.pp_getRight());
        this.consoleWarnFixed(this.object.pp_getUp());
        this.consoleWarnFixed(this.object.pp_getForward());
        this.consoleWarnFixed(this.object.pp_getPosition());

        console.warn("\nLOOK TO LOCAL\n");
        this.object.pp_lookToLocal([0, 0, 1], [0, 1, 0]);
        this.object.pp_lookToLocal([0, -1, 0]);
        this.consoleWarnFixed(this.object.pp_getRightLocal());
        this.consoleWarnFixed(this.object.pp_getUpLocal());
        this.consoleWarnFixed(this.object.pp_getForwardLocal());
        this.object.pp_lookToLocal([0, 0, 1], [0, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getRightLocal());
        this.consoleWarnFixed(this.object.pp_getUpLocal());
        this.consoleWarnFixed(this.object.pp_getForwardLocal());
        this.object.pp_lookToLocal([1, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getRightLocal());
        this.consoleWarnFixed(this.object.pp_getUpLocal());
        this.consoleWarnFixed(this.object.pp_getForwardLocal());
        this.object.pp_lookToLocal([0, 0, 1], [0, 1, 0]);
        this.object.pp_lookToLocal([1, -1, 1]);
        this.consoleWarnFixed(this.object.pp_getRightLocal());
        this.consoleWarnFixed(this.object.pp_getUpLocal());
        this.consoleWarnFixed(this.object.pp_getForwardLocal());
        this.object.pp_lookToLocal([0, 0, 1], [0, 1, 0]);
        this.object.pp_lookToLocal([2, -1, 3], [2, 1, 4]);
        this.consoleWarnFixed(this.object.pp_getRightLocal());
        this.consoleWarnFixed(this.object.pp_getUpLocal());
        this.consoleWarnFixed(this.object.pp_getForwardLocal());
        this.consoleWarnFixed(this.object.pp_getPosition());

        this.object.pp_getParent().pp_setTransformMatrix(initParentTransform);
        this.object.pp_setTransformMatrix(initTransform);

        console.warn("\nPARENT\n");
        this.object.pp_setPosition([1, 2, 3]);
        let oldParent = this.object.pp_getParent();
        let nullParent = null;
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorld());
        this.object.pp_setParent(nullParent);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorld());
        this.object.pp_setParent(oldParent);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorld());
        this.object.pp_setParent(nullParent, false);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorld());
        this.object.pp_setParent(oldParent, false);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorld());
        this.object.pp_setParent(nullParent, false);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorld());
        this.object.pp_setParent(oldParent);
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorld());

        console.warn("\nRESET POSITION\n");
        this.object.pp_resetPosition();
        this.consoleWarnFixed(this.object.pp_getPosition());
        this.object.pp_resetPositionWorld();
        this.consoleWarnFixed(this.object.pp_getPositionWorld());
        this.consoleWarnFixed(this.object.pp_getPositionLocal());
        this.object.pp_resetPositionLocal();
        this.consoleWarnFixed(this.object.pp_getPositionWorld());
        this.consoleWarnFixed(this.object.pp_getPositionLocal());

        console.warn("\nRESET ROTATION\n");
        this.object.pp_resetRotation();
        this.consoleWarnFixed(this.object.pp_getRotation());
        this.object.pp_resetRotationWorld();
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_resetRotationLocal();
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.consoleWarnFixed(this.object.pp_getRotationLocal());

        console.warn("\nRESET SCALE\n");
        this.object.pp_resetScale();
        this.consoleWarnFixed(this.object.pp_getScale());
        this.object.pp_resetScaleWorld();
        this.consoleWarnFixed(this.object.pp_getScaleWorld());
        this.consoleWarnFixed(this.object.pp_getScaleLocal());
        this.object.pp_resetScaleLocal();
        this.consoleWarnFixed(this.object.pp_getScaleWorld());
        this.consoleWarnFixed(this.object.pp_getScaleLocal());

        console.warn("\nRESET TRANSFORM\n");
        this.object.pp_setTransformWorldMatrix([0.9706, 4.1994, 4.1739, 0.0000, 1.5245, 3.1750, -3.5490, 0.0000, -5.6314, 1.9616, -0.6641, 0.0000, -13.8437, -2.7853, -36.3777, 1.0000]);
        this.object.pp_resetTransform();
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransform());
        this.object.pp_resetTransformWorld();
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorld());
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformLocal());
        this.object.pp_resetTransformLocal();
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorld());
        this.consoleWarnMatrix4Fixed(this.object.pp_getTransformLocal());

        console.warn("\nTRANSLATE\n");
        this.object.pp_resetPositionWorld();
        this.object.pp_translate([0, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getPosition());
        this.object.pp_translate([0, 1, 0]);
        this.consoleWarnFixed(this.object.pp_getPosition());
        this.object.pp_translate([1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getPosition());

        this.object.pp_resetPositionLocal();
        this.object.pp_translateLocal([0, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getPositionLocal());
        this.object.pp_translateLocal([0, 1, 0]);
        this.consoleWarnFixed(this.object.pp_getPositionLocal());
        this.object.pp_translateLocal([1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getPositionLocal());

        this.object.pp_resetPositionLocal();
        this.object.pp_lookTo(this.object.pp_getParent().pp_getUp());
        this.object.pp_translateObject([0, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getPositionLocal());
        this.object.pp_translateObject([0, 1, 0]);
        this.consoleWarnFixed(this.object.pp_getPositionLocal());
        this.object.pp_translateObject([1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getPositionLocal());

        this.object.pp_getParent().pp_setTransformMatrix(initParentTransform);
        this.object.pp_setTransformMatrix(initTransform);

        console.warn("\nTRANSLATE AXIS\n");
        let translateAxis = [23, 3, -12];
        let normalizedTranslateAxis = [];
        glMatrix.vec3.normalize(normalizedTranslateAxis, translateAxis);
        let length = glMatrix.vec3.length(translateAxis);
        this.object.pp_resetPosition();
        this.object.pp_translate(translateAxis);
        this.consoleWarnFixed(this.object.pp_getPosition());
        this.object.pp_resetPosition();
        this.object.pp_translateAxis(normalizedTranslateAxis, length);
        this.consoleWarnFixed(this.object.pp_getPosition());

        this.object.pp_resetPositionWorld();
        this.object.pp_translateWorld(translateAxis);
        this.consoleWarnFixed(this.object.pp_getPositionWorld());
        this.object.pp_resetPositionWorld();
        this.object.pp_translateAxisWorld(normalizedTranslateAxis, length);
        this.consoleWarnFixed(this.object.pp_getPositionWorld());

        this.object.pp_resetPositionLocal();
        this.object.pp_translateLocal(translateAxis);
        this.consoleWarnFixed(this.object.pp_getPositionLocal());
        this.object.pp_resetPositionLocal();
        this.object.pp_translateAxisLocal(normalizedTranslateAxis, length);
        this.consoleWarnFixed(this.object.pp_getPositionLocal());

        this.object.pp_resetPositionWorld();
        this.object.pp_resetRotationWorld();
        this.object.pp_translateObject(translateAxis);
        this.consoleWarnFixed(this.object.pp_getPositionWorld());
        this.object.pp_resetPositionWorld();
        this.object.pp_resetRotationWorld();
        this.object.pp_translateAxisObject(normalizedTranslateAxis, length);
        this.consoleWarnFixed(this.object.pp_getPositionWorld());

        this.object.pp_resetPositionLocal();
        this.object.pp_resetRotationLocal();
        this.object.pp_translateObject(translateAxis);
        this.consoleWarnFixed(this.object.pp_getPositionLocal());
        this.object.pp_resetPositionLocal();
        this.object.pp_resetRotationLocal();
        this.object.pp_translateAxisObject(normalizedTranslateAxis, length);
        this.consoleWarnFixed(this.object.pp_getPositionLocal());

        console.warn("\nROTATE\n");
        this.object.pp_resetRotation();
        this.object.pp_rotate([20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotation());
        this.object.pp_resetRotation();
        this.object.pp_rotateDegrees([0, 30, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationDegrees());
        this.object.pp_resetRotation();
        this.object.pp_rotateRadians([0, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getRotationRadians());
        this.object.pp_resetRotation();
        this.object.pp_rotateMatrix([0.5403, 0.8415, -0.0000, -0.8415, 0.5403, -0.0000, -0.0000, 0.0000, 1.0000]);
        this.consoleWarnMatrix3Fixed(this.object.pp_getRotationMatrix());
        this.object.pp_resetRotation();
        this.object.pp_rotateQuat([-0.4215, -0.7461, 0.0695, 0.5108]);
        this.consoleWarnFixed(this.object.pp_getRotationQuat());

        console.warn("\nROTATE WORLD\n");
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateWorld([20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateWorldDegrees([0, 30, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorldDegrees());
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateWorldRadians([0, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getRotationWorldRadians());
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateWorldMatrix([0.5403, 0.8415, -0.0000, -0.8415, 0.5403, -0.0000, -0.0000, 0.0000, 1.0000]);
        this.consoleWarnMatrix3Fixed(this.object.pp_getRotationWorldMatrix());
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateWorldQuat([-0.4215, -0.7461, 0.0695, 0.5108]);
        this.consoleWarnFixed(this.object.pp_getRotationWorldQuat());

        console.warn("\nROTATE LOCAL\n");
        this.object.pp_resetRotationLocal();
        this.object.pp_rotateLocal([20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_resetRotationLocal();
        this.object.pp_rotateLocalDegrees([0, 30, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocalDegrees());
        this.object.pp_resetRotationLocal();
        this.object.pp_rotateLocalRadians([0, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getRotationLocalRadians());
        this.object.pp_resetRotationLocal();
        this.object.pp_rotateLocalMatrix([0.5403, 0.8415, -0.0000, -0.8415, 0.5403, -0.0000, -0.0000, 0.0000, 1.0000]);
        this.consoleWarnMatrix3Fixed(this.object.pp_getRotationLocalMatrix());
        this.object.pp_resetRotationLocal();
        this.object.pp_rotateLocalQuat([-0.4215, -0.7461, 0.0695, 0.5108]);
        this.consoleWarnFixed(this.object.pp_getRotationLocalQuat());

        console.warn("\nROTATE OBJECT\n");
        this.object.pp_resetRotationLocal();
        this.object.pp_rotateObject([20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_resetRotationLocal();
        this.object.pp_rotateObjectDegrees([0, 30, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocalDegrees());
        this.object.pp_resetRotationLocal();
        this.object.pp_rotateObjectRadians([0, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getRotationLocalRadians());
        this.object.pp_resetRotationLocal();
        this.object.pp_rotateObjectMatrix([0.5403, 0.8415, -0.0000, -0.8415, 0.5403, -0.0000, -0.0000, 0.0000, 1.0000]);
        this.consoleWarnMatrix3Fixed(this.object.pp_getRotationLocalMatrix());
        this.object.pp_resetRotationLocal();
        this.object.pp_rotateObjectQuat([-0.4215, -0.7461, 0.0695, 0.5108]);
        this.consoleWarnFixed(this.object.pp_getRotationLocalQuat());

        this.object.pp_resetRotationWorld();
        this.object.pp_rotateObject([20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateObjectDegrees([0, 30, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorldDegrees());
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateObjectRadians([0, 0, 1]);
        this.consoleWarnFixed(this.object.pp_getRotationWorldRadians());
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateObjectMatrix([0.5403, 0.8415, -0.0000, -0.8415, 0.5403, -0.0000, -0.0000, 0.0000, 1.0000]);
        this.consoleWarnMatrix3Fixed(this.object.pp_getRotationWorldMatrix());
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateObjectQuat([-0.4215, -0.7461, 0.0695, 0.5108]);
        this.consoleWarnFixed(this.object.pp_getRotationWorldQuat());

        console.warn("\nROTATE AXIS\n");
        this.object.pp_resetRotation();
        this.object.pp_rotateObject([20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotation());
        this.object.pp_rotateAxis(20, [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotation());
        this.object.pp_rotateAxisDegrees(10, [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotation());
        this.object.pp_rotateAxisRadians(Math.pp_toRadians(10), [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotation());

        console.warn("\nROTATE WORLD AXIS\n");
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateWorld([-20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_rotateAxisWorld(-20, [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_rotateAxisWorldDegrees(10, [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_rotateAxisWorldRadians(Math.pp_toRadians(10), [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());

        console.warn("\nROTATE LOCAL AXIS\n");
        this.object.pp_resetRotationLocal();
        this.object.pp_rotateLocal([-20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_rotateAxisLocal(-20, [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_rotateAxisLocalDegrees(10, [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_rotateAxisLocalRadians(Math.pp_toRadians(10), [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());

        console.warn("\nROTATE OBJECT AXIS\n");
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateWorld([-20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_rotateAxisObject(-20, [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_rotateAxisObjectDegrees(10, [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_rotateAxisObjectRadians(Math.pp_toRadians(10), [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());

        this.object.pp_resetRotationLocal();
        this.object.pp_rotateLocal([-20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_rotateAxisObject(-20, [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_rotateAxisObjectDegrees(10, [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_rotateAxisObjectRadians(Math.pp_toRadians(10), [1, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());

        console.warn("\nROTATE AROUND\n");
        this.object.pp_rotateAround([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundDegrees([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundRadians([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundMatrix([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundQuat([-20, 0, 0], [1, 2, 3]);

        this.object.pp_rotateAroundWorldDegrees([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundWorldRadians([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundWorldMatrix([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundWorldQuat([-20, 0, 0], [1, 2, 3]);

        this.object.pp_rotateAroundLocalDegrees([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundLocalRadians([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundLocalMatrix([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundLocalQuat([-20, 0, 0], [1, 2, 3]);

        this.object.pp_rotateAroundObjectDegrees([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundObjectRadians([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundObjectMatrix([-20, 0, 0], [1, 2, 3]);
        this.object.pp_rotateAroundObjectQuat([-20, 0, 0], [1, 2, 3]);

        console.warn("\nROTATE AROUND AXIS\n");
        this.object.pp_resetRotation();
        this.object.pp_rotateObject([20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotation());
        this.object.pp_rotateAroundAxis(20, [1, 0, 0], this.object.pp_getPosition());
        this.consoleWarnFixed(this.object.pp_getRotation());
        this.object.pp_rotateAroundAxisDegrees(10, [1, 0, 0], this.object.pp_getPosition());
        this.consoleWarnFixed(this.object.pp_getRotation());
        this.object.pp_rotateAroundAxisRadians(Math.pp_toRadians(10), [1, 0, 0], this.object.pp_getParent().pp_getPosition());
        this.consoleWarnFixed(this.object.pp_getRotation());

        console.warn("\nROTATE WORLD AROUND AXIS\n");
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateWorld([-20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_rotateAroundAxisWorld(-20, [1, 0, 0], this.object.pp_getParent().pp_getPosition());
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_rotateAroundAxisWorldDegrees(10, [1, 0, 0], this.object.pp_getParent().pp_getPosition());
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_rotateAroundAxisWorldRadians(Math.pp_toRadians(10), [1, 0, 0], this.object.pp_getParent().pp_getPosition());
        this.consoleWarnFixed(this.object.pp_getRotationWorld());

        console.warn("\nROTATE LOCAL AROUND AXIS\n");
        this.object.pp_resetRotationLocal();
        this.object.pp_rotateLocal([-20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_rotateAroundAxisLocal(-20, [1, 0, 0], this.object.pp_getPositionLocal());
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_rotateAroundAxisLocalDegrees(10, [1, 0, 0], this.object.pp_getPositionLocal());
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_rotateAroundAxisLocalRadians(Math.pp_toRadians(10), [1, 0, 0], [0, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());

        console.warn("\nROTATE OBJECT AROUND AXIS\n");
        this.object.pp_resetRotationWorld();
        this.object.pp_rotateWorld([-20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_rotateAroundAxisObject(-20, [1, 0, 0], -20, [0, 1, 2]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_rotateAroundAxisObjectDegrees(10, [1, 0, 0], [0, 1, 2]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());
        this.object.pp_rotateAroundAxisObjectRadians(Math.pp_toRadians(10), [1, 0, 0], [0, 1, 2]);
        this.consoleWarnFixed(this.object.pp_getRotationWorld());

        this.object.pp_resetRotationLocal();
        this.object.pp_rotateLocal([-20, 0, 0]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_rotateAroundAxisObject(-20, [1, 0, 0], [0, 1, 2]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_rotateAroundAxisObjectDegrees(10, [1, 0, 0], [0, 1, 2]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());
        this.object.pp_rotateAroundAxisObjectRadians(Math.pp_toRadians(10), [1, 0, 0], [0, 1, 2]);
        this.consoleWarnFixed(this.object.pp_getRotationLocal());

        console.warn("\nSCALE OBJECT\n");
        this.object.pp_resetScaleWorld();
        this.object.pp_scaleObject([4, 2, 3]);
        this.consoleWarnFixed(this.object.pp_getScaleWorld());
        this.object.pp_scaleObject(3);
        this.consoleWarnFixed(this.object.pp_getScaleWorld());

        this.object.pp_resetScaleLocal();
        this.object.pp_scaleObject([4, 2, 3]);
        this.consoleWarnFixed(this.object.pp_getScaleLocal());
        this.object.pp_scaleObject(3);
        this.consoleWarnFixed(this.object.pp_getScaleLocal());

        //Reset Transform To Init
        this.object.pp_getParent().pp_setTransformMatrix(initParentTransform);
        this.object.pp_setTransformMatrix(initTransform);

        console.warn("\nCONVERT POSITION OBJECT WORLD\n");
        this.consoleWarnFixed(this.object.pp_getPositionWorld());
        this.consoleWarnFixed(this.object.pp_convertPositionObjectToWorld([0, 0, 0]));
        this.consoleWarnFixed(this.object.pp_convertPositionObjectToWorld([0, 1, 0]));
        this.consoleWarnFixed(this.object.pp_convertPositionWorldToObject([1.7023, 3.2364, 1.8554]));
        this.consoleWarnFixed(this.object.pp_convertPositionWorldToObject(this.object.pp_convertPositionObjectToWorld([0, 1, 0])));

        console.warn("\nCONVERT POSITION LOCAL WORLD\n");
        this.consoleWarnFixed(this.object.pp_getParent().pp_getPositionWorld());
        this.consoleWarnFixed(this.object.pp_convertPositionLocalToWorld([0, 0, 0]));
        this.consoleWarnFixed(this.object.pp_convertPositionLocalToWorld([2, 1, 0]));
        this.consoleWarnFixed(this.object.pp_convertPositionWorldToLocal([6.6682, 0.486, -2.153]));
        this.consoleWarnFixed(this.object.pp_convertPositionWorldToLocal(this.object.pp_convertPositionLocalToWorld([0, 1, 2])));

        console.warn("\nCONVERT POSITION LOCAL OBJECT\n");
        this.consoleWarnFixed(this.object.pp_getPositionLocal());
        this.consoleWarnFixed(this.object.pp_convertPositionObjectToLocal([0, 0, 0]));
        this.consoleWarnFixed(this.object.pp_convertPositionObjectToLocal([0, 2, 3]));
        this.consoleWarnFixed(this.object.pp_convertPositionLocalToObject([0.0114, 1.839, 3.605]));
        this.consoleWarnFixed(this.object.pp_convertPositionLocalToObject(this.object.pp_convertPositionObjectToLocal([1, 3, -20])));

        console.warn("\nCONVERT POSITION CHAIN\n");
        this.consoleWarnFixed(this.object.pp_convertPositionObjectToWorld(this.object.pp_convertPositionLocalToObject(this.object.pp_convertPositionWorldToLocal([1, 3, -20]))));
        this.consoleWarnFixed(this.object.pp_convertPositionWorldToObject(this.object.pp_convertPositionLocalToWorld(this.object.pp_convertPositionObjectToLocal([1, 3, -20]))));

        let tempDirection = [];
        console.warn("\nCONVERT DIRECTION OBJECT WORLD\n");
        glMatrix.vec3.add(tempDirection, this.object.pp_getForwardWorld(), this.object.pp_getRightWorld());
        this.consoleWarnFixed(this.object.pp_getForwardWorld());
        this.consoleWarnFixed(tempDirection);
        this.consoleWarnFixed(this.object.pp_convertDirectionObjectToWorld([0, 0, 1]));
        this.consoleWarnFixed(this.object.pp_convertDirectionObjectToWorld([0, 0, 2]));
        this.consoleWarnFixed(this.object.pp_convertDirectionObjectToWorld([0, 0, 3]));
        this.consoleWarnFixed(this.object.pp_convertDirectionObjectToWorld([-1, 0, 1]));
        this.consoleWarnFixed(this.object.pp_convertDirectionWorldToObject([0.3132, -0.7492, 0.5836]));
        this.consoleWarnFixed(this.object.pp_convertDirectionWorldToObject([0.9395, -2.2477, 1.7508]));
        this.consoleWarnFixed(this.object.pp_convertDirectionWorldToObject(this.object.pp_getForwardWorld()));
        this.consoleWarnFixed(this.object.pp_convertDirectionWorldToObject(this.object.pp_convertDirectionObjectToWorld([1, 2, 0])));

        console.warn("\nCONVERT DIRECTION LOCAL WORLD\n");
        glMatrix.vec3.add(tempDirection, this.object.pp_getParent().pp_getForwardWorld(), this.object.pp_getParent().pp_getRightWorld());
        this.consoleWarnFixed(this.object.pp_getParent().pp_getForwardWorld());
        this.consoleWarnFixed(tempDirection);
        this.consoleWarnFixed(this.object.pp_convertDirectionLocalToWorld([0, 0, 1]));
        this.consoleWarnFixed(this.object.pp_convertDirectionLocalToWorld([0, 0, 2]));
        this.consoleWarnFixed(this.object.pp_convertDirectionLocalToWorld([0, 0, 3]));
        this.consoleWarnFixed(this.object.pp_convertDirectionLocalToWorld([-1, 0, 1]));
        this.consoleWarnFixed(this.object.pp_convertDirectionWorldToLocal([0.3626, -0.2404, 0.9004]));
        this.consoleWarnFixed(this.object.pp_convertDirectionWorldToLocal([1.0878, -0.7213, 2.7012]));
        this.consoleWarnFixed(this.object.pp_convertDirectionWorldToLocal(this.object.pp_getParent().pp_getForwardWorld()));
        this.consoleWarnFixed(this.object.pp_convertDirectionWorldToLocal(this.object.pp_convertDirectionLocalToWorld([1, 2, 0])));

        console.warn("\nCONVERT DIRECTION OBJECT LOCAL\n");
        glMatrix.vec3.add(tempDirection, this.object.pp_getForwardLocal(), this.object.pp_getRightLocal());
        this.consoleWarnFixed(this.object.pp_getForwardLocal());
        this.consoleWarnFixed(tempDirection);
        this.consoleWarnFixed(this.object.pp_convertDirectionObjectToLocal([0, 0, 1]));
        this.consoleWarnFixed(this.object.pp_convertDirectionObjectToLocal([0, 0, 2]));
        this.consoleWarnFixed(this.object.pp_convertDirectionObjectToLocal([0, 0, 3]));
        this.consoleWarnFixed(this.object.pp_convertDirectionObjectToLocal([-1, 0, 1]));
        this.consoleWarnFixed(this.object.pp_convertDirectionLocalToObject([0.1193, -0.5610, 0.8192]));
        this.consoleWarnFixed(this.object.pp_convertDirectionLocalToObject([0.3578, -1.6831, 2.4575]));
        this.consoleWarnFixed(this.object.pp_convertDirectionLocalToObject(this.object.pp_getForwardLocal()));
        this.consoleWarnFixed(this.object.pp_convertDirectionLocalToObject(this.object.pp_convertDirectionObjectToLocal([1, 2, 0])));

        console.warn("\nCONVERT DIRECTION CHAIN\n");
        this.consoleWarnFixed(this.object.pp_convertDirectionObjectToWorld(this.object.pp_convertDirectionLocalToObject(this.object.pp_convertDirectionWorldToLocal([1, 3, -20]))));
        this.consoleWarnFixed(this.object.pp_convertDirectionWorldToObject(this.object.pp_convertDirectionLocalToWorld(this.object.pp_convertDirectionObjectToLocal([1, 3, -20]))));

        {
            this.object.pp_getParent().pp_setTransformMatrix(initParentTransform);
            this.object.pp_setTransformMatrix(initTransform);
            //this.object.parent.scalingWorld = [1, 1, 1];
            //this.object.scalingWorld = [1, 1, 1];
            this.object.setDirty();
            this.object.pp_getParent().setDirty();
            let defaultMatrix = glMatrix.mat4.create();
            let defaultQuat2 = glMatrix.quat2.create();

            let child = WL.scene.addObject(this.object);
            child.pp_setRotation([20, 30, -10]);
            child.pp_setPosition([2, 0, -7]);
            child.pp_setScale([4, 3, 2]);
            child.pp_markDirty();

            console.warn("\nCONVERT TRANSFORM OBJECT WORLD\n");
            this.consoleWarnMatrix4Fixed(child.pp_getTransformWorldMatrix());
            this.consoleWarnMatrix4Fixed(child.pp_getTransformWorldQuat());
            this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorldMatrix());
            this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorldQuat());

            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToWorld(child.pp_getTransformLocalMatrix()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToWorldQuat(child.pp_getTransformLocalQuat()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToWorldMatrix(defaultMatrix));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToWorldQuat(defaultQuat2));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToObject(this.object.pp_getTransformWorldMatrix()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToObjectMatrix(this.object.pp_getTransformWorldMatrix()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToObjectQuat(this.object.pp_getTransformWorldQuat()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToObjectMatrix(this.object.pp_convertTransformObjectToWorldMatrix(defaultMatrix)));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToObjectQuat(this.object.pp_convertTransformObjectToWorldQuat(defaultQuat2)));

            console.warn("\nCONVERT TRANSFORM LOCAL WORLD\n");
            this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorldMatrix());
            this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorldQuat());
            this.consoleWarnMatrix4Fixed(this.object.pp_getTransformLocalMatrix());
            this.consoleWarnMatrix4Fixed(this.object.pp_getTransformLocalQuat());

            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformLocalToWorld(this.object.pp_getTransformLocalMatrix()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformLocalToWorldMatrix(this.object.pp_getTransformLocalMatrix()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformLocalToWorldQuat(this.object.pp_getTransformLocalQuat()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToLocal(this.object.pp_getTransformWorldMatrix()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToLocalMatrix(this.object.pp_getTransformWorldMatrix()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToLocalQuat(this.object.pp_getTransformWorldQuat()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToLocalMatrix(this.object.pp_convertTransformLocalToWorldMatrix(this.object.pp_getTransformLocalMatrix())));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToLocalQuat(this.object.pp_convertTransformLocalToWorldQuat(this.object.pp_getTransformLocalQuat())));

            console.warn("\nCONVERT TRANSFORM LOCAL OBJECT\n");
            this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorldMatrix());
            this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorldQuat());
            this.consoleWarnMatrix4Fixed(this.object.pp_getTransformLocalMatrix());
            this.consoleWarnMatrix4Fixed(this.object.pp_getTransformLocalQuat());

            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToLocal(defaultMatrix));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToLocalMatrix(defaultMatrix));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToLocalQuat(defaultQuat2));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformLocalToObject(this.object.pp_getTransformLocalMatrix()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformLocalToObjectMatrix(this.object.pp_getTransformLocalMatrix()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformLocalToObjectQuat(this.object.pp_getTransformLocalQuat()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformLocalToObjectMatrix(this.object.pp_convertTransformObjectToLocalMatrix(defaultMatrix)));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformLocalToObjectQuat(this.object.pp_convertTransformObjectToLocalQuat(defaultQuat2)));

            console.warn("\nCONVERT TRANSFORM CHAIN\n");
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToWorld(this.object.pp_convertTransformLocalToObject(this.object.pp_convertTransformWorldToLocal(defaultMatrix))));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToObject(this.object.pp_convertTransformLocalToWorld(this.object.pp_convertTransformObjectToLocal(defaultMatrix))));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToWorldMatrix(this.object.pp_convertTransformLocalToObjectMatrix(this.object.pp_convertTransformWorldToLocalMatrix(this.object.pp_getTransformWorldMatrix()))));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToObjectMatrix(this.object.pp_convertTransformLocalToWorldMatrix(this.object.pp_convertTransformObjectToLocalMatrix(this.object.pp_getTransformWorldMatrix()))));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToWorldQuat(this.object.pp_convertTransformLocalToObjectQuat(this.object.pp_convertTransformWorldToLocalQuat(defaultQuat2))));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToObjectQuat(this.object.pp_convertTransformLocalToWorldQuat(this.object.pp_convertTransformObjectToLocalQuat(defaultQuat2))));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToWorldQuat(this.object.pp_convertTransformLocalToObjectQuat(this.object.pp_convertTransformWorldToLocalQuat(this.object.pp_getTransformWorldQuat()))));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToObjectQuat(this.object.pp_convertTransformLocalToWorldQuat(this.object.pp_convertTransformObjectToLocalQuat(this.object.pp_getTransformWorldQuat()))));

            console.warn("\nCONVERT TRANSFORM OBJECT WORLD UNIFORM\n");
            this.object.pp_setScale([3, 3, 3]);
            child.pp_setScale([2, 2, 2]);

            this.consoleWarnMatrix4Fixed(child.pp_getTransformWorldMatrix());
            this.consoleWarnMatrix4Fixed(this.object.pp_getTransformWorldMatrix());

            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToWorld(child.pp_getTransformLocalMatrix()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformObjectToWorldMatrix(defaultMatrix));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToObject(this.object.pp_getTransformWorldMatrix()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToObjectMatrix(this.object.pp_getTransformWorldMatrix()));
            this.consoleWarnMatrix4Fixed(this.object.pp_convertTransformWorldToObjectMatrix(this.object.pp_convertTransformObjectToWorldMatrix(defaultMatrix)));
        }

        console.warn("\nUNIFORM SCALE\n");
        this.object.pp_setScale([2, 2, 2]);
        console.warn(this.object.pp_hasUniformScale());
        this.object.pp_setScale([2, 2, 1]);
        console.warn(this.object.pp_hasUniformScale());
        this.object.pp_setScaleWorld([3, 2, 2]);
        console.warn(this.object.pp_hasUniformScaleWorld());
        this.object.pp_setScaleWorld([3, 2, 1]);
        console.warn(this.object.pp_hasUniformScaleWorld());
        this.object.pp_setScaleLocal([1, 2, 3]);
        console.warn(this.object.pp_hasUniformScaleLocal());
        this.object.pp_setScaleLocal([3, 3, 3]);
        console.warn(this.object.pp_hasUniformScaleLocal());

        console.warn("\nCAULDRON\n");
        this.object.pp_setName("ciao");
        this.object.pp_getName();
        this.object.pp_setActive(false);
        this.object.pp_setActiveHierarchy(true);
        this.object.pp_setActiveChildren(true);
        this.object.pp_getChildren();
        this.object.pp_markDirty();
        this.object.pp_equals(this.object.pp_getParent());
        this.object.pp_getComponent("ciao", 1);
        this.object.pp_getComponentHierarchy("ciao", 1);
        this.object.pp_getComponentChildren("ciao", 1);
        this.object.pp_getComponents("ciao");
        this.object.pp_getComponentsHierarchy("ciao");
        this.object.pp_getComponentsChildren("ciao");
        this.object.pp_addComponent("mesh");

        console.warn("\nMATRIX STABILITY\n");
        this.object.pp_setTransformWorldMatrix([0.9706, 4.1994, 4.1739, 0.0000, 1.5245, 3.1750, -3.5490, 0.0000, -5.6314, 1.9616, -0.6641, 0.0000, -13.8437, -2.7853, -36.3777, 1.0000]);
        let initialMatrix = this.object.pp_getTransformWorldMatrix();
        for (let i = 0; i < 100; i++) {
            this.object.pp_setTransformWorldMatrix(this.object.pp_getTransformWorldMatrix());
        }
        glMatrix.mat4.sub(initialMatrix, this.object.pp_getTransformWorldMatrix(), initialMatrix);
        initialMatrix = initialMatrix.map(a => a < 0.00000002 ? 0 : a);
        console.warn(initialMatrix);

        this.object.pp_getParent().pp_setTransformMatrix(initParentTransform);
        this.object.pp_setTransformMatrix(initTransform);

        console.warn("\nQUAT TRANSFORM POSITION STABILITY\n");
        {
            let transform = [0.5354, 0.5714, 0.1685, -0.5986, 5.3222, -4.4403, 6.6770, 2.4017];
            let transformParent = [0.1110, 0.1936, -0.0633, 0.9727, 0.4864, 0.0317, 0.0968, -0.0555];
            glMatrix.quat2.normalize(transform, transform);
            glMatrix.quat2.normalize(transformParent, transformParent);
            this.object.parent.pp_setTransformWorldQuat(transformParent);
            this.object.pp_setTransformWorldQuat(transform);
            let initialPos = this.object.pp_getPositionWorld();
            for (let i = 0; i < 100; i++) {
                this.object.pp_setTransformWorldQuat(this.object.pp_getTransformWorldQuat());
            }
            glMatrix.vec3.sub(initialPos, this.object.pp_getPositionWorld(), initialPos);
            initialPos = initialPos.map(a => a < 0.00000002 ? 0 : a);
            console.warn(initialPos);
        }

        console.warn("\nQUAT TRANSFORM POSITION STABILITY WLE\n");
        {
            this.object.scalingWorld = [5, 1, 2];
            this.object.parent.scalingWorld = [2, 5, 3];
            //this.object.parent.scalingWorld = [1, 1, 1];
            let transform = [0.5354, 0.5714, 0.1685, -0.5986, 5.3222, -4.4403, 6.6770, 2.4017];
            let transformParent = [0.1110, 0.1936, -0.0633, 0.9727, 0.4864, 0.0317, 0.0968, -0.0555];
            glMatrix.quat2.normalize(transform, transform);
            glMatrix.quat2.normalize(transformParent, transformParent);
            this.object.parent.transformWorld = transformParent;
            this.object.transformWorld = transform;
            this.object.parent.setDirty();
            this.object.setDirty();
            let initialPos = [];
            this.object.getTranslationWorld(initialPos);
            for (let i = 0; i < 100; i++) {
                this.object.transformWorld = this.object.transformWorld;
                this.object.setDirty();
            }
            let finalPos = [];
            this.object.getTranslationWorld(finalPos);
            glMatrix.vec3.sub(initialPos, finalPos, initialPos);
            initialPos = initialPos.map(a => a < 0.00000002 ? 0 : a);
            console.warn(initialPos);
        }

        console.warn("\nTEST END");
    },
    consoleWarnFixed(vector) {
        let result = [];
        for (let value of vector) {
            result.push(value.toFixed(4));
        }
        console.warn(result);
    },
    consoleWarnMatrix4Fixed(vector) {
        let result = [[], [], [], []];
        for (let i = 0; i < vector.length; i++) {
            result[Math.floor(i / 4)].push(vector[i].toFixed(4));
        }
        console.warn(result);
    },
    consoleWarnMatrix3Fixed(vector) {
        let result = [[], [], []];
        for (let i = 0; i < vector.length; i++) {
            result[Math.floor(i / 3)].push(vector[i].toFixed(4));
        }
        console.warn(result);
    }
});

/*WL.Object.prototype.pp_test = function () {
    console.log("OMG IT WORKS");
};*/

/*
let mat = [];
this.pp_getTransformWorldMatrix(mat);
glMatrix.mat4.sub(mat, mat, transform);
mat = mat.map(a => a < 0.00002 ? 0 : a);
console.warn(mat);
*/
WL.registerComponent('test-rotate-object', {
    _myX: { type: WL.Type.Float, default: 0.0 },
    _myY: { type: WL.Type.Float, default: 0.0 },
    _myZ: { type: WL.Type.Float, default: 0.0 },
    _myObjectRotate: { type: WL.Type.Bool, default: false }
}, {
    init: function () {
    },
    start: function () {
    },
    update: function (dt) {
        let quat = this.object._pp_degreesToQuaternion([this._myX * dt, this._myY * dt, this._myZ * dt]);
        if (!this._myObjectRotate) {
            this.object.pp_rotateObjectDegrees([this._myX * dt, this._myY * dt, this._myZ * dt]);
            //this.object.pp_rotateAxisWorldDegrees(this.object.pp_getRightWorld(), -this._myX * dt);
        } else {
            let axis = [];
            glMatrix.vec3.copy(axis, [this._myX * dt, this._myY * dt, this._myZ * dt]);
            glMatrix.vec3.normalize(axis, axis);
            //this.object.pp_transformDirectionWorldToObject(axis, axis);
            //this.object.pp_rotateAxisObjectDegrees(axis, this._myX * dt);
            //this.object.pp_rotateObjectDegrees([this._myX * dt, this._myY * dt, this._myZ * dt]);
            this.object.pp_rotateAroundAxisObjectDegrees(axis, this._myX * dt, [0, 5, 5]);
        }
    }
});
WL.registerComponent('test-set-alpha', {
}, {
    init: function () {
    },
    start: function () {
        this._myElapsedTime = 0;
        PP.MeshUtils.setClonedMaterials(this.object);
    },
    update: function (dt) {
        this._myElapsedTime += dt;
        PP.MeshUtils.setAlpha(this.object, Math.abs(Math.sin(this._myElapsedTime)));
    }
});
WL.registerComponent('test-trigger', {
}, {
    init: function () {
    },
    start: function () {
        this._myPhysx = this.object.pp_getComponent("physx");
        this._myPhysx.onCollision(function (type, other) {
            // Ignore uncollides
            if (type == WL.CollisionEventType.TouchLost) return;

            console.log("TRIGGER");
        }.bind(this));
    },
    update: function (dt) {
        var a = a + 2;
        a = a + 2;
        a = a + 2;
        a = a + 2;
        a = a + 2;
    }
});
WL.registerComponent("pp-clear-console-on-session", {
}, {
    init: function () {
    },
    start: function () {
        this._myFirstTime = true;
        WL.onXRSessionStart.push(function () {
            if (this._myFirstTime) {
                this._myFirstTime = false;
                console.clear();
            }
        }.bind(this));
    },
    update: function (dt) {
    }
});
WL.registerComponent("pp-player-height", {
    _myEyesHeight: { type: WL.Type.Float, default: 1.65 }
}, {
    start: function () {
        this.object.setTranslationLocal([0, this._myEyesHeight, 0]);

        if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
        }
        WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
        WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
    },
    _onXRSessionStart: function () {
        if (!["local", "viewer"].includes(WebXR.refSpace)) {
            this.object.resetTranslation();
        }
    },
    _onXRSessionEnd: function () {
        if (!["local", "viewer"].includes(WebXR.refSpace)) {
            this.object.setTranslationLocal([0, this._myEyesHeight, 0]);
        }
    }
});
WL.registerComponent('pp-set-hand-transform', {
    _myHandedness: { type: WL.Type.Enum, values: ['left', 'right'], default: 'left' },
    _myFixForward: { type: WL.Type.Bool, default: true }
}, {
    init: function () {
        this._myHandPose = new PP.HandPose(PP.InputUtils.getHandednessByIndex(this._myHandedness), this._myFixForward);
    },
    start: function () {
        this._myHandPose.start();
    },
    update: function (dt) {
        this._myHandPose.update(dt);
        this.object.pp_setTransformLocalQuat(this._myHandPose.getTransformQuat());
    },
});
WL.registerComponent('pp-set-head-transform', {
    _myFixForward: { type: WL.Type.Bool, default: true }
}, {
    init: function () {
        this._myHeadPose = new PP.HeadPose(this._myFixForward);
    },
    start: function () {
        this._myHeadPose.start();
    },
    update: function (dt) {
        this._myHeadPose.update(dt);
        this.object.pp_setTransformLocalQuat(this._myHeadPose.getTransformQuat());
    },
});
WL.registerComponent('pp-set-hierarchy-active', {
    _myHierarchyActive: { type: WL.Type.Bool, default: true },
    _mySetActiveOn: { type: WL.Type.Enum, values: ['init', 'start', 'first_update'], default: 'init' },
}, {
    init: function () {
        if (this.active && this._mySetActiveOn == 0) {
            this.object.pp_setActiveHierarchy(this._myHierarchyActive);
        }
    },
    start: function () {
        if (this._mySetActiveOn == 1) {
            this.object.pp_setActiveHierarchy(this._myHierarchyActive);
        }
        this._myFirst = true;
    },
    update: function (dt) {
        if (this._mySetActiveOn == 2 && this._myFirst) {
            this._myFirst = false;
            this.object.pp_setActiveHierarchy(this._myHierarchyActive);
        }
    },
});
PP.CAUtils = {
    _myDummyServer: null,
    _myUseDummyServerOnSDKMissing: false,
    _myUseDummyServerOnError: false,
    setUseDummyServerOnSDKMissing: function (useDummyServer) {
        PP.CAUtils._myUseDummyServerOnSDKMissing = useDummyServer;
    },
    setUseDummyServerOnError: function (useDummyServer) {
        PP.CAUtils._myUseDummyServerOnError = useDummyServer;
    },
    setDummyServer: function (dummyServer) {
        PP.CAUtils._myDummyServer = dummyServer;
    },
    isSDKAvailable: function () {
        return "casdk" in window;
    },
    isUseDummyServerOnSDKMissing: function () {
        return PP.CAUtils._myUseDummyServerOnSDKMissing;
    },
    isUseDummyServerOnError: function () {
        return PP.CAUtils._myUseDummyServerOnError;
    },
    getDummyServer: function () {
        return PP.CAUtils._myDummyServer;
    },
    getLeaderboard: function (leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError, overrideUseDummyServer = null) {
        if (PP.CAUtils.isSDKAvailable()) {
            if (!isAroundPlayer) {
                casdk.getLeaderboard(leaderboardID, isAscending, isAroundPlayer, scoresAmount).then(function (result) {
                    if (result.leaderboard) {
                        if (callbackOnDone) {
                            callbackOnDone(result.leaderboard);
                        }
                    } else {
                        if ((PP.CAUtils._myUseDummyServerOnError && overrideUseDummyServer == null) || (overrideUseDummyServer != null && overrideUseDummyServer)) {
                            PP.CAUtils.getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
                        } else if (callbackOnError) {
                            let error = {};
                            error.reason = "Get leaderboard failed";
                            error.type = PP.CAUtils.ErrorType.GET_LEADERBOARD_FAILED;
                            callbackOnError(error, result);
                        }
                    }
                });
            } else {
                PP.CAUtils.getUser(
                    function (user) {
                        let userName = user.displayName;
                        casdk.getLeaderboard(leaderboardID, isAscending, isAroundPlayer, scoresAmount).then(function (result) {
                            if (result.leaderboard) {
                                let userValid = false;
                                for (let value of result.leaderboard) {
                                    if (value.displayName == userName && value.score != 0) {
                                        userValid = true;
                                        break;
                                    }
                                }
                                if (userValid) {
                                    if (callbackOnDone) {
                                        callbackOnDone(result.leaderboard);
                                    }
                                } else {
                                    if ((PP.CAUtils._myUseDummyServerOnError && overrideUseDummyServer == null) || (overrideUseDummyServer != null && overrideUseDummyServer)) {
                                        PP.CAUtils.getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
                                    } else if (callbackOnError) {
                                        let error = {};
                                        error.reason = "Searching for around player but the user has not submitted a score yet";
                                        error.type = PP.CAUtils.ErrorType.USER_HAS_NO_SCORE;
                                        callbackOnError(error, result);
                                    }
                                }
                            } else {
                                if ((PP.CAUtils._myUseDummyServerOnError && overrideUseDummyServer == null) || (overrideUseDummyServer != null && overrideUseDummyServer)) {
                                    PP.CAUtils.getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
                                } else if (callbackOnError) {
                                    let error = {};
                                    error.reason = "Get leaderboard failed";
                                    error.type = PP.CAUtils.ErrorType.GET_LEADERBOARD_FAILED;
                                    callbackOnError(error, result);
                                }
                            }
                        });

                    },
                    function () {
                        if ((PP.CAUtils._myUseDummyServerOnError && overrideUseDummyServer == null) || (overrideUseDummyServer != null && overrideUseDummyServer)) {
                            PP.CAUtils.getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
                        } else if (callbackOnError) {
                            let error = {};
                            error.reason = "Searching for around player but the user can't be retrieved";
                            error.type = PP.CAUtils.ErrorType.GET_USER_FAILED;
                            callbackOnError(error, result);
                        }
                    },
                    false);
            }
        } else {
            if ((PP.CAUtils._myUseDummyServerOnSDKMissing && overrideUseDummyServer == null) || (overrideUseDummyServer != null && overrideUseDummyServer)) {
                PP.CAUtils.getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
            } else if (callbackOnError) {
                let error = {};
                error.reason = "Construct Arcade SDK missing";
                error.type = PP.CAUtils.ErrorType.CA_SDK_MISSING;
                callbackOnError(error, null);
            }
        }
    },
    getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError) {
        if (PP.CAUtils._myDummyServer) {
            PP.CAUtils._myDummyServer.getLeaderboard(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
        } else {
            if (callbackOnError) {
                let error = {};
                error.reason = "Dummy server not initialized";
                error.type = PP.CAUtils.ErrorType.DUMMY_NOT_INITIALIZED;
                callbackOnError(error);
            }
        }
    },
    submitScore: function (leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError, overrideUseDummyServer = null) {
        if (PP.CAUtils.isSDKAvailable()) {
            casdk.submitScore(leaderboardID, scoreToSubmit).then(function (result) {
                if (result.error) {
                    if ((PP.CAUtils._myUseDummyServerOnError && overrideUseDummyServer == null) || (overrideUseDummyServer != null && overrideUseDummyServer)) {
                        PP.CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError);
                    } else if (callbackOnError) {
                        let error = {};
                        error.reason = "Submit score failed";
                        error.type = PP.CAUtils.ErrorType.SUBMIT_SCORE_FAILED;
                        callbackOnError(error, result);
                    }
                } else {
                    callbackOnDone();
                }
            });
        } else {
            if ((PP.CAUtils._myUseDummyServerOnSDKMissing && overrideUseDummyServer == null) || (overrideUseDummyServer != null && overrideUseDummyServer)) {
                PP.CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError);
            } else if (callbackOnError) {
                let error = {};
                error.reason = "Construct Arcade SDK missing";
                error.type = PP.CAUtils.ErrorType.CA_SDK_MISSING;
                callbackOnError(error, null);
            }
        }
    },
    submitScoreDummy(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError) {
        if (PP.CAUtils._myDummyServer) {
            PP.CAUtils._myDummyServer.submitScore(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError);
        } else {
            if (callbackOnError) {
                let error = {};
                error.reason = "Dummy server not initialized";
                error.type = PP.CAUtils.ErrorType.DUMMY_NOT_INITIALIZED;
                callbackOnError(error);
            }
        }
    },
    getUser: function (callbackOnDone, callbackOnError, overrideUseDummyServer = null) {
        if (PP.CAUtils.isSDKAvailable()) {
            casdk.getUser().then(function (result) {
                if (result.user) {
                    if (callbackOnDone) {
                        callbackOnDone(result.user);
                    }
                } else {
                    if ((PP.CAUtils._myUseDummyServerOnError && overrideUseDummyServer == null) || (overrideUseDummyServer != null && overrideUseDummyServer)) {
                        PP.CAUtils.getUserDummy(callbackOnDone, callbackOnError);
                    } else if (callbackOnError) {
                        let error = {};
                        error.reason = "Get user failed";
                        error.type = PP.CAUtils.ErrorType.GET_USER_FAILED;
                        callbackOnError(error, result);
                    }
                }
            });
        } else {
            if ((PP.CAUtils._myUseDummyServerOnSDKMissing && overrideUseDummyServer == null) || (overrideUseDummyServer != null && overrideUseDummyServer)) {
                PP.CAUtils.getUserDummy(callbackOnDone, callbackOnError);
            } else if (callbackOnError) {
                let error = {};
                error.reason = "Construct Arcade SDK missing";
                error.type = PP.CAUtils.ErrorType.CA_SDK_MISSING;
                callbackOnError(error, null);
            }
        }
    },
    getUserDummy(callbackOnDone, callbackOnError) {
        if (PP.CAUtils._myDummyServer) {
            PP.CAUtils._myDummyServer.getUser(callbackOnDone, callbackOnError);
        } else {
            if (callbackOnError) {
                let error = {};
                error.reason = "Dummy server not initialized";
                error.type = PP.CAUtils.ErrorType.DUMMY_NOT_INITIALIZED;
                callbackOnError(error);
            }
        }
    },
    ErrorType: {
        DUMMY_NOT_INITIALIZED: 0,
        CA_SDK_MISSING: 1,
        SUBMIT_SCORE_FAILED: 2,
        GET_LEADERBOARD_FAILED: 3,
        GET_USER_FAILED: 4,
        USER_HAS_NO_SCORE: 5
    }
};

PP.CADummyServer = class CADummyServer {

    constructor() {
    }

    getLeaderboard(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError) {
        let leaderboard = null;

        if (isAroundPlayer) {
            leaderboard = [
                { rank: 7, displayName: "Player 1", score: 1000000 },
                { rank: 8, displayName: "Player 2", score: 1000000 },
                { rank: 9, displayName: "Player 3", score: 900000 },
                { rank: 10, displayName: "Player 4", score: 800000 },
                { rank: 11111, displayName: "Player 5", score: 70000000 },
                { rank: 22222, displayName: "VeryLongName_06", score: 600000 },
                { rank: 33333, displayName: "Player 7", score: 500000 },
                { rank: 44444, displayName: "Player 8", score: 400000 },
                { rank: 55555, displayName: "Player 9", score: 300000 },
                { rank: 66666, displayName: "Player 10", score: 200000 }];
        } else {
            leaderboard = [
                { rank: 0, displayName: "Player 1", score: 1000000 },
                { rank: 1, displayName: "Player 2", score: 1000000 },
                { rank: 2, displayName: "Player 3", score: 900000 },
                { rank: 3, displayName: "Player 4", score: 800000 },
                { rank: 4, displayName: "Player 5", score: 700000 },
                { rank: 5, displayName: "Player 6", score: 600000 },
                { rank: 6, displayName: "Player 7", score: 500000 },
                { rank: 7, displayName: "Player 8", score: 400000 },
                { rank: 8, displayName: "Player 9", score: 300000 },
                { rank: 9, displayName: "Player 10", score: 200000 }];
        }

        while (leaderboard.length > scoresAmount) {
            leaderboard.pop();
        }

        if (callbackOnDone) {
            callbackOnDone(leaderboard);
        }
    }

    submitScore(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError) {
        if (callbackOnDone) {
            callbackOnDone();
        }
    }

    getUser(callbackOnDone, callbackOnError) {
        let user = {};
        user.displayName = "Jonathan";

        if (callbackOnDone) {
            callbackOnDone(user);
        }
    }
};
PP.ColorUtils = {
    //RGB is in [0,1], alpha is not changed
    rgbToHsv: function (rgb) {
        let hsv = rgb.pp_clone();

        let r = rgb[0];
        let g = rgb[1];
        let b = rgb[2];

        var max = Math.max(r, g, b), min = Math.min(r, g, b),
            d = max - min,
            h,
            s = (max === 0 ? 0 : d / max),
            v = max;

        switch (max) {
            case min: h = 0; break;
            case r: h = (g - b) + d * (g < b ? 6 : 0); h /= 6 * d; break;
            case g: h = (b - r) + d * 2; h /= 6 * d; break;
            case b: h = (r - g) + d * 4; h /= 6 * d; break;
        }

        hsv[0] = h;
        hsv[1] = s;
        hsv[2] = v;

        return hsv;
    },
    //alpha is not changed
    hsvToRgb: function (hsv) {
        let rgb = hsv.pp_clone();

        let h = hsv[0];
        let s = hsv[1];
        let v = hsv[2];

        let r, g, b, i, f, p, q, t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);

        switch (i % 6) {
            case 0: r = v, g = t, b = p; break;
            case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break;
            case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break;
            case 5: r = v, g = p, b = q; break;
        }

        rgb[0] = r;
        rgb[1] = g;
        rgb[2] = b;

        return rgb;
    },
    rgbCodeToHuman(rgb) {
        return PP.ColorUtils.color1To255(rgb);
    },
    rgbHumanToCode(rgb) {
        return PP.ColorUtils.color255To1(rgb);
    },
    hsvCodeToHuman(hsv) {
        return PP.ColorUtils.color1To255(hsv);
    },
    hsvHumanToCode(hsv) {
        return PP.ColorUtils.color255To1(hsv);
    },
    color255To1(color) {
        let result = color.pp_clone();

        for (let i = 0; i < result.length; i++) {
            result[i] /= 255;
            result[i] = Math.pp_clamp(result[i], 0, 1);
        }

        return result;
    },
    color1To255(color) {
        let result = color.pp_clone();

        for (let i = 0; i < result.length; i++) {
            result[i] = Math.round(result[i] * 255);
            result[i] = Math.pp_clamp(result[i], 0, 255);
        }

        return result;
    },
};
PP.MeshUtils = {
    createPlaneMesh: function () {
        let vertexCount = 4;
        let vertexDataSize = WL.Mesh.VERTEX_FLOAT_SIZE; // vertex is like a class with x,y,z,u,v,normal unwrapped in an array

        let vertexData = new Float32Array(vertexCount * vertexDataSize);
        let indexData = new Uint32Array(vertexCount + 2); // +2 repeated vertexes

        for (let i = 0; i < 4; ++i) {
            vertexData[i * vertexDataSize + WL.Mesh.POS.X] = -1 + (i & 1) * 2;
            vertexData[i * vertexDataSize + WL.Mesh.POS.Y] = -1 + ((i & 2) >> 1) * 2; // this is a quick way to have positions (-1,-1) (1,-1) (1,-1) (1,1)
            vertexData[i * vertexDataSize + WL.Mesh.POS.Z] = 0;

            vertexData[i * vertexDataSize + WL.Mesh.TEXCOORD.U] = (i & 1);
            vertexData[i * vertexDataSize + WL.Mesh.TEXCOORD.V] = ((i & 2) >> 1);

            vertexData[i * vertexDataSize + WL.Mesh.NORMAL.X] = 0;
            vertexData[i * vertexDataSize + WL.Mesh.NORMAL.Y] = 0;
            vertexData[i * vertexDataSize + WL.Mesh.NORMAL.Z] = 1;
        }

        indexData[0] = 0;
        indexData[1] = 1;
        indexData[2] = 2;
        indexData[3] = 2;
        indexData[4] = 1;
        indexData[5] = 3;

        let mesh = new WL.Mesh({
            indexData: indexData,
            indexType: WL.MeshIndexType.UnsignedInt,
            vertexData: vertexData
        });

        return mesh;
    },
    // alpha between 0 and 1
    setAlpha: function (object, alpha) {
        let meshComponents = object.pp_getComponentsHierarchy("mesh");

        for (let meshComponent of meshComponents) {
            if (meshComponent.material.color != null) {
                let color = meshComponent.material.color;
                color[3] = alpha;
                meshComponent.material.color = color;
            }

            if (meshComponent.material.diffuseColor != null) {
                let color = meshComponent.material.diffuseColor;
                color[3] = alpha;
                meshComponent.material.diffuseColor = color;
            }

            if (meshComponent.material.ambientColor != null) {
                let color = meshComponent.material.ambientColor;
                color[3] = alpha;
                meshComponent.material.ambientColor = color;
            }
        }
    },
    setMaterial: function (object, material, cloneMaterial = false) {
        let meshComponents = object.pp_getComponentsHierarchy("mesh");

        for (let meshComponent of meshComponents) {
            if (cloneMaterial) {
                meshComponent.material = material.clone();
            } else {
                meshComponent.material = material;
            }
        }
    },
    setClonedMaterials: function (object) {
        let meshComponents = object.pp_getComponentsHierarchy("mesh");

        for (let meshComponent of meshComponents) {
            meshComponent.material = meshComponent.material.clone();
        }
    },
    setSpecularColor: function (object, color) {
        let meshComponents = object.pp_getComponentsHierarchy("mesh");

        for (let meshComponent of meshComponents) {
            if (meshComponent.material.specularColor != null) {
                meshComponent.material.specularColor = color;
            }
        }
    },
    setFogColor: function (object, color) {
        let meshComponents = object.pp_getComponentsHierarchy("mesh");

        for (let meshComponent of meshComponents) {
            if (meshComponent.material.fogColor != null) {
                meshComponent.material.fogColor = color;
            }
        }
    },
};
PP.SaveUtils = {
    save: function (id, value) {
        if (value != null) {
            localStorage.setItem(id, value);
        }
    },
    has: function (id) {
        return PP.SaveUtils.loadString(id, null) != null;
    },
    delete: function (id) {
        return localStorage.removeItem(id);
    },
    clear: function () {
        return localStorage.clear();
    },
    load: function (id, defaultValue = null) {
        return PP.SaveUtils.loadString(id, defaultValue);
    },
    loadString: function (id, defaultValue = null) {
        let item = localStorage.getItem(id);

        if (item == null) {
            item = defaultValue;
        }

        return item;
    },
    loadNumber: function (id, defaultValue = null) {
        let item = PP.SaveUtils.loadString(id);

        if (item != null) {
            return Number(item);
        }

        return defaultValue;
    },
    loadBool: function (id, defaultValue = null) {
        let item = PP.SaveUtils.loadString(id);

        if (item == "true") {
            return true;
        } else if (item == "false") {
            return false;
        }

        return defaultValue;
    }
};
PP.TextUtils = {
    setClonedMaterials: function (object) {
        let textComponents = object.pp_getComponentsHierarchy("text");

        for (let textComponent of textComponents) {
            textComponent.material = textComponent.material.clone();
        }
    },
};
PP.XRUtils = {
    isDeviceEmulated: function () {
        let isEmulated = ('CustomWebXRPolyfill' in window);
        return isEmulated;
    },
    isXRSessionActive: function () {
        return WL.xrSession != null;
    }
};
PP.DebugAxes = class DebugAxes {

    constructor(autoRefresh = true) {
        this._myDebugRight = new PP.DebugLine();
        this._myDebugRight.setColor([1, 0, 0, 1]);
        this._myDebugUp = new PP.DebugLine();
        this._myDebugUp.setColor([0, 1, 0, 1]);
        this._myDebugForward = new PP.DebugLine();
        this._myDebugForward.setColor([0, 0, 1, 1]);

        this._myTransform = glMatrix.mat4.create();
        this._myAxesLength = 0.1;
        this._myPositionOffset = [0, 0, 0];

        this._myVisible = true;
        this._myDirty = false;
        this._myAutoRefresh = autoRefresh;

        this._myDebugRight.setVisible(this._myVisible);
        this._myDebugUp.setVisible(this._myVisible);
        this._myDebugForward.setVisible(this._myVisible);

        this._myDebugRight.setAutoRefresh(false);
        this._myDebugUp.setAutoRefresh(false);
        this._myDebugForward.setAutoRefresh(false);
    }

    setVisible(visible) {
        this._myVisible = visible;
        this._myDebugRight.setVisible(visible);
        this._myDebugUp.setVisible(visible);
        this._myDebugForward.setVisible(visible);
    }

    setAutoRefresh(autoRefresh) {
        this._myAutoRefresh = autoRefresh;
        this._myDebugRight.setAutoRefresh(autoRefresh);
        this._myDebugUp.setAutoRefresh(autoRefresh);
        this._myDebugForward.setAutoRefresh(autoRefresh);
    }

    setTransform(transform) {
        if (transform.length == 8) {
            transform.quat2_toMatrix(this._myTransform);
        } else {
            this._myTransform.mat4_copy(transform);
        }

        this._markDirty();
    }

    setAxesLength(length) {
        this._myAxesLength = length;

        this._markDirty();
    }

    setPositionOffset(offset) {
        this._myPositionOffset.vec3_copy(offset);

        this._markDirty();
    }

    update(dt) {
        if (this._myDirty) {
            this._refreshAxes(dt);

            this._myDebugForward.update(dt);
            this._myDebugUp.update(dt);
            this._myDebugRight.update(dt);

            this._myDirty = false;
        }
    }

    _refreshAxes(dt) {
        let axes = this._myTransform.mat4_getAxes();
        let position = this._myTransform.mat4_getPosition();
        position.vec3_add(this._myPositionOffset, position);
        this._myDebugRight.setStartDirectionLength(position, axes[0], this._myAxesLength);
        this._myDebugUp.setStartDirectionLength(position, axes[1], this._myAxesLength);
        this._myDebugForward.setStartDirectionLength(position, axes[2], this._myAxesLength);
    }

    _markDirty() {
        this._myDirty = true;

        if (this._myAutoRefresh) {
            this._refreshAxes(0);
            this._myDebugForward._refreshLine(0);
            this._myDebugUp._refreshLine(0);
            this._myDebugRight._refreshLine(0);
        }
    }
}
WL.registerComponent('pp-debug-global-data', {
    _myCubeMesh: { type: WL.Type.Mesh },
    _myFlatMaterial: { type: WL.Type.Material },
}, {
    init: function () {
        PP.myDebugData.myRootObject = WL.scene.addObject(null);

        PP.myDebugData.myCubeMesh = this._myCubeMesh;
        PP.myDebugData.myFlatMaterial = this._myFlatMaterial;
    },
});

PP.myDebugData = {
    myRootObject: null,
    myCubeMesh: null,
    myFlatMaterial: null
};
PP.DebugLine = class DebugLine {

    constructor(autoRefresh = true) {
        this._myLineRootObject = null;
        this._myLineObject = null;

        this._myStartPosition = [0, 0, 0];
        this._myDirection = [0, 0, 1];
        this._myLength = 0;

        this._myThickness = 0.005;

        this._myColor = [0.7, 0.7, 0.7, 1];

        this._myVisible = true;

        this._myDirty = false;

        this._myAutoRefresh = autoRefresh;

        this._buildLine();
    }

    setVisible(visible) {
        if (this._myVisible != visible) {
            this._myVisible = visible;
            this._myLineRootObject.pp_setActiveHierarchy(visible);
        }
    }

    setAutoRefresh(autoRefresh) {
        this._myAutoRefresh = autoRefresh;
    }

    setStartEnd(start, end) {
        let direction = [];
        glMatrix.vec3.sub(direction, end, start);
        let length = glMatrix.vec3.length(direction);
        glMatrix.vec3.normalize(direction, direction);

        this.setStartDirectionLength(start, direction, length);
    }

    setStartDirectionLength(start, direction, length) {
        this._myStartPosition.vec3_copy(start);
        this._myDirection.vec3_copy(direction);
        this._myLength = length;

        this._markDirty();
    }

    setColor(color) {
        glMatrix.vec4.copy(this._myColor, color);

        this._markDirty();
    }

    setThickness(thickness) {
        this._myThickness = thickness;

        this._markDirty();
    }

    update(dt) {
        if (this._myDirty) {
            this._refreshLine(dt);

            this._myDirty = false;
        }
    }

    _refreshLine(dt) {
        this._myLineRootObject.setTranslationWorld(this._myStartPosition);
        this._myLineObject.resetTranslationRotation();
        this._myLineObject.resetScaling();

        this._myLineObject.scale([this._myThickness / 2, this._myThickness / 2, this._myLength / 2]);

        let forward = this._myLineObject.pp_getForward();
        let angle = glMatrix.vec3.angle(forward, this._myDirection);
        if (angle > 0.0001) {
            let rotationAxis = [];
            glMatrix.vec3.cross(rotationAxis, forward, this._myDirection);
            glMatrix.vec3.normalize(rotationAxis, rotationAxis);
            let rotationQuat = [];
            glMatrix.quat.setAxisAngle(rotationQuat, rotationAxis, angle);

            glMatrix.quat.mul(rotationQuat, rotationQuat, this._myLineObject.transformWorld);
            glMatrix.quat.normalize(rotationQuat, rotationQuat);
            this._myLineObject.rotateObject(rotationQuat);
        }

        forward = this._myLineObject.pp_getForward();
        let position = this._myLineObject.pp_getPosition();
        glMatrix.vec3.scale(forward, forward, this._myLength / 2);
        glMatrix.vec3.add(position, forward, position);
        this._myLineObject.setTranslationWorld(position);

        this._myLineMesh.material.color = this._myColor;
    }

    _buildLine() {
        this._myLineRootObject = WL.scene.addObject(PP.myDebugData.myRootObject);
        this._myLineObject = WL.scene.addObject(this._myLineRootObject);
        this._myLineObject.scale([0.01, 0.01, 0.01]);

        this._myLineMesh = this._myLineObject.addComponent('mesh');
        this._myLineMesh.mesh = PP.myDebugData.myCubeMesh;
        this._myLineMesh.material = PP.myDebugData.myFlatMaterial.clone();
    }

    _markDirty() {
        this._myDirty = true;

        if (this._myAutoRefresh) {
            this._refreshLine(0);
        }
    }
};
/*
    You can also use plain functions for state/transition if u want to do something simpler and faster

    Signatures:
        stateUpdateFunction(dt, fsm)
        initFunction(fsm, initStateData)
        transitionFunction(fsm, transitionData)
*/

PP.StateData = class StateData {
    constructor(stateID, stateObject) {
        this.myID = stateID;
        this.myObject = stateObject;
    }
};

PP.TransitionData = class TransitionData {
    constructor(transitionID, fromStateData, toStateData, transitionObject, skipStateFunction) {
        this.myID = transitionID;
        this.myFromState = fromStateData;
        this.myToState = toStateData;
        this.myObject = transitionObject;
        this.mySkipStateFunction = skipStateFunction;
    }
};

PP.PendingPerform = class PendingPerform {
    constructor(transitionID, ...args) {
        this.myID = transitionID;
        this.myArgs = args;
    }
};

PP.PerformType = {
    IMMEDIATE: 0,
    DELAYED: 1
};

PP.PerformDelayedType = {
    QUEUE: 0,
    KEEP_FIRST: 1,
    KEEP_LAST: 2
};

PP.SkipStateFunction = {
    NONE: 0,
    END: 1,
    START: 2,
    BOTH: 3
};

PP.FSM = class FSM {

    constructor(performType = PP.PerformType.IMMEDIATE, performDelayedType = PP.PerformDelayedType.QUEUE) {
        this._myCurrentStateData = null;

        this._myStateMap = new Map();
        this._myTransitionMap = new Map();

        this._myDebugLogActive = false;
        this._myDebugShowDelayedInfo = false;
        this._myDebugLogName = "FSM";

        this._myPerformType = performType;
        this._myPerformDelayedType = performDelayedType;
        this._myPendingPerforms = [];
    }

    addState(stateID, state = null) {
        let stateObject = null;
        if (!state || typeof state == 'function') {
            stateObject = {};
            if (typeof state == 'function') {
                stateObject.update = state;
            } else {
                stateObject.update = null;
            }
            stateObject.clone = function () {
                let cloneObject = {};
                cloneObject.update = this.update;
                cloneObject.clone = this.clone;
                return cloneObject;
            };
        } else {
            stateObject = state;
        }

        let stateData = new PP.StateData(stateID, stateObject);
        this._myStateMap.set(stateID, stateData);
        this._myTransitionMap.set(stateID, new Map());
    }

    addTransition(fromStateID, toStateID, transitionID, transition = null, skipStateFunction = PP.SkipStateFunction.NONE) {
        let transitionObject = null;
        if (!transition || typeof transition == 'function') {
            transitionObject = {};
            if (typeof transition == 'function') {
                transitionObject.perform = transition;
            } else {
                transitionObject.perform = null;
            }
            transitionObject.clone = function () {
                let cloneObject = {};
                cloneObject.perform = this.perform;
                cloneObject.clone = this.clone;
                return cloneObject;
            };
        } else {
            transitionObject = transition;
        }

        if (this.hasState(fromStateID) && this.hasState(toStateID)) {
            let fromMap = this._getTransitionMapFromState(fromStateID);

            let transitionData = new PP.TransitionData(transitionID, this.getState(fromStateID), this.getState(toStateID), transitionObject, skipStateFunction);
            fromMap.set(transitionID, transitionData);
        } else {
            if (!this.hasState(fromStateID) && !this.hasState(toStateID)) {
                console.error("Can't add transition:", transitionID, "- from state not found:", fromStateID, "- to state not found:", toStateID);
            } else if (!this.hasState(fromStateID)) {
                console.error("Can't add transition:", transitionID, "- from state not found:", fromStateID);
            } else if (!this.hasState(toStateID)) {
                console.error("Can't add transition:", transitionID, "- to state not found:", toStateID);
            }
        }
    }

    init(initStateID, initTransition = null, ...args) {
        let initTransitionObject = initTransition;
        if (initTransition && typeof initTransition == 'function') {
            initTransitionObject = {};
            initTransitionObject.performInit = initTransition;
        }

        if (this.hasState(initStateID)) {
            let initStateData = this._myStateMap.get(initStateID);

            if (this._myDebugLogActive) {
                console.log(this._myDebugLogName, "- Init:", initStateID);
            }

            if (initTransitionObject && initTransitionObject.performInit) {
                initTransitionObject.performInit(this, initStateData, ...args);
            } else if (initStateData.myObject && initStateData.myObject.init) {
                initStateData.myObject.init(this, initStateData, ...args);
            }

            this._myCurrentStateData = initStateData;
        } else if (this._myDebugLogActive) {
            console.warn(this._myDebugLogName, "- Init state not found:", initStateID);
        }
    }

    update(dt, ...args) {
        if (this._myPendingPerforms.length > 0) {
            for (let i = 0; i < this._myPendingPerforms.length; i++) {
                this._perform(this._myPendingPerforms[i].myID, true, ...this._myPendingPerforms[i].myArgs);
            }
            this._myPendingPerforms = [];
        }

        if (this._myCurrentStateData && this._myCurrentStateData.myObject && this._myCurrentStateData.myObject.update) {
            this._myCurrentStateData.myObject.update(dt, this, ...args);
        }
    }

    perform(transitionID, ...args) {
        if (this._myPerformType == PP.PerformType.DELAYED) {
            this.performDelayed(transitionID, ...args);
        } else {
            this.performImmediate(transitionID, ...args);
        }
    }

    performDelayed(transitionID, ...args) {
        let performDelayed = false;

        switch (this._myPerformDelayedType) {
            case PP.PerformDelayedType.QUEUE:
                this._myPendingPerforms.push(new PP.PendingPerform(transitionID, ...args));
                performDelayed = true;
                break;
            case PP.PerformDelayedType.KEEP_FIRST:
                if (!this.hasPendingPerforms()) {
                    this._myPendingPerforms.push(new PP.PendingPerform(transitionID, ...args));
                    performDelayed = true;
                }
                break;
            case PP.PerformDelayedType.KEEP_LAST:
                this.resetPendingPerforms();
                this._myPendingPerforms.push(new PP.PendingPerform(transitionID, ...args));
                performDelayed = true;
                break;
        }

        return performDelayed;
    }

    performImmediate(transitionID, ...args) {
        return this._perform(transitionID, false, ...args);
    }

    canPerform(transitionID) {
        return this.hasTransitionFromState(this._myCurrentStateData.myID, transitionID);
    }

    canGoTo(stateID, transitionID = null) {
        return this.hasTransitionFromStateToState(this._myCurrentStateData.myID, stateID, transitionID);
    }

    isInState(stateID) {
        return this._myCurrentStateData != null && this._myCurrentStateData.myID == stateID;
    }

    hasBeenInit() {
        return this._myCurrentStateData != null;
    }

    reset() {
        this.resetState();
        this.resetPendingPerforms();
    }

    resetState() {
        this._myCurrentStateData = null;
    }

    resetPendingPerforms() {
        this._myPendingPerforms = [];
    }

    getCurrentState() {
        return this._myCurrentStateData;
    }

    getCurrentTransitions() {
        return this.getTransitionsFromState(this._myCurrentStateData.myID);
    }

    getCurrentTransitionsToState(stateID) {
        return this.getTransitionsFromStateToState(this._myCurrentStateData.myID, stateID);
    }

    getState(stateID) {
        return this._myStateMap.get(stateID);
    }

    getStates() {
        return this._myStateMap.values();
    }

    getTransitions() {
        let transitions = [];

        for (let transitionsPerStateMap of this._myTransitionMap.values()) {
            for (let transitionData of transitionsPerStateMap.values()) {
                transitions.push(transitionData);
            }
        }

        return transitions;
    }

    getTransitionsFromState(fromStateID) {
        let transitionMap = this._getTransitionMapFromState(fromStateID);
        return Array.from(transitionMap.values());
    }

    getTransitionsFromStateToState(fromStateID, toStateID) {
        let transitionMap = this._getTransitionMapFromState(fromStateID);

        let transitionsToState = [];
        for (let transitionData of transitionMap.values()) {
            if (transitionData.myToState.myID == toStateID) {
                transitionsToState.push(transitionData);
            }
        }

        return transitionsToState;
    }

    removeState(stateID) {
        if (this.hasState(stateID)) {
            this._myStateMap.delete(stateID);
            this._myTransitionMap.delete(stateID);

            for (let transitionMap of this._myTransitionMap.values()) {
                let toDelete = [];
                for (let [transitionID, transitionData] of transitionMap.entries()) {
                    if (transitionData.myToState.myID == stateID) {
                        toDelete.push(transitionID);
                    }
                }

                for (let transitionID of toDelete) {
                    transitionMap.delete(transitionID);
                }
            }

            return true;
        }
        return false;
    }

    removeTransitionFromState(fromStateID, transitionID) {
        let fromTransitions = this._getTransitionMapFromState(fromStateID);
        if (fromTransitions) {
            return fromTransitions.delete(transitionID);
        }

        return false;
    }

    hasState(stateID) {
        return this._myStateMap.has(stateID);
    }

    hasTransitionFromState(fromStateID, transitionID) {
        let transitions = this.getTransitionsFromState(fromStateID);

        let transitionIndex = transitions.findIndex(function (transition) {
            return transition.myID == transitionID;
        });

        return transitionIndex >= 0;
    }

    hasTransitionFromStateToState(fromStateID, toStateID, transitionID = null) {
        let transitions = this.getTransitionsFromStateToState(fromStateID, toStateID);

        let hasTransition = false;
        if (transitionID) {
            let transitionIndex = transitions.findIndex(function (transition) {
                return transition.myID == transitionID;
            });

            hasTransition = transitionIndex >= 0;
        } else {
            hasTransition = transitions.length > 0;
        }

        return hasTransition;
    }

    setPerformType(performType) {
        this._myPerformType = performType;
    }

    getPerformType() {
        return this._myPerformType;
    }

    setPerformDelayedType(performDelayedType) {
        this._myPerformDelayedType = performDelayedType;
    }

    getPerformDelayedType() {
        return this._myPerformDelayedType;
    }

    hasPendingPerforms() {
        return this._myPendingPerforms.length > 0;
    }

    getPendingPerforms() {
        return this._myPendingPerforms.slice(0);
    }

    clone(deepClone = false) {
        if (!this.isCloneable(deepClone)) {
            return null;
        }

        let cloneFSM = new PP.FSM();

        cloneFSM._myDebugLogActive = this._myDebugLogActive;
        cloneFSM._myDebugShowDelayedInfo = this._myDebugShowDelayedInfo;
        cloneFSM._myDebugLogName = this._myDebugLogName.slice(0);

        cloneFSM._myPerformType = this._myPerformType;
        cloneFSM._myPerformDelayedType = this._myPerformDelayedType;
        cloneFSM._myPendingPerforms = this._myPendingPerforms.slice(0);

        for (let entry of this._myStateMap.entries()) {
            let stateData = null;

            if (deepClone) {
                stateData = new PP.StateData(entry[1].myID, entry[1].myObject.clone());
            } else {
                stateData = new PP.StateData(entry[1].myID, entry[1].myObject);
            }

            cloneFSM._myStateMap.set(stateData.myID, stateData);
        }

        for (let entry of this._myTransitionMap.entries()) {
            let fromStateMap = new Map();
            cloneFSM._myTransitionMap.set(entry[0], fromStateMap);

            for (let tEntry of entry[1].entries()) {
                let transitionData = null;

                let fromState = cloneFSM.getState(tEntry[1].myFromState.myID);
                let toState = cloneFSM.getState(tEntry[1].myToState.myID);

                if (deepClone) {
                    transitionData = new PP.TransitionData(tEntry[1].myID, fromState, toState, tEntry[1].myObject.clone(), tEntry[1].mySkipStateFunction);
                } else {
                    transitionData = new PP.TransitionData(tEntry[1].myID, fromState, toState, tEntry[1].myObject, tEntry[1].mySkipStateFunction);
                }

                fromStateMap.set(transitionData.myID, transitionData);
            }
        }

        if (this._myCurrentStateData) {
            cloneFSM._myCurrentStateData = cloneFSM.getState(this._myCurrentStateData.myID);
        }

        return cloneFSM;
    }

    isCloneable(deepClone = false) {
        if (!deepClone) {
            return true;
        }

        let isDeepCloneable = true;

        for (let entry of this._myStateMap.entries()) {
            isDeepCloneable = isDeepCloneable && entry[1].myObject.clone != null;
        }

        for (let entry of this._myTransitionMap.entries()) {
            for (let tEntry of entry[1].entries()) {
                isDeepCloneable = isDeepCloneable && tEntry[1].myObject.clone != null;
            }
        }

        return isDeepCloneable;
    }

    setDebugLogActive(active, debugLogName = null, showDelayedInfo = false) {
        this._myDebugLogActive = active;
        this._myDebugShowDelayedInfo = showDelayedInfo;
        if (debugLogName) {
            this._myDebugLogName = "FSM: ".concat(debugLogName);
        }
    }

    _perform(transitionID, isDelayed, ...args) {
        if (this._myCurrentStateData) {
            if (this.canPerform(transitionID)) {
                let transitions = this._myTransitionMap.get(this._myCurrentStateData.myID);
                let transitionToPerform = transitions.get(transitionID);

                let fromState = this._myCurrentStateData;
                let toState = this._myStateMap.get(transitionToPerform.myToState.myID);

                if (this._myDebugLogActive) {
                    let consoleArguments = [this._myDebugLogName, "- From:", fromState.myID, "- To:", toState.myID, "- With:", transitionID];
                    if (this._myDebugShowDelayedInfo) {
                        consoleArguments.push(isDelayed ? "- Delayed" : "- Immediate");
                    }
                    console.log(...consoleArguments);
                }

                if (transitionToPerform.mySkipStateFunction != PP.SkipStateFunction.END && transitionToPerform.mySkipStateFunction != PP.SkipStateFunction.BOTH &&
                    fromState.myObject && fromState.myObject.end) {
                    fromState.myObject.end(this, transitionToPerform, ...args);
                }

                if (transitionToPerform.myObject && transitionToPerform.myObject.perform) {
                    transitionToPerform.myObject.perform(this, transitionToPerform, ...args);
                }

                if (transitionToPerform.mySkipStateFunction != PP.SkipStateFunction.START && transitionToPerform.mySkipStateFunction != PP.SkipStateFunction.BOTH &&
                    toState.myObject && toState.myObject.start) {
                    toState.myObject.start(this, transitionToPerform, ...args);
                }

                this._myCurrentStateData = transitionToPerform.myToState;

                return true;
            } else if (this._myDebugLogActive) {
                let consoleArguments = [this._myDebugLogName, "- No Transition:", transitionID, "- From:", this._myCurrentStateData.myID];
                if (this._myDebugShowDelayedInfo) {
                    consoleArguments.push(isDelayed ? "- Delayed" : "- Immediate");
                }
                console.warn(...consoleArguments);
            }
        } else if (this._myDebugLogActive) {
            let consoleArguments = [this._myDebugLogName, "- FSM not initialized yet"];
            if (this._myDebugShowDelayedInfo) {
                consoleArguments.push(isDelayed ? "- Delayed" : "- Immediate");
            }
            console.warn(...consoleArguments);
        }

        return false;
    }

    _getTransitionMapFromState(fromStateID) {
        return this._myTransitionMap.get(fromStateID);
    }
};
/*
    There is no need to inherit from this state, especially since states can be only functions
    It's more like an example of what is needed
    
    If you don't specify some methods the fsm will just skip them
    Or consider them always valid

    The param state is of type PP.StateData and can be used to retrieve the stateID and other data
    The param transition is of type PP.TransitionData and can be used to retrieve the transitionID, the from and to states and other data
*/

PP.State = class State {

    //Called every frame if this is the current state
    //You can retrieve this state data by calling fsm.getCurrentState()
    update(dt, fsm, ...args) {
    }

    //Called when the fsm is started with this init state if no init transition object is specified or it does not have a performInit function
    //Since the state is set as the current one after the init, you can't use fsm.getCurrentState() to get it, so it is forwarded as a param if needed
    init(fsm, state, ...args) {
    }

    //Called when entering this state if no transition object is specified or it does not have a perform function
    //You can get this state data by accesing to the to state data inside the transition
    start(fsm, transition, ...args) {
    }

    //Called when exiting this state if no transition function is specified
    //You can get this state data by accesing to the from state data inside the transition
    end(fsm, transition, ...args) {
    }

};
/*
    There is no need to inherit from this transition, especially since states can be only transitions
    It's more like an example of what is needed
    
    The param transition (forwarded at the end every function) is of type PP.TransitionData and can be used to retrieve the transitionID and other data
    The initState param is of type PP.StateData and can be used to retrieve the stateID and other data
*/

PP.Transition = class Transition {

    //Called if this is used as an init transition for the fsm
    performInit(fsm, initState, ...args) {

    }

    //Called when performing a transition
    //You can find the from and to states inside the transition params
    perform(fsm, transition, ...args) {
    }

};
class enoughISenough {
    constructor() {
        this.prepareSFXSetups();
    }

    start() {
        this._myStatisticsManager = new StatisticsManager();
        this._myStatisticsManager.start();

        this._myMainFSM = new MainFSM();
        this._myMainFSM.init();
    }

    update(dt) {
        this._myMainFSM.update(dt);

        if (PP.XRUtils.isXRSessionActive()) {
            Global.myStatistics.myTotalPlayTime += dt;
        }

        this._myStatisticsManager.update(dt);
    }

    prepareSFXSetups() {
        let manager = Global.myAudioManager;

        {
            let audioSetup = new PP.AudioSetup("assets/audio/music/you_KNOW_22Hz.wav");
            audioSetup.myLoop = true;
            audioSetup.mySpatial = false;
            audioSetup.myVolume = 0.45;
            manager.addAudioSetup(SfxID.YOU_KNOW, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/NOT_ENOUGH.wav");
            audioSetup.myReferenceDistance = 1000000;
            manager.addAudioSetup(SfxID.NOT_ENOUGH, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/blather_0.wav");
            audioSetup.myVolume = 0.4;
            audioSetup.myReferenceDistance = 1000000;
            manager.addAudioSetup(SfxID.BLATHER_0, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/blather_1.wav");
            audioSetup.myVolume = 0.4;
            audioSetup.myReferenceDistance = 1000000;
            manager.addAudioSetup(SfxID.BLATHER_1, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/blather_dot.wav");
            audioSetup.myVolume = 0.4;
            audioSetup.myReferenceDistance = 1000000;
            manager.addAudioSetup(SfxID.BLATHER_DOT, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/ring_rise.wav");
            audioSetup.myVolume = 0.5;
            audioSetup.myRate = 0.8;
            manager.addAudioSetup(SfxID.RING_RISE, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/hand_piece_appear.wav");
            audioSetup.myVolume = 0.2;
            manager.addAudioSetup(SfxID.HAND_PIECE_APPEAR, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/mr_NOT_appear.wav");
            audioSetup.myReferenceDistance = 1000000;
            audioSetup.myPitch = 0.8;
            audioSetup.myVolume = 0.85;
            manager.addAudioSetup(SfxID.MR_NOT_APPEAR, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/mr_NOT_disappear.wav");
            audioSetup.myReferenceDistance = 1000000;
            audioSetup.myPitch = 0.8;
            audioSetup.myVolume = 0.45;
            manager.addAudioSetup(SfxID.MR_NOT_DISAPPEAR, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/title_appear.wav");
            audioSetup.myReferenceDistance = 1000000;
            audioSetup.myPitch = 0.8;
            audioSetup.myVolume = 0.55;
            manager.addAudioSetup(SfxID.TITLE_APPEAR, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/title_disappear.wav");
            audioSetup.myReferenceDistance = 1000000;
            audioSetup.myPitch = 0.8;
            audioSetup.myVolume = 0.8;
            manager.addAudioSetup(SfxID.TITLE_DISAPPEAR, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/mr_NOT_explode.wav");
            audioSetup.myVolume = 0.95;
            audioSetup.myReferenceDistance = 3;
            manager.addAudioSetup(SfxID.CLONE_EXPLODE, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/mr_NOT_explode.wav");
            audioSetup.myVolume = 0.95;
            audioSetup.myReferenceDistance = 3;
            manager.addAudioSetup(SfxID.MR_NOT_EXPLODE, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/evidence_appear.wav");
            audioSetup.myVolume = 0.2;
            audioSetup.myReferenceDistance = 3;
            manager.addAudioSetup(SfxID.EVIDENCE_APPEAR, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/evidence_disappear.wav");
            audioSetup.myVolume = 0.5;
            audioSetup.myReferenceDistance = 3;
            manager.addAudioSetup(SfxID.EVIDENCE_DISAPPEAR, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/clone_appear.wav");
            audioSetup.myVolume = 0.65;
            audioSetup.myReferenceDistance = 1000000;
            manager.addAudioSetup(SfxID.CLONE_APPEAR, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/mr_NOT_fast_appear.wav");
            audioSetup.myRate = 1.5;
            audioSetup.myVolume = 0.6;
            audioSetup.myReferenceDistance = 1000000;
            manager.addAudioSetup(SfxID.MR_NOT_FAST_APPEAR, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/grab.wav");
            audioSetup.myVolume = 0.55;
            audioSetup.myReferenceDistance = 0.3;
            manager.addAudioSetup(SfxID.GRAB, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/throw.wav");
            audioSetup.myRate = 0.7;
            audioSetup.myVolume = 0.225;
            audioSetup.myReferenceDistance = 0.3;
            manager.addAudioSetup(SfxID.THROW, audioSetup);
        }

        {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/collision.wav");
            audioSetup.myRate = 0.8;
            audioSetup.myVolume = 0.5;
            audioSetup.myReferenceDistance = 0.3;
            manager.addAudioSetup(SfxID.COLLISION, audioSetup);
        }

        manager.createAudioPlayer(SfxID.RING_RISE);
        for (let i = 0; i <= SfxID.BLATHER_DOT; i++) {
            manager.createAudioPlayer(i);
        }

        //This MAY avoid some crackle on first play with position
        let ringRise = manager.createAudioPlayer(SfxID.RING_RISE);
        ringRise.setVolume(0);
        ringRise.updatePosition([0, -10000, 0]);
        ringRise.play();
        ringRise.updatePosition([0, -10000, 0]);
    }
}

var SfxID = {
    NOT_ENOUGH: 0,
    BLATHER_0: 1,
    BLATHER_1: 2,
    RING_RISE: 3,
    HAND_PIECE_APPEAR: 4,
    MR_NOT_APPEAR: 5,
    MR_NOT_DISAPPEAR: 6,
    TITLE_APPEAR: 7,
    TITLE_DISAPPEAR: 8,
    CLONE_EXPLODE: 9,
    MR_NOT_EXPLODE: 10,
    EVIDENCE_APPEAR: 11,
    EVIDENCE_DISAPPEAR: 12,
    CLONE_APPEAR: 13,
    MR_NOT_FAST_APPEAR: 14,
    YOU_KNOW: 15,
    GRAB: 16,
    THROW: 17,
    COLLISION: 18,
    BLATHER_DOT: 19,
};
WL.registerComponent("enough-IS-enough-gateway", {
    _myPlayerRumbleObject: { type: WL.Type.Object },
    _myRingAnimator: { type: WL.Type.Object },
    _myLeftHandAnimator: { type: WL.Type.Object },
    _myRightHandAnimator: { type: WL.Type.Object },
}, {
    init: function () {
        Global.myGoogleAnalytics = window.gtag != null;
        //Global.myGoogleAnalytics = false;
        Global.myAudioManager = new PP.AudioManager();
        Global.myParticlesManager = new ParticlesManager();
        Global.myMeshObjectPoolMap = new PP.ObjectPoolManager();
        Global.myMeshNoFogObjectPoolMap = new PP.ObjectPoolManager();
        Global.myGameObjectPoolMap = new PP.ObjectPoolManager();
        Global.mySaveManager = new PP.SaveManager();
        //Global.mySaveManager.clear();
        Global.myScene = this.object;

        Global.myPlayerRumbleObject = this._myPlayerRumbleObject;
        Global.myRingAnimator = this._myRingAnimator.pp_getComponent("ring-animator");
        Global.myLeftHandAnimator = this._myLeftHandAnimator.pp_getComponent("hand-animator");
        Global.myRightHandAnimator = this._myRightHandAnimator.pp_getComponent("hand-animator");

        this.enoughISenough = new enoughISenough();

        Global.myAudioManager.setVolume(1);

        this._myFirstUpdate = true;
        this._myIncreasePool = false;
        this._myMeshObjectPoolSize = 20;
        this._myGameObjectPoolSize = 40;
        this._myUpdateReadyCountdown = 10;
        this._myLoadTimeSent = false;
    },
    start: function () {
        let version = Global.mySaveManager.loadNumber("game_version", 0);
        Global.myGameVersion = 12;

        let minVersionToReset = 6;
        if (version < minVersionToReset) {
            Global.mySaveManager.clear();
            Global.mySaveManager.save("game_version", Global.myGameVersion);
        } else if (version < Global.myGameVersion) {
            Global.mySaveManager.save("game_version", Global.myGameVersion);
        }

        let trialStartedOnce = Global.mySaveManager.loadBool("trial_started_once", false);
        let trialPhase = Global.mySaveManager.loadNumber("trial_phase", 1);
        let trialCompleted = Global.mySaveManager.loadBool("trial_completed", false);
        Global.myEnableSelectPhysx = trialCompleted || (trialStartedOnce && trialPhase >= 2);
    },
    update: function (dt) {
        if (this._myFirstUpdate) {
            this._myFirstUpdate = false;
            this._start();
            PP.setEasyTuneWidgetActiveVariable("Float 1");
        } else if (!Global.myUpdateReady) {
            if (!this._myLoadTimeSent) {
                if (window.performance) {
                    if (Global.myGoogleAnalytics) {
                        gtag("event", "load_time", {
                            "value": (performance.now() / 1000).toFixed(2)
                        });
                    }
                }

                this._myLoadTimeSent = true;
            }

            this._myUpdateReadyCountdown--;
            if (this._myUpdateReadyCountdown <= 0) {
                Global.myUpdateReady = true;
            }
        }

        if (Global.myUpdateReady) {
            if (this._myIncreasePool) {
                this._increasePools();
            } else {
                this.enoughISenough.update(dt * Global.myDeltaTimeSpeed);
                Global.myParticlesManager.update(dt * Global.myDeltaTimeSpeed);
                Global.mySaveManager.update(dt * Global.myDeltaTimeSpeed);
            }

            if (Global.myZestyToClick != null) {
                if (Global.myGoogleAnalytics) {
                    gtag("event", "zesty_market_opened", {
                        "value": 1
                    });
                }

                Global.myZestyToClick.onClick();
                Global.myZestyToClick = null;
            }
        }
    },
    _start() {
        //let componentAmountMapBeforeLoad = Global.myScene.pp_getComponentAmountMapHierarchy();
        //console.error(componentAmountMapBeforeLoad);

        WL.scene.reserveObjects(10700, { "mesh": 5850, "text": 800, "collision": 70, "text-color-fog": 140 });

        {
            let staringCube = Global.myGameObjects.get(GameObjectType.STARING_CUBE);
            PP.MeshUtils.setClonedMaterials(staringCube);
            let cloneParams = new PP.CloneParams();
            cloneParams.myComponentsToInclude.push("mesh");
            Global.myMeshObjects.set(GameObjectType.STARING_CUBE, staringCube.pp_clone(cloneParams));
        }

        for (let entry of Global.myMeshObjects.entries()) {
            if (entry[0] != GameObjectType.STARING_CUBE && entry[0] != GameObjectType.ZESTY_MARKET) {
                PP.MeshUtils.setClonedMaterials(entry[1]);
                PP.TextUtils.setClonedMaterials(entry[1]);
            }
            entry[1].pp_setActive(false);

            let clonedMesh = entry[1].pp_clone();
            PP.MeshUtils.setClonedMaterials(clonedMesh);
            PP.TextUtils.setClonedMaterials(clonedMesh);
            PP.MeshUtils.setFogColor(clonedMesh, [0, 0, 0, 0]);
            Global.myMeshNoFogObjects.set(entry[0], clonedMesh);
        }

        for (let entry of Global.myGameObjects.entries()) {
            if (entry[0] != GameObjectType.STARING_CUBE && entry[0] != GameObjectType.ZESTY_MARKET) {
                PP.MeshUtils.setClonedMaterials(entry[1]);
                PP.TextUtils.setClonedMaterials(entry[1]);
            }
            entry[1].pp_setActive(false);
        }

        let meshObjectPoolParams = new PP.ObjectPoolParams();
        meshObjectPoolParams.myInitialPoolSize = 20;
        meshObjectPoolParams.myPercentageToAddWhenEmpty = 0.2;

        for (let entry of Global.myMeshObjects.entries()) {
            Global.myMeshObjectPoolMap.addPool(entry[0], entry[1], meshObjectPoolParams);
        }

        for (let entry of Global.myMeshNoFogObjects.entries()) {
            Global.myMeshNoFogObjectPoolMap.addPool(entry[0], entry[1], meshObjectPoolParams);
        }

        Global.myMeshObjectPoolMap.increasePoolPercentage(GameObjectType.MR_NOT, 1.2);
        Global.myMeshNoFogObjectPoolMap.increasePoolPercentage(GameObjectType.MR_NOT, 1.2);
        Global.myMeshObjectPoolMap.increasePoolPercentage(GameObjectType.MR_NOT_CLONE, 1.2);
        Global.myMeshNoFogObjectPoolMap.increasePoolPercentage(GameObjectType.MR_NOT_CLONE, 1.2);

        let cloneParams = new PP.CloneParams();
        cloneParams.myDeepCloneParams.deepCloneComponentVariable("mesh", "material", true);
        let mrNOTCloneObjectPoolParams = new PP.ObjectPoolParams();
        mrNOTCloneObjectPoolParams.myInitialPoolSize = 40;
        mrNOTCloneObjectPoolParams.myPercentageToAddWhenEmpty = 0.2;
        mrNOTCloneObjectPoolParams.myCloneParams = cloneParams;
        Global.myGameObjectPoolMap.addPool(GameObjectType.MR_NOT_CLONE, Global.myGameObjects.get(GameObjectType.MR_NOT_CLONE), mrNOTCloneObjectPoolParams);

        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Float 1", 0, 10, 3));
        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Float 2", 30, 5, 3));
        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Float 3", 1.4, 5, 3));
        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Float 4", 4, 5, 3));
        PP.myEasyTuneVariables.add(new PP.EasyTuneInt("Int", 4, 1));
        PP.myEasyTuneVariables.add(new PP.EasyTuneBool("Bool", false));

        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("mr NOT Clone Scale", 0.35, 0.1, 3));
        PP.myEasyTuneVariables.add(new PP.EasyTuneBool("Prevent Vent Lost", false));

        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Explosion Particle Life", 0.15, 0.5, 3));
        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Explosion Particles Duration", 0.5, 0.5, 3));
        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Explosion Particles Delay", 0.05, 0.5, 3));
        PP.myEasyTuneVariables.add(new PP.EasyTuneInt("Explosion Particles Amount", 2, 10));

        PP.CAUtils.setDummyServer(new EIECADummyServer());
        PP.CAUtils.setUseDummyServerOnSDKMissing(true);
        PP.CAUtils.setUseDummyServerOnError(true);

        this.enoughISenough.start();

        /*
        let componentAmountMapAfterLoad = Global.myScene.pp_getComponentAmountMapHierarchy();
        //console.error(componentAmountMapAfterLoad);

        let componentAmountMapDifference = new Map();
        for (let entry of componentAmountMapAfterLoad.entries()) {
            valueBefore = componentAmountMapBeforeLoad.get(entry[0]);
            valueBefore = valueBefore == null ? 0 : valueBefore;
            let result = entry[1] - valueBefore;
            if (result > 0) {
                componentAmountMapDifference.set(entry[0], result);
            }
        }
        console.error(componentAmountMapDifference);
        */
    },
    _increasePools() {
        let amountToIncrease = 5;

        if (this._myMeshObjectPoolSize > 0) {
            this._myMeshObjectPoolSize -= amountToIncrease;

            for (let entry of Global.myMeshObjects.entries()) {
                Global.myMeshObjectPoolMap.increasePool(entry[0], amountToIncrease);
            }

            for (let entry of Global.myMeshNoFogObjects.entries()) {
                Global.myMeshNoFogObjectPoolMap.increasePool(entry[0], amountToIncrease);
            }
        }

        if (this._myGameObjectPoolSize > 0) {
            this._myGameObjectPoolSize -= amountToIncrease;

            Global.myGameObjectPoolMap.increasePool(GameObjectType.MR_NOT_CLONE, amountToIncrease);
        }

        if (this._myGameObjectPoolSize <= 0 && this._myMeshObjectPoolSize <= 0) {
            this._myIncreasePool = false;
            if (WL.xrSession) {
                console.clear();
            }
        }
    }
});

var Global = {
    myDeltaTimeSpeed: 1,
    myScene: null,
    myUpdateReady: false,
    myAudioManager: null,
    myParticlesManager: null,
    myPlayerRumbleObject: null,
    myRingAnimator: null,
    myLeftHandAnimator: null,
    myRightHandAnimator: null,
    myGameObjects: new Map(),
    myMeshObjects: new Map(),
    myMeshNoFogObjects: new Map(),
    myRingRadius: 0,
    myRingHeight: 0,
    myTitlesObject: null,
    myTitlesRumbleObject: null,
    myTitleObject: null,
    mySubtitleObject: null,
    myTitlePatchObject: null,
    myBigBlatherPatchObject: null,
    myMeshObjectPoolMap: null,
    myMeshNoFogObjectPoolMap: null,
    myGameObjectPoolMap: null,
    myMaterials: null,
    myTrialDuration: 0,
    myArcadeDuration: 0,
    myVentDuration: 0,
    myDebugShortcutsEnabled: false,
    myDebugShortcutsPress: 2,
    myPlayerPosition: [0, 0, 0],
    myPlayerRotation: [0, 0, 0],
    myPlayerForward: [0, 0, 1],
    myPlayerUp: [0, 1, 0],
    myLightFadeInTime: 0,
    myStartFadeOut: false,
    myStatistics: null,
    myIsInMenu: false,
    myIsInArcadeResult: false,
    myZestyToClick: null,
    myEnableSelectPhysx: false,
    mySaveManager: null,
    myDebugCurrentVentObject: null,
    myPlayMusic: false,
    myStopMusic: false,
    myGameVersion: 0,
    myGoogleAnalytics: false
};
WL.registerComponent('pp-tool-cursor', {
    _myHandedness: { type: WL.Type.Enum, values: ['left', 'right'], default: 'left' },
    _myPulseOnHover: { type: WL.Type.Bool, default: true },
    _myShowFingerCursor: { type: WL.Type.Bool, default: false },
    _myCursorMesh: { type: WL.Type.Mesh, default: null },
    _myCursorMaterial: { type: WL.Type.Material, default: null }
}, {
    init: function () {
        this._myHandednessString = ['left', 'right'][this._myHandedness];

        if (this._myHandedness == 0) {
            this._myCursorPosition = [-0.01, -0.024, -0.05];
        } else {
            this._myCursorPosition = [0.01, -0.024, -0.05];
        }

        this._myCursorRotation = [-0.382, 0, 0, 0.924];
        this._myCursorRotation = glMatrix.quat.normalize(this._myCursorRotation, this._myCursorRotation);
        this._myCursorMeshScale = [0.0025, 0.0025, 0.0025];

        this._myCursorColor = [255 / 255, 255 / 255, 255 / 255, 1];

        this._myCursorTargetCollisionGroup = 7;
    },
    start: function () {
        this._myFixForwardObject = WL.scene.addObject(this.object);
        this._myFixForwardObject.pp_rotateObject([0, 180, 0]);
        this._myCursorObject = WL.scene.addObject(this._myFixForwardObject);
        this._myCursorObject.setTranslationLocal(this._myCursorPosition);
        this._myCursorObject.rotateObject(this._myCursorRotation);

        this._myCursorMeshObject = WL.scene.addObject(this._myCursorObject);
        this._myCursorMeshObject.scale(this._myCursorMeshScale);

        this._myCursorMeshComponent = this._myCursorMeshObject.addComponent("mesh");
        this._myCursorMeshComponent.mesh = this._myCursorMesh;
        this._myCursorMeshComponent.material = this._myCursorMaterial.clone();
        this._myCursorMeshComponent.material.color = this._myCursorColor;

        this._myCursorComponent = this._myCursorObject.addComponent("cursor", { "collisionGroup": this._myCursorTargetCollisionGroup, "handedness": this._myHandedness + 1 });
        this._myCursorComponent.cursorObject = this._myCursorMeshObject;
        this._myCursorComponent.rayCastMode = 0; //collision
        if (this._myPulseOnHover) {
            this._myCursorComponent.globalTarget.addHoverFunction(this._pulseOnHover.bind(this));
        }

        this._myFingerCursorComponent = this.object.addComponent("pp-finger-cursor", {
            "_myHandedness": this._myHandedness,
            "_myEnableMultipleClicks": true,
            "_myCollisionGroup": this._myCursorTargetCollisionGroup,
            "_myCursorMesh": (this._myShowFingerCursor ? this._myCursorMesh : null),
            "_myCursorMaterial": this._myCursorMeshComponent.material
        });
        this._myFingerCursorComponent.setActive(false);
    },
    update: function (dt) {
        let isUsingHand = this._isUsingHand();

        this._myFingerCursorComponent.setActive(isUsingHand);

        this._myCursorComponent.active = !isUsingHand;
        if (!this._myCursorComponent.active) {
            this._myCursorComponent._setCursorVisibility(false);
        }
    },
    _isUsingHand: function () {
        let isUsingHand = false;

        if (WL.xrSession && WL.xrSession.inputSources) {
            for (let i = 0; i < WL.xrSession.inputSources.length; i++) {
                let input = WL.xrSession.inputSources[i];
                if (input.hand && input.handedness == this._myHandednessString) {
                    isUsingHand = true;
                    break;
                }
            }
        }

        return isUsingHand;
    },
    _pulseOnHover: function (object) {
        let targetComponent = object.getComponent("cursor-target");

        if (targetComponent && !targetComponent.myPreventPulseOnHover) {
            if (this._myHandedness == 0) {
                if (PP.myLeftGamepad) {
                    PP.myLeftGamepad.pulse(0.4, 0);
                }
            } else {
                if (PP.myRightGamepad) {
                    PP.myRightGamepad.pulse(0.4, 0);
                }
            }
        }
    }
});
/*
    How to use

    Warning: The extension is a WIP so not all the methods are available for all kinds of vector.

    By default rotations are in Degrees and transforms are Matrix 4 (and not Quat 2)    
    For methods that work with rotations, Matrix means Matrix 3 and Quat means Quat
    For methods that work with transforms, Matrix means Matrix 4 and Quat means Quat 2
    
    For rotations u can add a suffix like Degrees/Radians/Quat/Matrix to use a specific version, example:
        - vec3_rotateAroundRadians
        - vec3_degreesAddRotationDegrees
        
    For transform u can add a suffix like Quat/Matrix to use a specific version, example:
        - vec3_convertPositionToWorldMatrix
        - vec3_convertDirectionToWorldQuat

    Some vec3 methods let u add a prefix to specify if the vec3 represent a rotation in degrees or radians, where degrees is the default:
        - vec3_toQuat
        - vec3_degreesToQuat
        - vec3_radiansToQuat
        - vec3_degreesAddRotation

    Rotation operations return a rotation of the same kind of the starting variable:
        - vec3_degreesAddRotationQuat   -> returns a rotation in degrees
        - quat_rotationToDegrees        -> returns a rotation in quat

    The methods leave u the choice of forwarding an out parameter or just get the return value, example:
        - let quat = this.vec3_toQuat()
        - this.vec3_toQuat(quat)
        - the out parameter is always the last one

    List of methods:
        Note:
            - If a group of methods starts with ○ it means it modifies the variable itself
            - The suffixes (like Matrix or Radians) or prefixes (like degrees) are omitted 

        CREATION (u can call these functions without any object):
            - vec3_create

            - quat_create

            - quat2_create
            - quat2_fromPositionRotation

            - mat4_create
            - mat4_fromPositionRotation     / mat4_fromPositionRotationScale

        ARRAY:
            - pp_has        / pp_hasEqual
            - pp_find       / pp_findAll        / pp_findEquals / pp_findAllEqual
            ○ pp_remove     / pp_removeIndex    / pp_removeAll  / pp_removeEqual    / pp_removeAllEqual
            ○ pp_pushUnique / pp_unshiftUnique
            ○ pp_copy    
            - pp_clone      
            - pp_equals      

        GENERIC VECTOR (array with only numbers):
            - vec_scale
            - vec_round     / vec_floor         / vec_ceil      / vec_clamp
            - vec_log       / vec_error         / vec_warn      

        VECTOR 3:
            ○ vec3_set      / vec3_copy     / vec3_zero
            - vec3_clone 
            - vec3_normalize    / vec3_negate
            - vec3_isNormalized
            - vec3_length
            - vec3_distance
            - vec3_add      / vec3_sub          / vec3_mul      / vec3_div      / vec3_scale
            - vec3_componentAlongAxis           / vec3_removeComponentAlongAxis
            - vec3_isConcordant
            - vec3_convertPositionToWorld       / vec3_convertPositionToLocal 
            - vec3_convertDirectionToWorld      / vec3_convertDirectionToLocal   
            - vec3_angle
            - vec3_toRadians        / vec3_toDegrees            / vec3_toQuat       / vec3_toMatrix
            - vec3_rotate           / vec3_rotateAxis           / vec3_rotateAround / vec3_rotateAroundAxis
            - vec3_addRotation
            - vec3_log       / vec3_error         / vec3_warn     
            
        VECTOR 4:
            ○ vec4_set

        QUAT:
            ○ quat_set          / quat_copy     / quat_identity
            - quat_normalize    / quat_invert
            - quat_isNormalized
            - quat_length
            - quat_mul
            - quat_getAxis  / quat_getAngle
            ○ quat_fromRadians      / quat_fromDegrees      / quat_fromAxisAngle
            - quat_toRadians        / quat_toDegrees        / quat_toMatrix
            - quat_addRotation      / quat_subRotation
            - quat_rotationTo

        QUAT 2:
            ○ quat2_copy        / quat2_identity
            - quat2_normalize
            - quat2_getPosition     / quat2_getRotation
            ○ quat2_setPositionRotation
            - quat2_getAxes
            - quat2_toWorld     / quat2_toLocal
            - quat2_toMatrix
            ○ quat2_fromMatrix

        MATRIX 3:
            - mat3_toDegrees    / mat3_toRadians    / mat3_toQuat

        MATRIX 4:
            ○ mat4_copy         / mat4_identity
            - mat4_clone
            - mat4_invert
            - mat4_getPosition  / mat4_getRotation  / mat4_getScale
            ○ mat4_setPosition  / mat4_setRotation  / mat4_setScale
            ○ mat4_setPositionRotation      / mat4_setPositionRotationScale
            - mat4_getAxes
            - mat4_toWorld      / mat4_toLocal
            - mat4_hasUniformScale
            - mat4_toQuat
            ○ mat4_fromQuat
*/

//ARRAY

Array.prototype.pp_has = function (callback) {
    return this.pp_find(callback) != undefined;
};

Array.prototype.pp_hasEquals = function (elementToFind) {
    return this.pp_findEqual(elementToFind) != undefined;
};

Array.prototype.pp_find = function (callback) {
    let elementFound = undefined;

    let index = this.findIndex(callback);
    if (index >= 0) {
        elementFound = this[index];
    }

    return elementFound;
};

Array.prototype.pp_findAll = function (callback) {
    let elementsFound = this.filter(callback);

    return elementsFound;
};

Array.prototype.pp_findEqual = function (elementToFind) {
    return this.pp_find(element => element === elementToFind);
};

Array.prototype.pp_findAllEqual = function (elementToFind) {
    return this.pp_findAll(element => element === elementToFind);
};

Array.prototype.pp_removeIndex = function (index) {
    let elementRemoved = undefined;

    if (index >= 0 && index < this.length) {
        let arrayRemoved = this.splice(index, 1);
        if (arrayRemoved.length == 1) {
            elementRemoved = arrayRemoved[0];
        }
    }

    return elementRemoved;
};

Array.prototype.pp_remove = function (callback) {
    let elementRemoved = undefined;

    let index = this.findIndex(callback);
    if (index >= 0) {
        elementRemoved = this.pp_removeIndex(index);
    }

    return elementRemoved;
};

Array.prototype.pp_removeAll = function (callback) {
    let elementsRemoved = [];

    let currentElement = undefined;
    do {
        currentElement = this.pp_remove(callback);
        if (currentElement !== undefined) {
            elementsRemoved.push(currentElement);
        }
    } while (currentElement !== undefined);

    return elementsRemoved;
};

Array.prototype.pp_removeEqual = function (elementToRemove) {
    return this.pp_remove(element => element === elementToRemove);
};

Array.prototype.pp_removeAllEqual = function (elementToRemove) {
    return this.pp_removeAll(element => element === elementToRemove);
};

Array.prototype.pp_pushUnique = function (element, hasElementCallback = null) {
    let length = this.length;

    let hasElement = false;
    if (hasElementCallback != null) {
        hasElement = this.pp_has(hasElementCallback);
    } else {
        hasElement = this.pp_hasEquals(element);
    }

    if (!hasElement) {
        length = this.push(element);
    }

    return length;
};

Array.prototype.pp_unshiftUnique = function (element, hasElementCallback = null) {
    let length = this.length;

    let hasElement = false;
    if (hasElementCallback != null) {
        hasElement = this.pp_has(hasElementCallback);
    } else {
        hasElement = this.pp_hasEquals(element);
    }

    if (!hasElement) {
        length = this.unshift(element);
    }

    return length;
};

Array.prototype.pp_copy = function (array) {
    while (this.length > array.length) {
        this.pop();
    }

    for (let i = 0; i < array.length; i++) {
        this[i] = array[i];
    }

    return this;
};

Array.prototype.pp_clone = function () {
    return this.slice(0);
};

Array.prototype.pp_equals = function (array, elementEqualsCallback = null) {
    let equals = true;

    if (array != null && this.length == array.length) {
        for (let i = 0; i < this.length; i++) {
            if ((elementEqualsCallback != null && !elementEqualsCallback(this[i], array[i])) ||
                (elementEqualsCallback == null && this[i] != array[i])) {
                equals = false;
                break;
            }
        }
    } else {
        equals = false;
    }

    return equals;
};

// GENERIC VECTOR

Array.prototype.vec_toString = function (decimalPlaces = 4) {
    let message = this._vec_buildConsoleMessage(decimalPlaces);
    return message;
};

Array.prototype.vec_log = function (decimalPlaces = 4) {
    let message = this._vec_buildConsoleMessage(decimalPlaces);
    console.log(message);
};

Array.prototype.vec_error = function (decimalPlaces = 4) {
    let message = this._vec_buildConsoleMessage(decimalPlaces);
    console.error(message);
};

Array.prototype.vec_warn = function (decimalPlaces = 4) {
    let message = this._vec_buildConsoleMessage(decimalPlaces);
    console.warn(message);
};

Array.prototype.vec_scale = function (value, out = null) {
    out = this._vec_prepareOut(out);

    for (let i = 0; i < out.length; i++) {
        out[i] = out[i] * value;
    }

    return out;
};

Array.prototype.vec_round = function (out = null) {
    out = this._vec_prepareOut(out);

    for (let i = 0; i < out.length; i++) {
        out[i] = Math.round(out[i]);
    }

    return out;
};

Array.prototype.vec_floor = function (out = null) {
    out = this._vec_prepareOut(out);

    for (let i = 0; i < out.length; i++) {
        out[i] = Math.floor(out[i]);
    }

    return out;
};

Array.prototype.vec_ceil = function (out = null) {
    out = this._vec_prepareOut(out);

    for (let i = 0; i < out.length; i++) {
        out[i] = Math.ceil(out[i]);
    }

    return out;
};

Array.prototype.vec_clamp = function (start, end, out = null) {
    out = this._vec_prepareOut(out);

    let fixedStart = (start != null) ? start : Number.MIN_VALUE;
    let fixedEnd = (end != null) ? end : Number.MAX_VALUE;
    let min = Math.min(fixedStart, fixedEnd);
    let max = Math.max(fixedStart, fixedEnd);

    for (let i = 0; i < out.length; i++) {
        out[i] = Math.min(Math.max(out[i], min), max);
    }

    return out;
};

Array.prototype.vec_equals = function (vector) {
    let equals = this.length == vector.length;

    for (let i = 0; i < this.length && equals; i++) {
        equals &= Math.abs(this[i] - vector[i]) < this._pp_epsilon;
    }

    return equals;
};

// VECTOR 3

//glMatrix Bridge

Array.prototype.vec3_normalize = function (out = glMatrix.vec3.create()) {
    glMatrix.vec3.normalize(out, this);
    return out;
};

Array.prototype.vec3_copy = function (vector) {
    glMatrix.vec3.copy(this, vector);
    return this;
};

Array.prototype.vec3_clone = function (out = glMatrix.vec3.create()) {
    glMatrix.vec3.copy(out, this);
    return out;
};

Array.prototype.vec3_set = function (x, y = null, z = null) {
    if (y == null) {
        glMatrix.vec3.set(this, x, x, x);
    } else {
        glMatrix.vec3.set(this, x, y, z);
    }
    return this;
};

Array.prototype.vec3_zero = function () {
    glMatrix.vec3.zero(this);
    return this;
};

Array.prototype.vec3_angle = function (vector) {
    return this.vec3_angleDegrees(vector);
};

Array.prototype.vec3_angleDegrees = function (vector) {
    return this.vec3_angleRadians(vector) * (180 / Math.PI);
};

Array.prototype.vec3_angleRadians = function (vector) {
    return glMatrix.vec3.angle(this, vector);
};

Array.prototype.vec3_length = function () {
    return glMatrix.vec3.length(this);
};

Array.prototype.vec3_distance = function (vector) {
    return glMatrix.vec3.dist(this, vector);
};

Array.prototype.vec3_add = function (vector, out = glMatrix.vec3.create()) {
    glMatrix.vec3.add(out, this, vector);
    return out;
};

Array.prototype.vec3_sub = function (vector, out = glMatrix.vec3.create()) {
    glMatrix.vec3.sub(out, this, vector);
    return out;
};

Array.prototype.vec3_mul = function (vector, out = glMatrix.vec3.create()) {
    glMatrix.vec3.mul(out, this, vector);
    return out;
};

Array.prototype.vec3_div = function (vector, out = glMatrix.vec3.create()) {
    glMatrix.vec3.div(out, this, vector);
    return out;
};

Array.prototype.vec3_scale = function (value, out = glMatrix.vec3.create()) {
    glMatrix.vec3.scale(out, this, value);
    return out;
};

Array.prototype.vec3_negate = function (out = glMatrix.vec3.create()) {
    glMatrix.vec3.negate(out, this);
    return out;
};

Array.prototype.vec3_cross = function (vector, out = glMatrix.vec3.create()) {
    glMatrix.vec3.cross(out, this, vector);
    return out;
};

//New Methods

Array.prototype.vec3_angleSigned = function (vector, axis) {
    return this.vec3_angleSignedDegrees(vector, axis);
};

Array.prototype.vec3_angleSignedDegrees = function (vector, axis) {
    return this.vec3_angleSignedRadians(vector, axis) * (180 / Math.PI);
};

Array.prototype.vec3_angleSignedRadians = function () {
    let crossAxis = glMatrix.vec3.create();
    return function (vector, axis) {
        this.vec3_cross(vector, crossAxis);
        let angle = this.vec3_angleRadians(vector);
        if (!crossAxis.vec3_isConcordant(axis)) {
            angle = -angle;
        }

        return angle;
    };
}();

Array.prototype.vec3_toRadians = function (out = glMatrix.vec3.create()) {
    glMatrix.vec3.set(out, glMatrix.glMatrix.toRadian(this[0]), glMatrix.glMatrix.toRadian(this[1]), glMatrix.glMatrix.toRadian(this[2]));
    return out;
};

Array.prototype.vec3_toDegrees = function (out = glMatrix.vec3.create()) {
    glMatrix.vec3.set(out, this[0] * (180 / Math.PI), this[1] * (180 / Math.PI), this[2] * (180 / Math.PI));
    return out;
};

Array.prototype.vec3_toQuat = function (out) {
    return this.vec3_degreesToQuat(out);
};

Array.prototype.vec3_radiansToQuat = function (out = glMatrix.quat.create()) {
    out.quat_fromRadians(this);
    return out;
};

Array.prototype.vec3_degreesToQuat = function (out = glMatrix.quat.create()) {
    out.quat_fromDegrees(this);
    return out;
};

Array.prototype.vec3_isNormalized = function () {
    return Math.abs(glMatrix.vec3.length(this) - 1) < this._pp_epsilon;
};

Array.prototype.vec3_componentAlongAxis = function (axis, out = glMatrix.vec3.create()) {
    let angle = glMatrix.vec3.angle(this, axis);
    let length = Math.cos(angle) * glMatrix.vec3.length(this);

    glMatrix.vec3.copy(out, axis);
    glMatrix.vec3.scale(out, out, length);
    return out;
};

Array.prototype.vec3_removeComponentAlongAxis = function () {
    let componentAlong = glMatrix.vec3.create();
    return function (axis, out = glMatrix.vec3.create()) {
        this.vec3_componentAlongAxis(axis, componentAlong);
        glMatrix.vec3.sub(out, this, componentAlong);
        return out;
    };
}();

Array.prototype.vec3_isConcordant = function (vector) {
    return glMatrix.vec3.angle(this, vector) <= Math.PI / 2;
};

Array.prototype.vec3_rotate = function (rotation, out) {
    return this.vec3_rotateDegrees(rotation, out);
};

Array.prototype.vec3_rotateDegrees = function () {
    let zero = glMatrix.vec3.create();
    return function (rotation, out) {
        return this.vec3_rotateAroundDegrees(rotation, zero, out);
    };
}();

Array.prototype.vec3_rotateRadians = function () {
    let zero = glMatrix.vec3.create();
    return function (rotation, out) {
        return this.vec3_rotateAroundRadians(rotation, zero, out);
    };
}();

Array.prototype.vec3_rotateQuat = function () {
    let zero = glMatrix.vec3.create();
    return function (rotation, out) {
        return this.vec3_rotateAroundQuat(rotation, zero, out);
    };
}();

Array.prototype.vec3_rotateAxis = function (angle, axis, out) {
    return this.vec3_rotateAxisDegrees(angle, axis, out);
};

Array.prototype.vec3_rotateAxisDegrees = function () {
    let zero = glMatrix.vec3.create();
    return function (angle, axis, out) {
        return this.vec3_rotateAroundAxisDegrees(angle, axis, zero, out);
    };
}();

Array.prototype.vec3_rotateAxisRadians = function () {
    let zero = glMatrix.vec3.create();
    return function (angle, axis, out) {
        return this.vec3_rotateAroundAxisRadians(angle, axis, zero, out);
    };
}();

Array.prototype.vec3_rotateAround = function (rotation, origin, out) {
    return this.vec3_rotateAroundDegrees(rotation, origin, out);
};

Array.prototype.vec3_rotateAroundDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, origin, out = glMatrix.vec3.create()) {
        rotation.vec3_degreesToQuat(quat);
        return this.vec3_rotateAroundQuat(quat, origin, out);
    };
}();

Array.prototype.vec3_rotateAroundRadians = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, origin, out = glMatrix.vec3.create()) {
        rotation.vec3_radiansToQuat(quat);
        return this.vec3_rotateAroundQuat(quat, origin, out);
    };
}();

Array.prototype.vec3_rotateAroundQuat = function (rotation, origin, out = glMatrix.vec3.create()) {
    glMatrix.vec3.sub(out, this, origin);
    glMatrix.vec3.transformQuat(out, out, rotation);
    glMatrix.vec3.add(out, out, origin);
    return out;
};

Array.prototype.vec3_rotateAroundAxis = function (angle, axis, origin, out) {
    return this.vec3_rotateAroundAxisDegrees(angle, axis, origin, out);
};

Array.prototype.vec3_rotateAroundAxisDegrees = function (angle, axis, origin, out) {
    return this.vec3_rotateAroundAxisRadians(glMatrix.glMatrix.toRadian(angle), axis, origin, out);
};

Array.prototype.vec3_rotateAroundAxisRadians = function () {
    let quat = glMatrix.quat.create();
    return function (angle, axis, origin, out = glMatrix.vec3.create()) {
        glMatrix.quat.setAxisAngle(quat, axis, angle);
        return this.vec3_rotateAroundQuat(quat, origin, out);
    };
}();

Array.prototype.vec3_convertPositionToWorld = function (parentTransform, out) {
    return this.vec3_convertPositionToWorldMatrix(parentTransform, out);
};

Array.prototype.vec3_convertPositionToLocal = function (parentTransform, out) {
    return this.vec3_convertPositionToLocalMatrix(parentTransform, out);
};

Array.prototype.vec3_convertPositionToWorldMatrix = function (parentTransform, out = glMatrix.vec3.create()) {
    glMatrix.vec3.transformMat4(out, this, parentTransform);
    return out;
};

Array.prototype.vec3_convertPositionToLocalMatrix = function () {
    let inverse = glMatrix.mat4.create();
    return function (parentTransform, out = glMatrix.vec3.create()) {
        glMatrix.mat4.invert(inverse, parentTransform);
        glMatrix.vec3.transformMat4(out, this, inverse);
        return out;
    };
}();

Array.prototype.vec3_convertPositionToWorldQuat = function () {
    let parentTransformMatrix = glMatrix.mat4.create();
    let position = glMatrix.vec3.create();
    let rotation = glMatrix.quat.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (parentTransform, out = glMatrix.vec3.create()) {
        parentTransform.quat2_getPosition(position);
        parentTransform.quat2_getRotationQuat(rotation);
        parentTransformMatrix.mat4_setPositionRotationQuatScale(position, rotation, one);
        return this.vec3_convertPositionToWorldMatrix(parentTransformMatrix, out);
    };
}();

Array.prototype.vec3_convertPositionToLocalQuat = function () {
    let parentTransformMatrix = glMatrix.mat4.create();
    let position = glMatrix.vec3.create();
    let rotation = glMatrix.quat.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (parentTransform, out = glMatrix.vec3.create()) {
        parentTransform.quat2_getPosition(position);
        parentTransform.quat2_getRotationQuat(rotation);
        parentTransformMatrix.mat4_setPositionRotationQuatScale(position, rotation, one);
        return this.vec3_convertPositionToLocalMatrix(parentTransformMatrix, out);
    };
}();

Array.prototype.vec3_convertDirectionToWorld = function (parentTransform, out) {
    return this.vec3_convertDirectionToWorldMatrix(parentTransform, out);
};

Array.prototype.vec3_convertDirectionToLocal = function (parentTransform, out) {
    return this.vec3_convertDirectionToLocalMatrix(parentTransform, out);
};

Array.prototype.vec3_convertDirectionToWorldMatrix = function () {
    let rotation = glMatrix.quat.create();
    return function (parentTransform, out = glMatrix.vec3.create()) {
        parentTransform.mat4_getRotationQuat(rotation);
        glMatrix.vec3.transformQuat(out, this, rotation);
        return out;
    };
}();

Array.prototype.vec3_convertDirectionToLocalMatrix = function () {
    let rotation = glMatrix.quat.create();
    return function (parentTransform, out = glMatrix.vec3.create()) {
        parentTransform.mat4_getRotationQuat(rotation);
        glMatrix.quat.conjugate(rotation, rotation);
        glMatrix.vec3.transformQuat(out, this, rotation);
        return out;
    };
}();


Array.prototype.vec3_convertDirectionToWorldQuat = function () {
    let rotation = glMatrix.quat.create();
    return function (parentTransform, out = glMatrix.vec3.create()) {
        parentTransform.quat2_getRotationQuat(rotation);
        glMatrix.vec3.transformQuat(out, this, rotation);
        return out;
    };
}();

Array.prototype.vec3_convertDirectionToLocalQuat = function () {
    let rotation = glMatrix.quat.create();
    return function (parentTransform, out = glMatrix.vec3.create()) {
        parentTransform.quat2_getRotationQuat(rotation);
        glMatrix.quat.conjugate(rotation, rotation);
        glMatrix.vec3.transformQuat(out, this, rotation);
        return out;
    };
}();

Array.prototype.vec3_log = function (decimalPlaces = 4) {
    this.vec_log(decimalPlaces);
};

Array.prototype.vec3_error = function (decimalPlaces = 4) {
    this.vec_error(decimalPlaces);
};

Array.prototype.vec3_warn = function (decimalPlaces = 4) {
    this.vec_warn(decimalPlaces);
};

Array.prototype.vec3_addRotation = function (rotation, out) {
    return this.vec3_degreesAddRotation(rotation, out);
};

Array.prototype.vec3_addRotationDegrees = function (rotation, out) {
    return quat.vec3_degreesAddRotationDegrees(rotation, out);
};

Array.prototype.vec3_addRotationRadians = function (rotation, out) {
    return quat.vec3_degreesAddRotationRadians(rotation, out);
};

Array.prototype.vec3_addRotationQuat = function (rotation, out) {
    return quat.vec3_degreesAddRotationQuat(rotation, out);
};

Array.prototype.vec3_degreesAddRotation = function (rotation, out) {
    return this.vec3_degreesAddRotationDegrees(rotation, out);
};

Array.prototype.vec3_degreesAddRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out = glMatrix.vec3.create()) {
        this.vec3_degreesToQuat(quat);
        return quat.quat_addRotationDegrees(rotation, quat).quat_toDegrees(out);
    };
}();

Array.prototype.vec3_degreesAddRotationRadians = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out = glMatrix.vec3.create()) {
        this.vec3_degreesToQuat(quat);
        return quat.quat_addRotationRadians(rotation, quat).quat_toDegrees(out);
    };
}();

Array.prototype.vec3_degreesAddRotationQuat = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out = glMatrix.vec3.create()) {
        this.vec3_degreesToQuat(quat);
        return quat.quat_addRotationQuat(rotation, quat).quat_toDegrees(out);
    };
}();

Array.prototype.vec3_radiansAddRotation = function (rotation, out) {
    return this.vec3_radiansAddRotationDegrees(rotation, out);
};

Array.prototype.vec3_radiansAddRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out = glMatrix.vec3.create()) {
        this.vec3_radiansToQuat(quat);
        return quat.quat_addRotationDegrees(rotation, quat).quat_toRadians(out);
    };
}();

Array.prototype.vec3_radiansAddRotationRadians = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out = glMatrix.vec3.create()) {
        this.vec3_radiansToQuat(quat);
        return quat.quat_addRotationRadians(rotation, quat).quat_toRadians(out);
    };
}();

Array.prototype.vec3_radiansAddRotationQuat = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out = glMatrix.vec3.create()) {
        this.vec3_radiansToQuat(quat);
        return quat.quat_addRotationQuat(rotation, quat).quat_toRadians(out);
    };
}();

Array.prototype.vec3_toMatrix = function (out = glMatrix.mat3.create()) {
    return this.vec3_degreesToMatrix(out);
};

Array.prototype.vec3_degreesToMatrix = function () {
    let quat = glMatrix.quat.create();
    return function (out = glMatrix.mat3.create()) {
        this.vec3_degreesToQuat(quat);
        return quat.quat_toMatrix(out);
    };
}();

Array.prototype.vec3_radiansToMatrix = function () {
    let quat = glMatrix.quat.create();
    return function (out = glMatrix.mat3.create()) {
        this.vec3_radiansToQuat(quat);
        return quat.quat_toMatrix(out);
    };
}();

// VECTOR 4

//glMatrix Bridge

Array.prototype.vec4_set = function (x, y = null, z = null, w = null) {
    if (y == null) {
        glMatrix.vec4.set(this, x, x, x, x);
    } else {
        glMatrix.vec4.set(this, x, y, z, w);
    }
    return this;
};

//QUAT

//glMatrix Bridge

Array.prototype.quat_normalize = function (out = glMatrix.quat.create()) {
    glMatrix.quat.normalize(out, this);
    return out;
};

Array.prototype.quat_copy = function (quat) {
    glMatrix.quat.copy(this, quat);
    return this;
};

Array.prototype.quat_set = function (x, y = null, z = null, w = null) {
    if (y == null) {
        glMatrix.quat.set(this, x, x, x, x);
    } else {
        glMatrix.quat.set(this, x, y, z, w);
    }
    return this;
};

Array.prototype.quat_identity = function () {
    glMatrix.quat.identity(this);
    return this;
};

Array.prototype.quat_length = function () {
    return glMatrix.quat.length(this);
};

Array.prototype.quat_invert = function (out = glMatrix.quat.create()) {
    glMatrix.quat.invert(out, this);
    return out;
};

Array.prototype.quat_mul = function (rotation, out = glMatrix.quat.create()) {
    glMatrix.quat.mul(out, this, rotation);
    return out;
};

Array.prototype.quat_getAxis = function (out = glMatrix.vec3.create()) {
    glMatrix.quat.getAxisAngle(out, this);
    return out;
};

Array.prototype.quat_getAngle = function () {
    let vector = glMatrix.vec3.create();
    return function () {
        let angle = glMatrix.quat.getAxisAngle(vector, this);
        return angle;
    };
}();

Array.prototype.quat_fromAxisAngle = function (axis, angle) {
    return this.quat_fromAxisAngleDegrees(axis, angle);
};

Array.prototype.quat_fromAxisAngleDegrees = function (axis, angle) {
    glMatrix.quat.setAxisAngle(this, axis, glMatrix.glMatrix.toRadian(angle));
    return this;
};

Array.prototype.quat_fromAxisAngleRadians = function (axis, angle) {
    glMatrix.quat.setAxisAngle(this, axis, angle);
    return this;
};

//New Methods

Array.prototype.quat_fromRadians = function () {
    let vector = glMatrix.vec3.create();
    return function (radiansRotation) {
        radiansRotation.vec3_toDegrees(vector);
        return this.quat_fromDegrees(vector);
    };
}();

Array.prototype.quat_fromDegrees = function (degreesRotation) {
    glMatrix.quat.fromEuler(this, degreesRotation[0], degreesRotation[1], degreesRotation[2]);
    return this;
};

Array.prototype.quat_toRadians = function () {
    let mat3 = glMatrix.mat3.create();
    return function (out = glMatrix.vec3.create()) {
        glMatrix.mat3.fromQuat(mat3, this);

        //Rotation order is ZYX 
        out[1] = Math.asin(-this._pp_clamp(mat3[2], -1, 1));

        if (Math.abs(mat3[2]) < (1 - this._pp_epsilon)) {
            out[0] = Math.atan2(mat3[5], mat3[8]);
            out[2] = Math.atan2(mat3[1], mat3[0]);
        } else {
            out[0] = 0;
            out[2] = Math.atan2(-mat3[3], mat3[4]);
        }

        return out;
    };
}();

Array.prototype.quat_toDegrees = function (out = glMatrix.vec3.create()) {
    this.quat_toRadians(out);
    out.vec3_toDegrees(out);
    return out;
};

Array.prototype.quat_isNormalized = function () {
    return Math.abs(glMatrix.quat.length(this) - 1) < this._pp_epsilon;
};

Array.prototype.quat_addRotation = function (rotation, out) {
    return this.quat_addRotationDegrees(rotation, out);
};

Array.prototype.quat_addRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out) {
        rotation.vec3_degreesToQuat(quat);
        return this.quat_addRotationQuat(quat, out);
    };
}();

Array.prototype.quat_addRotationRadians = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out) {
        rotation.vec3_radiansToQuat(quat);
        return this.quat_addRotationQuat(quat, out);
    };
}();

Array.prototype.quat_addRotationQuat = function (rotation, out = glMatrix.quat.create()) {
    rotation.quat_mul(this, out);
    return out;
};

Array.prototype.quat_subRotation = function (rotation, out) {
    return this.quat_subRotationDegrees(rotation, out);
};

Array.prototype.quat_subRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out) {
        rotation.vec3_degreesToQuat(quat);
        return this.quat_subRotationQuat(quat, out);
    };
}();

Array.prototype.quat_subRotationRadians = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out) {
        rotation.vec3_radiansToQuat(quat);
        return this.quat_subRotationQuat(quat, out);
    };
}();

Array.prototype.quat_subRotationQuat = function () {
    let inverse = glMatrix.quat.create();
    return function (rotation, out = glMatrix.quat.create()) {
        rotation.quat_invert(inverse);
        this.quat_mul(inverse, out);
        return out;
    };
}();

Array.prototype.quat_rotationTo = function (rotation, out) {
    return this.quat_rotationToDegrees(rotation, out);
};

Array.prototype.quat_rotationToDegrees = function (rotation, out) {
    return rotation.quat_subRotationDegrees(this, out);
};

Array.prototype.quat_rotationToRadians = function (rotation, out) {
    return rotation.quat_subRotationRadians(this, out);
};

Array.prototype.quat_rotationToQuat = function (rotation, out) {
    return rotation.quat_subRotationQuat(this, out);
};

Array.prototype.quat_toMatrix = function (out = glMatrix.mat3.create()) {
    glMatrix.mat3.fromQuat(out, this);
    return out;
};

//QUAT 2

//glMatrix Bridge

Array.prototype.quat2_normalize = function (out = glMatrix.quat2.create()) {
    glMatrix.quat2.normalize(out, this);
    return out;
};

Array.prototype.quat2_copy = function (quat2) {
    glMatrix.quat2.copy(this, quat2);
    return this;
};

Array.prototype.quat2_identity = function () {
    glMatrix.quat2.identity(this);
    return this;
};

Array.prototype.quat2_getPosition = function (out = glMatrix.vec3.create()) {
    glMatrix.quat2.getTranslation(out, this);
    return this;
};

Array.prototype.quat2_getRotation = function (out) {
    return this.quat2_getRotationDegrees(out);
};
Array.prototype.quat2_getRotationDegrees = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (out = glMatrix.vec3.create()) {
        this.quat2_getRotationQuat(rotationQuat).quat_toDegrees(out);
        return out;
    };
}();

Array.prototype.quat2_getRotationRadians = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (out = glMatrix.vec3.create()) {
        this.quat2_getRotationQuat(rotationQuat).quat_toRadians(out);
        return out;
    };
}();

Array.prototype.quat2_getRotationQuat = function (out = glMatrix.quat.create()) {
    glMatrix.quat.copy(out, this);
    return this;
};

Array.prototype.quat2_setPositionRotation = function (position, rotation) {
    return this.quat2_setPositionRotationDegrees(position, rotation);
};

Array.prototype.quat2_setPositionRotationDegrees = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (position, rotation) {
        rotation.vec3_degreesToQuat(rotationQuat);
        glMatrix.quat2.fromRotationTranslation(this, rotationQuat, position);

        return this;
    };
}();

Array.prototype.quat2_setPositionRotationRadians = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (position, rotation) {
        rotation.vec3_radiansToQuat(rotationQuat);
        glMatrix.quat2.fromRotationTranslation(this, rotationQuat, position);

        return this;
    };
}();

Array.prototype.quat2_setPositionRotationQuat = function (position, rotation) {
    glMatrix.quat2.fromRotationTranslation(this, rotation, position);
    return this;
};

//New Methods

Array.prototype.quat2_getAxes = function () {
    let rotationMatrix = glMatrix.mat3.create();
    return function (out = [glMatrix.vec3.create(), glMatrix.vec3.create(), glMatrix.vec3.create()]) {
        glMatrix.mat3.fromQuat(rotationMatrix, this);

        glMatrix.vec3.set(out[0], rotationMatrix[0], rotationMatrix[1], rotationMatrix[2]);
        glMatrix.vec3.set(out[1], rotationMatrix[3], rotationMatrix[4], rotationMatrix[5]);
        glMatrix.vec3.set(out[2], rotationMatrix[6], rotationMatrix[7], rotationMatrix[8]);

        glMatrix.vec3.normalize(out[0], out[0]);
        glMatrix.vec3.normalize(out[1], out[1]);
        glMatrix.vec3.normalize(out[2], out[2]);

        return out;
    };
}();

Array.prototype.quat2_toLocal = function () {
    let invertQuat = glMatrix.quat2.create();
    return function (parentTransform, out = glMatrix.quat2.create()) {
        glMatrix.quat2.conjugate(invertQuat, parentTransform);
        glMatrix.quat2.mul(out, invertQuat, this);
        return out;
    };
}();

Array.prototype.quat2_toWorld = function (parentTransform, out = glMatrix.quat2.create()) {
    glMatrix.quat2.mul(out, parentTransform, this);
    return out;
};

Array.prototype.quat2_toMatrix = function (out = glMatrix.mat4.create()) {
    glMatrix.mat4.fromQuat2(out, this);
    return out;
};

Array.prototype.quat2_fromMatrix = function (transformMatrix) {
    transformMatrix.mat4_toQuat(this);
    return this;
};

//MATRIX 3

//glMatrix Bridge

//New Methods

Array.prototype.mat3_toDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (out = glMatrix.vec3.create()) {
        this.mat3_toQuat(quat);
        quat.quat_toDegrees(out);
        return out;
    };
}();

Array.prototype.mat3_toRadians = function () {
    let quat = glMatrix.quat.create();
    return function (out = glMatrix.vec3.create()) {
        this.mat3_toQuat(quat);
        quat.quat_toRadians(out);
        return out;
    };
}();

Array.prototype.mat3_toQuat = function (out = glMatrix.quat.create()) {
    glMatrix.quat.fromMat3(out, this);
    return out;
};

//MATRIX 4

//glMatrix Bridge

Array.prototype.mat4_copy = function (mat4) {
    glMatrix.mat4.copy(this, mat4);
    return this;
};

Array.prototype.mat4_identity = function () {
    glMatrix.mat4.identity(this);
    return this;
};

Array.prototype.mat4_invert = function (out = glMatrix.mat4.create()) {
    glMatrix.mat4.invert(out, this);
    return out;
};

Array.prototype.mat4_clone = function (out = glMatrix.mat4.create()) {
    glMatrix.mat4.copy(out, this);
    return out;
};

Array.prototype.mat4_getPosition = function (out = glMatrix.vec3.create()) {
    glMatrix.mat4.getTranslation(out, this);
    return out;
};

Array.prototype.mat4_getRotation = function (out = glMatrix.vec3.create()) {
    return this.mat4_getRotationDegrees(out);
};

Array.prototype.mat4_getRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (out = glMatrix.vec3.create()) {
        this.mat4_getRotationQuat(quat);
        quat.quat_toDegrees(out);
        return out;
    };
}();

Array.prototype.mat4_getRotationRadians = function () {
    let quat = glMatrix.quat.create();
    return function (out = glMatrix.vec3.create()) {
        this.mat4_getRotationQuat(quat);
        quat.quat_toRadians(out);
        return out;
    };
}();

Array.prototype.mat4_getRotationQuat = function () {
    let scale = glMatrix.vec3.create();
    let transformMatrixNoScale = glMatrix.mat4.create();
    let inverseScale = glMatrix.vec3.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (out = glMatrix.quat.create()) {
        glMatrix.mat4.getScaling(scale, this);
        glMatrix.vec3.divide(inverseScale, one, scale);
        glMatrix.mat4.scale(transformMatrixNoScale, this, inverseScale);
        glMatrix.mat4.getRotation(out, transformMatrixNoScale);
        glMatrix.quat.normalize(out, out);
        return out;
    };
}();

Array.prototype.mat4_getScale = function (out = glMatrix.vec3.create()) {
    glMatrix.mat4.getScaling(out, this);
    return out;
};

//New Methods

Array.prototype.mat4_setPosition = function (position) {
    this[12] = position[0];
    this[13] = position[1];
    this[14] = position[2];
    return this;
};

Array.prototype.mat4_setRotation = function (rotation) {
    this.mat4_setRotationDegrees(rotation);
    return this;
};

Array.prototype.mat4_setRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation) {
        this.mat4_setRotationQuat(rotation.vec3_degreesToQuat(quat));
        return this;
    };
}();

Array.prototype.mat4_setRotationRadians = function () {
    let vector = glMatrix.vec3.create();
    return function (rotation) {
        this.mat4_setRotationDegrees(rotation.vec3_toDegrees(vector));
        return this;
    };
}();

Array.prototype.mat4_setRotationQuat = function () {
    let position = glMatrix.vec3.create();
    let scale = glMatrix.vec3.create();
    return function (rotation) {
        this.mat4_getPosition(position);
        this.mat4_getScale(scale);
        this.mat4_setPositionRotationQuatScale(position, rotation, scale);
        return this;
    };
}();

Array.prototype.mat4_setScale = function () {
    let tempScale = glMatrix.vec3.create();
    return function (scale) {
        glMatrix.mat4.getScaling(tempScale, this);
        glMatrix.vec3.divide(tempScale, scale, tempScale);
        glMatrix.mat4.scale(this, this, tempScale);
        return this;
    };
}();

Array.prototype.mat4_setPositionRotationScale = function (position, rotation, scale) {
    this.mat4_setPositionRotationDegreesScale(position, rotation, scale);
    return this;
};

Array.prototype.mat4_setPositionRotationDegreesScale = function () {
    let quat = glMatrix.quat.create();
    return function (position, rotation, scale) {
        this.mat4_setPositionRotationQuatScale(position, rotation.vec3_degreesToQuat(quat), scale);
        return this;
    };
}();

Array.prototype.mat4_setPositionRotationRadiansScale = function () {
    let vector = glMatrix.vec3.create();
    return function (position, rotation, scale) {
        this.mat4_setPositionRotationDegreesScale(position, rotation.vec3_toDegrees(vector), scale);
        return this;
    };
}();

Array.prototype.mat4_setPositionRotationQuatScale = function (position, rotation, scale) {
    glMatrix.mat4.fromRotationTranslationScale(this, rotation, position, scale);
    return this;
};

Array.prototype.mat4_setPositionRotation = function (position, rotation) {
    this.mat4_setPositionRotationDegrees(position, rotation);
    return this;
};

Array.prototype.mat4_setPositionRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (position, rotation) {
        this.mat4_setPositionRotationQuat(position, rotation.vec3_degreesToQuat(quat));
        return this;
    };
}();

Array.prototype.mat4_setPositionRotationRadians = function () {
    let vector = glMatrix.vec3.create();
    return function (position, rotation) {
        this.mat4_setPositionRotationDegrees(position, rotation.vec3_toDegrees(vector));
        return this;
    };
}();

Array.prototype.mat4_setPositionRotationQuat = function (position, rotation) {
    glMatrix.mat4.fromRotationTranslation(this, rotation, position);
    return this;
};

Array.prototype.mat4_getAxes = function (out = [glMatrix.vec3.create(), glMatrix.vec3.create(), glMatrix.vec3.create()]) {
    glMatrix.vec3.set(out[0], this[0], this[1], this[2]);
    glMatrix.vec3.set(out[1], this[4], this[5], this[6]);
    glMatrix.vec3.set(out[2], this[8], this[9], this[10]);

    glMatrix.vec3.normalize(out[0], out[0]);
    glMatrix.vec3.normalize(out[1], out[1]);
    glMatrix.vec3.normalize(out[2], out[2]);

    return out;
};

Array.prototype.mat4_toWorld = function () {
    let convertTransform = glMatrix.mat4.create();
    let position = glMatrix.vec3.create();
    let scale = glMatrix.vec3.create();
    let inverseScale = glMatrix.vec3.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (parentTransform, out = glMatrix.mat4.create()) {
        if (parentTransform.mat4_hasUniformScale()) {
            glMatrix.mat4.mul(out, parentTransform, this);
        } else {
            glMatrix.vec3.set(position, this[12], this[13], this[14]);
            position.vec3_convertPositionToWorldMatrix(parentTransform, position);

            glMatrix.mat4.getScaling(scale, parentTransform);
            glMatrix.vec3.divide(inverseScale, one, scale);
            glMatrix.mat4.scale(convertTransform, parentTransform, inverseScale);

            glMatrix.mat4.mul(out, convertTransform, this);
            glMatrix.mat4.scale(out, out, scale);

            out[12] = position[0];
            out[13] = position[1];
            out[14] = position[2];
            out[15] = 1;
        }
        return out;
    };
}();

Array.prototype.mat4_toLocal = function () {
    let convertTransform = glMatrix.mat4.create();
    let position = glMatrix.vec3.create();
    let scale = glMatrix.vec3.create();
    let inverseScale = glMatrix.vec3.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (parentTransform, out = glMatrix.mat4.create()) {
        if (parentTransform.mat4_hasUniformScale()) {
            glMatrix.mat4.invert(convertTransform, parentTransform);
            glMatrix.mat4.mul(out, convertTransform, this);
        } else {
            glMatrix.vec3.set(position, this[12], this[13], this[14]);
            position.vec3_convertPositionToLocalMatrix(parentTransform, position);

            glMatrix.mat4.getScaling(scale, parentTransform);
            glMatrix.vec3.divide(inverseScale, one, scale);
            glMatrix.mat4.scale(convertTransform, parentTransform, inverseScale);

            glMatrix.mat4.invert(convertTransform, convertTransform);
            glMatrix.mat4.mul(out, convertTransform, this);
            glMatrix.mat4.scale(out, out, inverseScale);

            out[12] = position[0];
            out[13] = position[1];
            out[14] = position[2];
            out[15] = 1;
        }
        return out;
    };
}();

Array.prototype.mat4_hasUniformScale = function () {
    let scale = glMatrix.vec3.create();
    return function () {
        glMatrix.mat4.getScaling(scale, this);
        return Math.abs(scale[0] - scale[1]) < this._pp_epsilon && Math.abs(scale[1] - scale[2]) < this._pp_epsilon && Math.abs(scale[0] - scale[2]) < this._pp_epsilon;
    };
}();

Array.prototype.mat4_toQuat = function () {
    let position = glMatrix.vec3.create();
    let rotation = glMatrix.quat.create();
    return function (out = glMatrix.quat2.create()) {
        glMatrix.mat4.getTranslation(position, this);
        this.mat4_getRotationQuat(rotation);
        glMatrix.quat2.fromRotationTranslation(out, rotation, position);
        return out;
    };
}();

Array.prototype.mat4_fromQuat = function (transformQuat) {
    transformQuat.quat2_toMatrix(this);
    return this;
};

//CREATION

function vec3_create(x = null, y = null, z = null) {
    let out = glMatrix.vec3.create();
    if (x != null) {
        out.vec3_set(x, y, z);
    }
    return out;
}

function vec4_create(x = null, y = null, z = null, w = null) {
    let out = glMatrix.vec4.create();
    if (x != null) {
        out.vec4_set(x, y, z, w);
    }
    return out;
}

function quat_create(x = null, y = null, z = null, w = null) {
    let out = glMatrix.quat.create();
    if (x != null) {
        out.quat_set(x, y, z, w);
    }
    return out;
}

function quat2_create() {
    let out = glMatrix.quat2.create();
    return out;
}

function quat2_fromPositionRotation(position, rotation) {
    return quat2_fromPositionRotationDegrees(position, rotation);
}

function quat2_fromPositionRotationDegrees(position, rotation) {
    let out = glMatrix.mat4.create();
    out.quat2_setPositionRotationDegrees(position, rotation);
    return out;
}

function quat2_fromPositionRotationRadians(position, rotation) {
    let out = glMatrix.mat4.create();
    out.quat2_setPositionRotationRadians(position, rotation);
    return out;
}

function quat2_fromPositionRotationQuat(position, rotation) {
    let out = glMatrix.quat2.create();
    out.quat2_setPositionRotationQuat(position, rotation);
    return out;
}

function mat4_create() {
    let out = glMatrix.mat4.create();
    return out;
}

function mat4_fromPositionRotation(position, rotation) {
    return mat4_fromPositionRotationDegrees(position, rotation);
}

function mat4_fromPositionRotationDegrees(position, rotation) {
    let out = glMatrix.mat4.create();
    out.mat4_setPositionRotationDegrees(position, rotation);
    return out;
}

function mat4_fromPositionRotationRadians(position, rotation) {
    let out = glMatrix.mat4.create();
    out.mat4_setPositionRotationRadians(position, rotation);
    return out;
}

function mat4_fromPositionRotationQuat(position, rotation) {
    let out = glMatrix.mat4.create();
    out.mat4_setPositionRotationQuat(position, rotation);
    return out;
}

function mat4_fromPositionRotationScale(position, rotation, scale) {
    return mat4_fromPositionRotationDegreesScale(position, rotation, scale);
}

function mat4_fromPositionRotationDegreesScale(position, rotation, scale) {
    let out = glMatrix.mat4.create();
    out.mat4_setPositionRotationDegreesScale(position, rotation, scale);
    return out;
}

function mat4_fromPositionRotationRadiansScale(position, rotation, scale) {
    let out = glMatrix.mat4.create();
    out.mat4_setPositionRotationRadiansScale(position, rotation, scale);
    return out;
}

function mat4_fromPositionRotationQuatScale(position, rotation, scale) {
    let out = glMatrix.mat4.create();
    out.mat4_setPositionRotationQuatScale(position, rotation, scale);
    return out;
}

//UTILS

Array.prototype._pp_epsilon = 0.000001;

Array.prototype._pp_clamp = function (value, min, max) {
    return Math.min(Math.max(value, min), max);
};

Array.prototype._vec_buildConsoleMessage = function (decimalPlaces) {
    let message = "[";

    for (let i = 0; i < this.length; i++) {
        if (i != 0) {
            message = message.concat(", ");
        }

        message = message.concat(this[i].toFixed(decimalPlaces));
    }

    message = message.concat("]");
    return message;
};

Array.prototype._vec_prepareOut = function (out) {
    if (out == null) {
        out = this.pp_clone();
    } else if (out != this) {
        out.pp_copy(this);
    }

    return out;
};

for (let key in Array.prototype) {
    let prefixes = ["pp_", "vec_", "vec3_", "vec4_", "quat_", "quat2_", "mat3_", "mat4_", "_pp_", "_vec_",];

    let found = false;
    for (let prefix of prefixes) {
        if (key.startsWith(prefix)) {
            found = true;
            break;
        }
    }

    if (found) {
        Object.defineProperty(Array.prototype, key, { enumerable: false });
    }
}
/*
    How to use

    Warning: The extension is a WIP so not all the methods are available for all kinds of vector.

    By default rotations are in Degrees and transforms are Matrix 4 (and not Quat 2)    
    For methods that work with rotations, Matrix means Matrix 3 and Quat means Quat
    For methods that work with transforms, Matrix means Matrix 4 and Quat means Quat 2
    
    For rotations u can add a suffix like Degrees/Radians/Quat/Matrix to use a specific version, example:
        - vec3_rotateAroundRadians
        - vec3_degreesAddRotationDegrees
        
    For transform u can add a suffix like Quat/Matrix to use a specific version, example:
        - vec3_convertPositionToWorldMatrix
        - vec3_convertDirectionToWorldQuat

    Some vec3 methods let u add a prefix to specify if the vec3 represent a rotation in degrees or radians, where degrees is the default:
        - vec3_toQuat
        - vec3_degreesToQuat
        - vec3_radiansToQuat
        - vec3_degreesAddRotation

    Rotation operations return a rotation of the same kind of the starting variable:
        - vec3_degreesAddRotationQuat   -> returns a rotation in degrees
        - quat_rotationToDegrees        -> returns a rotation in quat

    The methods leave u the choice of forwarding an out parameter or just get the return value, example:
        - let quat = this.vec3_toQuat()
        - this.vec3_toQuat(quat)
        - the out parameter is always the last one

    List of methods:
        Note:
            - If a group of methods starts with ○ it means it modifies the variable itself
            - The suffixes (like Matrix or Radians) or prefixes (like degrees) are omitted 

        CREATION (u can call these functions without any object):
            - vec3_create

            - quat_create

            - quat2_create
            - quat2_fromPositionRotation

            - mat4_create
            - mat4_fromPositionRotation     / mat4_fromPositionRotationScale

        ARRAY:
            - pp_has        / pp_hasEqual
            - pp_find       / pp_findAll        / pp_findEquals / pp_findAllEqual
            ○ pp_remove     / pp_removeIndex    / pp_removeAll  / pp_removeEqual    / pp_removeAllEqual
            ○ pp_pushUnique / pp_unshiftUnique
            ○ pp_copy    
            - pp_clone      
            - pp_equals      

        GENERIC VECTOR (array with only numbers):
            - vec_scale
            - vec_round     / vec_floor         / vec_ceil      / vec_clamp
            - vec_log       / vec_error         / vec_warn      

        VECTOR 3:
            ○ vec3_set      / vec3_copy     / vec3_zero
            - vec3_clone 
            - vec3_normalize    / vec3_negate
            - vec3_isNormalized
            - vec3_length
            - vec3_distance
            - vec3_add      / vec3_sub          / vec3_mul      / vec3_div      / vec3_scale
            - vec3_componentAlongAxis           / vec3_removeComponentAlongAxis
            - vec3_isConcordant
            - vec3_convertPositionToWorld       / vec3_convertPositionToLocal 
            - vec3_convertDirectionToWorld      / vec3_convertDirectionToLocal   
            - vec3_angle
            - vec3_toRadians        / vec3_toDegrees            / vec3_toQuat       / vec3_toMatrix
            - vec3_rotate           / vec3_rotateAxis           / vec3_rotateAround / vec3_rotateAroundAxis
            - vec3_addRotation
            - vec3_log       / vec3_error         / vec3_warn     
            
        VECTOR 4:
            ○ vec4_set

        QUAT:
            ○ quat_set          / quat_copy     / quat_identity
            - quat_normalize    / quat_invert
            - quat_isNormalized
            - quat_length
            - quat_mul
            - quat_getAxis  / quat_getAngle
            ○ quat_fromRadians      / quat_fromDegrees      / quat_fromAxisAngle
            - quat_toRadians        / quat_toDegrees        / quat_toMatrix
            - quat_addRotation      / quat_subRotation
            - quat_rotationTo

        QUAT 2:
            ○ quat2_copy        / quat2_identity
            - quat2_normalize
            - quat2_getPosition     / quat2_getRotation
            ○ quat2_setPositionRotation
            - quat2_getAxes
            - quat2_toWorld     / quat2_toLocal
            - quat2_toMatrix
            ○ quat2_fromMatrix

        MATRIX 3:
            - mat3_toDegrees    / mat3_toRadians    / mat3_toQuat

        MATRIX 4:
            ○ mat4_copy         / mat4_identity
            - mat4_clone
            - mat4_invert
            - mat4_getPosition  / mat4_getRotation  / mat4_getScale
            ○ mat4_setPosition  / mat4_setRotation  / mat4_setScale
            ○ mat4_setPositionRotation      / mat4_setPositionRotationScale
            - mat4_getAxes
            - mat4_toWorld      / mat4_toLocal
            - mat4_hasUniformScale
            - mat4_toQuat
            ○ mat4_fromQuat
*/

//ARRAY

Float32Array.prototype.pp_has = function (callback) {
    return this.pp_find(callback) != undefined;
};

Float32Array.prototype.pp_hasEquals = function (elementToFind) {
    return this.pp_findEqual(elementToFind) != undefined;
};

Float32Array.prototype.pp_find = function (callback) {
    let elementFound = undefined;

    let index = this.findIndex(callback);
    if (index >= 0) {
        elementFound = this[index];
    }

    return elementFound;
};

Float32Array.prototype.pp_findAll = function (callback) {
    let elementsFound = this.filter(callback);

    return elementsFound;
};

Float32Array.prototype.pp_findEqual = function (elementToFind) {
    return this.pp_find(element => element === elementToFind);
};

Float32Array.prototype.pp_findAllEqual = function (elementToFind) {
    return this.pp_findAll(element => element === elementToFind);
};

Float32Array.prototype.pp_removeIndex = function (index) {
    let elementRemoved = undefined;

    if (index >= 0 && index < this.length) {
        let arrayRemoved = this.splice(index, 1);
        if (arrayRemoved.length == 1) {
            elementRemoved = arrayRemoved[0];
        }
    }

    return elementRemoved;
};

Float32Array.prototype.pp_remove = function (callback) {
    let elementRemoved = undefined;

    let index = this.findIndex(callback);
    if (index >= 0) {
        elementRemoved = this.pp_removeIndex(index);
    }

    return elementRemoved;
};

Float32Array.prototype.pp_removeAll = function (callback) {
    let elementsRemoved = [];

    let currentElement = undefined;
    do {
        currentElement = this.pp_remove(callback);
        if (currentElement !== undefined) {
            elementsRemoved.push(currentElement);
        }
    } while (currentElement !== undefined);

    return elementsRemoved;
};

Float32Array.prototype.pp_removeEqual = function (elementToRemove) {
    return this.pp_remove(element => element === elementToRemove);
};

Float32Array.prototype.pp_removeAllEqual = function (elementToRemove) {
    return this.pp_removeAll(element => element === elementToRemove);
};

Float32Array.prototype.pp_pushUnique = function (element, hasElementCallback = null) {
    let length = this.length;

    let hasElement = false;
    if (hasElementCallback != null) {
        hasElement = this.pp_has(hasElementCallback);
    } else {
        hasElement = this.pp_hasEquals(element);
    }

    if (!hasElement) {
        length = this.push(element);
    }

    return length;
};

Float32Array.prototype.pp_unshiftUnique = function (element, hasElementCallback = null) {
    let length = this.length;

    let hasElement = false;
    if (hasElementCallback != null) {
        hasElement = this.pp_has(hasElementCallback);
    } else {
        hasElement = this.pp_hasEquals(element);
    }

    if (!hasElement) {
        length = this.unshift(element);
    }

    return length;
};

Float32Array.prototype.pp_copy = function (array) {
    while (this.length > array.length) {
        this.pop();
    }

    for (let i = 0; i < array.length; i++) {
        this[i] = array[i];
    }

    return this;
};

Float32Array.prototype.pp_clone = function () {
    return this.slice(0);
};

Float32Array.prototype.pp_equals = function (array, elementEqualsCallback = null) {
    let equals = true;

    if (array != null && this.length == array.length) {
        for (let i = 0; i < this.length; i++) {
            if ((elementEqualsCallback != null && !elementEqualsCallback(this[i], array[i])) ||
                (elementEqualsCallback == null && this[i] != array[i])) {
                equals = false;
                break;
            }
        }
    } else {
        equals = false;
    }

    return equals;
};

// GENERIC VECTOR

Float32Array.prototype.vec_toString = function (decimalPlaces = 4) {
    let message = this._vec_buildConsoleMessage(decimalPlaces);
    return message;
};

Float32Array.prototype.vec_log = function (decimalPlaces = 4) {
    let message = this._vec_buildConsoleMessage(decimalPlaces);
    console.log(message);
};

Float32Array.prototype.vec_error = function (decimalPlaces = 4) {
    let message = this._vec_buildConsoleMessage(decimalPlaces);
    console.error(message);
};

Float32Array.prototype.vec_warn = function (decimalPlaces = 4) {
    let message = this._vec_buildConsoleMessage(decimalPlaces);
    console.warn(message);
};

Float32Array.prototype.vec_scale = function (value, out = null) {
    out = this._vec_prepareOut(out);

    for (let i = 0; i < out.length; i++) {
        out[i] = out[i] * value;
    }

    return out;
};

Float32Array.prototype.vec_round = function (out = null) {
    out = this._vec_prepareOut(out);

    for (let i = 0; i < out.length; i++) {
        out[i] = Math.round(out[i]);
    }

    return out;
};

Float32Array.prototype.vec_floor = function (out = null) {
    out = this._vec_prepareOut(out);

    for (let i = 0; i < out.length; i++) {
        out[i] = Math.floor(out[i]);
    }

    return out;
};

Float32Array.prototype.vec_ceil = function (out = null) {
    out = this._vec_prepareOut(out);

    for (let i = 0; i < out.length; i++) {
        out[i] = Math.ceil(out[i]);
    }

    return out;
};

Float32Array.prototype.vec_clamp = function (start, end, out = null) {
    out = this._vec_prepareOut(out);

    let fixedStart = (start != null) ? start : Number.MIN_VALUE;
    let fixedEnd = (end != null) ? end : Number.MAX_VALUE;
    let min = Math.min(fixedStart, fixedEnd);
    let max = Math.max(fixedStart, fixedEnd);

    for (let i = 0; i < out.length; i++) {
        out[i] = Math.min(Math.max(out[i], min), max);
    }

    return out;
};

Float32Array.prototype.vec_equals = function (vector) {
    let equals = this.length == vector.length;

    for (let i = 0; i < this.length && equals; i++) {
        equals &= Math.abs(this[i] - vector[i]) < this._pp_epsilon;
    }

    return equals;
};

// VECTOR 3

//glMatrix Bridge

Float32Array.prototype.vec3_normalize = function (out = glMatrix.vec3.create()) {
    glMatrix.vec3.normalize(out, this);
    return out;
};

Float32Array.prototype.vec3_copy = function (vector) {
    glMatrix.vec3.copy(this, vector);
    return this;
};

Float32Array.prototype.vec3_clone = function (out = glMatrix.vec3.create()) {
    glMatrix.vec3.copy(out, this);
    return out;
};

Float32Array.prototype.vec3_set = function (x, y = null, z = null) {
    if (y == null) {
        glMatrix.vec3.set(this, x, x, x);
    } else {
        glMatrix.vec3.set(this, x, y, z);
    }
    return this;
};

Float32Array.prototype.vec3_zero = function () {
    glMatrix.vec3.zero(this);
    return this;
};

Float32Array.prototype.vec3_angle = function (vector) {
    return this.vec3_angleDegrees(vector);
};

Float32Array.prototype.vec3_angleDegrees = function (vector) {
    return this.vec3_angleRadians(vector) * (180 / Math.PI);
};

Float32Array.prototype.vec3_angleRadians = function (vector) {
    return glMatrix.vec3.angle(this, vector);
};

Float32Array.prototype.vec3_length = function () {
    return glMatrix.vec3.length(this);
};

Float32Array.prototype.vec3_distance = function (vector) {
    return glMatrix.vec3.dist(this, vector);
};

Float32Array.prototype.vec3_add = function (vector, out = glMatrix.vec3.create()) {
    glMatrix.vec3.add(out, this, vector);
    return out;
};

Float32Array.prototype.vec3_sub = function (vector, out = glMatrix.vec3.create()) {
    glMatrix.vec3.sub(out, this, vector);
    return out;
};

Float32Array.prototype.vec3_mul = function (vector, out = glMatrix.vec3.create()) {
    glMatrix.vec3.mul(out, this, vector);
    return out;
};

Float32Array.prototype.vec3_div = function (vector, out = glMatrix.vec3.create()) {
    glMatrix.vec3.div(out, this, vector);
    return out;
};

Float32Array.prototype.vec3_scale = function (value, out = glMatrix.vec3.create()) {
    glMatrix.vec3.scale(out, this, value);
    return out;
};

Float32Array.prototype.vec3_negate = function (out = glMatrix.vec3.create()) {
    glMatrix.vec3.negate(out, this);
    return out;
};

Float32Array.prototype.vec3_cross = function (vector, out = glMatrix.vec3.create()) {
    glMatrix.vec3.cross(out, this, vector);
    return out;
};

//New Methods

Float32Array.prototype.vec3_angleSigned = function (vector, axis) {
    return this.vec3_angleSignedDegrees(vector, axis);
};

Float32Array.prototype.vec3_angleSignedDegrees = function (vector, axis) {
    return this.vec3_angleSignedRadians(vector, axis) * (180 / Math.PI);
};

Float32Array.prototype.vec3_angleSignedRadians = function () {
    let crossAxis = glMatrix.vec3.create();
    return function (vector, axis) {
        this.vec3_cross(vector, crossAxis);
        let angle = this.vec3_angleRadians(vector);
        if (!crossAxis.vec3_isConcordant(axis)) {
            angle = -angle;
        }

        return angle;
    };
}();

Float32Array.prototype.vec3_toRadians = function (out = glMatrix.vec3.create()) {
    glMatrix.vec3.set(out, glMatrix.glMatrix.toRadian(this[0]), glMatrix.glMatrix.toRadian(this[1]), glMatrix.glMatrix.toRadian(this[2]));
    return out;
};

Float32Array.prototype.vec3_toDegrees = function (out = glMatrix.vec3.create()) {
    glMatrix.vec3.set(out, this[0] * (180 / Math.PI), this[1] * (180 / Math.PI), this[2] * (180 / Math.PI));
    return out;
};

Float32Array.prototype.vec3_toQuat = function (out) {
    return this.vec3_degreesToQuat(out);
};

Float32Array.prototype.vec3_radiansToQuat = function (out = glMatrix.quat.create()) {
    out.quat_fromRadians(this);
    return out;
};

Float32Array.prototype.vec3_degreesToQuat = function (out = glMatrix.quat.create()) {
    out.quat_fromDegrees(this);
    return out;
};

Float32Array.prototype.vec3_isNormalized = function () {
    return Math.abs(glMatrix.vec3.length(this) - 1) < this._pp_epsilon;
};

Float32Array.prototype.vec3_componentAlongAxis = function (axis, out = glMatrix.vec3.create()) {
    let angle = glMatrix.vec3.angle(this, axis);
    let length = Math.cos(angle) * glMatrix.vec3.length(this);

    glMatrix.vec3.copy(out, axis);
    glMatrix.vec3.scale(out, out, length);
    return out;
};

Float32Array.prototype.vec3_removeComponentAlongAxis = function () {
    let componentAlong = glMatrix.vec3.create();
    return function (axis, out = glMatrix.vec3.create()) {
        this.vec3_componentAlongAxis(axis, componentAlong);
        glMatrix.vec3.sub(out, this, componentAlong);
        return out;
    };
}();

Float32Array.prototype.vec3_isConcordant = function (vector) {
    return glMatrix.vec3.angle(this, vector) <= Math.PI / 2;
};

Float32Array.prototype.vec3_rotate = function (rotation, out) {
    return this.vec3_rotateDegrees(rotation, out);
};

Float32Array.prototype.vec3_rotateDegrees = function () {
    let zero = glMatrix.vec3.create();
    return function (rotation, out) {
        return this.vec3_rotateAroundDegrees(rotation, zero, out);
    };
}();

Float32Array.prototype.vec3_rotateRadians = function () {
    let zero = glMatrix.vec3.create();
    return function (rotation, out) {
        return this.vec3_rotateAroundRadians(rotation, zero, out);
    };
}();

Float32Array.prototype.vec3_rotateQuat = function () {
    let zero = glMatrix.vec3.create();
    return function (rotation, out) {
        return this.vec3_rotateAroundQuat(rotation, zero, out);
    };
}();

Float32Array.prototype.vec3_rotateAxis = function (angle, axis, out) {
    return this.vec3_rotateAxisDegrees(angle, axis, out);
};

Float32Array.prototype.vec3_rotateAxisDegrees = function () {
    let zero = glMatrix.vec3.create();
    return function (angle, axis, out) {
        return this.vec3_rotateAroundAxisDegrees(angle, axis, zero, out);
    };
}();

Float32Array.prototype.vec3_rotateAxisRadians = function () {
    let zero = glMatrix.vec3.create();
    return function (angle, axis, out) {
        return this.vec3_rotateAroundAxisRadians(angle, axis, zero, out);
    };
}();

Float32Array.prototype.vec3_rotateAround = function (rotation, origin, out) {
    return this.vec3_rotateAroundDegrees(rotation, origin, out);
};

Float32Array.prototype.vec3_rotateAroundDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, origin, out = glMatrix.vec3.create()) {
        rotation.vec3_degreesToQuat(quat);
        return this.vec3_rotateAroundQuat(quat, origin, out);
    };
}();

Float32Array.prototype.vec3_rotateAroundRadians = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, origin, out = glMatrix.vec3.create()) {
        rotation.vec3_radiansToQuat(quat);
        return this.vec3_rotateAroundQuat(quat, origin, out);
    };
}();

Float32Array.prototype.vec3_rotateAroundQuat = function (rotation, origin, out = glMatrix.vec3.create()) {
    glMatrix.vec3.sub(out, this, origin);
    glMatrix.vec3.transformQuat(out, out, rotation);
    glMatrix.vec3.add(out, out, origin);
    return out;
};

Float32Array.prototype.vec3_rotateAroundAxis = function (angle, axis, origin, out) {
    return this.vec3_rotateAroundAxisDegrees(angle, axis, origin, out);
};

Float32Array.prototype.vec3_rotateAroundAxisDegrees = function (angle, axis, origin, out) {
    return this.vec3_rotateAroundAxisRadians(glMatrix.glMatrix.toRadian(angle), axis, origin, out);
};

Float32Array.prototype.vec3_rotateAroundAxisRadians = function () {
    let quat = glMatrix.quat.create();
    return function (angle, axis, origin, out = glMatrix.vec3.create()) {
        glMatrix.quat.setAxisAngle(quat, axis, angle);
        return this.vec3_rotateAroundQuat(quat, origin, out);
    };
}();

Float32Array.prototype.vec3_convertPositionToWorld = function (parentTransform, out) {
    return this.vec3_convertPositionToWorldMatrix(parentTransform, out);
};

Float32Array.prototype.vec3_convertPositionToLocal = function (parentTransform, out) {
    return this.vec3_convertPositionToLocalMatrix(parentTransform, out);
};

Float32Array.prototype.vec3_convertPositionToWorldMatrix = function (parentTransform, out = glMatrix.vec3.create()) {
    glMatrix.vec3.transformMat4(out, this, parentTransform);
    return out;
};

Float32Array.prototype.vec3_convertPositionToLocalMatrix = function () {
    let inverse = glMatrix.mat4.create();
    return function (parentTransform, out = glMatrix.vec3.create()) {
        glMatrix.mat4.invert(inverse, parentTransform);
        glMatrix.vec3.transformMat4(out, this, inverse);
        return out;
    };
}();

Float32Array.prototype.vec3_convertPositionToWorldQuat = function () {
    let parentTransformMatrix = glMatrix.mat4.create();
    let position = glMatrix.vec3.create();
    let rotation = glMatrix.quat.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (parentTransform, out = glMatrix.vec3.create()) {
        parentTransform.quat2_getPosition(position);
        parentTransform.quat2_getRotationQuat(rotation);
        parentTransformMatrix.mat4_setPositionRotationQuatScale(position, rotation, one);
        return this.vec3_convertPositionToWorldMatrix(parentTransformMatrix, out);
    };
}();

Float32Array.prototype.vec3_convertPositionToLocalQuat = function () {
    let parentTransformMatrix = glMatrix.mat4.create();
    let position = glMatrix.vec3.create();
    let rotation = glMatrix.quat.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (parentTransform, out = glMatrix.vec3.create()) {
        parentTransform.quat2_getPosition(position);
        parentTransform.quat2_getRotationQuat(rotation);
        parentTransformMatrix.mat4_setPositionRotationQuatScale(position, rotation, one);
        return this.vec3_convertPositionToLocalMatrix(parentTransformMatrix, out);
    };
}();

Float32Array.prototype.vec3_convertDirectionToWorld = function (parentTransform, out) {
    return this.vec3_convertDirectionToWorldMatrix(parentTransform, out);
};

Float32Array.prototype.vec3_convertDirectionToLocal = function (parentTransform, out) {
    return this.vec3_convertDirectionToLocalMatrix(parentTransform, out);
};

Float32Array.prototype.vec3_convertDirectionToWorldMatrix = function () {
    let rotation = glMatrix.quat.create();
    return function (parentTransform, out = glMatrix.vec3.create()) {
        parentTransform.mat4_getRotationQuat(rotation);
        glMatrix.vec3.transformQuat(out, this, rotation);
        return out;
    };
}();

Float32Array.prototype.vec3_convertDirectionToLocalMatrix = function () {
    let rotation = glMatrix.quat.create();
    return function (parentTransform, out = glMatrix.vec3.create()) {
        parentTransform.mat4_getRotationQuat(rotation);
        glMatrix.quat.conjugate(rotation, rotation);
        glMatrix.vec3.transformQuat(out, this, rotation);
        return out;
    };
}();


Float32Array.prototype.vec3_convertDirectionToWorldQuat = function () {
    let rotation = glMatrix.quat.create();
    return function (parentTransform, out = glMatrix.vec3.create()) {
        parentTransform.quat2_getRotationQuat(rotation);
        glMatrix.vec3.transformQuat(out, this, rotation);
        return out;
    };
}();

Float32Array.prototype.vec3_convertDirectionToLocalQuat = function () {
    let rotation = glMatrix.quat.create();
    return function (parentTransform, out = glMatrix.vec3.create()) {
        parentTransform.quat2_getRotationQuat(rotation);
        glMatrix.quat.conjugate(rotation, rotation);
        glMatrix.vec3.transformQuat(out, this, rotation);
        return out;
    };
}();

Float32Array.prototype.vec3_log = function (decimalPlaces = 4) {
    this.vec_log(decimalPlaces);
};

Float32Array.prototype.vec3_error = function (decimalPlaces = 4) {
    this.vec_error(decimalPlaces);
};

Float32Array.prototype.vec3_warn = function (decimalPlaces = 4) {
    this.vec_warn(decimalPlaces);
};

Float32Array.prototype.vec3_addRotation = function (rotation, out) {
    return this.vec3_degreesAddRotation(rotation, out);
};

Float32Array.prototype.vec3_addRotationDegrees = function (rotation, out) {
    return quat.vec3_degreesAddRotationDegrees(rotation, out);
};

Float32Array.prototype.vec3_addRotationRadians = function (rotation, out) {
    return quat.vec3_degreesAddRotationRadians(rotation, out);
};

Float32Array.prototype.vec3_addRotationQuat = function (rotation, out) {
    return quat.vec3_degreesAddRotationQuat(rotation, out);
};

Float32Array.prototype.vec3_degreesAddRotation = function (rotation, out) {
    return this.vec3_degreesAddRotationDegrees(rotation, out);
};

Float32Array.prototype.vec3_degreesAddRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out = glMatrix.vec3.create()) {
        this.vec3_degreesToQuat(quat);
        return quat.quat_addRotationDegrees(rotation, quat).quat_toDegrees(out);
    };
}();

Float32Array.prototype.vec3_degreesAddRotationRadians = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out = glMatrix.vec3.create()) {
        this.vec3_degreesToQuat(quat);
        return quat.quat_addRotationRadians(rotation, quat).quat_toDegrees(out);
    };
}();

Float32Array.prototype.vec3_degreesAddRotationQuat = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out = glMatrix.vec3.create()) {
        this.vec3_degreesToQuat(quat);
        return quat.quat_addRotationQuat(rotation, quat).quat_toDegrees(out);
    };
}();

Float32Array.prototype.vec3_radiansAddRotation = function (rotation, out) {
    return this.vec3_radiansAddRotationDegrees(rotation, out);
};

Float32Array.prototype.vec3_radiansAddRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out = glMatrix.vec3.create()) {
        this.vec3_radiansToQuat(quat);
        return quat.quat_addRotationDegrees(rotation, quat).quat_toRadians(out);
    };
}();

Float32Array.prototype.vec3_radiansAddRotationRadians = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out = glMatrix.vec3.create()) {
        this.vec3_radiansToQuat(quat);
        return quat.quat_addRotationRadians(rotation, quat).quat_toRadians(out);
    };
}();

Float32Array.prototype.vec3_radiansAddRotationQuat = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out = glMatrix.vec3.create()) {
        this.vec3_radiansToQuat(quat);
        return quat.quat_addRotationQuat(rotation, quat).quat_toRadians(out);
    };
}();

Float32Array.prototype.vec3_toMatrix = function (out = glMatrix.mat3.create()) {
    return this.vec3_degreesToMatrix(out);
};

Float32Array.prototype.vec3_degreesToMatrix = function () {
    let quat = glMatrix.quat.create();
    return function (out = glMatrix.mat3.create()) {
        this.vec3_degreesToQuat(quat);
        return quat.quat_toMatrix(out);
    };
}();

Float32Array.prototype.vec3_radiansToMatrix = function () {
    let quat = glMatrix.quat.create();
    return function (out = glMatrix.mat3.create()) {
        this.vec3_radiansToQuat(quat);
        return quat.quat_toMatrix(out);
    };
}();

// VECTOR 4

//glMatrix Bridge

Float32Array.prototype.vec4_set = function (x, y = null, z = null, w = null) {
    if (y == null) {
        glMatrix.vec4.set(this, x, x, x, x);
    } else {
        glMatrix.vec4.set(this, x, y, z, w);
    }
    return this;
};

//QUAT

//glMatrix Bridge

Float32Array.prototype.quat_normalize = function (out = glMatrix.quat.create()) {
    glMatrix.quat.normalize(out, this);
    return out;
};

Float32Array.prototype.quat_copy = function (quat) {
    glMatrix.quat.copy(this, quat);
    return this;
};

Float32Array.prototype.quat_set = function (x, y = null, z = null, w = null) {
    if (y == null) {
        glMatrix.quat.set(this, x, x, x, x);
    } else {
        glMatrix.quat.set(this, x, y, z, w);
    }
    return this;
};

Float32Array.prototype.quat_identity = function () {
    glMatrix.quat.identity(this);
    return this;
};

Float32Array.prototype.quat_length = function () {
    return glMatrix.quat.length(this);
};

Float32Array.prototype.quat_invert = function (out = glMatrix.quat.create()) {
    glMatrix.quat.invert(out, this);
    return out;
};

Float32Array.prototype.quat_mul = function (rotation, out = glMatrix.quat.create()) {
    glMatrix.quat.mul(out, this, rotation);
    return out;
};

Float32Array.prototype.quat_getAxis = function (out = glMatrix.vec3.create()) {
    glMatrix.quat.getAxisAngle(out, this);
    return out;
};

Float32Array.prototype.quat_getAngle = function () {
    let vector = glMatrix.vec3.create();
    return function () {
        let angle = glMatrix.quat.getAxisAngle(vector, this);
        return angle;
    };
}();

Float32Array.prototype.quat_fromAxisAngle = function (axis, angle) {
    return this.quat_fromAxisAngleDegrees(axis, angle);
};

Float32Array.prototype.quat_fromAxisAngleDegrees = function (axis, angle) {
    glMatrix.quat.setAxisAngle(this, axis, glMatrix.glMatrix.toRadian(angle));
    return this;
};

Float32Array.prototype.quat_fromAxisAngleRadians = function (axis, angle) {
    glMatrix.quat.setAxisAngle(this, axis, angle);
    return this;
};

//New Methods

Float32Array.prototype.quat_fromRadians = function () {
    let vector = glMatrix.vec3.create();
    return function (radiansRotation) {
        radiansRotation.vec3_toDegrees(vector);
        return this.quat_fromDegrees(vector);
    };
}();

Float32Array.prototype.quat_fromDegrees = function (degreesRotation) {
    glMatrix.quat.fromEuler(this, degreesRotation[0], degreesRotation[1], degreesRotation[2]);
    return this;
};

Float32Array.prototype.quat_toRadians = function () {
    let mat3 = glMatrix.mat3.create();
    return function (out = glMatrix.vec3.create()) {
        glMatrix.mat3.fromQuat(mat3, this);

        //Rotation order is ZYX 
        out[1] = Math.asin(-this._pp_clamp(mat3[2], -1, 1));

        if (Math.abs(mat3[2]) < (1 - this._pp_epsilon)) {
            out[0] = Math.atan2(mat3[5], mat3[8]);
            out[2] = Math.atan2(mat3[1], mat3[0]);
        } else {
            out[0] = 0;
            out[2] = Math.atan2(-mat3[3], mat3[4]);
        }

        return out;
    };
}();

Float32Array.prototype.quat_toDegrees = function (out = glMatrix.vec3.create()) {
    this.quat_toRadians(out);
    out.vec3_toDegrees(out);
    return out;
};

Float32Array.prototype.quat_isNormalized = function () {
    return Math.abs(glMatrix.quat.length(this) - 1) < this._pp_epsilon;
};

Float32Array.prototype.quat_addRotation = function (rotation, out) {
    return this.quat_addRotationDegrees(rotation, out);
};

Float32Array.prototype.quat_addRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out) {
        rotation.vec3_degreesToQuat(quat);
        return this.quat_addRotationQuat(quat, out);
    };
}();

Float32Array.prototype.quat_addRotationRadians = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out) {
        rotation.vec3_radiansToQuat(quat);
        return this.quat_addRotationQuat(quat, out);
    };
}();

Float32Array.prototype.quat_addRotationQuat = function (rotation, out = glMatrix.quat.create()) {
    rotation.quat_mul(this, out);
    return out;
};

Float32Array.prototype.quat_subRotation = function (rotation, out) {
    return this.quat_subRotationDegrees(rotation, out);
};

Float32Array.prototype.quat_subRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out) {
        rotation.vec3_degreesToQuat(quat);
        return this.quat_subRotationQuat(quat, out);
    };
}();

Float32Array.prototype.quat_subRotationRadians = function () {
    let quat = glMatrix.quat.create();
    return function (rotation, out) {
        rotation.vec3_radiansToQuat(quat);
        return this.quat_subRotationQuat(quat, out);
    };
}();

Float32Array.prototype.quat_subRotationQuat = function () {
    let inverse = glMatrix.quat.create();
    return function (rotation, out = glMatrix.quat.create()) {
        rotation.quat_invert(inverse);
        this.quat_mul(inverse, out);
        return out;
    };
}();

Float32Array.prototype.quat_rotationTo = function (rotation, out) {
    return this.quat_rotationToDegrees(rotation, out);
};

Float32Array.prototype.quat_rotationToDegrees = function (rotation, out) {
    return rotation.quat_subRotationDegrees(this, out);
};

Float32Array.prototype.quat_rotationToRadians = function (rotation, out) {
    return rotation.quat_subRotationRadians(this, out);
};

Float32Array.prototype.quat_rotationToQuat = function (rotation, out) {
    return rotation.quat_subRotationQuat(this, out);
};

Float32Array.prototype.quat_toMatrix = function (out = glMatrix.mat3.create()) {
    glMatrix.mat3.fromQuat(out, this);
    return out;
};

//QUAT 2

//glMatrix Bridge

Float32Array.prototype.quat2_normalize = function (out = glMatrix.quat2.create()) {
    glMatrix.quat2.normalize(out, this);
    return out;
};

Float32Array.prototype.quat2_copy = function (quat2) {
    glMatrix.quat2.copy(this, quat2);
    return this;
};

Float32Array.prototype.quat2_identity = function () {
    glMatrix.quat2.identity(this);
    return this;
};

Float32Array.prototype.quat2_getPosition = function (out = glMatrix.vec3.create()) {
    glMatrix.quat2.getTranslation(out, this);
    return this;
};

Float32Array.prototype.quat2_getRotation = function (out) {
    return this.quat2_getRotationDegrees(out);
};
Float32Array.prototype.quat2_getRotationDegrees = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (out = glMatrix.vec3.create()) {
        this.quat2_getRotationQuat(rotationQuat).quat_toDegrees(out);
        return out;
    };
}();

Float32Array.prototype.quat2_getRotationRadians = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (out = glMatrix.vec3.create()) {
        this.quat2_getRotationQuat(rotationQuat).quat_toRadians(out);
        return out;
    };
}();

Float32Array.prototype.quat2_getRotationQuat = function (out = glMatrix.quat.create()) {
    glMatrix.quat.copy(out, this);
    return this;
};

Float32Array.prototype.quat2_setPositionRotation = function (position, rotation) {
    return this.quat2_setPositionRotationDegrees(position, rotation);
};

Float32Array.prototype.quat2_setPositionRotationDegrees = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (position, rotation) {
        rotation.vec3_degreesToQuat(rotationQuat);
        glMatrix.quat2.fromRotationTranslation(this, rotationQuat, position);

        return this;
    };
}();

Float32Array.prototype.quat2_setPositionRotationRadians = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (position, rotation) {
        rotation.vec3_radiansToQuat(rotationQuat);
        glMatrix.quat2.fromRotationTranslation(this, rotationQuat, position);

        return this;
    };
}();

Float32Array.prototype.quat2_setPositionRotationQuat = function (position, rotation) {
    glMatrix.quat2.fromRotationTranslation(this, rotation, position);
    return this;
};

//New Methods

Float32Array.prototype.quat2_getAxes = function () {
    let rotationMatrix = glMatrix.mat3.create();
    return function (out = [glMatrix.vec3.create(), glMatrix.vec3.create(), glMatrix.vec3.create()]) {
        glMatrix.mat3.fromQuat(rotationMatrix, this);

        glMatrix.vec3.set(out[0], rotationMatrix[0], rotationMatrix[1], rotationMatrix[2]);
        glMatrix.vec3.set(out[1], rotationMatrix[3], rotationMatrix[4], rotationMatrix[5]);
        glMatrix.vec3.set(out[2], rotationMatrix[6], rotationMatrix[7], rotationMatrix[8]);

        glMatrix.vec3.normalize(out[0], out[0]);
        glMatrix.vec3.normalize(out[1], out[1]);
        glMatrix.vec3.normalize(out[2], out[2]);

        return out;
    };
}();

Float32Array.prototype.quat2_toLocal = function () {
    let invertQuat = glMatrix.quat2.create();
    return function (parentTransform, out = glMatrix.quat2.create()) {
        glMatrix.quat2.conjugate(invertQuat, parentTransform);
        glMatrix.quat2.mul(out, invertQuat, this);
        return out;
    };
}();

Float32Array.prototype.quat2_toWorld = function (parentTransform, out = glMatrix.quat2.create()) {
    glMatrix.quat2.mul(out, parentTransform, this);
    return out;
};

Float32Array.prototype.quat2_toMatrix = function (out = glMatrix.mat4.create()) {
    glMatrix.mat4.fromQuat2(out, this);
    return out;
};

Float32Array.prototype.quat2_fromMatrix = function (transformMatrix) {
    transformMatrix.mat4_toQuat(this);
    return this;
};

//MATRIX 3

//glMatrix Bridge

//New Methods

Float32Array.prototype.mat3_toDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (out = glMatrix.vec3.create()) {
        this.mat3_toQuat(quat);
        quat.quat_toDegrees(out);
        return out;
    };
}();

Float32Array.prototype.mat3_toRadians = function () {
    let quat = glMatrix.quat.create();
    return function (out = glMatrix.vec3.create()) {
        this.mat3_toQuat(quat);
        quat.quat_toRadians(out);
        return out;
    };
}();

Float32Array.prototype.mat3_toQuat = function (out = glMatrix.quat.create()) {
    glMatrix.quat.fromMat3(out, this);
    return out;
};

//MATRIX 4

//glMatrix Bridge

Float32Array.prototype.mat4_copy = function (mat4) {
    glMatrix.mat4.copy(this, mat4);
    return this;
};

Float32Array.prototype.mat4_identity = function () {
    glMatrix.mat4.identity(this);
    return this;
};

Float32Array.prototype.mat4_invert = function (out = glMatrix.mat4.create()) {
    glMatrix.mat4.invert(out, this);
    return out;
};

Float32Array.prototype.mat4_clone = function (out = glMatrix.mat4.create()) {
    glMatrix.mat4.copy(out, this);
    return out;
};

Float32Array.prototype.mat4_getPosition = function (out = glMatrix.vec3.create()) {
    glMatrix.mat4.getTranslation(out, this);
    return out;
};

Float32Array.prototype.mat4_getRotation = function (out = glMatrix.vec3.create()) {
    return this.mat4_getRotationDegrees(out);
};

Float32Array.prototype.mat4_getRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (out = glMatrix.vec3.create()) {
        this.mat4_getRotationQuat(quat);
        quat.quat_toDegrees(out);
        return out;
    };
}();

Float32Array.prototype.mat4_getRotationRadians = function () {
    let quat = glMatrix.quat.create();
    return function (out = glMatrix.vec3.create()) {
        this.mat4_getRotationQuat(quat);
        quat.quat_toRadians(out);
        return out;
    };
}();

Float32Array.prototype.mat4_getRotationQuat = function () {
    let scale = glMatrix.vec3.create();
    let transformMatrixNoScale = glMatrix.mat4.create();
    let inverseScale = glMatrix.vec3.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (out = glMatrix.quat.create()) {
        glMatrix.mat4.getScaling(scale, this);
        glMatrix.vec3.divide(inverseScale, one, scale);
        glMatrix.mat4.scale(transformMatrixNoScale, this, inverseScale);
        glMatrix.mat4.getRotation(out, transformMatrixNoScale);
        glMatrix.quat.normalize(out, out);
        return out;
    };
}();

Float32Array.prototype.mat4_getScale = function (out = glMatrix.vec3.create()) {
    glMatrix.mat4.getScaling(out, this);
    return out;
};

//New Methods

Float32Array.prototype.mat4_setPosition = function (position) {
    this[12] = position[0];
    this[13] = position[1];
    this[14] = position[2];
    return this;
};

Float32Array.prototype.mat4_setRotation = function (rotation) {
    this.mat4_setRotationDegrees(rotation);
    return this;
};

Float32Array.prototype.mat4_setRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation) {
        this.mat4_setRotationQuat(rotation.vec3_degreesToQuat(quat));
        return this;
    };
}();

Float32Array.prototype.mat4_setRotationRadians = function () {
    let vector = glMatrix.vec3.create();
    return function (rotation) {
        this.mat4_setRotationDegrees(rotation.vec3_toDegrees(vector));
        return this;
    };
}();

Float32Array.prototype.mat4_setRotationQuat = function () {
    let position = glMatrix.vec3.create();
    let scale = glMatrix.vec3.create();
    return function (rotation) {
        this.mat4_getPosition(position);
        this.mat4_getScale(scale);
        this.mat4_setPositionRotationQuatScale(position, rotation, scale);
        return this;
    };
}();

Float32Array.prototype.mat4_setScale = function () {
    let tempScale = glMatrix.vec3.create();
    return function (scale) {
        glMatrix.mat4.getScaling(tempScale, this);
        glMatrix.vec3.divide(tempScale, scale, tempScale);
        glMatrix.mat4.scale(this, this, tempScale);
        return this;
    };
}();

Float32Array.prototype.mat4_setPositionRotationScale = function (position, rotation, scale) {
    this.mat4_setPositionRotationDegreesScale(position, rotation, scale);
    return this;
};

Float32Array.prototype.mat4_setPositionRotationDegreesScale = function () {
    let quat = glMatrix.quat.create();
    return function (position, rotation, scale) {
        this.mat4_setPositionRotationQuatScale(position, rotation.vec3_degreesToQuat(quat), scale);
        return this;
    };
}();

Float32Array.prototype.mat4_setPositionRotationRadiansScale = function () {
    let vector = glMatrix.vec3.create();
    return function (position, rotation, scale) {
        this.mat4_setPositionRotationDegreesScale(position, rotation.vec3_toDegrees(vector), scale);
        return this;
    };
}();

Float32Array.prototype.mat4_setPositionRotationQuatScale = function (position, rotation, scale) {
    glMatrix.mat4.fromRotationTranslationScale(this, rotation, position, scale);
    return this;
};

Float32Array.prototype.mat4_setPositionRotation = function (position, rotation) {
    this.mat4_setPositionRotationDegrees(position, rotation);
    return this;
};

Float32Array.prototype.mat4_setPositionRotationDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (position, rotation) {
        this.mat4_setPositionRotationQuat(position, rotation.vec3_degreesToQuat(quat));
        return this;
    };
}();

Float32Array.prototype.mat4_setPositionRotationRadians = function () {
    let vector = glMatrix.vec3.create();
    return function (position, rotation) {
        this.mat4_setPositionRotationDegrees(position, rotation.vec3_toDegrees(vector));
        return this;
    };
}();

Float32Array.prototype.mat4_setPositionRotationQuat = function (position, rotation) {
    glMatrix.mat4.fromRotationTranslation(this, rotation, position);
    return this;
};

Float32Array.prototype.mat4_getAxes = function (out = [glMatrix.vec3.create(), glMatrix.vec3.create(), glMatrix.vec3.create()]) {
    glMatrix.vec3.set(out[0], this[0], this[1], this[2]);
    glMatrix.vec3.set(out[1], this[4], this[5], this[6]);
    glMatrix.vec3.set(out[2], this[8], this[9], this[10]);

    glMatrix.vec3.normalize(out[0], out[0]);
    glMatrix.vec3.normalize(out[1], out[1]);
    glMatrix.vec3.normalize(out[2], out[2]);

    return out;
};

Float32Array.prototype.mat4_toWorld = function () {
    let convertTransform = glMatrix.mat4.create();
    let position = glMatrix.vec3.create();
    let scale = glMatrix.vec3.create();
    let inverseScale = glMatrix.vec3.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (parentTransform, out = glMatrix.mat4.create()) {
        if (parentTransform.mat4_hasUniformScale()) {
            glMatrix.mat4.mul(out, parentTransform, this);
        } else {
            glMatrix.vec3.set(position, this[12], this[13], this[14]);
            position.vec3_convertPositionToWorldMatrix(parentTransform, position);

            glMatrix.mat4.getScaling(scale, parentTransform);
            glMatrix.vec3.divide(inverseScale, one, scale);
            glMatrix.mat4.scale(convertTransform, parentTransform, inverseScale);

            glMatrix.mat4.mul(out, convertTransform, this);
            glMatrix.mat4.scale(out, out, scale);

            out[12] = position[0];
            out[13] = position[1];
            out[14] = position[2];
            out[15] = 1;
        }
        return out;
    };
}();

Float32Array.prototype.mat4_toLocal = function () {
    let convertTransform = glMatrix.mat4.create();
    let position = glMatrix.vec3.create();
    let scale = glMatrix.vec3.create();
    let inverseScale = glMatrix.vec3.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (parentTransform, out = glMatrix.mat4.create()) {
        if (parentTransform.mat4_hasUniformScale()) {
            glMatrix.mat4.invert(convertTransform, parentTransform);
            glMatrix.mat4.mul(out, convertTransform, this);
        } else {
            glMatrix.vec3.set(position, this[12], this[13], this[14]);
            position.vec3_convertPositionToLocalMatrix(parentTransform, position);

            glMatrix.mat4.getScaling(scale, parentTransform);
            glMatrix.vec3.divide(inverseScale, one, scale);
            glMatrix.mat4.scale(convertTransform, parentTransform, inverseScale);

            glMatrix.mat4.invert(convertTransform, convertTransform);
            glMatrix.mat4.mul(out, convertTransform, this);
            glMatrix.mat4.scale(out, out, inverseScale);

            out[12] = position[0];
            out[13] = position[1];
            out[14] = position[2];
            out[15] = 1;
        }
        return out;
    };
}();

Float32Array.prototype.mat4_hasUniformScale = function () {
    let scale = glMatrix.vec3.create();
    return function () {
        glMatrix.mat4.getScaling(scale, this);
        return Math.abs(scale[0] - scale[1]) < this._pp_epsilon && Math.abs(scale[1] - scale[2]) < this._pp_epsilon && Math.abs(scale[0] - scale[2]) < this._pp_epsilon;
    };
}();

Float32Array.prototype.mat4_toQuat = function () {
    let position = glMatrix.vec3.create();
    let rotation = glMatrix.quat.create();
    return function (out = glMatrix.quat2.create()) {
        glMatrix.mat4.getTranslation(position, this);
        this.mat4_getRotationQuat(rotation);
        glMatrix.quat2.fromRotationTranslation(out, rotation, position);
        return out;
    };
}();

Float32Array.prototype.mat4_fromQuat = function (transformQuat) {
    transformQuat.quat2_toMatrix(this);
    return this;
};

//CREATION

function vec3_create(x = null, y = null, z = null) {
    let out = glMatrix.vec3.create();
    if (x != null) {
        out.vec3_set(x, y, z);
    }
    return out;
}

function vec4_create(x = null, y = null, z = null, w = null) {
    let out = glMatrix.vec4.create();
    if (x != null) {
        out.vec4_set(x, y, z, w);
    }
    return out;
}

function quat_create(x = null, y = null, z = null, w = null) {
    let out = glMatrix.quat.create();
    if (x != null) {
        out.quat_set(x, y, z, w);
    }
    return out;
}

function quat2_create() {
    let out = glMatrix.quat2.create();
    return out;
}

function quat2_fromPositionRotation(position, rotation) {
    return quat2_fromPositionRotationDegrees(position, rotation);
}

function quat2_fromPositionRotationDegrees(position, rotation) {
    let out = glMatrix.mat4.create();
    out.quat2_setPositionRotationDegrees(position, rotation);
    return out;
}

function quat2_fromPositionRotationRadians(position, rotation) {
    let out = glMatrix.mat4.create();
    out.quat2_setPositionRotationRadians(position, rotation);
    return out;
}

function quat2_fromPositionRotationQuat(position, rotation) {
    let out = glMatrix.quat2.create();
    out.quat2_setPositionRotationQuat(position, rotation);
    return out;
}

function mat4_create() {
    let out = glMatrix.mat4.create();
    return out;
}

function mat4_fromPositionRotation(position, rotation) {
    return mat4_fromPositionRotationDegrees(position, rotation);
}

function mat4_fromPositionRotationDegrees(position, rotation) {
    let out = glMatrix.mat4.create();
    out.mat4_setPositionRotationDegrees(position, rotation);
    return out;
}

function mat4_fromPositionRotationRadians(position, rotation) {
    let out = glMatrix.mat4.create();
    out.mat4_setPositionRotationRadians(position, rotation);
    return out;
}

function mat4_fromPositionRotationQuat(position, rotation) {
    let out = glMatrix.mat4.create();
    out.mat4_setPositionRotationQuat(position, rotation);
    return out;
}

function mat4_fromPositionRotationScale(position, rotation, scale) {
    return mat4_fromPositionRotationDegreesScale(position, rotation, scale);
}

function mat4_fromPositionRotationDegreesScale(position, rotation, scale) {
    let out = glMatrix.mat4.create();
    out.mat4_setPositionRotationDegreesScale(position, rotation, scale);
    return out;
}

function mat4_fromPositionRotationRadiansScale(position, rotation, scale) {
    let out = glMatrix.mat4.create();
    out.mat4_setPositionRotationRadiansScale(position, rotation, scale);
    return out;
}

function mat4_fromPositionRotationQuatScale(position, rotation, scale) {
    let out = glMatrix.mat4.create();
    out.mat4_setPositionRotationQuatScale(position, rotation, scale);
    return out;
}

//UTILS

Float32Array.prototype._pp_epsilon = 0.000001;

Float32Array.prototype._pp_clamp = function (value, min, max) {
    return Math.min(Math.max(value, min), max);
};

Float32Array.prototype._vec_buildConsoleMessage = function (decimalPlaces) {
    let message = "[";

    for (let i = 0; i < this.length; i++) {
        if (i != 0) {
            message = message.concat(", ");
        }

        message = message.concat(this[i].toFixed(decimalPlaces));
    }

    message = message.concat("]");
    return message;
};

Float32Array.prototype._vec_prepareOut = function (out) {
    if (out == null) {
        out = this.pp_clone();
    } else if (out != this) {
        out.pp_copy(this);
    }

    return out;
};

for (let key in Float32Array.prototype) {
    let prefixes = ["pp_", "vec_", "vec3_", "vec4_", "quat_", "quat2_", "mat3_", "mat4_", "_pp_", "_vec_",];

    let found = false;
    for (let prefix of prefixes) {
        if (key.startsWith(prefix)) {
            found = true;
            break;
        }
    }

    if (found) {
        Object.defineProperty(Float32Array.prototype, key, { enumerable: false });
    }
}
if (!PP) {
    var PP = {};
}

Math.pp_clamp = function (value, start, end) {
    let fixedStart = (start != null) ? start : Number.MIN_VALUE;
    let fixedEnd = (end != null) ? end : Number.MAX_VALUE;

    let min = Math.min(fixedStart, fixedEnd);
    let max = Math.max(fixedStart, fixedEnd);
    return Math.min(Math.max(value, min), max);
};

Math.pp_sign = function (value, zeroSign = 1) {
    let sign = Math.sign(value);
    if (sign == 0) {
        sign = Math.sign(zeroSign);
    }
    return sign;
};

Math.pp_toDegrees = function (angle) {
    return angle * (180 / Math.PI);
};

Math.pp_toRadians = function (angle) {
    return glMatrix.glMatrix.toRadian(angle);
};

Math.pp_roundDecimal = function (number, decimalPlaces) {
    let factor = Math.pow(10, decimalPlaces);
    number = Math.round(number * factor) / factor;

    return number;
};

// Start range value doesn't need to be lower than the end one, so you can map from [0,1] to [3,2], where 3 is greater than 2
Math.pp_mapToRange = function (value, originRangeStart, originRangeEnd, newRangeStart, newRangeEnd) {
    if (originRangeStart == originRangeEnd) {
        return newRangeStart;
    }

    let clampedValue = Math.pp_clamp(value, originRangeStart, originRangeEnd);

    if (clampedValue == originRangeStart) {
        return newRangeStart;
    } else if (clampedValue == originRangeEnd) {
        return newRangeEnd;
    }

    let newValue = newRangeStart + ((newRangeEnd - newRangeStart) / (originRangeEnd - originRangeStart)) * (clampedValue - originRangeStart);
    let clampedNewValue = Math.pp_clamp(newValue, newRangeStart, newRangeEnd);
    return clampedNewValue;
};

//Range is [start, end)
Math.pp_random = function (start = 0, end = 1) {
    return Math.random() * (end - start) + start;
};

//Range is [start, end]
Math.pp_randomInt = function (start, end) {
    let min = Math.min(start, end);
    let max = Math.max(start, end);
    return Math.floor(Math.random() * (max - min + 1) + min);
};

//Return 1 or -1
Math.pp_randomSign = function () {
    return (Math.random() < 0.5) ? 1 : -1;
};

//You give it a list of parameters and returns one
Math.pp_randomPick = function (...args) {
    let random = null;

    if (args.length > 0) {
        if (args.length == 1 && args[0].length != null) {
            if (args[0].length > 0) {
                let randomIndex = Math.pp_randomInt(0, args[0].length - 1);
                random = args[0][randomIndex];
            }
        } else {
            let randomIndex = Math.pp_randomInt(0, args.length - 1);
            random = args[randomIndex];
        }
    }

    return random;
};

Math.pp_lerp = function (from, to, interpolationValue) {
    if (interpolationValue == 0) {
        return from;
    } else if (interpolationValue == 1) {
        return to;
    }

    return interpolationValue * (to - from) + from;
};

PP.EasingFunction = {
    linear: t => t,
    easeIn: t => t * t * t,
    easeOut: t => (t - 1) * (t - 1) * (t - 1) + 1,
    easeInOut: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
};

Math.pp_interpolate = function (from, to, interpolationValue, easingFunction = PP.EasingFunction.linear) {
    let lerpValue = easingFunction(interpolationValue);
    return Math.pp_lerp(from, to, lerpValue);
};

Math.pp_angleDistance = function (first, second) {
    return Math.pp_angleDistanceDegrees(first, second);
};

Math.pp_angleDistanceDegrees = function (first, second) {
    return Math.abs(Math.pp_angleDistanceSignedDegrees(first, second));
};

Math.pp_angleDistanceRadians = function (first, second) {
    return Math.abs(Math.pp_angleDistanceSignedRadians(first, second));
};

Math.pp_angleDistanceSigned = function (first, second) {
    return Math.pp_angleDistanceSignedDegrees(first, second);
};

Math.pp_angleDistanceSignedDegrees = function (first, second) {
    let clampedFirst = Math.pp_angleClampDegrees(first, true);
    let clampedSecond = Math.pp_angleClampDegrees(second, true);

    let distance = clampedSecond - clampedFirst;
    if (clampedSecond - clampedFirst > 180) {
        distance = (clampedSecond - clampedFirst) - 360;
    } else if (clampedSecond - clampedFirst < -180) {
        distance = (clampedSecond - clampedFirst) + 360;
    }

    return distance;
};

Math.pp_angleDistanceSignedRadians = function (first, second) {
    return Math.pp_toRadians(Math.pp_angleDistanceSignedDegrees(Math.pp_toDegrees(first), Math.pp_toDegrees(second)));
};

//Clamp the angle to -180/+180, so that, for example, 270 will be -90
//if usePositiveRange is true, the angle will be clamped to 0/360
Math.pp_angleClamp = function (angle, usePositiveRange = false) {
    return Math.pp_angleClampDegrees(angle, usePositiveRange);
};

//Clamp the angle to -180/+180, so that, for example, 270 will be -90
//if usePositiveRange is true, the angle will be clamped to 0/360
Math.pp_angleClampDegrees = function (angle, usePositiveRange = false) {
    let clampedAngle = angle % 360;

    if (clampedAngle < 0) {
        clampedAngle += 360;
    }

    if (!usePositiveRange) {
        if (clampedAngle > 180) {
            clampedAngle -= 360;
        }
    }

    return clampedAngle;
};

//Clamp the angle to -Pi/+Pi, so that, for example, 270 will be -90
//if usePositiveRange is true, the angle will be clamped to 0/2Pi
Math.pp_angleClampRadians = function (angle, usePositiveRange = false) {
    return Math.pp_toRadians(Math.pp_angleClampDegrees(Math.pp_toDegrees(angle), usePositiveRange));
};

//The range goes from start to end by going toward the positive direction (if useShortestAngle is false)
//[20,300] is a 280 degrees range, [300, 20] is an 80 degrees range, [-150,-170] = [210, 190] is a 240 degrees range, [0, -10] = [0, 350] is a 350 degrees range
Math.pp_isInsideAngleRange = function (angle, start, end, useShortestAngle = false) {
    return Math.pp_isInsideAngleRangeDegrees(angle, start, end, useShortestAngle);
};

Math.pp_isInsideAngleRangeDegrees = function (angle, start, end, useShortestAngle = false) {
    let isInside = false;

    let anglePositive = Math.pp_angleClampDegrees(angle, true);
    let startPositive = Math.pp_angleClampDegrees(start, true);
    let endPositive = Math.pp_angleClampDegrees(end, true);

    if (useShortestAngle) {
        if (Math.pp_angleDistanceSignedDegrees(startPositive, endPositive) < 0) {
            let temp = startPositive;
            startPositive = endPositive;
            endPositive = temp;
        }
    }

    if (startPositive < endPositive) {
        isInside = anglePositive >= startPositive && anglePositive <= endPositive;
    } else {
        isInside = anglePositive >= startPositive || anglePositive <= endPositive;
    }

    return isInside;
};

Math.pp_isInsideAngleRangeRadians = function (angle, start, end, useShortestAngle = false) {
    return Math.pp_isInsideAngleRangeDegrees(Math.pp_toDegrees(angle), Math.pp_toDegrees(start), Math.pp_toDegrees(end), useShortestAngle);
};

for (let key in Math) {
    let prefixes = ["pp_", "_pp_"];

    let found = false;
    for (let prefix of prefixes) {
        if (key.startsWith(prefix)) {
            found = true;
            break;
        }
    }

    if (found) {
        Object.defineProperty(Math, key, { enumerable: false });
    }
}
/*
    How to use

    By default the methods work on World space, rotations are in Degrees and transforms are Matrix (and not Quat 2) 
    For methods that work with rotations, Matrix means Matrix 3 and Quat means Quat
    For methods that work with transforms, Matrix means Matrix 4 and Quat means Quat 2

    You can add a suffix like World/Local/Object at the end of some methods to specify the space, example:
        - pp_getPositionLocal to get the position in local space (parent space)
        - pp_translateObject to translate in object space

    For rotations u can add a suffix like Degrees/Radians/Quat/Matrix to use a specific version, example:
        - pp_getRotationDegrees
        - pp_setRotationLocalMatrix
        - pp_rotateWorldQuat
        
    For transform u can add a suffix like Quat/Matrix to use a specific version, example:
        - pp_getTransformQuat
        - pp_setTransformWorldMatrix
        
    Some methods let you specify if u want them to work on the Hierarchy/Descendants/Children where:
        - Children: direct children of the object
        - Descendants: all the children of the object, including child of child and so on 
        - Hierarchy: Descendants plus the current object
    By default the methods work on the current object alone:
        - pp_getComponent
        - pp_getComponentHierarchy
        - pp_getComponentAmountMapDescendants
        - pp_setActiveChildren

    The methods leave u the choice of forwarding an out parameter or just get the return value, example:
        - let position = this.object.pp_getPosition()
        - this.object.pp_getPosition(position)
        - the out parameter is always the last one

    List of methods:
        Note:
            - The suffixes (like World or Radians) are omitted 

        - pp_getPosition    / pp_setPosition    / pp_resetPosition
        - pp_getRotation    / pp_setRotation    / pp_resetRotation
        - pp_getScale       / pp_setScale (u can specify a single number instead of a vector to uniform scale easily)   / pp_resetScale 
        - pp_getTransform   / pp_setTransform   / pp_resetTransform

        - pp_getLeft        / pp_getRight
        - pp_getUp          / pp_getDown
        - pp_getForward     / pp_getBackward

        - pp_translate      / pp_translateAxis
        - pp_rotate         / pp_rotateAxis     / pp_rotateAround    / pp_rotateAroundAxis
        - pp_scaleObject (for now scale only have this variant) (u can specify a single number instead of a vector to uniform scale easily)

        - pp_lookAt         / pp_lookTo (u can avoid to specify up and the method will pickup the object up by default)

        - pp_getParent      / pp_setParent (let u specify if u want to keep the transform or not)

        - pp_convertPositionObjectToWorld (you can use all the combinations between Object/Local/World)
        - pp_convertDirectionObjectToWorld (you can use all the combinations between Object/Local/World)
        - pp_convertTransformObjectToWorld (you can use all the combinations between Object/Local/World) (u also have Quat and Matrix version)

        - pp_hasUniformScale

        - pp_addComponent  /  pp_getComponent  / pp_getComponentHierarchy / pp_getComponentDescendants / pp_getComponentChildren
        - pp_getComponents  / pp_getComponentsHierarchy / pp_getComponentsDescendants / pp_getComponentsChildren

        - pp_setActive  / pp_setActiveHierarchy / pp_setActiveDescendants / pp_setActiveChildren

        - pp_clone      / pp_isCloneable

        - pp_getName    / pp_setName
        - pp_getID
        - pp_getHierarchy / pp_getDescendants / pp_getChildren
        - pp_getComponentAmountMap / pp_getComponentAmountMapHierarchy / pp_getComponentAmountMapDescendants / pp_getComponentAmountMapChildren
        - pp_markDirty
        - pp_equals
        - pp_destroy
*/


//GETTER

//Position

WL.Object.prototype.pp_getPosition = function (position) {
    return this.pp_getPositionWorld(position);
};

WL.Object.prototype.pp_getPositionWorld = function (position = glMatrix.vec3.create()) {
    this.getTranslationWorld(position);
    return position;
};

WL.Object.prototype.pp_getPositionLocal = function (position = glMatrix.vec3.create()) {
    this.getTranslationLocal(position);
    return position;
};

//Rotation

WL.Object.prototype.pp_getRotation = function (rotation) {
    return this.pp_getRotationWorld(rotation);
};
WL.Object.prototype.pp_getRotationDegrees = function (rotation) {
    return this.pp_getRotationWorldDegrees(rotation);
};

WL.Object.prototype.pp_getRotationRadians = function (rotation) {
    return this.pp_getRotationWorldRadians(rotation);
};

WL.Object.prototype.pp_getRotationMatrix = function (rotation) {
    return this.pp_getRotationWorldMatrix(rotation);
};

WL.Object.prototype.pp_getRotationQuat = function (rotation) {
    return this.pp_getRotationWorldQuat(rotation);
};

//Rotation World

WL.Object.prototype.pp_getRotationWorld = function (rotation) {
    return this.pp_getRotationWorldDegrees(rotation);
};

WL.Object.prototype.pp_getRotationWorldDegrees = function (rotation) {
    rotation = this.pp_getRotationWorldRadians(rotation);
    rotation.forEach(function (value, index, array) {
        array[index] = this._pp_toDegrees(value);
    }.bind(this));
    return rotation;
};

WL.Object.prototype.pp_getRotationWorldRadians = function () {
    let quat = glMatrix.quat.create();
    return function (rotation = glMatrix.vec3.create()) {
        this.pp_getRotationWorldQuat(quat);
        this._pp_quaternionToRadians(quat, rotation);
        return rotation;
    };
}();

WL.Object.prototype.pp_getRotationWorldMatrix = function () {
    let quat = glMatrix.quat.create();
    return function (rotation = glMatrix.mat3.create()) {
        this.pp_getRotationWorldQuat(quat);
        glMatrix.mat3.fromQuat(rotation, quat);
        return rotation;
    };
}();

WL.Object.prototype.pp_getRotationWorldQuat = function (rotation = glMatrix.quat.create()) {
    glMatrix.quat.copy(rotation, this.rotationWorld);
    return rotation;
};

//Rotation Local

WL.Object.prototype.pp_getRotationLocal = function (rotation) {
    return this.pp_getRotationLocalDegrees(rotation);
};

WL.Object.prototype.pp_getRotationLocalDegrees = function (rotation) {
    rotation = this.pp_getRotationLocalRadians(rotation);
    rotation.forEach(function (value, index, array) {
        array[index] = this._pp_toDegrees(value);
    }.bind(this));
    return rotation;
};

WL.Object.prototype.pp_getRotationLocalRadians = function () {
    let quat = glMatrix.quat.create();
    return function (rotation = glMatrix.vec3.create()) {
        this.pp_getRotationLocalQuat(quat);
        this._pp_quaternionToRadians(quat, rotation);
        return rotation;
    };
}();

WL.Object.prototype.pp_getRotationLocalMatrix = function () {
    let quat = glMatrix.quat.create();
    return function (rotation = glMatrix.mat3.create()) {
        this.pp_getRotationLocalQuat(quat);
        glMatrix.mat3.fromQuat(rotation, quat);
        return rotation;
    };
}();

WL.Object.prototype.pp_getRotationLocalQuat = function (rotation = glMatrix.quat.create()) {
    glMatrix.quat.copy(rotation, this.rotationLocal);
    return rotation;
};

//Scale

WL.Object.prototype.pp_getScale = function (scale) {
    return this.pp_getScaleWorld(scale);
};

WL.Object.prototype.pp_getScaleWorld = function (scale = glMatrix.vec3.create()) {
    glMatrix.vec3.copy(scale, this.scalingWorld);
    return scale;
};

WL.Object.prototype.pp_getScaleLocal = function (scale = glMatrix.vec3.create()) {
    glMatrix.vec3.copy(scale, this.scalingLocal);
    return scale;
};

//Transform

WL.Object.prototype.pp_getTransform = function (transform) {
    return this.pp_getTransformWorld(transform);
};

WL.Object.prototype.pp_getTransformMatrix = function (transform) {
    return this.pp_getTransformWorldMatrix(transform);
};

WL.Object.prototype.pp_getTransformQuat = function (transform) {
    return this.pp_getTransformWorldQuat(transform);
};

//Transform World

WL.Object.prototype.pp_getTransformWorld = function (transform) {
    return this.pp_getTransformWorldMatrix(transform);
};

WL.Object.prototype.pp_getTransformWorldMatrix = function () {
    let transformQuat = glMatrix.quat2.create();
    let scale = glMatrix.vec3.create();
    return function (transform = glMatrix.mat4.create()) {
        this.pp_getTransformWorldQuat(transformQuat);
        this.pp_getScaleWorld(scale);
        glMatrix.mat4.fromQuat2(transform, transformQuat);
        glMatrix.mat4.scale(transform, transform, scale);
        return transform;
    };
}();

WL.Object.prototype.pp_getTransformWorldQuat = function (transform = glMatrix.quat2.create()) {
    glMatrix.quat2.copy(transform, this.transformWorld);
    return transform;
};

//Transform Local

WL.Object.prototype.pp_getTransformLocal = function (transform) {
    return this.pp_getTransformLocalMatrix(transform);
};

WL.Object.prototype.pp_getTransformLocalMatrix = function () {
    let transformQuat = glMatrix.quat2.create();
    let scale = glMatrix.vec3.create();
    return function (transform = glMatrix.mat4.create()) {
        this.pp_getTransformLocalQuat(transformQuat);
        this.pp_getScaleLocal(scale);
        glMatrix.mat4.fromQuat2(transform, transformQuat);
        glMatrix.mat4.scale(transform, transform, scale);
        return transform;
    };
}();

WL.Object.prototype.pp_getTransformLocalQuat = function (transform = glMatrix.quat2.create()) {
    glMatrix.quat2.copy(transform, this.transformLocal);
    return transform;
};

//Forward

WL.Object.prototype.pp_getForward = function (forward) {
    return this.pp_getForwardWorld(forward);
};

WL.Object.prototype.pp_getForwardWorld = function () {
    let rotation = glMatrix.mat3.create();
    return function (forward = glMatrix.vec3.create()) {
        this.pp_getRotationWorldMatrix(rotation);
        forward[0] = rotation[6];
        forward[1] = rotation[7];
        forward[2] = rotation[8];
        return forward;
    };
}();

WL.Object.prototype.pp_getForwardLocal = function () {
    let rotation = glMatrix.mat3.create();
    return function (forward = glMatrix.vec3.create()) {
        this.pp_getRotationLocalMatrix(rotation);
        forward[0] = rotation[6];
        forward[1] = rotation[7];
        forward[2] = rotation[8];
        return forward;
    };
}();

//Backward

WL.Object.prototype.pp_getBackward = function (backward) {
    return this.pp_getBackwardWorld(backward);
};

WL.Object.prototype.pp_getBackwardWorld = function () {
    let rotation = glMatrix.mat3.create();
    return function (backward = glMatrix.vec3.create()) {
        this.pp_getRotationWorldMatrix(rotation);
        backward[0] = -rotation[6];
        backward[1] = -rotation[7];
        backward[2] = -rotation[8];
        return backward;
    };
}();

WL.Object.prototype.pp_getBackwardLocal = function () {
    let rotation = glMatrix.mat3.create();
    return function (backward = glMatrix.vec3.create()) {
        this.pp_getRotationLocalMatrix(rotation);
        backward[0] = -rotation[6];
        backward[1] = -rotation[7];
        backward[2] = -rotation[8];
        return backward;
    };
}();

//Up

WL.Object.prototype.pp_getUp = function (up) {
    return this.pp_getUpWorld(up);
};

WL.Object.prototype.pp_getUpWorld = function () {
    let rotation = glMatrix.mat3.create();
    return function (up = glMatrix.vec3.create()) {
        this.pp_getRotationWorldMatrix(rotation);
        up[0] = rotation[3];
        up[1] = rotation[4];
        up[2] = rotation[5];
        return up;
    };
}();

WL.Object.prototype.pp_getUpLocal = function () {
    let rotation = glMatrix.mat3.create();
    return function (up = glMatrix.vec3.create()) {
        this.pp_getRotationLocalMatrix(rotation);
        up[0] = rotation[3];
        up[1] = rotation[4];
        up[2] = rotation[5];
        return up;
    };
}();

//Down

WL.Object.prototype.pp_getDown = function (down) {
    return this.pp_getDownWorld(down);
};

WL.Object.prototype.pp_getDownWorld = function () {
    let rotation = glMatrix.mat3.create();
    return function (down = glMatrix.vec3.create()) {
        this.pp_getRotationWorldMatrix(rotation);
        down[0] = -rotation[3];
        down[1] = -rotation[4];
        down[2] = -rotation[5];
        return down;
    };
}();

WL.Object.prototype.pp_getDownLocal = function () {
    let rotation = glMatrix.mat3.create();
    return function (down = glMatrix.vec3.create()) {
        this.pp_getRotationLocalMatrix(rotation);
        down[0] = -rotation[3];
        down[1] = -rotation[4];
        down[2] = -rotation[5];
        return down;
    };
}();

//Left

WL.Object.prototype.pp_getLeft = function (left) {
    return this.pp_getLeftWorld(left);
};

WL.Object.prototype.pp_getLeftWorld = function () {
    let rotation = glMatrix.mat3.create();
    return function (left = glMatrix.vec3.create()) {
        this.pp_getRotationWorldMatrix(rotation);
        left[0] = rotation[0];
        left[1] = rotation[1];
        left[2] = rotation[2];
        return left;
    };
}();

WL.Object.prototype.pp_getLeftLocal = function () {
    let rotation = glMatrix.mat3.create();
    return function (left = glMatrix.vec3.create()) {
        this.pp_getRotationLocalMatrix(rotation);
        left[0] = rotation[0];
        left[1] = rotation[1];
        left[2] = rotation[2];
        return left;
    };
}();

//Right

WL.Object.prototype.pp_getRight = function (right) {
    return this.pp_getRightWorld(right);
};

WL.Object.prototype.pp_getRightWorld = function () {
    let rotation = glMatrix.mat3.create();
    return function (right = glMatrix.vec3.create()) {
        this.pp_getRotationWorldMatrix(rotation);
        right[0] = -rotation[0];
        right[1] = -rotation[1];
        right[2] = -rotation[2];
        return right;
    };
}();

WL.Object.prototype.pp_getRightLocal = function () {
    let rotation = glMatrix.mat3.create();
    return function (right = glMatrix.vec3.create()) {
        this.pp_getRotationLocalMatrix(rotation);
        right[0] = -rotation[0];
        right[1] = -rotation[1];
        right[2] = -rotation[2];
        return right;
    };
}();

//SETTER

//Position

WL.Object.prototype.pp_setPosition = function (position) {
    this.pp_setPositionWorld(position);
};

WL.Object.prototype.pp_setPositionWorld = function (position) {
    this.setTranslationWorld(position);
};

WL.Object.prototype.pp_setPositionLocal = function (position) {
    this.setTranslationLocal(position);
};

//Rotation

WL.Object.prototype.pp_setRotation = function (rotation) {
    this.pp_setRotationWorld(rotation);
};
WL.Object.prototype.pp_setRotationDegrees = function (rotation) {
    this.pp_setRotationWorldDegrees(rotation);
};

WL.Object.prototype.pp_setRotationRadians = function (rotation) {
    this.pp_setRotationWorldRadians(rotation);
};

WL.Object.prototype.pp_setRotationMatrix = function (rotation) {
    this.pp_setRotationWorldMatrix(rotation);
};

WL.Object.prototype.pp_setRotationQuat = function (rotation) {
    this.pp_setRotationWorldQuat(rotation);
};

//Rotation World

WL.Object.prototype.pp_setRotationWorld = function (rotation) {
    this.pp_setRotationWorldDegrees(rotation);
};

WL.Object.prototype.pp_setRotationWorldDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation) {
        this._pp_degreesToQuaternion(rotation, quat);
        this.pp_setRotationWorldQuat(quat);
    };
}();

WL.Object.prototype.pp_setRotationWorldRadians = function () {
    let degreesRotation = glMatrix.vec3.create();
    return function (rotation) {
        rotation.forEach(function (value, index, array) {
            degreesRotation[index] = this._pp_toDegrees(value);
        }.bind(this));
        this.pp_setRotationWorldDegrees(degreesRotation);
    };
}();

WL.Object.prototype.pp_setRotationWorldMatrix = function () {
    let quat = glMatrix.quat.create();
    return function (rotation) {
        glMatrix.quat.fromMat3(quat, rotation);
        this.pp_setRotationWorldQuat(quat);
    };
}();

WL.Object.prototype.pp_setRotationWorldQuat = function (rotation) {
    this.rotationWorld = rotation;
};

//Rotation Local

WL.Object.prototype.pp_setRotationLocal = function (rotation) {
    this.pp_setRotationLocalDegrees(rotation);
};

WL.Object.prototype.pp_setRotationLocalDegrees = function () {
    let quat = glMatrix.quat.create();
    return function (rotation) {
        this._pp_degreesToQuaternion(rotation, quat);
        this.pp_setRotationLocalQuat(quat);
    };
}();

WL.Object.prototype.pp_setRotationLocalRadians = function () {
    let degreesRotation = glMatrix.vec3.create();
    return function (rotation) {
        rotation.forEach(function (value, index, array) {
            degreesRotation[index] = this._pp_toDegrees(value);
        }.bind(this));
        this.pp_setRotationLocalDegrees(degreesRotation);
    };
}();

WL.Object.prototype.pp_setRotationLocalMatrix = function () {
    let quat = glMatrix.quat.create();
    return function (rotation) {
        glMatrix.quat.fromMat3(quat, rotation);
        this.pp_setRotationLocalQuat(quat);
    };
}();

WL.Object.prototype.pp_setRotationLocalQuat = function (rotation) {
    this.rotationLocal = rotation;
};

//Scale

WL.Object.prototype.pp_setScale = function (scale) {
    this.pp_setScaleWorld(scale);
};

WL.Object.prototype.pp_setScaleWorld = function () {
    let vector = glMatrix.vec3.create();
    return function (scale) {
        if (isNaN(scale)) {
            this.scalingWorld = scale;
        } else {
            glMatrix.vec3.set(vector, scale, scale, scale);
            this.scalingWorld = vector;
        }
    };
}();

WL.Object.prototype.pp_setScaleLocal = function () {
    let vector = glMatrix.vec3.create();
    return function (scale) {
        if (isNaN(scale)) {
            this.scalingLocal = scale;
        } else {
            glMatrix.vec3.set(vector, scale, scale, scale);
            this.scalingLocal = vector;
        }
    };
}();

//Transform

WL.Object.prototype.pp_setTransform = function (transform) {
    this.pp_setTransformWorld(transform);
};

WL.Object.prototype.pp_setTransformMatrix = function (transform) {
    this.pp_setTransformWorldMatrix(transform);
};

WL.Object.prototype.pp_setTransformQuat = function (transform) {
    this.pp_setTransformWorldQuat(transform);
};

//Transform World

WL.Object.prototype.pp_setTransformWorld = function (transform) {
    return this.pp_setTransformWorldMatrix(transform);
};

WL.Object.prototype.pp_setTransformWorldMatrix = function () {
    let position = glMatrix.vec3.create();
    let rotation = glMatrix.quat.create();
    let scale = glMatrix.vec3.create();
    let transformMatrixNoScale = glMatrix.mat4.create();
    let inverseScale = glMatrix.vec3.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (transform) {
        glMatrix.mat4.getTranslation(position, transform);
        glMatrix.mat4.getScaling(scale, transform);
        glMatrix.vec3.divide(inverseScale, one, scale);
        glMatrix.mat4.scale(transformMatrixNoScale, transform, inverseScale);
        glMatrix.mat4.getRotation(rotation, transformMatrixNoScale);
        glMatrix.quat.normalize(rotation, rotation);
        this.pp_setScaleWorld(scale);
        this.pp_setRotationWorldQuat(rotation);
        this.pp_setPositionWorld(position);
    };
}();

WL.Object.prototype.pp_setTransformWorldQuat = function (transform) {
    this.transformWorld = transform;
};

//Transform Local

WL.Object.prototype.pp_setTransformLocal = function (transform) {
    return this.pp_setTransformLocalMatrix(transform);
};

WL.Object.prototype.pp_setTransformLocalMatrix = function () {
    let position = glMatrix.vec3.create();
    let rotation = glMatrix.quat.create();
    let scale = glMatrix.vec3.create();
    let transformMatrixNoScale = glMatrix.mat4.create();
    let inverseScale = glMatrix.vec3.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (transform) {
        glMatrix.mat4.getTranslation(position, transform);
        glMatrix.mat4.getScaling(scale, transform);
        glMatrix.vec3.divide(inverseScale, one, scale);
        glMatrix.mat4.scale(transformMatrixNoScale, transform, inverseScale);
        glMatrix.mat4.getRotation(rotation, transformMatrixNoScale);
        glMatrix.quat.normalize(rotation, rotation);
        this.pp_setScaleLocal(scale);
        this.pp_setRotationLocalQuat(rotation);
        this.pp_setPositionLocal(position);
    };
}();

WL.Object.prototype.pp_setTransformLocalQuat = function (transform) {
    this.transformLocal = transform;
};

//RESET

//Position

WL.Object.prototype.pp_resetPosition = function () {
    this.pp_resetPositionWorld();
};

WL.Object.prototype.pp_resetPositionWorld = function () {
    let zero = glMatrix.vec3.create();
    return function () {
        this.pp_setPositionWorld(zero);
    };
}();

WL.Object.prototype.pp_resetPositionLocal = function () {
    let zero = glMatrix.vec3.create();
    return function () {
        this.pp_setPositionLocal(zero);
    };
}();

//Rotation

WL.Object.prototype.pp_resetRotation = function () {
    this.pp_resetRotationWorld();
};

WL.Object.prototype.pp_resetRotationWorld = function () {
    let identity = glMatrix.quat.create();
    return function () {
        this.pp_setRotationWorldQuat(identity);
    };
}();

WL.Object.prototype.pp_resetRotationLocal = function () {
    let identity = glMatrix.quat.create();
    return function () {
        this.pp_setRotationLocalQuat(identity);
    };
}();

//Scale

WL.Object.prototype.pp_resetScale = function () {
    this.pp_resetScaleWorld();
};

WL.Object.prototype.pp_resetScaleWorld = function () {
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function () {
        this.pp_setScaleWorld(one);
    };
}();

WL.Object.prototype.pp_resetScaleLocal = function () {
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function () {
        this.pp_setScaleLocal(one);
    };
}();

//Transform

WL.Object.prototype.pp_resetTransform = function () {
    this.pp_resetTransformWorld();
};

WL.Object.prototype.pp_resetTransformWorld = function () {
    this.pp_resetScaleWorld();
    this.pp_resetRotationWorld();
    this.pp_resetPositionWorld();
};

WL.Object.prototype.pp_resetTransformLocal = function () {
    this.pp_resetScaleLocal();
    this.pp_resetRotationLocal();
    this.pp_resetPositionLocal();
};

//TRANSFORMATIONS

//Translate

WL.Object.prototype.pp_translate = function (translation) {
    this.pp_translateWorld(translation);
};

WL.Object.prototype.pp_translateWorld = function (translation) {
    this.translateWorld(translation);
};

WL.Object.prototype.pp_translateLocal = function (translation) {
    this.translate(translation);
};

WL.Object.prototype.pp_translateObject = function (translation) {
    this.translateObject(translation);
};

//Translate Axis

WL.Object.prototype.pp_translateAxis = function (direction, amount) {
    this.pp_translateAxisWorld(direction, amount);
};

WL.Object.prototype.pp_translateAxisWorld = function () {
    let translation = glMatrix.vec3.create();
    return function (direction, amount) {
        glMatrix.vec3.scale(translation, direction, amount);
        this.pp_translateWorld(translation);
    };
}();

WL.Object.prototype.pp_translateAxisLocal = function () {
    let translation = glMatrix.vec3.create();
    return function (direction, amount) {
        glMatrix.vec3.scale(translation, direction, amount);
        this.pp_translateLocal(translation);
    };
}();

WL.Object.prototype.pp_translateAxisObject = function () {
    let translation = glMatrix.vec3.create();
    return function (direction, amount) {
        glMatrix.vec3.scale(translation, direction, amount);
        this.pp_translateObject(translation);
    };
}();

//Rotate

WL.Object.prototype.pp_rotate = function (rotation) {
    this.pp_rotateWorld(rotation);
};

WL.Object.prototype.pp_rotateDegrees = function (rotation) {
    this.pp_rotateWorldDegrees(rotation);
};

WL.Object.prototype.pp_rotateRadians = function (rotation) {
    this.pp_rotateWorldRadians(rotation);
};

WL.Object.prototype.pp_rotateMatrix = function (rotation) {
    this.pp_rotateWorldMatrix(rotation);
};

WL.Object.prototype.pp_rotateQuat = function (rotation) {
    this.pp_rotateWorldQuat(rotation);
};

//Rotate World

WL.Object.prototype.pp_rotateWorld = function (rotation) {
    this.pp_rotateWorldDegrees(rotation);
};

WL.Object.prototype.pp_rotateWorldDegrees = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (rotation) {
        this._pp_degreesToQuaternion(rotation, rotationQuat);
        this.pp_rotateWorldQuat(rotationQuat);
    };
}();

WL.Object.prototype.pp_rotateWorldRadians = function () {
    let degreesRotation = glMatrix.vec3.create();
    return function (rotation) {
        rotation.forEach(function (value, index, array) {
            degreesRotation[index] = this._pp_toDegrees(value);
        }.bind(this));
        this.pp_rotateWorldDegrees(degreesRotation);
    };
}();

WL.Object.prototype.pp_rotateWorldMatrix = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (rotation) {
        glMatrix.quat.fromMat3(rotationQuat, rotation);
        glMatrix.quat.normalize(rotationQuat, rotationQuat);
        this.pp_rotateWorldQuat(rotationQuat);
    };
}();

WL.Object.prototype.pp_rotateWorldQuat = function () {
    let currentRotationQuat = glMatrix.quat.create();
    return function (rotation) {
        this.pp_getRotationWorldQuat(currentRotationQuat);
        glMatrix.quat.mul(currentRotationQuat, rotation, currentRotationQuat);
        glMatrix.quat.normalize(currentRotationQuat, currentRotationQuat);
        this.pp_setRotationWorldQuat(currentRotationQuat);
    };
}();

//Rotate Local

WL.Object.prototype.pp_rotateLocal = function (rotation) {
    this.pp_rotateLocalDegrees(rotation);
};

WL.Object.prototype.pp_rotateLocalDegrees = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (rotation) {
        this._pp_degreesToQuaternion(rotation, rotationQuat);
        this.pp_rotateLocalQuat(rotationQuat);
    };
}();

WL.Object.prototype.pp_rotateLocalRadians = function () {
    let degreesRotation = glMatrix.vec3.create();
    return function (rotation) {
        rotation.forEach(function (value, index, array) {
            degreesRotation[index] = this._pp_toDegrees(value);
        }.bind(this));
        this.pp_rotateLocalDegrees(degreesRotation);
    };
}();

WL.Object.prototype.pp_rotateLocalMatrix = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (rotation) {
        glMatrix.quat.fromMat3(rotationQuat, rotation);
        glMatrix.quat.normalize(rotationQuat, rotationQuat);
        this.pp_rotateLocalQuat(rotationQuat);
    };
}();

WL.Object.prototype.pp_rotateLocalQuat = function () {
    let currentRotationQuat = glMatrix.quat.create();
    return function (rotation) {
        this.pp_getRotationLocalQuat(currentRotationQuat);
        glMatrix.quat.mul(currentRotationQuat, rotation, currentRotationQuat);
        glMatrix.quat.normalize(currentRotationQuat, currentRotationQuat);
        this.pp_setRotationLocalQuat(currentRotationQuat);
    };
}();

//Rotate Object

WL.Object.prototype.pp_rotateObject = function (rotation) {
    this.pp_rotateObjectDegrees(rotation);
};

WL.Object.prototype.pp_rotateObjectDegrees = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (rotation) {
        this._pp_degreesToQuaternion(rotation, rotationQuat);
        this.pp_rotateObjectQuat(rotationQuat);
    };
}();

WL.Object.prototype.pp_rotateObjectRadians = function () {
    let degreesRotation = glMatrix.vec3.create();
    return function (rotation) {
        rotation.forEach(function (value, index, array) {
            degreesRotation[index] = this._pp_toDegrees(value);
        }.bind(this));
        this.pp_rotateObjectDegrees(degreesRotation);
    };
}();

WL.Object.prototype.pp_rotateObjectMatrix = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (rotation) {
        glMatrix.quat.fromMat3(rotationQuat, rotation);
        glMatrix.quat.normalize(rotationQuat, rotationQuat);
        this.pp_rotateObjectQuat(rotationQuat);
    };
}();

WL.Object.prototype.pp_rotateObjectQuat = function (rotation) {
    this.rotateObject(rotation);
};

//Rotate Axis

WL.Object.prototype.pp_rotateAxis = function (angle, axis) {
    this.pp_rotateAxisWorld(angle, axis);
};

WL.Object.prototype.pp_rotateAxisDegrees = function (angle, axis) {
    this.pp_rotateAxisWorldDegrees(angle, axis);
};

WL.Object.prototype.pp_rotateAxisRadians = function (angle, axis) {
    this.pp_rotateAxisWorldRadians(angle, axis);
};

//Rotate Axis World

WL.Object.prototype.pp_rotateAxisWorld = function (angle, axis) {
    this.pp_rotateAxisWorldDegrees(angle, axis);
};

WL.Object.prototype.pp_rotateAxisWorldDegrees = function (angle, axis) {
    this.pp_rotateAxisWorldRadians(glMatrix.glMatrix.toRadian(angle), axis);
};

WL.Object.prototype.pp_rotateAxisWorldRadians = function () {
    let rotation = glMatrix.quat.create();
    return function (angle, axis) {
        glMatrix.quat.setAxisAngle(rotation, axis, angle);
        this.pp_rotateWorldQuat(rotation);
    };
}();

//Rotate Axis Local

WL.Object.prototype.pp_rotateAxisLocal = function (angle, axis) {
    this.pp_rotateAxisLocalDegrees(angle, axis);
};

WL.Object.prototype.pp_rotateAxisLocalDegrees = function (angle, axis) {
    this.pp_rotateAxisLocalRadians(glMatrix.glMatrix.toRadian(angle), axis);
};

WL.Object.prototype.pp_rotateAxisLocalRadians = function () {
    let rotation = glMatrix.quat.create();
    return function (angle, axis) {
        glMatrix.quat.setAxisAngle(rotation, axis, angle);
        this.pp_rotateLocalQuat(rotation);
    };
}();

//Rotate Axis Object

WL.Object.prototype.pp_rotateAxisObject = function (angle, axis) {
    this.pp_rotateAxisObjectDegrees(angle, axis);
};

WL.Object.prototype.pp_rotateAxisObjectDegrees = function (angle, axis) {
    this.pp_rotateAxisObjectRadians(glMatrix.glMatrix.toRadian(angle), axis);
};

WL.Object.prototype.pp_rotateAxisObjectRadians = function () {
    let rotation = glMatrix.quat.create();
    return function (angle, axis) {
        glMatrix.quat.setAxisAngle(rotation, axis, angle);
        this.pp_rotateObjectQuat(rotation);
    };
}();

//Rotate Around

WL.Object.prototype.pp_rotateAround = function (rotation, origin) {
    this.pp_rotateAroundWorld(rotation, origin);
};

WL.Object.prototype.pp_rotateAroundDegrees = function (rotation, origin) {
    this.pp_rotateAroundWorldDegrees(rotation, origin);
};

WL.Object.prototype.pp_rotateAroundRadians = function (rotation, origin) {
    this.pp_rotateAroundWorldRadians(rotation, origin);
};

WL.Object.prototype.pp_rotateAroundMatrix = function (rotation, origin) {
    this.pp_rotateAroundWorldMatrix(rotation, origin);
};

WL.Object.prototype.pp_rotateAroundQuat = function (rotation, origin) {
    this.pp_rotateAroundWorldQuat(rotation, origin);
};

//Rotate Around World

WL.Object.prototype.pp_rotateAroundWorld = function (rotation, origin) {
    this.pp_rotateAroundWorldDegrees(rotation, origin);
};

WL.Object.prototype.pp_rotateAroundWorldDegrees = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (rotation, origin) {
        this._pp_degreesToQuaternion(rotation, rotationQuat);
        this.pp_rotateAroundWorldQuat(rotationQuat, origin);
    };
}();

WL.Object.prototype.pp_rotateAroundWorldRadians = function () {
    let degreesRotation = glMatrix.vec3.create();
    return function (rotation, origin) {
        rotation.forEach(function (value, index, array) {
            degreesRotation[index] = this._pp_toDegrees(value);
        }.bind(this));
        this.pp_rotateAroundWorldDegrees(degreesRotation, origin);
    };
}();

WL.Object.prototype.pp_rotateAroundWorldMatrix = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (rotation, origin) {
        glMatrix.quat.fromMat3(rotationQuat, rotation);
        glMatrix.quat.normalize(rotationQuat, rotationQuat);
        this.pp_rotateAroundWorldQuat(rotationQuat, origin);
    };
}();

WL.Object.prototype.pp_rotateAroundWorldQuat = function () {
    let axis = glMatrix.vec3.create();
    return function (rotation, origin) {
        let angle = glMatrix.quat.getAxisAngle(axis, rotation);
        this.pp_rotateAroundAxisWorldRadians(angle, axis, origin);
    };
}();

//Rotate Around Local

WL.Object.prototype.pp_rotateAroundLocal = function (rotation, origin) {
    this.pp_rotateAroundLocalDegrees(rotation, origin);
};

WL.Object.prototype.pp_rotateAroundLocalDegrees = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (rotation, origin) {
        this._pp_degreesToQuaternion(rotation, rotationQuat);
        this.pp_rotateAroundLocalQuat(rotationQuat, origin);
    };
}();

WL.Object.prototype.pp_rotateAroundLocalRadians = function () {
    let degreesRotation = glMatrix.vec3.create();
    return function (rotation, origin) {
        rotation.forEach(function (value, index, array) {
            degreesRotation[index] = this._pp_toDegrees(value);
        }.bind(this));
        this.pp_rotateAroundLocalDegrees(degreesRotation, origin);
    };
}();

WL.Object.prototype.pp_rotateAroundLocalMatrix = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (rotation, origin) {
        glMatrix.quat.fromMat3(rotationQuat, rotation);
        glMatrix.quat.normalize(rotationQuat, rotationQuat);
        this.pp_rotateAroundLocalQuat(rotationQuat, origin);
    };
}();

WL.Object.prototype.pp_rotateAroundLocalQuat = function () {
    let axis = glMatrix.vec3.create();
    return function (rotation, origin) {
        let angle = glMatrix.quat.getAxisAngle(axis, rotation);
        this.pp_rotateAroundAxisLocalRadians(angle, axis, origin);
    };
}();

//Rotate Around Object

WL.Object.prototype.pp_rotateAroundObject = function (rotation, origin) {
    this.pp_rotateAroundObjectDegrees(rotation, origin);
};

WL.Object.prototype.pp_rotateAroundObjectDegrees = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (rotation, origin) {
        this._pp_degreesToQuaternion(rotation, rotationQuat);
        this.pp_rotateAroundObjectQuat(rotationQuat, origin);
    };
}();

WL.Object.prototype.pp_rotateAroundObjectRadians = function () {
    let degreesRotation = glMatrix.vec3.create();
    return function (rotation, origin) {
        rotation.forEach(function (value, index, array) {
            degreesRotation[index] = this._pp_toDegrees(value);
        }.bind(this));
        this.pp_rotateAroundObjectDegrees(degreesRotation, origin);
    };
}();

WL.Object.prototype.pp_rotateAroundObjectMatrix = function () {
    let rotationQuat = glMatrix.quat.create();
    return function (rotation, origin) {
        glMatrix.quat.fromMat3(rotationQuat, rotation);
        glMatrix.quat.normalize(rotationQuat, rotationQuat);
        this.pp_rotateAroundObjectQuat(rotationQuat, origin);
    };
}();

WL.Object.prototype.pp_rotateAroundObjectQuat = function () {
    let axis = glMatrix.vec3.create();
    return function (rotation, origin) {
        let angle = glMatrix.quat.getAxisAngle(axis, rotation);
        this.pp_rotateAroundAxisObjectRadians(angle, axis, origin);
    };
}();

//Rotate Around Axis

WL.Object.prototype.pp_rotateAroundAxis = function (angle, axis, origin) {
    this.pp_rotateAroundAxisWorld(angle, axis, origin);
};

WL.Object.prototype.pp_rotateAroundAxisDegrees = function (angle, axis, origin) {
    this.pp_rotateAroundAxisWorldDegrees(angle, axis, origin);
};

WL.Object.prototype.pp_rotateAroundAxisRadians = function (angle, axis, origin) {
    this.pp_rotateAroundAxisWorldRadians(angle, axis, origin);
};

//Rotate Around Axis World

WL.Object.prototype.pp_rotateAroundAxisWorld = function (angle, axis, origin) {
    this.pp_rotateAroundAxisWorldDegrees(angle, axis, origin);
};

WL.Object.prototype.pp_rotateAroundAxisWorldDegrees = function (angle, axis, origin) {
    this.pp_rotateAroundAxisWorldRadians(glMatrix.glMatrix.toRadian(angle), axis, origin);
};

WL.Object.prototype.pp_rotateAroundAxisWorldRadians = function () {
    let transformToRotate = glMatrix.quat2.create();
    let transformToRotateConjugate = glMatrix.quat2.create();
    let transformQuat = glMatrix.quat2.create();
    let defaultQuat = glMatrix.quat.create();
    return function (angle, axis, origin) {
        glMatrix.quat2.fromRotationTranslation(transformToRotate, defaultQuat, origin);
        this.pp_getTransformWorldQuat(transformQuat);
        glMatrix.quat2.conjugate(transformToRotateConjugate, transformToRotate);
        glMatrix.quat2.mul(transformQuat, transformToRotateConjugate, transformQuat);
        glMatrix.quat2.rotateAroundAxis(transformToRotate, transformToRotate, axis, angle);
        glMatrix.quat2.mul(transformQuat, transformToRotate, transformQuat);
        this.pp_setTransformWorldQuat(transformQuat);
    };
}();

//Rotate Around Axis Local

WL.Object.prototype.pp_rotateAroundAxisLocal = function (angle, axis, origin) {
    this.pp_rotateAroundAxisLocalDegrees(angle, axis, origin);
};

WL.Object.prototype.pp_rotateAroundAxisLocalDegrees = function (angle, axis, origin) {
    this.pp_rotateAroundAxisLocalRadians(glMatrix.glMatrix.toRadian(angle), axis, origin);
};

WL.Object.prototype.pp_rotateAroundAxisLocalRadians = function () {
    let convertedPosition = glMatrix.vec3.create();
    let convertedAxis = glMatrix.vec3.create();
    return function (angle, axis, origin) {
        this.pp_convertPositionLocalToWorld(origin, convertedPosition);
        this.pp_convertDirectionLocalToWorld(axis, convertedAxis);
        this.pp_rotateAroundAxisWorldRadians(angle, convertedAxis, convertedPosition);
    };
}();

//Rotate Around Axis Object

WL.Object.prototype.pp_rotateAroundAxisObject = function (angle, axis, origin) {
    this.pp_rotateAroundAxisObjectDegrees(angle, axis, origin);
};

WL.Object.prototype.pp_rotateAroundAxisObjectDegrees = function (angle, axis, origin) {
    this.pp_rotateAroundAxisObjectRadians(glMatrix.glMatrix.toRadian(angle), axis, origin);
};

WL.Object.prototype.pp_rotateAroundAxisObjectRadians = function () {
    let convertedPosition = glMatrix.vec3.create();
    let convertedAxis = glMatrix.vec3.create();
    return function (angle, axis, origin) {
        this.pp_convertPositionObjectToWorld(origin, convertedPosition);
        this.pp_convertDirectionObjectToWorld(axis, convertedAxis);
        this.pp_rotateAroundAxisWorldRadians(angle, convertedAxis, convertedPosition);
    };
}();

//Scale

//For now it does not really make sense in wle to scale in world space or parent space
//so there is no pp_scale default function

WL.Object.prototype.pp_scaleObject = function () {
    let vector = glMatrix.vec3.create();
    return function (scale) {
        if (isNaN(scale)) {
            this.scale(scale);
        } else {
            glMatrix.vec3.set(vector, scale, scale, scale);
            this.scale(vector);
        }
    };
}();

//Look At

WL.Object.prototype.pp_lookAt = function (position, up) {
    this.pp_lookAtWorld(position, up);
};

WL.Object.prototype.pp_lookAtWorld = function () {
    let direction = glMatrix.vec3.create();
    return function (position, up) {
        this.pp_getPositionWorld(direction);
        glMatrix.vec3.sub(direction, position, direction);
        this.pp_lookToWorld(direction, up);
    };
}();

WL.Object.prototype.pp_lookAtLocal = function () {
    let direction = glMatrix.vec3.create();
    return function (position, up) {
        this.pp_getPositionLocal(direction);
        glMatrix.vec3.sub(direction, position, direction);
        this.pp_lookToLocal(direction, up);
    };
}();

WL.Object.prototype.pp_lookTo = function (direction, up) {
    this.pp_lookToWorld(direction, up);
};

WL.Object.prototype.pp_lookToWorld = function () {
    let internalUp = glMatrix.vec3.create();
    let currentPosition = glMatrix.vec3.create();
    let targetPosition = glMatrix.vec3.create();
    let targetToMatrix = glMatrix.mat4.create();
    let rotation = glMatrix.quat.create();
    return function (direction, up = this.pp_getUpWorld(internalUp)) {
        glMatrix.vec3.copy(internalUp, up); //to avoid changing the forwarded up
        let angle = glMatrix.vec3.angle(direction, internalUp);
        if (angle < this._pp_epsilon || angle > Math.PI - this._pp_epsilon) {
            //direction and up are too similar, trying with the default up
            this.pp_getUpWorld(internalUp);
            angle = glMatrix.vec3.angle(direction, internalUp);
            if (angle < this._pp_epsilon || angle > Math.PI - this._pp_epsilon) {
                //this means we want the forward to become up, so getting forward as the up
                this.pp_getForwardWorld(internalUp);
                if (angle < this._pp_epsilon) {
                    glMatrix.vec3.negate(internalUp, internalUp);
                }
            }
        }

        this.pp_getPositionWorld(currentPosition);
        glMatrix.vec3.add(targetPosition, currentPosition, direction);
        glMatrix.mat4.targetTo(targetToMatrix, targetPosition, currentPosition, internalUp);
        glMatrix.mat4.getRotation(rotation, targetToMatrix);
        glMatrix.quat.normalize(rotation, rotation);

        this.pp_setRotationWorldQuat(rotation);
    };
}();

WL.Object.prototype.pp_lookToLocal = function () {
    let internalUp = glMatrix.vec3.create();
    let currentPosition = glMatrix.vec3.create();
    let targetPosition = glMatrix.vec3.create();
    let targetToMatrix = glMatrix.mat4.create();
    let rotation = glMatrix.quat.create();
    return function (direction, up = this.pp_getUpLocal(internalUp)) {
        glMatrix.vec3.copy(internalUp, up); //to avoid changing the forwarded up
        let angle = glMatrix.vec3.angle(direction, internalUp);
        if (angle < this._pp_epsilon || angle > Math.PI - this._pp_epsilon) {
            //direction and up are too similar, trying with the default up
            this.pp_getUpLocal(internalUp);
            angle = glMatrix.vec3.angle(direction, internalUp);
            if (angle < this._pp_epsilon || angle > Math.PI - this._pp_epsilon) {
                //this means we want the forward to become up, so getting forward as the up
                this.pp_getForwardLocal(internalUp);
                if (angle < this._pp_epsilon) {
                    glMatrix.vec3.negate(internalUp, internalUp);
                }
            }
        }

        this.pp_getPositionLocal(currentPosition);
        glMatrix.vec3.add(targetPosition, currentPosition, direction);
        glMatrix.mat4.targetTo(targetToMatrix, targetPosition, currentPosition, internalUp);
        glMatrix.mat4.getRotation(rotation, targetToMatrix);
        glMatrix.quat.normalize(rotation, rotation);

        this.pp_setRotationLocalQuat(rotation);
    };
}();

//EXTRA

//Parent

WL.Object.prototype.pp_setParent = function () {
    let position = glMatrix.vec3.create();
    let rotation = glMatrix.quat.create();
    let scale = glMatrix.vec3.create();
    return function (newParent, keepTransform = true) {
        if (!keepTransform) {
            this.parent = newParent;
        } else {
            this.pp_getPositionWorld(position);
            this.pp_getRotationWorldQuat(rotation);
            this.pp_getScaleWorld(scale);
            this.parent = newParent;
            this.pp_setScaleWorld(scale);
            this.pp_setRotationWorldQuat(rotation);
            this.pp_setPositionWorld(position);
        }
    };
}();

WL.Object.prototype.pp_getParent = function () {
    return this.parent;
};

//Convert Vector Object World

WL.Object.prototype.pp_convertPositionObjectToWorld = function () {
    let matrix = glMatrix.mat4.create();
    return function (position, resultPosition = glMatrix.vec3.create()) {
        this.pp_getTransformWorldMatrix(matrix);
        glMatrix.vec3.transformMat4(resultPosition, position, matrix);
        return resultPosition;
    };
}();

WL.Object.prototype.pp_convertDirectionObjectToWorld = function () {
    let rotation = glMatrix.quat.create();
    return function (direction, resultDirection = glMatrix.vec3.create()) {
        this.pp_getRotationWorldQuat(rotation);
        glMatrix.vec3.transformQuat(resultDirection, direction, rotation);
        return resultDirection;
    };
}();

WL.Object.prototype.pp_convertPositionWorldToObject = function () {
    let matrix = glMatrix.mat4.create();
    return function (position, resultPosition = glMatrix.vec3.create()) {
        this.pp_getTransformWorldMatrix(matrix);
        glMatrix.mat4.invert(matrix, matrix);
        glMatrix.vec3.transformMat4(resultPosition, position, matrix);
        return resultPosition;
    };
}();

WL.Object.prototype.pp_convertDirectionWorldToObject = function () {
    let rotation = glMatrix.quat.create();
    return function (direction, resultDirection = glMatrix.vec3.create()) {
        this.pp_getRotationWorldQuat(rotation);
        glMatrix.quat.conjugate(rotation, rotation);
        glMatrix.vec3.transformQuat(resultDirection, direction, rotation);
        return resultDirection;
    };
}();

//Convert Vector Local World

WL.Object.prototype.pp_convertPositionLocalToWorld = function (position, resultPosition = glMatrix.vec3.create()) {
    if (this.pp_getParent()) {
        this.pp_getParent().pp_convertPositionObjectToWorld(position, resultPosition);
    } else {
        glMatrix.vec3.copy(resultPosition, position);
    }
    return resultPosition;
};

WL.Object.prototype.pp_convertDirectionLocalToWorld = function (direction, resultDirection = glMatrix.vec3.create()) {
    if (this.pp_getParent()) {
        this.pp_getParent().pp_convertDirectionObjectToWorld(direction, resultDirection);
    } else {
        glMatrix.vec3.copy(resultDirection, direction);
    }
    return resultDirection;
};

WL.Object.prototype.pp_convertPositionWorldToLocal = function (position, resultPosition = glMatrix.vec3.create()) {
    if (this.pp_getParent()) {
        this.pp_getParent().pp_convertPositionWorldToObject(position, resultPosition);
    } else {
        glMatrix.vec3.copy(resultPosition, position);
    }
    return resultPosition;
};

WL.Object.prototype.pp_convertDirectionWorldToLocal = function (direction, resultDirection = glMatrix.vec3.create()) {
    if (this.pp_getParent()) {
        this.pp_getParent().pp_convertDirectionWorldToObject(direction, resultDirection);
    } else {
        glMatrix.vec3.copy(resultDirection, direction);
    }
    return resultDirection;
};

//Convert Vector Local Object

//I need to use the converson to world and then local also use the parent scale that changes the position in local space

WL.Object.prototype.pp_convertPositionObjectToLocal = function (position, resultPosition = glMatrix.vec3.create()) {
    this.pp_convertPositionObjectToWorld(position, resultPosition);
    this.pp_convertPositionWorldToLocal(resultPosition, resultPosition);
    return resultPosition;
};

WL.Object.prototype.pp_convertDirectionObjectToLocal = function (direction, resultDirection = glMatrix.vec3.create()) {
    this.pp_convertDirectionObjectToWorld(direction, resultDirection);
    this.pp_convertDirectionWorldToLocal(resultDirection, resultDirection);
    return resultDirection;
};

WL.Object.prototype.pp_convertPositionLocalToObject = function (position, resultPosition = glMatrix.vec3.create()) {
    this.pp_convertPositionLocalToWorld(position, resultPosition);
    this.pp_convertPositionWorldToObject(resultPosition, resultPosition);
    return resultPosition;
};

WL.Object.prototype.pp_convertDirectionLocalToObject = function (direction, resultDirection = glMatrix.vec3.create()) {
    this.pp_convertDirectionLocalToWorld(direction, resultDirection);
    this.pp_convertDirectionWorldToObject(resultDirection, resultDirection);
    return resultDirection;
};

//Convert Transform Object World

WL.Object.prototype.pp_convertTransformObjectToWorld = function (transform, resultTransform) {
    return this.pp_convertTransformObjectToWorldMatrix(transform, resultTransform);
};

WL.Object.prototype.pp_convertTransformObjectToWorldMatrix = function () {
    let convertTransform = glMatrix.mat4.create();
    let position = glMatrix.vec3.create();
    let scale = glMatrix.vec3.create();
    let inverseScale = glMatrix.vec3.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (transform, resultTransform = glMatrix.mat4.create()) {
        this.pp_getTransformWorldMatrix(convertTransform);
        if (this.pp_hasUniformScaleWorld()) {
            glMatrix.mat4.mul(resultTransform, convertTransform, transform);
        } else {
            glMatrix.vec3.set(position, transform[12], transform[13], transform[14]);
            this.pp_convertPositionObjectToWorld(position, position);

            glMatrix.mat4.getScaling(scale, convertTransform);
            glMatrix.vec3.divide(inverseScale, one, scale);
            glMatrix.mat4.scale(convertTransform, convertTransform, inverseScale);

            glMatrix.mat4.mul(resultTransform, convertTransform, transform);
            glMatrix.mat4.scale(resultTransform, resultTransform, scale);

            resultTransform[12] = position[0];
            resultTransform[13] = position[1];
            resultTransform[14] = position[2];
            resultTransform[15] = 1;
        }
        return resultTransform;
    };
}();

WL.Object.prototype.pp_convertTransformObjectToWorldQuat = function () {
    let position = glMatrix.vec3.create();
    let rotation = glMatrix.quat.create();
    return function (transform, resultTransform = glMatrix.quat2.create()) {
        this.pp_getRotationWorldQuat(rotation);
        glMatrix.quat.mul(rotation, rotation, transform);
        glMatrix.quat2.getTranslation(position, transform);
        this.pp_convertPositionObjectToWorld(position, position);
        glMatrix.quat2.fromRotationTranslation(resultTransform, rotation, position);
        return resultTransform;
    };
}();

WL.Object.prototype.pp_convertTransformWorldToObject = function (transform, resultTransform) {
    return this.pp_convertTransformWorldToObjectMatrix(transform, resultTransform);
};

WL.Object.prototype.pp_convertTransformWorldToObjectMatrix = function () {
    let convertTransform = glMatrix.mat4.create();
    let position = glMatrix.vec3.create();
    let scale = glMatrix.vec3.create();
    let inverseScale = glMatrix.vec3.create();
    let one = glMatrix.vec3.create();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function (transform, resultTransform = glMatrix.mat4.create()) {
        this.pp_getTransformWorldMatrix(convertTransform);
        if (this.pp_hasUniformScaleWorld()) {
            glMatrix.mat4.invert(convertTransform, convertTransform);
            glMatrix.mat4.mul(resultTransform, convertTransform, transform);
        } else {
            glMatrix.vec3.set(position, transform[12], transform[13], transform[14]);
            this.pp_convertPositionWorldToObject(position, position);

            glMatrix.mat4.getScaling(scale, convertTransform);
            glMatrix.vec3.divide(inverseScale, one, scale);
            glMatrix.mat4.scale(convertTransform, convertTransform, inverseScale);

            glMatrix.mat4.invert(convertTransform, convertTransform);
            glMatrix.mat4.mul(resultTransform, convertTransform, transform);
            glMatrix.mat4.scale(resultTransform, resultTransform, inverseScale);

            resultTransform[12] = position[0];
            resultTransform[13] = position[1];
            resultTransform[14] = position[2];
            resultTransform[15] = 1;
        }
        return resultTransform;
    };
}();

WL.Object.prototype.pp_convertTransformWorldToObjectQuat = function () {
    let position = glMatrix.vec3.create();
    let rotation = glMatrix.quat.create();
    return function (transform, resultTransform = glMatrix.quat2.create()) {
        this.pp_getRotationWorldQuat(rotation);
        glMatrix.quat.conjugate(rotation, rotation);
        glMatrix.quat.mul(rotation, rotation, transform);
        glMatrix.quat2.getTranslation(position, transform);
        this.pp_convertPositionWorldToObject(position, position);
        glMatrix.quat2.fromRotationTranslation(resultTransform, rotation, position);
        return resultTransform;
    };
}();

//Convert Transform Local World

WL.Object.prototype.pp_convertTransformLocalToWorld = function (transform, resultTransform) {
    return this.pp_convertTransformLocalToWorldMatrix(transform, resultTransform);
};

WL.Object.prototype.pp_convertTransformLocalToWorldMatrix = function (transform, resultTransform = glMatrix.mat4.create()) {
    if (this.pp_getParent()) {
        this.pp_getParent().pp_convertTransformObjectToWorldMatrix(transform, resultTransform);
    } else {
        glMatrix.mat4.copy(resultTransform, transform);
    }
    return resultTransform;
};

WL.Object.prototype.pp_convertTransformLocalToWorldQuat = function (transform, resultTransform = glMatrix.quat2.create()) {
    if (this.pp_getParent()) {
        this.pp_getParent().pp_convertTransformObjectToWorldQuat(transform, resultTransform);
    } else {
        glMatrix.quat2.copy(resultTransform, transform);
    }
    return resultTransform;
};

WL.Object.prototype.pp_convertTransformWorldToLocal = function (transform, resultTransform) {
    return this.pp_convertTransformWorldToLocalMatrix(transform, resultTransform);
};

WL.Object.prototype.pp_convertTransformWorldToLocalMatrix = function (transform, resultTransform = glMatrix.mat4.create()) {
    if (this.pp_getParent()) {
        this.pp_getParent().pp_convertTransformWorldToObjectMatrix(transform, resultTransform);
    } else {
        glMatrix.mat4.copy(resultTransform, transform);
    }
    return resultTransform;
};

WL.Object.prototype.pp_convertTransformWorldToLocalQuat = function (transform, resultTransform = glMatrix.quat2.create()) {
    if (this.pp_getParent()) {
        this.pp_getParent().pp_convertTransformWorldToObjectQuat(transform, resultTransform);
    } else {
        glMatrix.quat2.copy(resultTransform, transform);
    }
    return resultTransform;
};

//Convert Transform Object Local

//I need to use the converson to world and then local also use the parent scale that changes the position in local space

WL.Object.prototype.pp_convertTransformObjectToLocal = function (transform, resultTransform) {
    return this.pp_convertTransformObjectToLocalMatrix(transform, resultTransform);
};

WL.Object.prototype.pp_convertTransformObjectToLocalMatrix = function (transform, resultTransform = glMatrix.mat4.create()) {
    this.pp_convertTransformObjectToWorldMatrix(transform, resultTransform);
    this.pp_convertTransformWorldToLocalMatrix(resultTransform, resultTransform);
    return resultTransform;
};

WL.Object.prototype.pp_convertTransformObjectToLocalQuat = function (transform, resultTransform = glMatrix.quat2.create()) {
    this.pp_convertTransformObjectToWorldQuat(transform, resultTransform);
    this.pp_convertTransformWorldToLocalQuat(resultTransform, resultTransform);
    return resultTransform;
};

WL.Object.prototype.pp_convertTransformLocalToObject = function (transform, resultTransform) {
    return this.pp_convertTransformLocalToObjectMatrix(transform, resultTransform);
};

WL.Object.prototype.pp_convertTransformLocalToObjectMatrix = function (transform, resultTransform = glMatrix.mat4.create()) {
    this.pp_convertTransformLocalToWorldMatrix(transform, resultTransform);
    this.pp_convertTransformWorldToObjectMatrix(resultTransform, resultTransform);
    return resultTransform;
};

WL.Object.prototype.pp_convertTransformLocalToObjectQuat = function (transform, resultTransform = glMatrix.quat2.create()) {
    this.pp_convertTransformLocalToWorldQuat(transform, resultTransform);
    this.pp_convertTransformWorldToObjectQuat(resultTransform, resultTransform);
    return resultTransform;
};

//Component

WL.Object.prototype.pp_addComponent = function (type, paramsOrActive, active = null) {
    let params = null;

    if (typeof paramsOrActive == "boolean") {
        params = {};
        params["active"] = paramsOrActive;
    } else {
        params = paramsOrActive;

        if (active != null) {
            if (params == null) {
                params = {};
            }
            params["active"] = active;
        }
    }

    return this.addComponent(type, params);
};

WL.Object.prototype.pp_getComponent = function (type, index) {
    return this.getComponent(type, index);
};

WL.Object.prototype.pp_getComponents = function (type) {
    return this.getComponents(type);
};

WL.Object.prototype.pp_getComponentHierarchy = function (type, index) {
    let component = this.getComponent(type, index);

    if (!component) {
        component = this.pp_getComponentDescendants(type, index);
    }

    return component;
};

WL.Object.prototype.pp_getComponentDescendants = function (type, index) {
    let component = null;

    let descendants = this.children;
    while (!component && descendants.length > 0) {
        let descendant = descendants.shift();
        component = descendant.getComponent(type, index);
        if (!component) {
            for (let object of descendant.children) {
                descendants.push(object);
            }
        }
    }

    return component;
};
WL.Object.prototype.pp_getComponentChildren = function (type, index) {
    let component = null;

    let children = this.children;
    for (let child of children) {
        component = child.getComponent(type, index);
        if (component) {
            break;
        }
    }

    return component;
};

WL.Object.prototype.pp_getComponentsHierarchy = function (type) {
    let components = this.getComponents(type);

    let descendantsComponents = this.pp_getComponentsDescendants(type);
    for (let component of descendantsComponents) {
        components.push(component);
    }

    return components;
};

WL.Object.prototype.pp_getComponentsDescendants = function (type) {
    let components = [];

    let descendants = this.children;
    while (descendants.length > 0) {
        let descendant = descendants.shift();
        let descendantComponents = descendant.getComponents(type);
        for (let component of descendantComponents) {
            components.push(component);
        }
        for (let object of descendant.children) {
            descendants.push(object);
        }
    }

    return components;
};

WL.Object.prototype.pp_getComponentsChildren = function (type) {
    let components = [];

    let children = this.children;
    for (let child of children) {
        let childComponents = child.getComponents(type);
        for (let component of childComponents) {
            components.push(component);
        }
    }

    return components;
};

//Active

WL.Object.prototype.pp_setActive = function (active, applyToHierarchy = true) {
    if (applyToHierarchy) {
        this.pp_setActiveHierarchy(active);
    } else {
        this.active = active;
    }
};

WL.Object.prototype.pp_setActiveHierarchy = function (active) {
    this.active = active;
    this.pp_setActiveDescendants(active);
};

WL.Object.prototype.pp_setActiveDescendants = function (active) {
    let descendants = this.children;
    while (descendants.length > 0) {
        let descendant = descendants.shift();
        descendant.active = active;
        for (let object of descendant.children) {
            descendants.push(object);
        }
    }
};

WL.Object.prototype.pp_setActiveChildren = function (active) {
    let children = this.children;
    for (let child of children) {
        child.active = active;
    }
};

//Uniform Scale

WL.Object.prototype.pp_hasUniformScale = function () {
    return this.pp_hasUniformScaleWorld();
};

WL.Object.prototype.pp_hasUniformScaleWorld = function () {
    let scale = glMatrix.vec3.create();
    return function () {
        this.pp_getScaleWorld(scale);
        return Math.abs(scale[0] - scale[1]) < this._pp_epsilon && Math.abs(scale[1] - scale[2]) < this._pp_epsilon && Math.abs(scale[0] - scale[2]) < this._pp_epsilon;
    };
}();

WL.Object.prototype.pp_hasUniformScaleLocal = function () {
    let scale = glMatrix.vec3.create();
    return function () {
        this.pp_getScaleLocal(scale);
        return Math.abs(scale[0] - scale[1]) < this._pp_epsilon && Math.abs(scale[1] - scale[2]) < this._pp_epsilon && Math.abs(scale[0] - scale[2]) < this._pp_epsilon;
    };
}();

//Clone

if (!PP) {
    var PP = {};
}

PP.CloneParams = class CloneParams {
    constructor() {
        this.myIgnoreNonCloneable = false; // Ignores components that are not clonable
        this.myIgnoreComponents = false; // All components are ignored, cloning only the object hierarchy
        this.myIgnoreChildren = false; // Clones only the given object without the children

        this.myComponentsToIgnore = []; // Ignores all component types in this list (example: "mesh"), has lower priority over myComponentsToInclude
        this.myComponentsToInclude = []; // Clones only the component types in this list (example: "mesh"), has higher priority over myComponentsToIgnore, if empty it's ignored
        this.myIgnoreComponentCallback = null; // Signature: callback(component) returns true if the component must be ignored, it is called after the previous filters

        this.myChildrenToIgnore = []; // Ignores all the objects in this list (example: "mesh"), has lower priority over myChildrenToInclude
        this.myChildrenToInclude = []; // Clones only the objects in this list (example: "mesh"), has higher priority over myChildrenToIgnore, if empty it's ignored
        this.myIgnoreChildCallback = null; // Signature: callback(object) returns true if the object must be ignored, it is called after the previous filters

        this.myDeepCloneParams = new PP.DeepCloneParams(); // Used to specify if the object must be deep cloned or not, you can also override the behavior for specific components and variables

        this.myExtraData = new Map(); // This map can be filled with whatever extra data the component clone function could need
    }
};

PP.DeepCloneParams = class DeepCloneParams {
    constructor() {
        this._myDeepCloneObject = false;
        this._myOverrideDeepCloneComponentMap = new Map();
        this._myOverrideDeepCloneComponentVariableMap = new Map();
    }

    // The implementation is component dependant, not every component implements the deep clone
    deepCloneObject(deepClone) {
        this._myDeepCloneObject = deepClone;
    }

    // This value override the deep clone object value
    // The implementation is component dependant, not every component implements the deep clone
    deepCloneComponent(componentName, deepClone) {
        this._myOverrideDeepCloneComponentMap.set(componentName, deepClone);
    }

    // This value override both the deep clone object value and the deep clone component one
    // The implementation is component dependant, not every component variable override is taken into consideration
    deepCloneComponentVariable(componentName, variableName, deepClone) {
        let componentMap = null;

        if (!this._myOverrideDeepCloneComponentVariableMap.has(componentName)) {
            this._myOverrideDeepCloneComponentVariableMap.set(componentName, new Map());
        }

        componentMap = this._myOverrideDeepCloneComponentVariableMap.get(componentName);

        componentMap.set(variableName, deepClone);
    }

    shouldDeepCloneComponent(componentName) {
        let overrideValue = this._myOverrideDeepCloneComponentMap.get(componentName);

        if (overrideValue != null) {
            return overrideValue;
        }

        return this._myDeepCloneObject;
    }

    shouldDeepCloneComponentVariable(componentName, variableName) {
        let componentMap = this._myOverrideDeepCloneComponentVariableMap.get(componentName);
        if (componentMap != null) {
            let overrideValue = componentMap.get(variableName);
            if (overrideValue != null) {
                return overrideValue;
            }
        }

        return this.shouldDeepCloneComponent(componentName);
    }
};

WL.Object.prototype.pp_clone = function (params = new PP.CloneParams()) {
    let clonedObject = null;

    if (this.pp_isCloneable(params)) {
        let objectsToCloneData = [];
        objectsToCloneData.push([this.parent, this]);

        //Create object hierarchy
        let objectsToCloneComponentsData = [];
        while (objectsToCloneData.length > 0) {
            let cloneData = objectsToCloneData.shift();
            let parent = cloneData[0];
            let objectToClone = cloneData[1];

            let currentClonedObject = WL.scene.addObject(parent);
            currentClonedObject.name = objectToClone.name.slice(0);

            currentClonedObject.pp_setScaleLocal(objectToClone.pp_getScaleLocal());
            currentClonedObject.pp_setTransformLocalQuat(objectToClone.pp_getTransformLocalQuat());

            if (!params.myIgnoreComponents) {
                objectsToCloneComponentsData.push([objectToClone, currentClonedObject]);
            }

            if (!params.myIgnoreChildren) {
                for (let child of objectToClone.children) {
                    let cloneChild = false;
                    if (params.myChildrenToInclude.length > 0) {
                        cloneChild = params.myChildrenToInclude.find(childToInclude => childToInclude.pp_equals(child)) != null;
                    } else {
                        cloneChild = params.myChildrenToIgnore.find(childToIgnore => childToIgnore.pp_equals(child)) == null;
                    }

                    if (cloneChild && params.myIgnoreChildCallback != null) {
                        cloneChild = !params.myIgnoreChildCallback(child);
                    }

                    if (cloneChild) {
                        objectsToCloneData.push([currentClonedObject, child]);
                    }
                }
            }

            if (clonedObject == null) {
                clonedObject = currentClonedObject;
            }
        }

        //Create components
        let componentsToCloneData = [];
        while (objectsToCloneComponentsData.length > 0) {
            let cloneData = objectsToCloneComponentsData.shift();
            let objectToClone = cloneData[0];
            let currentClonedObject = cloneData[1];

            let components = objectToClone.pp_getComponents();
            for (let component of components) {
                if (component.pp_clone != null) {
                    let cloneComponent = false;
                    if (params.myComponentsToInclude.length > 0) {
                        cloneComponent = params.myComponentsToInclude.indexOf(component.type) != -1;
                    } else {
                        cloneComponent = params.myComponentsToIgnore.indexOf(component.type) == -1;
                    }

                    if (cloneComponent && params.myIgnoreComponentCallback != null) {
                        cloneComponent = !params.myIgnoreComponentCallback(component);
                    }

                    if (cloneComponent) {
                        //Not managing the fact that inactive components from editor haven't called start yet, but clones do, since there is no way to know
                        let clonedComponent = currentClonedObject.pp_addComponent(component.type);
                        clonedComponent.active = component.active;
                        componentsToCloneData.push([component, clonedComponent]);
                    }
                }
            }
        }

        //Now that all the hierarchy is completed (with components) we can clone them
        while (componentsToCloneData.length > 0) {
            let cloneData = componentsToCloneData.shift();
            let componentToClone = cloneData[0];
            let currentClonedComponent = cloneData[1];

            componentToClone.pp_clone(currentClonedComponent, params.myDeepCloneParams, params.myExtraData);
        }
    }

    return clonedObject;
};

WL.Object.prototype.pp_isCloneable = function (params = new PP.CloneParams()) {
    if (params.myIgnoreNonCloneable || params.myIgnoreComponents) {
        return true;
    }

    let isCloneable = true;

    let objects = [];
    objects.push(this);

    while (isCloneable && objects.length > 0) {
        let object = objects.shift();

        let components = this.pp_getComponents();
        for (let component of components) {
            let cloneComponent = false;
            if (params.myComponentsToInclude.length > 0) {
                cloneComponent = params.myComponentsToInclude.indexOf(component.type) != -1;
            } else {
                cloneComponent = params.myComponentsToIgnore.indexOf(component.type) == -1;
            }

            if (cloneComponent && params.myIgnoreComponentCallback != null) {
                cloneComponent = !params.myIgnoreComponentCallback(component);
            }

            if (cloneComponent && component.pp_clone == null) {
                isCloneable = false;
                break;
            }
        }

        if (isCloneable && !params.myIgnoreChildren) {
            for (let child of object.children) {
                let cloneChild = false;
                if (params.myChildrenToInclude.length > 0) {
                    cloneChild = params.myChildrenToInclude.find(childToInclude => childToInclude.pp_equals(child)) != null;
                } else {
                    cloneChild = params.myChildrenToIgnore.find(childToInclude => childToInclude.pp_equals(child)) == null;
                }

                if (cloneChild && params.myIgnoreChildCallback != null) {
                    cloneChild = !params.myIgnoreChildCallback(child);
                }

                if (cloneChild) {
                    objects.push(child);
                }
            }
        }
    }

    return isCloneable;
};

//Cauldron

WL.Object.prototype.pp_getName = function () {
    return this.name;
};

WL.Object.prototype.pp_setName = function (name) {
    this.name = name;
};

WL.Object.prototype.pp_getID = function () {
    return this.objectId;
};

WL.Object.prototype.pp_getHierarchy = function () {
    let hierarchy = this.pp_getDescendants();

    hierarchy.unshift(this);

    return hierarchy;
};

WL.Object.prototype.pp_getDescendants = function () {
    let descendants = [];

    let descendantsQueue = this.children;

    while (descendantsQueue.length > 0) {
        let descendant = descendantsQueue.shift();
        descendants.push(descendant);
        for (let object of descendant.children) {
            descendantsQueue.push(object);
        }
    }

    return descendants;
};

WL.Object.prototype.pp_getChildren = function () {
    return this.children;
};

WL.Object.prototype.pp_markDirty = function () {
    return this.setDirty();
};

WL.Object.prototype.pp_equals = function (otherObject) {
    return this.equals(otherObject);
};

WL.Object.prototype.pp_destroy = function () {
    return this.destroy();
};

WL.Object.prototype.pp_getComponentAmountMap = function (amountMap = new Map()) {
    let objectAmount = amountMap.get("object");
    if (objectAmount == null) {
        objectAmount = 0;
    }
    objectAmount += 1;
    amountMap.set("object", objectAmount);

    let components = this.pp_getComponents();
    for (let component of components) {
        let type = component.type;
        let typeAmount = amountMap.get(type);
        if (typeAmount == null) {
            typeAmount = 0;
        }
        typeAmount += 1;
        amountMap.set(type, typeAmount);
    }

    return amountMap;
};

WL.Object.prototype.pp_getComponentAmountMapHierarchy = function (amountMap = new Map()) {
    let hierarchy = this.pp_getHierarchy();

    for (let object of hierarchy) {
        object.pp_getComponentAmountMap(amountMap);
    }

    return amountMap;
};

WL.Object.prototype.pp_getComponentAmountMapDescendants = function (amountMap = new Map()) {
    let descendants = this.pp_getDescendants();

    for (let object of descendants) {
        object.pp_getComponentAmountMap(amountMap);
    }

    return amountMap;
};

WL.Object.prototype.pp_getComponentAmountMapChildren = function (amountMap = new Map()) {
    let children = this.children;

    for (let object of children) {
        object.pp_getComponentAmountMap(amountMap);
    }

    return amountMap;
};

//Private Utils

WL.Object.prototype._pp_epsilon = 0.000001;

WL.Object.prototype._pp_quaternionToRadians = function () {
    let mat3 = glMatrix.mat3.create();
    return function (quatRotation, radiansRotation = glMatrix.vec3.create()) {
        glMatrix.mat3.fromQuat(mat3, quatRotation);

        //Rotation order is ZYX
        radiansRotation[1] = Math.asin(-this._pp_clamp(mat3[2], -1, 1));

        if (Math.abs(mat3[2]) < 0.9999999) {

            radiansRotation[0] = Math.atan2(mat3[5], mat3[8]);
            radiansRotation[2] = Math.atan2(mat3[1], mat3[0]);

        } else {

            radiansRotation[0] = 0;
            radiansRotation[2] = Math.atan2(-mat3[3], mat3[4]);
        }

        return radiansRotation;
    };
}();

WL.Object.prototype._pp_degreesToQuaternion = function (degreesRotation, quatRotation = glMatrix.quat.create()) {
    glMatrix.quat.fromEuler(quatRotation, degreesRotation[0], degreesRotation[1], degreesRotation[2]);
    return quatRotation;
};

WL.Object.prototype._pp_toDegrees = function (angle) {
    return angle * (180 / Math.PI);
};

WL.Object.prototype._pp_clamp = function (value, min, max) {
    return Math.min(Math.max(value, min), max);
};

for (let key in WL.Object.prototype) {
    let prefixes = ["pp_", "_pp_"];

    let found = false;
    for (let prefix of prefixes) {
        if (key.startsWith(prefix)) {
            found = true;
            break;
        }
    }

    if (found) {
        Object.defineProperty(WL.Object.prototype, key, { enumerable: false });
    }
}
//This is added just to make it easy to just use plain number instead of doing new PP.NumberOverValue(<number>) 
//You can remove this if it cause issues but you won't be able anymore to use plain number and will have to use new PP.NumberOverValue(<number>) 
Number.prototype.get = function () {
    return this.valueOf();
};
Object.defineProperty(Number.prototype, "get", { enumerable: false });

//You can just put startNumber if u want a number that doesn't actually change -> new PP.NumberOverValue(13)
PP.NumberOverValue = class NumberOverValue {
    constructor(startNumber, endNumber = null, startInterpolationValue = 0, endInterpolationValue = 0, easingFunction = PP.EasingFunction.linear, roundingFunction = null) {
        if (endNumber == null) {
            endNumber = startNumber;
        }

        this._myStartNumber = startNumber;
        this._myEndNumber = endNumber;

        this._myStartInterpolationValue = startInterpolationValue;
        this._myEndInterpolationValue = endInterpolationValue;

        this._myEasingFunction = easingFunction;
        this._myRoundingFunction = roundingFunction; // function(numberToRound, startNumber = null, endNumber = null), Math.round/floor/ceil can be used, must return an int
    }

    get(interpolationValue) {
        let lerpInterpolationValue = this._myEasingFunction(Math.pp_mapToRange(interpolationValue, this._myStartInterpolationValue, this._myEndInterpolationValue, 0, 1));
        let lerpNumber = Math.pp_lerp(this._myStartNumber, this._myEndNumber, lerpInterpolationValue);

        if (this._myRoundingFunction) {
            lerpNumber = this._myRoundingFunction(lerpNumber, this._myStartNumber, this._myEndNumber);
        }

        return lerpNumber;
    }

    getAverage(interpolationValue) {
        return this.get(interpolationValue);
    }

    getRange(interpolationValue) {
        let number = this.get(interpolationValue);
        return [number, number];
    }

    getMax(interpolationValue) {
        return this.get(interpolationValue);
    }

    getMin(interpolationValue) {
        return this.get(interpolationValue);
    }

    isInside(number, interpolationValue) {
        let currentNumber = this.get(interpolationValue);

        return currentNumber == number;
    }

    isInsideAngleRange(number, interpolationValue) {
        return this.isInsideAngleRangeDegrees(number, interpolationValue);
    }

    isInsideAngleRangeDegrees(number, interpolationValue) {
        let currentNumber = this.get(interpolationValue);

        let clampedNumber = Math.pp_angleClampDegrees(number);
        let clampedCurrentNumber = Math.pp_angleClampDegrees(currentNumber);

        return clampedNumber == clampedCurrentNumber;
    }

    isInsideAngleRangeRadians(number, interpolationValue) {
        let currentNumber = this.get(interpolationValue);

        let clampedNumber = Math.pp_angleClampRadians(number);
        let clampedCurrentNumber = Math.pp_angleClampRadians(currentNumber);

        return clampedNumber == clampedCurrentNumber;
    }
};

PP.IntOverValue = class IntOverValue extends PP.NumberOverValue {
    constructor(startNumber, endNumber, startInterpolationValue, endInterpolationValue, easingFunction = PP.EasingFunction.linear, roundingFunction = null) {
        if (roundingFunction == null) {
            roundingFunction = function (numberToRound, startNumber, endNumber) {
                let roundedNumber = null;

                let useFloor = startNumber <= endNumber;
                if (useFloor) {
                    roundedNumber = Math.floor(numberToRound);
                } else {
                    roundedNumber = Math.ceil(numberToRound);
                }

                return roundedNumber;
            };
        }

        super(startNumber, endNumber, startInterpolationValue, endInterpolationValue, easingFunction, roundingFunction);
    }
};

//You can just put startRange if u want a range that doesn't actually change -> new PP.NumberOverValue([1,25])
PP.NumberRangeOverValue = class NumberRangeOverValue {
    constructor(startRange, endRange = null, startInterpolationValue = 0, endInterpolationValue = 0, easingFunction = PP.EasingFunction.linear, roundingFunction = null) {
        if (endRange == null) {
            endRange = startRange;
        }

        this._myStartNumberOverValue = new PP.NumberOverValue(startRange[0], endRange[0], startInterpolationValue, endInterpolationValue, easingFunction, roundingFunction);
        this._myEndNumberOverValue = new PP.NumberOverValue(startRange[1], endRange[1], startInterpolationValue, endInterpolationValue, easingFunction, roundingFunction);

        this._myRoundingFunction = roundingFunction; // function(numberToRound, startNumber = null, endNumber = null), Math.round/floor/ceil can be used, must return an int
    }

    get(interpolationValue) {
        let startNumber = this._myStartNumberOverValue.get(interpolationValue);
        let endNumber = this._myEndNumberOverValue.get(interpolationValue);

        let randomValue = null;

        if (this._myRoundingFunction) {
            randomValue = Math.pp_randomInt(startNumber, endNumber);
        } else {
            randomValue = Math.pp_random(startNumber, endNumber);
        }

        return randomValue;
    }

    getAverage(interpolationValue) {
        let startNumber = this._myStartNumberOverValue.get(interpolationValue);
        let endNumber = this._myEndNumberOverValue.get(interpolationValue);

        let average = (startNumber + endNumber) / 2;
        if (this._myRoundingFunction) {
            average = this._myRoundingFunction(average, startNumber, endNumber);
        }

        return average;
    }

    getRange(interpolationValue) {
        let startNumber = this._myStartNumberOverValue.get(interpolationValue);
        let endNumber = this._myEndNumberOverValue.get(interpolationValue);

        return [startNumber, endNumber];
    }

    getMax(interpolationValue) {
        let startNumber = this._myStartNumberOverValue.get(interpolationValue);
        let endNumber = this._myEndNumberOverValue.get(interpolationValue);

        return Math.max(startNumber, endNumber);
    }

    getMin(interpolationValue) {
        let startNumber = this._myStartNumberOverValue.get(interpolationValue);
        let endNumber = this._myEndNumberOverValue.get(interpolationValue);

        return Math.min(startNumber, endNumber);
    }

    isInside(number, interpolationValue) {
        let startNumber = this._myStartNumberOverValue.get(interpolationValue);
        let endNumber = this._myEndNumberOverValue.get(interpolationValue);

        let min = Math.min(startNumber, endNumber);
        let max = Math.max(startNumber, endNumber);

        return number >= min && number <= max;
    }

    isInsideAngleRange(number, interpolationValue) {
        return this.isInsideAngleRangeDegrees(number, interpolationValue);
    }

    isInsideAngleRangeDegrees(number, interpolationValue) {
        let startNumber = this._myStartNumberOverValue.get(interpolationValue);
        let endNumber = this._myEndNumberOverValue.get(interpolationValue);

        return Math.pp_isInsideAngleRangeDegrees(number, startNumber, endNumber);
    }

    isInsideAngleRangeRadians(number, interpolationValue) {
        let startNumber = this._myStartNumberOverValue.get(interpolationValue);
        let endNumber = this._myEndNumberOverValue.get(interpolationValue);

        return Math.pp_isInsideAngleRangeRadians(number, startNumber, endNumber);
    }
};

PP.IntRangeOverValue = class IntRangeOverValue extends PP.NumberRangeOverValue {
    constructor(startRange, endRange, startInterpolationValue, endInterpolationValue, easingFunction = PP.EasingFunction.linear, roundingFunction = null) {
        if (roundingFunction == null) {
            roundingFunction = function (numberToRound, startNumber, endNumber) {
                let roundedNumber = null;

                let useFloor = startNumber <= endNumber;
                if (useFloor) {
                    roundedNumber = Math.floor(numberToRound);
                } else {
                    roundedNumber = Math.ceil(numberToRound);
                }

                return roundedNumber;
            };
        }

        super(startRange, endRange, startInterpolationValue, endInterpolationValue, easingFunction, roundingFunction);
    }
};
PP.ObjectPoolManager = class ObjectPoolManager {
    constructor() {
        this._myPoolMap = new Map();
    }

    addPool(poolID, poolObject, objectPoolParams = new PP.ObjectPoolParams()) {
        if (!this._myPoolMap.has(poolID)) {
            let pool = new PP.ObjectPool(poolObject, objectPoolParams);
            this._myPoolMap.set(poolID, pool);
        } else {
            console.error("Pool already created with this ID");
        }
    }

    increasePool(poolID, amount) {
        let pool = this._myPoolMap.get(poolID);
        if (pool) {
            pool.increase(amount);
        }
    }

    increasePoolPercentage(poolID, percentage) {
        let pool = this._myPoolMap.get(poolID);
        if (pool) {
            pool.increasePercentage(percentage);
        }
    }

    getPool(poolID) {
        return this._myPoolMap.get(poolID);
    }

    getObject(poolID) {
        return this._myPoolMap.get(poolID).get();
    }

    releaseObject(poolID, object) {
        this._myPoolMap.get(poolID).release(object);
    }
};

PP.ObjectPoolParams = class ObjectPoolParams {
    constructor() {
        this.myInitialPoolSize = 0;
        this.myAmountToAddWhenEmpty = 1;  //If all the objects are busy, this amount will be added to the pool
        this.myPercentageToAddWhenEmpty = 0.5;  //If all the objects are busy, this percentage of the current pool size will be added to the pool

        this.myCloneParams = undefined;
        this.myCloneFunctionName = undefined;
        this.mySetActiveFunctionName = undefined;
        this.myEqualsFunctionName = undefined;
    }
};

PP.ObjectPool = class ObjectPool {
    constructor(poolObject, objectPoolParams) {
        this._myObjectPoolParams = objectPoolParams;
        this._myPrototype = this._clone(poolObject);

        this._myAvailableObjects = [];
        this._myBusyObjects = [];

        this._addToPool(objectPoolParams.myInitialPoolSize, false);
    }

    get() {
        let object = this._myAvailableObjects.shift();

        if (object == null) {
            let amountToAdd = Math.ceil(this._myBusyObjects.length * this._myObjectPoolParams.myPercentageToAddWhenEmpty);
            amountToAdd += this._myObjectPoolParams.myAmountToAddWhenEmpty;
            this._addToPool(amountToAdd, true);
            object = this._myAvailableObjects.shift();
        }

        this._myBusyObjects.push(object);

        return object;
    }

    release(object) {
        let released = this._myBusyObjects.pp_remove(this._equals.bind(this, object));
        if (released) {
            this._setActive(released, false);
            this._myAvailableObjects.push(released);
        }
    }

    increase(amount) {
        this._addToPool(amount, false);
    }

    increasePercentage(percentage) {
        let amount = Math.ceil((this._myBusyObjects.length + this._myAvailableObjects.length) * percentage);
        this._addToPool(amount, false);
    }

    _addToPool(size, log) {
        for (let i = 0; i < size; i++) {
            this._myAvailableObjects.push(this._clone(this._myPrototype));
        }

        if (log) {
            console.warn("Added new elements to the pool:", size);
        }
    }

    _clone(object) {
        let clone = null;

        if (this._myObjectPoolParams.myCloneFunctionName != null) {
            clone = object[this._myObjectPoolParams.myCloneFunctionName](this._myObjectPoolParams.myCloneParams);
        } else if (object.pp_clone != null) {
            clone = object.pp_clone(this._myObjectPoolParams.myCloneParams);
        } else if (object.clone != null) {
            clone = object.clone(this._myObjectPoolParams.myCloneParams);
        }

        if (clone == null) {
            console.error("Object not cloneable, pool will return null");
        } else {
            this._setActive(clone, false);
        }

        return clone;
    }

    _setActive(object, active) {
        if (this._myObjectPoolParams.mySetActiveFunctionName != null) {
            object[this._myObjectPoolParams.mySetActiveFunctionName](active);
        } else if (object.pp_setActive != null) {
            object.pp_setActive(active);
        } else if (object.setActive != null) {
            object.setActive(active);
        }
    }

    _equals(first, second) {
        let equals = false;

        if (this._myObjectPoolParams.myEqualsFunctionName != null) {
            equals = first[this._myObjectPoolParams.myEqualsFunctionName](second);
        } else if (first.pp_equals != null) {
            equals = first.pp_equals(second);
        } else if (first.equals != null) {
            equals = first.equals(second);
        }

        return equals;
    }
};
PP.PhysXCollisionCollector = class PhysXCollisionCollector {
    constructor(physXComponent, isTrigger = false) {
        this._myPhysX = physXComponent;

        this._myIsTrigger = isTrigger;

        this._myCollisions = [];

        this._myCollisionsStart = [];
        this._myCollisionsEnd = [];
        this._myUpdateActive = false;
        this._myCollisionsStartToProcess = [];
        this._myCollisionsEndToProcess = [];

        this._myCollisionCallbackID = null;

        this._myIsActive = false;
        this.setActive(true);

        this._myDebugActive = false;

        this._myTriggerDesyncFixDelay = new PP.Timer(0.1);
    }

    getPhysX() {
        return this._myPhysX;
    }

    getCollisions() {
        return this._myCollisions.pp_clone();
    }

    getCollisionsStart() {
        return this._myCollisionsStart.pp_clone();
    }

    getCollisionsEnd() {
        return this._myCollisionsEnd.pp_clone();
    }

    setActive(active) {
        if (this._myIsActive != active) {
            this._myIsActive = active;

            this._myCollisions = [];

            this._myCollisionsStart = [];
            this._myCollisionsEnd = [];
            this._myUpdateActive = false;
            this._myCollisionsStartToProcess = [];
            this._myCollisionsEndToProcess = [];

            if (this._myIsActive) {
                this._myCollisionCallbackID = this._myPhysX.onCollision(this._onCollision.bind(this));
            } else if (this._myCollisionCallbackID != null) {
                this._myPhysX.removeCollisionCallback(this._myCollisionCallbackID);
                this._myCollisionCallbackID = null;
            }
        }
    }

    //Set to true only if u are going to actually update this object and don't want to lose any collision start/end events prior to updating the first time after activation
    setUpdateActive(active) {
        this._myUpdateActive = active;
    }

    //Update is not mandatory, use it only if u want to access collisions start and end
    update(dt) {
        if (!this._myIsActive) {
            return;
        }

        this._myUpdateActive = true;

        this._myCollisionsStart = this._myCollisionsStartToProcess;
        this._myCollisionsStartToProcess = [];

        this._myCollisionsEnd = this._myCollisionsEndToProcess;
        this._myCollisionsEndToProcess = [];

        if (this._myIsTrigger) {
            this._triggerDesyncFix(dt);
        }
    }

    destroy() {
        if (this._myCollisionCallbackID != null) {
            this._myPhysX.removeCollisionCallback(this._myCollisionCallbackID);
            this._myCollisionCallbackID = null;
        }
    }

    setDebugActive(active) {
        this._myDebugActive = active;
    }

    _onCollision(type, physXComponent) {
        if (type == WL.CollisionEventType.Touch || type == WL.CollisionEventType.TriggerTouch) {
            this._onCollisionStart(physXComponent);
        } else if (type == WL.CollisionEventType.TouchLost || type == WL.CollisionEventType.TriggerTouchLost) {
            this._onCollisionEnd(physXComponent);
        }
    }

    _onCollisionStart(physXComponent) {
        if (this._myDebugActive) {
            let objectFound = false;
            for (let object of this._myCollisions) {
                if (object.pp_equals(physXComponent.object)) {
                    objectFound = true;
                    break;
                }
            }

            if (objectFound) {
                console.error("Collision Start on object already collected");
            }
        }

        this._myCollisions.push(physXComponent.object);

        if (this._myUpdateActive) {
            this._myCollisionsStartToProcess.push(physXComponent.object);
            this._myCollisionsEndToProcess.pp_removeAll(function (element) {
                return element.pp_equals(physXComponent.object);
            });
        }

        if (this._myDebugActive) {
            console.log("Collision Start -", this._myCollisions.length);
        }
    }

    _onCollisionEnd(physXComponent) {
        if (this._myDebugActive) {
            let objectFound = false;
            for (let object of this._myCollisions) {
                if (object.pp_equals(physXComponent.object)) {
                    objectFound = true;
                    break;
                }
            }

            if (!objectFound) {
                console.error("Collision End on object not collected");
            }
        }


        this._myCollisions.pp_removeAll(function (element) {
            return element.pp_equals(physXComponent.object);
        });

        if (this._myUpdateActive) {
            this._myCollisionsEndToProcess.push(physXComponent.object);
            this._myCollisionsStartToProcess.pp_removeAll(function (element) {
                return element.pp_equals(physXComponent.object);
            });
        }

        if (this._myDebugActive) {
            console.log("Collision End -", this._myCollisions.length);
        }
    }

    _triggerDesyncFix(dt) {
        this._myTriggerDesyncFixDelay.update(dt);
        if (this._myTriggerDesyncFixDelay.isDone()) {
            this._myTriggerDesyncFixDelay.start();

            let collisionsToEnd = this._myCollisions.pp_findAll(function (element) {
                let physX = element.pp_getComponent("physx");
                return physX == null || !physX.active;
            });

            if (collisionsToEnd.length > 0) {
                //console.error("DESYNC RESOLVED");

                for (let collision of collisionsToEnd) {
                    let physX = collision.pp_getComponent("physx");
                    if (physX) {
                        this._onCollisionEnd(physX);
                    } else {
                        console.error("NO PHYSX, HOW?");
                    }
                }
            }
        }
    }
};
PP.SaveManager = class SaveManager {
    constructor() {
        this._mySaveCache = new Map();

        this._myCommitSavesDelayTimer = new PP.Timer(0, false);
        this._myDelaySavesCommit = true;
        this._myIDsToCommit = [];

        this._myCacheDefaultValueOnFail = true;

        if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
        }
        WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
        WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));

        this._myClearCallbacks = new Map();                 // Signature: callback()
        this._myDeleteCallbacks = new Map();                // Signature: callback(id)
        this._myDeleteIDCallbacks = new Map();              // Signature: callback(id)
        this._mySaveCallbacks = new Map();                  // Signature: callback(id, value)
        this._mySaveValueChangedCallbacks = new Map();      // Signature: callback(id, value)
        this._mySaveIDCallbacks = new Map();                // Signature: callback(id, value)
        this._mySaveValueChangedIDCallbacks = new Map();    // Signature: callback(id, value)
        this._myCommitSaveCallbacks = new Map();            // Signature: callback(id, value, isCommitSaveDelayed, failed)
        this._myCommitSaveIDCallbacks = new Map();          // Signature: callback(id, value, isCommitSaveDelayed, failed)
        this._myCommitSavesCallbacks = new Map();           // Signature: callback(isCommitSavesDelayed, failed)

        this._myLoadCallbacks = new Map();                  // Signature: callback(id, value, loadFromCache, failed)
        this._myLoadIDCallbacks = new Map();                // Signature: callback(id, value, loadFromCache, failed)
    }

    setCommitSavesDelay(delay) {
        this._myCommitSavesDelayTimer.start(delay);
    }

    setDelaySavesCommit(delayed) {
        this._myDelaySavesCommit = delayed;
    }

    setCacheDefaultValueOnFail(cache) {
        this._myCacheDefaultValueOnFail = cache;
    }

    update(dt) {
        if (this._myCommitSavesDelayTimer.isRunning()) {
            this._myCommitSavesDelayTimer.update(dt);
            if (this._myCommitSavesDelayTimer.isDone()) {
                this.commitSaves();
            }
        }
    }

    save(id, value, overrideDelaySavesCommit = null) {
        let sameValue = false;
        if (this._mySaveCache.has(id)) {
            sameValue = this._mySaveCache.get(id) === value;
        }

        if (!sameValue) {
            this._mySaveCache.set(id, value);
            if ((this._myDelaySavesCommit && overrideDelaySavesCommit == null) || (overrideDelaySavesCommit != null && overrideDelaySavesCommit)) {
                this._myIDsToCommit.pp_pushUnique(id);
                if (!this._myCommitSavesDelayTimer.isRunning()) {
                    this._myCommitSavesDelayTimer.start();
                }
            } else {
                let failed = this._commitSave(id, false);

                if (this._myCommitSavesCallbacks.size > 0) {
                    let isCommitSaveDelayed = false;
                    this._myCommitSavesCallbacks.forEach(function (callback) { callback(isCommitSaveDelayed, failed); });
                }
            }
        }

        if (this._mySaveCallbacks.size > 0) {
            this._mySaveCallbacks.forEach(function (callback) { callback(id, value); });
        }

        if (this._mySaveIDCallbacks.size > 0) {
            let callbackMap = this._mySaveIDCallbacks.get(id);
            if (callbackMap != null) {
                callbackMap.forEach(function (callback) { callback(id, value); });
            }
        }

        if (!sameValue) {
            if (this._mySaveValueChangedCallbacks.size > 0) {
                this._mySaveValueChangedCallbacks.forEach(function (callback) { callback(id, value); });
            }

            if (this._mySaveValueChangedIDCallbacks.size > 0) {
                let callbackMap = this._mySaveValueChangedIDCallbacks.get(id);
                if (callbackMap != null) {
                    callbackMap.forEach(function (callback) { callback(id, value); });
                }
            }
        }
    }

    commitSaves() {
        if (this._myIDsToCommit.length > 0) {
            let failed = false;

            for (let id of this._myIDsToCommit) {
                if (this._mySaveCache.has(id)) {
                    let result = this._commitSave(id, true);
                    failed = failed || result;
                }
            }

            this._myIDsToCommit = [];

            if (this._myCommitSavesCallbacks.size > 0) {
                let isCommitSavesDelayed = true;
                this._myCommitSavesCallbacks.forEach(function (callback) { callback(isCommitSavesDelayed, failed); });
            }
        }
    }

    has(id) {
        return this._mySaveCache.has(id) || PP.SaveUtils.has(id);
    }

    delete(id) {
        this._mySaveCache.delete(id);
        PP.SaveUtils.delete(id);

        if (this._myDeleteCallbacks.size > 0) {
            this._myDeleteCallbacks.forEach(function (callback) { callback(id); });
        }

        if (this._myDeleteIDCallbacks.size > 0) {
            let callbackMap = this._myDeleteIDCallbacks.get(id);
            if (callbackMap != null) {
                callbackMap.forEach(function (callback) { callback(id); });
            }
        }
    }

    clear() {
        this._mySaveCache.clear();
        PP.SaveUtils.clear();

        if (this._myClearCallbacks.size > 0) {
            this._myClearCallbacks.forEach(function (callback) { callback(); });
        }
    }

    load(id, defaultValue = null) {
        return this._load(id, defaultValue, "load");
    }

    loadString(id, defaultValue = null) {
        return this._load(id, defaultValue, "loadString");
    }

    loadNumber(id, defaultValue = null) {
        return this._load(id, defaultValue, "loadNumber");
    }

    loadBool(id, defaultValue = null) {
        return this._load(id, defaultValue, "loadBool");
    }

    getCommitSavesDelay() {
        return this._myCommitSavesDelayTimer.getDuration();
    }

    isDelaySavesCommit() {
        return this._myDelaySavesCommit;
    }

    isCacheDefaultValueOnFail() {
        return this._myCacheDefaultValueOnFail;
    }

    _commitSave(id, isCommitSaveDelayed) {
        let value = this._mySaveCache.get(id);
        let failed = false;

        try {
            PP.SaveUtils.save(id, value);
        } catch (error) {
            failed = true;
        }

        if (this._myCommitSaveCallbacks.size > 0) {
            this._myCommitSaveCallbacks.forEach(function (callback) { callback(id, value, isCommitSaveDelayed, failed); });
        }

        if (this._myCommitSaveIDCallbacks.size > 0) {
            let callbackMap = this._myCommitSaveIDCallbacks.get(id);
            if (callbackMap != null) {
                callbackMap.forEach(function (callback) { callback(id, value, isCommitSaveDelayed, failed); });
            }
        }

        return failed;
    }

    _load(id, defaultValue, functionName) {
        let value = null;
        let failed = false;
        let loadFromCache = false;

        if (this._mySaveCache.has(id)) {
            value = this._mySaveCache.get(id);

            if (value == null && defaultValue != null) {
                value = defaultValue;
                if (this._myCacheDefaultValueOnFail) {
                    this._mySaveCache.set(id, value);
                }
            }

            loadFromCache = true;
        } else {
            let saveResult = null;
            try {
                saveResult = PP.SaveUtils[functionName](id, null);
            } catch (error) {
                // Error is managed as if it worked but there was no value
                saveResult = null;
                failed = true;
            }

            if (saveResult == null) {
                value = defaultValue;
            } else {
                value = saveResult;
            }

            if (saveResult != null || this._myCacheDefaultValueOnFail) {
                this._mySaveCache.set(id, value);
            } else {
                this._mySaveCache.set(id, null);
            }
        }

        if (this._myLoadCallbacks.size > 0) {
            this._myLoadCallbacks.forEach(function (callback) { callback(id, value, loadFromCache, failed); });
        }

        if (this._myLoadIDCallbacks.size > 0) {
            let callbackMap = this._myLoadIDCallbacks.get(id);
            if (callbackMap != null) {
                callbackMap.forEach(function (callback) { callback(id, value, loadFromCache, failed); });
            }
        }

        return value;
    }

    _onXRSessionStart(session) {
        session.addEventListener('visibilitychange', function (event) {
            if (event.session.visibilityState != "visible") {
                this._onXRSessionInterrupt();
            }
        }.bind(this));
    }

    _onXRSessionEnd() {
        this._onXRSessionInterrupt();
    }

    _onXRSessionInterrupt() {
        this.commitSaves();
    }

    registerClearEventListener(callbackID, callback) {
        this._myClearCallbacks.set(callbackID, callback);
    }

    unregisterClearEventListener(callbackID) {
        this._myClearCallbacks.delete(callbackID);
    }

    registerDeleteEventListener(callbackID, callback) {
        this._myDeleteCallbacks.set(callbackID, callback);
    }

    unregisterDeleteEventListener(callbackID) {
        this._myDeleteCallbacks.delete(callbackID);
    }

    registerDeleteIDEventListener(valueID, callbackID, callback) {
        let valueIDMap = this._myDeleteIDCallbacks.get(valueID);
        if (valueIDMap == null) {
            this._myDeleteIDCallbacks.set(valueID, new Map());
            valueIDMap = this._myDeleteIDCallbacks.get(valueID);
        }

        valueIDMap.set(callbackID, callback);
    }

    unregisterDeleteIDEventListener(valueID, callbackID) {
        let valueIDMap = this._myDeleteIDCallbacks.get(valueID);
        if (valueIDMap != null) {
            valueIDMap.delete(callbackID);
        }
    }

    registerSaveEventListener(callbackID, callback) {
        this._mySaveCallbacks.set(callbackID, callback);
    }

    unregisterSaveEventListener(callbackID) {
        this._mySaveCallbacks.delete(callbackID);
    }

    registerSaveIDEventListener(valueID, callbackID, callback) {
        let valueIDMap = this._mySaveIDCallbacks.get(valueID);
        if (valueIDMap == null) {
            this._mySaveIDCallbacks.set(valueID, new Map());
            valueIDMap = this._mySaveIDCallbacks.get(valueID);
        }

        valueIDMap.set(callbackID, callback);
    }

    unregisterSaveIDEventListener(valueID, callbackID) {
        let valueIDMap = this._mySaveIDCallbacks.get(valueID);
        if (valueIDMap != null) {
            valueIDMap.delete(callbackID);
        }
    }

    registerSaveValueChangedEventListener(callbackID, callback) {
        this._mySaveValueChangedCallbacks.set(callbackID, callback);
    }

    unregisterSaveValueChangedEventListener(callbackID) {
        this._mySaveValueChangedCallbacks.delete(callbackID);
    }

    registerSaveValueChangedIDEventListener(valueID, callbackID, callback) {
        let valueIDMap = this._mySaveValueChangedIDCallbacks.get(valueID);
        if (valueIDMap == null) {
            this._mySaveValueChangedIDCallbacks.set(valueID, new Map());
            valueIDMap = this._mySaveValueChangedIDCallbacks.get(valueID);
        }

        valueIDMap.set(callbackID, callback);
    }

    unregisterSaveValueChangedIDEventListener(valueID, callbackID) {
        let valueIDMap = this._mySaveValueChangedIDCallbacks.get(valueID);
        if (valueIDMap != null) {
            valueIDMap.delete(callbackID);
        }
    }

    registerCommitSavesEventListener(callbackID, callback) {
        this._myCommitSavesCallbacks.set(callbackID, callback);
    }

    unregisterCommitSavesEventListener(callbackID) {
        this._myCommitSavesCallbacks.delete(callbackID);
    }

    registerCommitSaveEventListener(callbackID, callback) {
        this._myCommitSaveCallbacks.set(callbackID, callback);
    }

    unregisterCommitSaveEventListener(callbackID) {
        this._myCommitSaveCallbacks.delete(callbackID);
    }

    registerCommitSaveIDEventListener(valueID, callbackID, callback) {
        let valueIDMap = this._myCommitSaveIDCallbacks.get(valueID);
        if (valueIDMap == null) {
            this._myCommitSaveIDCallbacks.set(valueID, new Map());
            valueIDMap = this._myCommitSaveIDCallbacks.get(valueID);
        }

        valueIDMap.set(callbackID, callback);
    }

    unregisterCommitSaveIDEventListener(valueID, callbackID) {
        let valueIDMap = this._myCommitSaveIDCallbacks.get(valueID);
        if (valueIDMap != null) {
            valueIDMap.delete(callbackID);
        }
    }

    registerLoadEventListener(callbackID, callback) {
        this._myLoadCallbacks.set(callbackID, callback);
    }

    unregisterLoadEventListener(callbackID) {
        this._myLoadCallbacks.delete(callbackID);
    }

    registerLoadIDEventListener(valueID, callbackID, callback) {
        let valueIDMap = this._myLoadIDCallbacks.get(valueID);
        if (valueIDMap == null) {
            this._myLoadIDCallbacks.set(valueID, new Map());
            valueIDMap = this._myLoadIDCallbacks.get(valueID);
        }

        valueIDMap.set(callbackID, callback);
    }

    unregisterLoadIDEventListener(valueID, callbackID) {
        let valueIDMap = this._myLoadIDCallbacks.get(valueID);
        if (valueIDMap != null) {
            valueIDMap.delete(callbackID);
        }
    }
};
PP.Timer = class Timer {
    constructor(duration, autoStart = true) {
        this._myDuration = duration;
        this._myOnEndCallbacks = new Map();     // Signature: callback()

        this._myIsDone = false;
        this._myStarted = false;

        if (autoStart) {
            this.start();
        } else {
            this.reset();
        }
    }

    start(duration = null) {
        this.reset(duration);
        this._myStarted = true;
    }

    reset(duration = null) {
        if (duration != null) {
            this._myDuration = Math.max(0, duration);
        }

        this._myTimer = this._myDuration;
        this._myIsDone = false;
        this._myStarted = false;
    }

    update(dt) {
        if (this.isRunning()) {
            this._myTimer = Math.max(0, this._myTimer - dt);
            if (this._myTimer == 0) {
                this._done();
            }
        }
    }

    isDone() {
        return this._myIsDone;
    }

    isStarted() {
        return this._myStarted;
    }

    isRunning() {
        return this.isStarted() && !this.isDone();
    }

    getDuration() {
        return this._myDuration;
    }

    setDuration(duration) {
        this._myDuration = Math.max(0, duration);
    }

    getTimer() {
        return this._myTimer;
    }

    getPercentage() {
        let percentage = 1;
        if (this._myTimer > 0) {
            percentage = (this._myDuration - this._myTimer) / this._myDuration;
        }
        return Math.pp_clamp(percentage, 0, 1);
    }

    onEnd(callback, id = null) {
        this._myOnEndCallbacks.set(id, callback);
    }

    unregisterOnEnd(id = null) {
        this._myOnEndCallbacks.delete(id);
    }

    _done() {
        this._myTimer = 0;
        this._myIsDone = true;
        if (this._myOnEndCallbacks.size > 0) {
            for (let callback of this._myOnEndCallbacks.values()) {
                callback();
            }
        }
    }
};
WL.registerComponent("pp-audio-listener", {
    _mySpatial: { type: WL.Type.Bool, default: true },
}, {
    init: function () {
        this._myOrigin = new Float32Array(3);
        this._myForward = new Float32Array(3);
        this._myUp = new Float32Array(3);
    },
    update: function () {
        if (!this._mySpatial) return;

        this.object.pp_getPosition(this._myOrigin);
        this.object.pp_getForward(this._myForward);
        this.object.pp_getUp(this._myUp);

        Howler.pos(this._myOrigin[0], this._myOrigin[1], this._myOrigin[2]);
        Howler.orientation(this._myForward[0], this._myForward[1], this._myForward[2],
            this._myUp[0], this._myUp[1], this._myUp[2]);
    },
});
PP.AudioManager = class AudioManager {
    constructor() {
        this._myAudioSetupMap = new Map();
    }

    createAudioPlayer(audioSetupID) {
        return new PP.AudioPlayer(this.getAudioSetup(audioSetupID));
    }

    getAudioSetup(id) {
        return this._myAudioSetupMap.get(id);
    }

    addAudioSetup(id, audioSetup, preload = true) {
        this._myAudioSetupMap.set(id, audioSetup);
        if (preload) {
            this.createAudioPlayer(id);
        }
    }

    removeAudioSetup(id) {
        this._myAudioSetupMap.delete(id);
    }

    setVolume(volume) {
        Howler.volume(volume);
    }

    setMute(mute) {
        Howler.mute(mute);
    }

    stop() {
        Howler.stop();
    }
};
WL.registerComponent("pp-audio-manager", {
}, {
    init: function () {
        PP.myAudioManager = new PP.AudioManagerClass();
    },
    start: function () {
    },
    update: function (dt) {
    }
});

PP.myAudioManager = null;
PP.AudioEvent = {
    END: "end",
    STOP: "stop",
    LOAD: "load",
    LOAD_ERROR: "loaderror",
    PLAY: "play",
    PLAY_ERROR: "playerror",
    PAUSE: "pause",
    MUTE: "mute",
    VOLUME: "volume",
    RATE: "rate",
    SEEK: "seek",
    FADE: "fade",
    UNLOCK: "unlock"
};

PP.AudioPlayer = class AudioPlayer {
    constructor(audioSetupOrAudioFilePath) {
        if (typeof audioSetupOrAudioFilePath === 'string') {
            this._myAudioSetup = new PP.AudioSetup(audioSetupOrAudioFile);
        } else {
            this._myAudioSetup = audioSetupOrAudioFilePath.clone();
        }

        this._myAudio = new Howl({
            src: [this._myAudioSetup.myAudioFilePath],
            loop: this._myAudioSetup.myLoop,
            volume: this._myAudioSetup.myVolume,
            autoplay: this._myAudioSetup.myAutoplay,
            rate: this._myAudioSetup.myRate,
            pool: this._myAudioSetup.myPool,
            preload: true
        });

        this._myAudio._pannerAttr.refDistance = this._myAudioSetup.myReferenceDistance;

        this._myLastAudioID = null;

        this._myCallbackMap = new Map();
        for (let eventKey in PP.AudioEvent) {
            this._myCallbackMap.set(PP.AudioEvent[eventKey], new Map());    // Signature: callback(audioID)
        }

        this._addListeners();
    }

    play() {
        let audioID = this._myAudio.play();
        if (audioID != null) {
            this._myLastAudioID = audioID;

            this.updatePosition(this._myAudioSetup.myPosition, true);
            this.updatePitch(this._myAudioSetup.myPitch, true);
            this.updateVolume(this._myAudioSetup.myVolume, true);
        }
    }

    stop() {
        this._myAudio.stop();
    }

    pause() {
        this._myAudio.pause();
    }

    resume() {
        this._myAudio.play();
    }

    isPlaying(checkOnlyLast = false) {
        let isPlaying = false;

        if (checkOnlyLast) {
            isPlaying = this._myAudio.playing(this._myLastAudioID);
        }
        else {
            isPlaying = this._myAudio.playing();
        }

        return isPlaying;
    }

    isLoaded() {
        return this._myAudio.state() == "loaded";
    }

    fade(fromVolume, toVolume, duration, updateOnlyLast = false) {
        this.setVolume(toVolume);

        if (updateOnlyLast) {
            this._myAudio.fade(fromVolume, toVolume, duration * 1000, this._myLastAudioID);
        } else {
            this._myAudio.fade(fromVolume, toVolume, duration * 1000);
        }
    }

    updatePosition(position, updateOnlyLast = false) {
        this.setPosition(position);

        if (this._myAudioSetup.mySpatial && position) {
            if (updateOnlyLast) {
                this._myAudio.pos(position[0], position[1], position[2], this._myLastAudioID);
            } else {
                this._myAudio.pos(position[0], position[1], position[2]);
            }
        }
    }

    updatePitch(pitch, updateOnlyLast = false) {
        this.updateRate(pitch, updateOnlyLast);
    }

    updateRate(rate, updateOnlyLast = false) {
        this.setRate(rate);

        if (rate != null) {
            if (updateOnlyLast) {
                this._myAudio.rate(rate, this._myLastAudioID);
            } else {
                this._myAudio.rate(rate);
            }
        }
    }

    updateVolume(volume, updateOnlyLast = false) {
        this.setVolume(volume);

        if (volume != null) {
            if (updateOnlyLast) {
                this._myAudio.volume(volume, this._myLastAudioID);
            } else {
                this._myAudio.volume(volume);
            }
        }
    }

    setSpatial(spatial) {
        this._myAudioSetup.mySpatial = spatial;
    }

    setPosition(position) {
        this._myAudioSetup.myPosition = position;
    }

    setPitch(pitch) {
        this._myAudioSetup.myPitch = pitch;
    }

    setRate(rate) {
        this._myAudioSetup.myRate = rate;
    }

    setVolume(volume) {
        this._myAudioSetup.myVolume = volume;
    }

    getDuration() {
        return this._myAudio.duration();
    }

    getVolume() {
        return this._myAudioSetup.myVolume;
    }

    getPitch() {
        return this._myAudioSetup.myPitch;
    }

    getRate() {
        return this._myAudioSetup.myRate;
    }

    registerAudioEventListener(audioEvent, listenerID, callback) {
        this._myCallbackMap.get(audioEvent).set(listenerID, callback);
    }

    unregisterAudioEventListener(audioEvent, listenerID) {
        this._myCallbackMap.get(audioEvent).delete(listenerID);
    }

    _addListeners() {
        for (let eventKey in PP.AudioEvent) {
            let event = PP.AudioEvent[eventKey];
            this._myAudio.on(event, function (audioID) {
                let callbacks = this._myCallbackMap.get(event);
                for (let callback of callbacks.values()) {
                    callback(audioID);
                }
            }.bind(this));
        }
    }
};
PP.AudioSetup = class AudioSetup {
    constructor(audioFilePath = null) {
        this.myAudioFilePath = (audioFilePath) ? audioFilePath.slice(0) : null;

        this.myLoop = false;
        this.myAutoplay = false;

        this.myVolume = 1.0;
        this._myRate = 1.0; //From 0.5 to 4.0

        this.myPool = 5;

        //Spatial
        this.myPosition = null;
        this.mySpatial = true;
        this.myReferenceDistance = 1.0; // At this distance (and closer) the volume is not reduced
    }

    clone() {
        let audioSetup = new PP.AudioSetup();

        audioSetup.myAudioFilePath = this.myAudioFilePath.slice(0);

        audioSetup.myLoop = this.myLoop;
        audioSetup.myAutoplay = this.myAutoplay;

        audioSetup.myVolume = this.myVolume;
        audioSetup.myPitch = this.myPitch;
        audioSetup.myRate = this.myRate;

        audioSetup.myPool = this.myPool;

        //Spatial
        audioSetup.myPosition = this.myPosition;
        audioSetup.mySpatial = this.mySpatial;
        audioSetup.myReferenceDistance = this.myReferenceDistance;

        return audioSetup;
    }

    get myPitch() {
        return this._myRate;
    }

    get myRate() {
        return this._myRate;
    }

    set myPitch(pitch) {
        this._myRate = pitch;
    }

    set myRate(rate) {
        this._myRate = rate;
    }
};
WL.registerComponent('pp-mute-all', {
}, {
    init: function () {
    },
    start: function () {
        Howler.mute(true);
    },
    update: function (dt) {
    },
});
WL.registerComponent("activate-on-select", {
    _myHandedness: { type: WL.Type.Enum, values: ['left', 'right'], default: 'left' },
    _myTrigger: { type: WL.Type.Object },
}, {
    init: function () {
    },
    start: function () {
        if (this._myHandedness == 0) {
            this._myGamepad = PP.myLeftGamepad;
        } else {
            this._myGamepad = PP.myRightGamepad;
        }

        this._myPhysx = this.object.pp_getComponent("physx");

        this._myTriggerPhysx = this._myTrigger.pp_getComponent("physx");
        this._myTriggerPhysx.onCollision(this._onCollision.bind(this));

        this._myGamepad.registerButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.PRESS_START, this, this._selectPressStart.bind(this));
        this._myGamepad.registerButtonEventListener(PP.ButtonType.SELECT, PP.ButtonEvent.PRESS_END, this, this._selectPressEnd.bind(this));

        this._myPhysx.active = false;
        this._myTriggerPhysx.active = false;

        this._myCollisionAudio = Global.myAudioManager.createAudioPlayer(SfxID.COLLISION);
        this._myCollisionPitch = this._myCollisionAudio.getPitch();

        this._myAnalyticsTimer = new PP.Timer(0);
    },
    update(dt) {
        this._myAnalyticsTimer.update(dt);

        if (!Global.myEnableSelectPhysx) {
            this._myPhysx.active = false;
            this._myTriggerPhysx.active = false;
        }
    },
    _selectPressStart() {
        if (Global.myEnableSelectPhysx) {
            this._myPhysx.active = true;
            this._myTriggerPhysx.active = true;

            if (this._myAnalyticsTimer.isDone()) {
                this._myAnalyticsTimer.start(20);

                if (Global.myGoogleAnalytics) {
                    gtag("event", "select_physx_actived", {
                        "value": 1
                    });
                }
            }
        }
    },
    _selectPressEnd() {
        this._myPhysx.active = false;
        this._myTriggerPhysx.active = false;
    },
    _onCollision(type, physx) {
        if (type == WL.CollisionEventType.TriggerTouch) {
            if (physx.object.pp_getComponent("evidence-component") != null) {
                let intensity = 0.1;
                let pulseInfo = this._myGamepad.getPulseInfo();
                if (pulseInfo.myIntensity <= intensity) {
                    this._myGamepad.pulse(intensity, 0.1);
                }

                this._myCollisionAudio.setPosition(this.object.pp_getPosition());
                this._myCollisionAudio.setPitch(Math.pp_random(this._myCollisionPitch - 0.15, this._myCollisionPitch + 0.05));
                this._myCollisionAudio.play();
            }
        }
    }
});
WL.registerComponent("adjust-materials", {
    _myFogAlpha: { type: WL.Type.Float, default: 0 }, //0.330
    _mySpecularMultiplier: { type: WL.Type.Float, default: 1 },
    _my1: { type: WL.Type.Material },
    _my2: { type: WL.Type.Material },
    _my3: { type: WL.Type.Material },
    _my4: { type: WL.Type.Material },
    _my5: { type: WL.Type.Material },
    _my6: { type: WL.Type.Material },
    _my7: { type: WL.Type.Material },
    _my8: { type: WL.Type.Material },
    _my9: { type: WL.Type.Material },
    _my10: { type: WL.Type.Material },
    _my11: { type: WL.Type.Material },
    _my12: { type: WL.Type.Material },
    _my13: { type: WL.Type.Material },
    _my14: { type: WL.Type.Material },
    _my15: { type: WL.Type.Material },
    _my16: { type: WL.Type.Material }
}, {
    init: function () {
        if (this.active) {
            this._myMaterials = [];
            this._mySpecularColors = [];
            for (let i = 1; i < 17; i++) {
                let material = "_my".concat(i);
                this[material].fogColor = [0, 0, 0, this._myFogAlpha];
                this._myMaterials.push(this[material]);

                this._mySpecularColors.push(this[material].specularColor.pp_clone());
                let specularColor = this[material].specularColor.vec_scale(this._mySpecularMultiplier);
                specularColor[3] = this[material].specularColor[3];

                this[material].specularColor = specularColor;
            }
        }
    },
    start() {
        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Fog Alpha", this._myFogAlpha, 0.1, 3, 0, 1));
        this._myLastFogAlpha = PP.myEasyTuneVariables.get("Fog Alpha");

        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Specular Multiplier", this._mySpecularMultiplier, 1, 3, 0, 3));
        this._myLastSpecularMultiplier = PP.myEasyTuneVariables.get("Specular Multiplier");
    },
    update(dt) {
        let fogAlpha = PP.myEasyTuneVariables.get("Fog Alpha");
        if (fogAlpha != this._myLastFogAlpha) {
            this._myLastFogAlpha = fogAlpha;
            for (let material of this._myMaterials) {
                material.fogColor = [0, 0, 0, fogAlpha];
            }
        }

        let specularMultiplier = PP.myEasyTuneVariables.get("Specular Multiplier");
        if (specularMultiplier != this._myLastSpecularMultiplier) {
            this._myLastSpecularMultiplier = specularMultiplier;
            for (let i = 0; i < this._myMaterials.length; i++) {
                let specularColor = this._mySpecularColors[i].vec_scale(specularMultiplier);
                specularColor[3] = this._mySpecularColors[i][3];

                this._myMaterials[i].specularColor = specularColor;
            }
        }
    }
});
WL.registerComponent("clear-console-on-session", {
}, {
    init: function () {
    },
    start: function () {
        this._myFirstTime = true;
        WL.onXRSessionStart.push(function () {
            if (this._myFirstTime) {
                this._myFirstTime = false;
                console.clear();
            }
        }.bind(this));
    },
    update: function (dt) {
    }
});
WL.registerComponent("color-on-select", {
    _myHandedness: { type: WL.Type.Enum, values: ['left', 'right'], default: 'left' },
    _myPhysxMaterial: { type: WL.Type.Material },
    _myIdleMaterial: { type: WL.Type.Material }
}, {
    init: function () {
        this._myDiffuseColor = vec4_create();
        this._myAmbientColor = vec4_create();
        this._mySpecularColor = vec4_create();
    },
    start: function () {
        if (this._myHandedness == 0) {
            this._myGamepad = PP.myLeftGamepad;
        } else {
            this._myGamepad = PP.myRightGamepad;
        }

        this._myFirstUpdate = true;
        this._myPrevSelectValue = -1;
    },
    update() {
        if (this._myFirstUpdate) {
            this._myFirstUpdate = false;
            this._myPhysxMaterialDiffuseColor = this._myPhysxMaterial.diffuseColor.pp_clone();
            this._myIdleMaterialDiffuseColor = this._myIdleMaterial.diffuseColor.pp_clone();

            this._myPhysxMaterialAmbientColor = this._myPhysxMaterial.ambientColor.pp_clone();
            this._myIdleMaterialAmbientColor = this._myIdleMaterial.ambientColor.pp_clone();

            this._myPhysxMaterialSpecularColor = this._myPhysxMaterial.specularColor.pp_clone();
            this._myIdleMaterialSpecularColor = this._myIdleMaterial.specularColor.pp_clone();

            this._myMaterial = this.object.pp_getComponentHierarchy("mesh").material.clone();
            PP.MeshUtils.setMaterial(this.object, this._myMaterial);
        } else {
            let selectValue = Math.pp_mapToRange(this._myGamepad.getButtonInfo(PP.ButtonType.SELECT).getValue(), 0.1, 0.85, 0, 1);
            if (!Global.myEnableSelectPhysx) {
                selectValue = 0;
            }

            if (selectValue != this._myPrevSelectValue) {
                this._myDiffuseColor[0] = Math.pp_lerp(this._myIdleMaterialDiffuseColor[0], this._myPhysxMaterialDiffuseColor[0], selectValue);
                this._myDiffuseColor[1] = Math.pp_lerp(this._myIdleMaterialDiffuseColor[1], this._myPhysxMaterialDiffuseColor[1], selectValue);
                this._myDiffuseColor[2] = Math.pp_lerp(this._myIdleMaterialDiffuseColor[2], this._myPhysxMaterialDiffuseColor[2], selectValue);
                this._myDiffuseColor[3] = 1;
                this._myMaterial.diffuseColor = this._myDiffuseColor;

                this._myAmbientColor[0] = Math.pp_lerp(this._myIdleMaterialAmbientColor[0], this._myPhysxMaterialAmbientColor[0], selectValue);
                this._myAmbientColor[1] = Math.pp_lerp(this._myIdleMaterialAmbientColor[1], this._myPhysxMaterialAmbientColor[1], selectValue);
                this._myAmbientColor[2] = Math.pp_lerp(this._myIdleMaterialAmbientColor[2], this._myPhysxMaterialAmbientColor[2], selectValue);
                this._myAmbientColor[3] = 1;
                this._myMaterial.ambientColor = this._myAmbientColor;

                this._mySpecularColor[0] = Math.pp_lerp(this._myIdleMaterialSpecularColor[0], this._myPhysxMaterialSpecularColor[0], selectValue);
                this._mySpecularColor[1] = Math.pp_lerp(this._myIdleMaterialSpecularColor[1], this._myPhysxMaterialSpecularColor[1], selectValue);
                this._mySpecularColor[2] = Math.pp_lerp(this._myIdleMaterialSpecularColor[2], this._myPhysxMaterialSpecularColor[2], selectValue);
                this._mySpecularColor[3] = 1;
                this._myMaterial.specularColor = this._mySpecularColor;
            }

            this._myPrevSelectValue = selectValue;
        }

    }
});
WL.registerComponent("credits-visualizer", {
    _myWondermelon: { type: WL.Type.Object }
}, {
    init: function () {
        this._myFSM = new PP.FSM();
        this._myFSM.addState("hide", this._hideUpdate.bind(this));
        this._myFSM.addState("visible", this._visibleUpdate.bind(this));
        this._myFSM.addState("spawning", this._spawn.bind(this));
        this._myFSM.addState("unspawning", this._unspawn.bind(this));

        this._myFSM.addTransition("hide", "spawning", "spawn");
        this._myFSM.addTransition("spawning", "visible", "end");
        this._myFSM.addTransition("visible", "unspawning", "unspawn");
        this._myFSM.addTransition("unspawning", "hide", "end");
    },
    start: function () {
        this._myText = this.object.pp_getComponentHierarchy("text");
        this._myText.material = this._myText.material.clone();
        this._myTextColor = this._myText.material.color.pp_clone();

        let color = this._myText.material.color;
        color[3] = 0;
        this._myText.material.color = color;
        this._myText.active = false;

        this._myGrabbable = this._myWondermelon.pp_getComponent("pp-grabbable");

        this._myWondermelonGrabTime = 0;
        this._mySpawnTimer = new PP.Timer(1.5);
        this._myHideScale = 0.85;

        this._myAppearAudio = Global.myAudioManager.createAudioPlayer(SfxID.TITLE_APPEAR);
        this._myDisappearAudio = Global.myAudioManager.createAudioPlayer(SfxID.TITLE_DISAPPEAR);
        this._myAppearAudio.setPosition(this.object.pp_getPosition());
        this._myDisappearAudio.setPosition(this.object.pp_getPosition());
        this._myAppearAudio.setVolume(1);
        this._myDisappearAudio.setVolume(0.7);

        this._myFSM.init("hide");
    },
    update(dt) {
        this._myFSM.update(dt);
    },
    _hideUpdate(dt) {
        if (this._myGrabbable.isGrabbed() && Global.myIsInMenu) {
            this._myWondermelonGrabTime += dt;
            if (this._myWondermelonGrabTime > 2.5) {
                this._myText.active = true;
                this._myWondermelonGrabTime = 0;
                this._mySpawnTimer.start();

                this._myAppearAudio.play();
                this._myFSM.perform("spawn");

                if (Global.myGoogleAnalytics) {
                    gtag("event", "credits_shown", {
                        "value": 1
                    });
                }
            }
        } else {
            this._myWondermelonGrabTime = 0;
        }
    },
    _visibleUpdate(dt) {
        if (!this._myGrabbable.isGrabbed()) {
            this._myWondermelonGrabTime += dt;
            if (this._myWondermelonGrabTime > 1) {
                this._myWondermelonGrabTime = 0;
                this._mySpawnTimer.start();
                this._myDisappearAudio.play();
                this._myFSM.perform("unspawn");
            }
        } else {
            this._myWondermelonGrabTime = 0;
        }
    },
    _spawn(dt) {
        if (this._mySpawnTimer.isRunning()) {
            this._mySpawnTimer.update(dt);

            let tempColor = [0, 0, 0, 1];

            tempColor[0] = Math.pp_interpolate(0, this._myTextColor[0], this._mySpawnTimer.getPercentage(), PP.EasingFunction.easeInOut);
            tempColor[1] = Math.pp_interpolate(0, this._myTextColor[1], this._mySpawnTimer.getPercentage(), PP.EasingFunction.easeInOut);
            tempColor[2] = Math.pp_interpolate(0, this._myTextColor[2], this._mySpawnTimer.getPercentage(), PP.EasingFunction.easeInOut);

            this._myText.material.color = tempColor;

            let easing = t => t * (2 - t);
            this._myText.object.pp_setScaleLocal(Math.pp_interpolate(this._myHideScale, 1, this._mySpawnTimer.getPercentage(), easing));

            if (this._mySpawnTimer.isDone()) {
                this._myFSM.perform("end");
            }
        }
    },
    _unspawn(dt) {
        if (this._mySpawnTimer.isRunning()) {
            this._mySpawnTimer.update(dt);

            let tempColor = [0, 0, 0, 1];

            tempColor[0] = Math.pp_interpolate(this._myTextColor[0], 0, this._mySpawnTimer.getPercentage(), PP.EasingFunction.easeInOut);
            tempColor[1] = Math.pp_interpolate(this._myTextColor[1], 0, this._mySpawnTimer.getPercentage(), PP.EasingFunction.easeInOut);
            tempColor[2] = Math.pp_interpolate(this._myTextColor[2], 0, this._mySpawnTimer.getPercentage(), PP.EasingFunction.easeInOut);

            this._myText.material.color = tempColor;

            let easing = t => t * t;
            let scale = Math.pp_interpolate(1, this._myHideScale, this._mySpawnTimer.getPercentage(), easing);
            this._myText.object.pp_setScaleLocal(scale);

            if (this._mySpawnTimer.isDone()) {
                this._myText.active = false;
                this._myFSM.perform("end");
            }
        }
    }
});
WL.registerComponent('pp-deactivate-on-first-update', {
}, {
    init: function () {
    },
    start: function () {
        this._myFirst = true;
    },
    update: function (dt) {
        if (this._myFirst) {
            this._myFirst = false;
            this.object.pp_setActiveHierarchy(false);
        }
    },
});
WL.registerComponent("display-leaderboard", {
    _myName: { type: WL.Type.String, default: '' },
    _myIsLocal: { type: WL.Type.Bool, default: false },
    _myNamesText: { type: WL.Type.Object },
    _myScoresText: { type: WL.Type.Object },
}, {
    init: function () {
    },
    start: function () {
        this._myNamesTextComponent = this._myNamesText.pp_getComponent("text");
        this._myScoresTextComponent = this._myScoresText.pp_getComponent("text");
    },
    update: function (dt) {
    },
    onActivate: function () {
        PP.CAUtils.getLeaderboard(this._myName, true, this._myIsLocal, 10, this._onLeaderboardRetrieved.bind(this));
    },
    _onLeaderboardRetrieved(leaderboard) {
        let namesText = "";
        let scoresText = "";

        let maxRankDigit = 0;
        for (let value of leaderboard) {
            let rank = value.rank + 1;
            if (rank.toFixed(0).length > maxRankDigit) {
                maxRankDigit = rank.toFixed(0).length;
            }
        }

        for (let value of leaderboard) {
            let rank = value.rank + 1;
            let fixedRank = rank.toFixed(0);
            while (fixedRank.length < maxRankDigit) {
                fixedRank = "0".concat(fixedRank);
            }

            namesText = namesText.concat(fixedRank, " - ", value.displayName, "\n\n");

            let convertedScore = this._convertTime(value.score);
            scoresText = scoresText.concat(convertedScore, "\n\n");
        }

        this._myNamesTextComponent.text = namesText;
        this._myScoresTextComponent.text = scoresText;
    },
    _convertTime(score) {
        let time = Math.floor(score / 1000);

        let hours = Math.floor(time / 3600);
        time -= hours * 3600;
        let minutes = Math.floor(time / 60);
        time -= minutes * 60;
        let seconds = Math.floor(time);


        let secondsText = (seconds.toFixed(0).length < 2) ? "0".concat(seconds.toFixed(0)) : seconds.toFixed(0);
        let minutesText = (minutes.toFixed(0).length < 2) ? "0".concat(minutes.toFixed(0)) : minutes.toFixed(0);
        let hoursText = (hours.toFixed(0).length < 2) ? "0".concat(hours.toFixed(0)) : hours.toFixed(0);

        let convertedTime = hoursText.concat(":", minutesText, ":", secondsText);

        return convertedTime;
    }
});
class EIECADummyServer {

    constructor() {
    }

    getLeaderboard(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError) {
        let leaderboard = null;

        if (isAroundPlayer) {
            leaderboard = [
                { rank: 0, displayName: "Login", score: 0 },
                { rank: 1, displayName: "And", score: 0 },
                { rank: 2, displayName: "Play", score: 0 },
                { rank: 3, displayName: "On", score: 0 },
                { rank: 4, displayName: "Construct", score: 0 },
                { rank: 5, displayName: "Arcade", score: 0 },
                { rank: 6, displayName: "To", score: 0 },
                { rank: 7, displayName: "Submit", score: 0 },
                { rank: 8, displayName: "Your", score: 0 },
                { rank: 9, displayName: "Score", score: 0 }
            ];
        } else {
            leaderboard = [
                { rank: 0, displayName: "The", score: 0 },
                { rank: 1, displayName: "Leaderboard", score: 0 },
                { rank: 2, displayName: "Is", score: 0 },
                { rank: 3, displayName: "Available", score: 0 },
                { rank: 4, displayName: "Only", score: 0 },
                { rank: 5, displayName: "When", score: 0 },
                { rank: 6, displayName: "Playing", score: 0 },
                { rank: 7, displayName: "On", score: 0 },
                { rank: 8, displayName: "Construct", score: 0 },
                { rank: 9, displayName: "Arcade", score: 0 }
            ];
        }

        while (leaderboard.length > scoresAmount) {
            leaderboard.pop();
        }

        if (callbackOnDone) {
            callbackOnDone(leaderboard);
        }
    }

    submitScore(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError) {
        if (callbackOnDone) {
            callbackOnDone();
        }
    }

    getUser(callbackOnDone, callbackOnError) {
        let user = {};
        user.displayName = "mr NOT";

        if (callbackOnDone) {
            callbackOnDone(user);
        }
    }
}

WL.registerComponent("enable-debug-shortcuts", {
    _myShortcutsEnabled: { type: WL.Type.Bool, default: false },
}, {
    init: function () {
    },
    start: function () {
        Global.myDebugShortcutsEnabled = this._myShortcutsEnabled;
        if (this._myShortcutsEnabled) {
            if (WL.xrSession) {
                this._onXRSessionStart(WL.xrSession);
            }
            WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
        }
    },
    update: function (dt) {
    },
    _onXRSessionStart: function (session) {
        if (PP.XRUtils.isDeviceEmulated()) {
            Global.myDebugShortcutsPress = 1;
        } else {
            Global.myDebugShortcutsPress = 2;
        }
    }
});


WL.registerComponent('evidence-objects', {
    _myTrialTimer: { type: WL.Type.Object },
    _myVentTimer: { type: WL.Type.Object },
    _myTuciaDrawing: { type: WL.Type.Object },
    _myCPlusPlusPrimer: { type: WL.Type.Object },
    _myPiano: { type: WL.Type.Object },
    _myMiccoTheBear: { type: WL.Type.Object },
    _myStaringCube: { type: WL.Type.Object },
    _myWaterLily: { type: WL.Type.Object },
    _myLoL: { type: WL.Type.Object },
    _myDrinkMeEarring: { type: WL.Type.Object },
    _mySkate: { type: WL.Type.Object },
    _myNotCoin: { type: WL.Type.Object },
    _myPsi: { type: WL.Type.Object },
    _myWonderland: { type: WL.Type.Object },
    _myEthereum: { type: WL.Type.Object },
    _myMrNOTEvidence: { type: WL.Type.Object },
    _myHeart: { type: WL.Type.Object },
    _myAntMainCharacter: { type: WL.Type.Object },
    _myHaloSword: { type: WL.Type.Object },
    _myFox: { type: WL.Type.Object },
    _myPICO_8: { type: WL.Type.Object },
    _myEggplant: { type: WL.Type.Object },
    _myVR: { type: WL.Type.Object },
    _myTrophy: { type: WL.Type.Object },
    _myFamily: { type: WL.Type.Object },
    _myMirror: { type: WL.Type.Object },
    _myWayfinder: { type: WL.Type.Object },
    _myEveryeye: { type: WL.Type.Object },
    _myAloeVera: { type: WL.Type.Object },
}, {
    init: function () {
        Global.myGameObjects.set(GameObjectType.TRIAL_TIMER, this._myTrialTimer);
        Global.myGameObjects.set(GameObjectType.VENT_TIMER, this._myVentTimer);
        Global.myGameObjects.set(GameObjectType.TUCIA_DRAWING, this._myTuciaDrawing);
        Global.myGameObjects.set(GameObjectType.CPLUSPLUS_PRIMER, this._myCPlusPlusPrimer);
        Global.myGameObjects.set(GameObjectType.PIANO, this._myPiano);
        Global.myGameObjects.set(GameObjectType.MICCO_THE_BEAR, this._myMiccoTheBear);
        Global.myGameObjects.set(GameObjectType.STARING_CUBE, this._myStaringCube);
        Global.myGameObjects.set(GameObjectType.WATER_LILY, this._myWaterLily);
        Global.myGameObjects.set(GameObjectType.LOL, this._myLoL);
        Global.myGameObjects.set(GameObjectType.DRINK_ME_EARRING, this._myDrinkMeEarring);
        Global.myGameObjects.set(GameObjectType.SKATE, this._mySkate);
        Global.myGameObjects.set(GameObjectType.SHATTERED_COIN, this._myNotCoin);
        Global.myGameObjects.set(GameObjectType.PSI, this._myPsi);
        Global.myGameObjects.set(GameObjectType.WONDERLAND, this._myWonderland);
        Global.myGameObjects.set(GameObjectType.ETHEREUM, this._myEthereum);
        Global.myGameObjects.set(GameObjectType.MR_NOT_EVIDENCE, this._myMrNOTEvidence);
        Global.myGameObjects.set(GameObjectType.HEART, this._myHeart);
        Global.myGameObjects.set(GameObjectType.ANT_MAIN_CHARACTER, this._myAntMainCharacter);
        Global.myGameObjects.set(GameObjectType.HALO_SWORD, this._myHaloSword);
        Global.myGameObjects.set(GameObjectType.FOX, this._myFox);
        Global.myGameObjects.set(GameObjectType.PICO_8, this._myPICO_8);
        Global.myGameObjects.set(GameObjectType.EGGPLANT, this._myEggplant);
        Global.myGameObjects.set(GameObjectType.VR, this._myVR);
        Global.myGameObjects.set(GameObjectType.TROPHY, this._myTrophy);
        Global.myGameObjects.set(GameObjectType.FAMILY, this._myFamily);
        Global.myGameObjects.set(GameObjectType.MIRROR, this._myMirror);
        Global.myGameObjects.set(GameObjectType.WAYFINDER, this._myWayfinder);
        Global.myGameObjects.set(GameObjectType.EVERYEYE, this._myEveryeye);
        Global.myGameObjects.set(GameObjectType.ALOE_VERA, this._myAloeVera);

        let cloneParams = new PP.CloneParams();
        cloneParams.myComponentsToInclude.push("mesh");
        cloneParams.myComponentsToInclude.push("text");
        cloneParams.myComponentsToInclude.push("text-color-fog");
        Global.myMeshObjects.set(GameObjectType.TRIAL_TIMER, this._myTrialTimer.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.VENT_TIMER, this._myVentTimer.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.TUCIA_DRAWING, this._myTuciaDrawing.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.CPLUSPLUS_PRIMER, this._myCPlusPlusPrimer.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.PIANO, this._myPiano.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.MICCO_THE_BEAR, this._myMiccoTheBear.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.STARING_CUBE, this._myStaringCube.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.WATER_LILY, this._myWaterLily.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.LOL, this._myLoL.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.DRINK_ME_EARRING, this._myDrinkMeEarring.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.SKATE, this._mySkate.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.SHATTERED_COIN, this._myNotCoin.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.PSI, this._myPsi.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.WONDERLAND, this._myWonderland.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.ETHEREUM, this._myEthereum.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.MR_NOT_EVIDENCE, this._myMrNOTEvidence.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.HEART, this._myHeart.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.ANT_MAIN_CHARACTER, this._myAntMainCharacter.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.HALO_SWORD, this._myHaloSword.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.FOX, this._myFox.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.PICO_8, this._myPICO_8.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.EGGPLANT, this._myEggplant.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.VR, this._myVR.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.TROPHY, this._myTrophy.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.FAMILY, this._myFamily.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.MIRROR, this._myMirror.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.WAYFINDER, this._myWayfinder.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.EVERYEYE, this._myEveryeye.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.ALOE_VERA, this._myAloeVera.pp_clone(cloneParams));
    },
    start: function () {
    },
    update: function (dt) {
    },
});


WL.registerComponent("fireworks", {
}, {
    init: function () {
    },
    update() {
        if (PP.GamepadUtils.areButtonsPressEnd([PP.myRightGamepad, PP.ButtonType.SQUEEZE])) {
            Global.myParticlesManager.fireworks([0, 5, -5], 2.5, [3, 3, 3]);
        }
    }
});

var GameObjectType = {
    MR_NOT: 0,
    COIN: 1,
    ARCADE_STICK_DISPUTE: 2,
    ARCADE_STICK_CHAT: 3,
    ARCADE_LEADERBOARD_DISPUTE: 4,
    ARCADE_LEADERBOARD_CHAT: 5,
    WONDERMELON: 6,
    ZESTY_MARKET: 7,
    FLOPPY_DISK: 8,
    TRIAL_TIMER: 9,
    TUCIA_DRAWING: 10,
    CPLUSPLUS_PRIMER: 11,
    PIANO: 12,
    MICCO_THE_BEAR: 13,
    STARING_CUBE: 14,
    WATER_LILY: 15,
    LOL: 16,
    DRINK_ME_EARRING: 17,
    SKATE: 18,
    MR_NOT_CLONE: 19,
    SHATTERED_COIN: 20,
    NOT_COIN: 21,
    PSI: 22,
    VENT_TIMER: 23,
    WONDERLAND: 24,
    ETHEREUM: 25,
    MR_NOT_EVIDENCE: 26,
    HEART: 27,
    ANT_MAIN_CHARACTER: 28,
    HALO_SWORD: 29,
    FOX: 30,
    PICO_8: 31,
    EGGPLANT: 32,
    VR: 33,
    TROPHY: 34,
    FAMILY: 35,
    MIRROR: 36,
    WAYFINDER: 37,
    EVERYEYE: 38,
    ALOE_VERA: 39,
};

WL.registerComponent('get-player-transform', {
}, {
    init: function () {
    },
    start: function () {
    },
    update: function (dt) {
        Global.myPlayerPosition = this.object.pp_getPosition();
        Global.myPlayerRotation = this.object.pp_getRotation();
        Global.myPlayerForward = this.object.pp_getForward();
        if (PP.XRUtils.isDeviceEmulated()) {
            Global.myPlayerForward = [0, 0, -1];
        }
        Global.myPlayerUp = this.object.pp_getUp();
    },
});
WL.registerComponent("hand-animator", {
    _myHandPieceObject: { type: WL.Type.Object },
    _myHandedness: { type: WL.Type.Enum, values: ['left', 'right'], default: 'left' }
}, {
    init: function () {
    },
    start: function () {
        this._myHandObject = WL.scene.addObject(this.object);
        this._myHandObject.pp_rotateObject([0, 180, 0]);

        let cloneParams = new PP.CloneParams();
        cloneParams.myIgnoreNonCloneable = true;
        let handPieceBase = this._myHandPieceObject.pp_clone(cloneParams);
        handPieceBase.pp_setParent(this._myHandObject);

        let xDistance = 0.005;
        let yDistance = 0.005;
        let zDistance = 0.01;

        let leftMultiplier = -1;
        if (this._myHandedness == PP.HandednessIndex.RIGHT) {
            leftMultiplier = 1;
        }

        let rotations = [[0, 0, 0], [0, 0, -90 * leftMultiplier], [0, 0, 180], [0, 0, 90 * leftMultiplier], [180, 0, -90],
        [180, 0, (leftMultiplier > 0) ? 180 : 0], [180, 0, 90], [180, 0, (leftMultiplier < 0) ? 180 : 0]];
        let endPositions = [[-xDistance * leftMultiplier, yDistance, -zDistance], [xDistance * -leftMultiplier, -yDistance, -zDistance], [xDistance * leftMultiplier, -yDistance, -zDistance], [xDistance * leftMultiplier, yDistance, -zDistance],
        [xDistance, -yDistance * leftMultiplier, zDistance], [xDistance, yDistance * leftMultiplier, zDistance], [-xDistance, yDistance * leftMultiplier, zDistance], [-xDistance, -yDistance * leftMultiplier, zDistance]];

        let elementsToRemove = [7, 5, 4];
        if (this._myHandedness == PP.HandednessIndex.RIGHT) {
            elementsToRemove = [7, 6, 5];
        }

        for (let index of elementsToRemove) {
            rotations.pp_removeIndex(index);
            endPositions.pp_removeIndex(index);
        }

        let startPosition = [0, 0, 0];

        this._myHandPieces = [];

        for (let i = 0; i < rotations.length; i++) {
            let piece = null;
            if (i == rotations.length - 1) {
                piece = handPieceBase;
            } else {
                piece = handPieceBase.pp_clone(cloneParams);
            }

            piece.pp_rotateObject(rotations[i]);
            this._myHandPieces[i] = new HandPiece(piece, startPosition, endPositions[i]);
        }

        this._myGamepad = PP.myGamepads[PP.InputUtils.getHandednessByIndex(this._myHandedness)];

        this._myAppearList = [];
        this._myStarted = false;

        this._myPulseTimer = new PP.Timer(0.25);
    },
    update: function (dt) {
        for (let piece of this._myHandPieces) {
            piece.update(dt, this._myGamepad.getButtonInfo(PP.ButtonType.SQUEEZE).myValue);
        }

        if (this._myAppearList.length > 0) {
            let first = this._myAppearList[0];
            first[1].update(dt);
            if (first[1].isDone()) {
                this._myHandPieces[first[0]].start();
                this._myAppearList.shift();
            }
        }

        if (this._myStarted && !this.isDone()) {
            this._myPulseTimer.update(dt);
            if (this._myPulseTimer.isDone()) {
                this._myGamepad.pulse(0.5);
            }
        }
    },
    begin: function () {
        this._myStarted = true;
        this._myAppearList = [];

        let indexList = [];
        for (let i = 0; i < this._myHandPieces.length; i++) {
            indexList[i] = i;
        }

        let firstTime = true;
        while (indexList.length > 0) {
            let randomIndex = Math.pp_randomInt(0, indexList.length - 1);
            let index = indexList.pp_removeIndex(randomIndex);

            let randomTimer = Math.pp_random(0.15, 0.45);
            if (firstTime) {
                randomTimer = 0.1;
                firstTime = false;
            }

            this._myAppearList.push([index, new PP.Timer(randomTimer)]);
        }
    },
    isDone: function () {
        let done = true;

        for (let piece of this._myHandPieces) {
            done = done && piece.isDone();
        }

        return done;
    },
    skip: function () {
        for (let piece of this._myHandPieces) {
            piece.skip();
        }

        this._myAppearList = [];
    }
});

class HandPiece {
    constructor(object, startPosition, endPosition) {
        this._myObject = object;
        this._myStartPosition = startPosition;
        this._myEndPosition = endPosition;

        this._myCurrentPosition = startPosition.slice(0);

        this._myIsActive = false;
        this._myObject.pp_setActive(this._myIsActive);

        this._myScale = 0;
        this._myObject.pp_setScale(this._myScale);

        this._myTimer = new PP.Timer(1);

        this._myAudio = Global.myAudioManager.createAudioPlayer(SfxID.HAND_PIECE_APPEAR);
        this._myAudio.setPitch(Math.pp_random(0.7, 1));
    }

    start() {
        this._myIsActive = true;
        this._myObject.pp_setActive(this._myIsActive);

        this._myAudio.play();
    }

    update(dt, interpolateValue) {
        if (this._myIsActive) {
            if (this._myTimer.isRunning()) {
                this._myTimer.update(dt);

                this._myScale = PP.EasingFunction.easeInOut(this._myTimer.getPercentage());
                this._myObject.pp_setScale(this._myScale);

                this._myAudio.updatePosition(this._myObject.pp_getPosition());
            }

            glMatrix.vec3.lerp(this._myCurrentPosition, this._myEndPosition, this._myStartPosition, interpolateValue);
            this._myObject.pp_setPositionLocal(this._myCurrentPosition);
        }
    }

    isDone() {
        return this._myScale == 1;
    }

    skip() {
        this._myIsActive = true;
        this._myObject.pp_setActive(this._myIsActive);

        this._myTimer.reset();

        this._myAudio.stop();

        this._myScale = 1;
        this._myObject.pp_setScale(this._myScale);
    }
}
WL.registerComponent("light-fade-in", {
}, {
    init: function () {
    },
    start: function () {
        this._myLight = this.object.pp_getComponent("light");
        this._myLightColor = this._myLight.color.pp_clone();

        this._myLight.color[0] = 0;
        this._myLight.color[1] = 0;
        this._myLight.color[2] = 0;

        this._myFadeTimer = new PP.Timer(Global.myLightFadeInTime);
        this._myFadeOutTimer = new PP.Timer(Global.myLightFadeInTime);

        this._myLastFadeOut = false;
    },
    update(dt) {
        if (!Global.myStartFadeOut && this._myFadeTimer.isRunning()) {
            this._myFadeTimer.update(dt);

            this._myLight.color[0] = this._myLightColor[0] * PP.EasingFunction.easeOut(this._myFadeTimer.getPercentage());
            this._myLight.color[1] = this._myLightColor[1] * PP.EasingFunction.easeOut(this._myFadeTimer.getPercentage());
            this._myLight.color[2] = this._myLightColor[2] * PP.EasingFunction.easeOut(this._myFadeTimer.getPercentage());
        }

        if (!this._myLastFadeOut && Global.myStartFadeOut) {
            this._myFadeOutTimer.start(Global.myLightFadeInTime);
        }
        this._myLastFadeOut = Global.myStartFadeOut;

        if (Global.myStartFadeOut) {
            if (this._myFadeOutTimer.isRunning()) {
                this._myFadeOutTimer.update(dt);

                this._myLight.color[0] = this._myLightColor[0] * (1 - PP.EasingFunction.easeIn(this._myFadeOutTimer.getPercentage()));
                this._myLight.color[1] = this._myLightColor[1] * (1 - PP.EasingFunction.easeIn(this._myFadeOutTimer.getPercentage()));
                this._myLight.color[2] = this._myLightColor[2] * (1 - PP.EasingFunction.easeIn(this._myFadeOutTimer.getPercentage()));
            }
        }

    },
    onActivate: function () {
        this._myFadeTimer.start(Global.myLightFadeInTime);
    },
    onDeactivate: function () {
        this._myLight.color[0] = 0;
        this._myLight.color[1] = 0;
        this._myLight.color[2] = 0;
    },
});
WL.registerComponent("material-container", {
    _myTitle: { type: WL.Type.Material },
    _mySubtitle: { type: WL.Type.Material },
    _myText: { type: WL.Type.Material },
    _myBigText: { type: WL.Type.Material },
    _myTitlePatch: { type: WL.Type.Object },
    _myBigBlatherPatch: { type: WL.Type.Object },
}, {
    init: function () {
        Global.myMaterials = {};
        Global.myMaterials.myTitle = this._myTitle.clone();
        Global.myMaterials.mySubtitle = this._mySubtitle.clone();
        Global.myMaterials.myText = this._myText.clone();
        Global.myMaterials.myBigText = this._myBigText.clone();

        Global.myTitlePatchObject = this._myTitlePatch;
        Global.myBigBlatherPatchObject = this._myBigBlatherPatch;
        Global.myBigBlatherPatchObject.pp_setActive(false);
    },
    start: function () {
    },
    update: function (dt) {
    }
});
WL.registerComponent('menu-objects', {
    _myCoin: { type: WL.Type.Object },
    _myNotCoin: { type: WL.Type.Object },
    _myArcadeStickDispute: { type: WL.Type.Object },
    _myArcadeStickChat: { type: WL.Type.Object },
    _myArcadLeaderboardeDispute: { type: WL.Type.Object },
    _myArcadLeaderboardeChat: { type: WL.Type.Object },
    _myWondermelon: { type: WL.Type.Object },
    _myZestyMarket: { type: WL.Type.Object },
    _myFloppyDisk: { type: WL.Type.Object }
}, {
    init: function () {
        Global.myGameObjects.set(GameObjectType.COIN, this._myCoin);
        Global.myGameObjects.set(GameObjectType.NOT_COIN, this._myNotCoin);
        Global.myGameObjects.set(GameObjectType.ARCADE_STICK_DISPUTE, this._myArcadeStickDispute);
        Global.myGameObjects.set(GameObjectType.ARCADE_STICK_CHAT, this._myArcadeStickChat);
        Global.myGameObjects.set(GameObjectType.ARCADE_LEADERBOARD_DISPUTE, this._myArcadLeaderboardeDispute);
        Global.myGameObjects.set(GameObjectType.ARCADE_LEADERBOARD_CHAT, this._myArcadLeaderboardeChat);
        Global.myGameObjects.set(GameObjectType.WONDERMELON, this._myWondermelon);
        Global.myGameObjects.set(GameObjectType.ZESTY_MARKET, this._myZestyMarket);
        Global.myGameObjects.set(GameObjectType.FLOPPY_DISK, this._myFloppyDisk);

        let cloneParams = new PP.CloneParams();
        cloneParams.myComponentsToInclude.push("mesh");
        Global.myMeshObjects.set(GameObjectType.ARCADE_STICK_DISPUTE, this._myArcadeStickDispute.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.ARCADE_STICK_CHAT, this._myArcadeStickChat.pp_clone(cloneParams));

        cloneParams.myComponentsToInclude.push("text");
        cloneParams.myComponentsToInclude.push("text-color-fog");
        Global.myMeshObjects.set(GameObjectType.COIN, this._myCoin.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.NOT_COIN, this._myNotCoin.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.ARCADE_LEADERBOARD_DISPUTE, this._myArcadLeaderboardeDispute.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.ARCADE_LEADERBOARD_CHAT, this._myArcadLeaderboardeChat.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.WONDERMELON, this._myWondermelon.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.ZESTY_MARKET, this._myZestyMarket.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.FLOPPY_DISK, this._myFloppyDisk.pp_clone(cloneParams));
    },
    start: function () {
    },
    update: function (dt) {
    },
});


WL.registerComponent('mr_NOT_object', {
    _myMrNOT: { type: WL.Type.Object },
    _myMrNOTClone: { type: WL.Type.Object },
}, {
    init: function () {
        Global.myGameObjects.set(GameObjectType.MR_NOT, this._myMrNOT);
        Global.myGameObjects.set(GameObjectType.MR_NOT_CLONE, this._myMrNOTClone);

        let cloneParams = new PP.CloneParams();
        cloneParams.myComponentsToInclude.push("mesh");
        Global.myMeshObjects.set(GameObjectType.MR_NOT, this._myMrNOT.pp_clone(cloneParams));
        Global.myMeshObjects.set(GameObjectType.MR_NOT_CLONE, this._myMrNOTClone.pp_clone(cloneParams));
    },
    start: function () {
    },
    update: function (dt) {
    },
});


WL.registerComponent("mr_not_mirror", {
}, {
    init: function () {
    },
    start: function () {
    },
    update: function (dt) {
        let difference = this.object.pp_getPosition().vec3_sub(Global.myPlayerPosition);
        let diffLength = difference.vec3_length();

        let distanceFactor = Math.pp_mapToRange(diffLength, 0.1, 0.5, 0.9, 0);

        let forward = this.object.pp_getUp();
        let playerForward = Global.myPlayerForward;
        if (!forward.vec3_isConcordant(playerForward)) {
            playerForward = playerForward.vec3_negate();
        }

        let angle = Math.pp_toDegrees(forward.vec3_angleRadians(playerForward));

        let angleFactor = Math.pp_mapToRange(angle, 10, 45, 0.9, 0);

        let alpha = Math.pp_clamp(angleFactor * distanceFactor, 0, 0.6);

        PP.MeshUtils.setAlpha(this.object, alpha);
    }
});
class NotEnough {
    constructor(audioPosition = null) {
        this._myTimer = new PP.Timer(1, false);
        this._myExtraTimer = new PP.Timer(2, false);
        this._myNotEnoughAudio = Global.myAudioManager.createAudioPlayer(SfxID.NOT_ENOUGH);
        this._myAudioPosition = audioPosition;
    }

    start() {
        this._myTimer.start();

        if (this._myAudioPosition && false) {
            this._myNotEnoughAudio.setPosition(this._myAudioPosition);
        } else {
            this._updateAudioPosition();
        }

        this._myNotEnoughAudio.play();

        this._myLeftTimer = new PP.Timer(0);
        this._myRightTimer = new PP.Timer(0);

        this._myLastLeftIntensity = 0.4;
        this._myLastRightIntensity = 0.4;

        if (Math.pp_random() < 0.5) {
            this._myLastRightIntensity = 0.7;
        } else {
            this._myLastLeftIntensity = 0.7;
        }
    }

    stop() {
        this._myTimer.reset();
        Global.myPlayerRumbleObject.pp_resetPositionLocal();
        Global.myTitlesRumbleObject.pp_resetPositionLocal();
        this._myExtraTimer.start();
    }

    update(dt) {
        if (this._myTimer.isRunning()) {
            this._myTimer.update(dt);

            this._updateAudioPosition();

            let rumbleValue = 0.04;
            Global.myPlayerRumbleObject.pp_setPositionLocal([Math.pp_random(-rumbleValue, rumbleValue), Math.pp_random(-rumbleValue, rumbleValue), Math.pp_random(-rumbleValue, rumbleValue)]);
            rumbleValue = 8;
            Global.myTitlesRumbleObject.pp_setPositionLocal([Math.pp_random(-rumbleValue, rumbleValue), Math.pp_random(-rumbleValue, rumbleValue), Math.pp_random(-rumbleValue, rumbleValue)]);

            this._myLeftTimer.update(dt);
            if (this._myLeftTimer.isDone()) {
                this._myLeftTimer.start(Math.pp_random(0.25, 0.4));

                let intensity = Math.pp_random(0.3, 0.5);
                if (this._myLastLeftIntensity < 0.55) {
                    intensity = Math.pp_random(0.65, 0.8);
                }
                this._myLastLeftIntensity = intensity;

                PP.myLeftGamepad.pulse(intensity, this._myLeftTimer.getDuration() + 0.05);
            }

            this._myRightTimer.update(dt);
            if (this._myRightTimer.isDone()) {
                this._myRightTimer.start(Math.pp_random(0.25, 0.4));

                let intensity = Math.pp_random(0.3, 0.5);
                if (this._myLastRightIntensity < 0.55) {
                    intensity = Math.pp_random(0.65, 0.8);
                }
                this._myLastRightIntensity = intensity;

                PP.myRightGamepad.pulse(intensity, this._myRightTimer.getDuration() + 0.05);
            }

            if (this._myTimer.isDone()) {
                this.stop();

                PP.myLeftGamepad.pulse(this._myLastLeftIntensity, Math.pp_random(0.25, 0.35));
                PP.myRightGamepad.pulse(this._myLastRightIntensity, Math.pp_random(0.25, 0.35));
            }

        }

        if (this._myExtraTimer.isRunning()) {
            this._myExtraTimer.update(dt);
            this._updateAudioPosition();
        }
    }

    _updateAudioPosition() {
        let position = Global.myPlayerPosition.vec3_clone();
        position.vec3_add(Global.myPlayerUp.vec3_scale(0.15), position);
        position.vec3_add(Global.myPlayerForward.vec3_scale(0.5), position);
        this._myNotEnoughAudio.updatePosition(position);
    }

    isNotEnoughing() {
        return this._myTimer.isRunning();
    }
}
WL.registerComponent("palette-visualizer", {
    _myPaletteObject: { type: WL.Type.Object },
    _myPaletteObjectScaleFactor: { type: WL.Type.Float, default: 1 },
    _myOffsetX: { type: WL.Type.Float, default: 0.05 },
    _myOffsetY: { type: WL.Type.Float, default: 0.05 },
    _myCloneMaterial: { type: WL.Type.Bool, default: false },
    _my1: { type: WL.Type.Material },
    _my2: { type: WL.Type.Material },
    _my3: { type: WL.Type.Material },
    _my4: { type: WL.Type.Material },
    _my5: { type: WL.Type.Material },
    _my6: { type: WL.Type.Material },
    _my7: { type: WL.Type.Material },
    _my8: { type: WL.Type.Material },
    _my9: { type: WL.Type.Material },
    _my10: { type: WL.Type.Material },
    _my11: { type: WL.Type.Material },
    _my12: { type: WL.Type.Material },
    _my13: { type: WL.Type.Material },
    _my14: { type: WL.Type.Material },
    _my15: { type: WL.Type.Material },
    _my16: { type: WL.Type.Material }
}, {
    init: function () {
        this._myMeshes = [];

        this._myMaterials = [];
        for (let i = 1; i < 17; i++) {
            let material = "_my".concat(i);
            if (this._myCloneMaterial) {
                this._myMaterials.push(this[material].clone());
            } else {
                this._myMaterials.push(this[material]);
            }
        }

        this._myColumns = Math.ceil(Math.sqrt(this._myMaterials.length));
        this._myRows = Math.ceil(this._myMaterials.length / this._myColumns);
    },
    start: function () {
        let cloneParams = new PP.CloneParams();
        cloneParams.myComponentsToInclude.push("mesh");

        let positions = this._createPositions();
        for (let i = 0; i < this._myMaterials.length; i++) {
            let newObject = this._myPaletteObject.pp_clone(cloneParams);

            newObject.pp_setParent(this.object);
            newObject.pp_setPositionLocal(positions[i]);
            newObject.pp_scaleObject(this._myPaletteObjectScaleFactor);
            newObject.pp_resetRotationLocal();
            newObject.pp_setActive(true);

            PP.MeshUtils.setMaterial(newObject, this._myMaterials[i], false);
        }
    },
    update: function (dt) {
    },
    _createPositions() {
        let positions = [];
        let startingRowPosition = vec3_create();
        let startingColumnPosition = vec3_create();

        let halfColumn = Math.floor(this._myColumns / 2);
        startingColumnPosition[0] = -(this._myOffsetX * halfColumn);
        if (this._myColumns % 2 == 0) {
            startingColumnPosition[0] += this._myOffsetX / 2;
        }

        let halfRow = Math.floor(this._myRows / 2);
        startingRowPosition[1] = +(this._myOffsetX * halfRow);
        if (this._myRows % 2 == 0) {
            startingRowPosition[1] -= this._myOffsetX / 2;
        }

        for (let i = 0; i < this._myRows; i++) {
            let rowPosition = startingRowPosition.pp_clone();
            rowPosition[1] -= this._myOffsetY * i;
            for (let j = 0; j < this._myColumns; j++) {
                let position = rowPosition.pp_clone();
                position.vec3_add(startingColumnPosition, position);
                position[0] += this._myOffsetX * j;

                positions.push(position);
            }
        }

        return positions;
    }
});
class ParticlesManager {
    constructor() {
        this._myParticlesList = [];
    }

    update(dt) {
        for (let particles of this._myParticlesList) {
            particles.update(dt);
        }

        this._myParticlesList.pp_removeAll(element => element.isDone());
    }

    explosion(position, radius, objectScale, objectType, noFog = false) {
        let explosionParticles = new ExplosionParticles(position, radius, objectScale, objectType, noFog);
        this._myParticlesList.push(explosionParticles);
    }

    fireworks(position, radius, objectScale) {
        let explosionParticles = new FireworkParticles(position, radius, objectScale);
        this._myParticlesList.push(explosionParticles);
    }

    mrNOTParticles(position) {
        let explosionParticles = new MrNOTParticles(position, 3, [1, 1, 1].vec3_scale(PP.myEasyTuneVariables.get("mr NOT Clone Scale")));
        this._myParticlesList.push(explosionParticles);
    }
}

class ExplosionParticles {
    constructor(position, radius, objectScale, objectType, noFog) {
        this._myPosition = position.slice(0);
        this._myScale = objectScale[0];
        this._myRadius = radius;
        this._myObjectType = objectType;
        this._myNoFog = noFog;

        this._myTimer = new PP.Timer(PP.myEasyTuneVariables.get("Explosion Particles Duration"));
        this._mySpawnTimer = new PP.Timer(0);
        this._myParticles = [];

        this._myLastScale = 1;
    }

    update(dt) {
        if (this._myTimer.isRunning()) {
            this._myTimer.update(dt);

            this._mySpawnTimer.update(dt);
            if (this._mySpawnTimer.isDone()) {
                for (let i = 0; i < PP.myEasyTuneVariables.get("Explosion Particles Amount"); i++) {
                    this._myParticles.push(this._createParticle());
                }
                this._mySpawnTimer.start(PP.myEasyTuneVariables.get("Explosion Particles Delay"));
            }
        }

        for (let particle of this._myParticles) {
            particle.update(dt);
        }

        this._myParticles.pp_removeAll(element => element.isDone());

    }

    isDone() {
        return this._myTimer.isDone() && this._myParticles.length == 0;
    }

    _createParticle() {
        let direction = [0, 0, 1];
        direction = direction.vec3_rotate([Math.pp_random(-180, 180), Math.pp_random(-180, 180), Math.pp_random(-180, 180)]);

        let radius = Math.pp_random(this._myRadius * 0.75, this._myRadius * 1.25);
        let position = direction.vec3_scale(radius).vec3_add(this._myPosition);

        let minScale = 0.1;
        let maxScale = 0.25;
        let half = (maxScale + minScale) / 2;

        let scale = half;

        if (this._myLastScale >= 0) {
            let ottave = (maxScale - minScale) / 8;
            if (this._myLastScale > half) {
                scale = Math.pp_random(this._myScale * minScale, this._myScale * (half + ottave));
            } else {
                scale = Math.pp_random(this._myScale * (half - ottave), this._myScale * maxScale);
            }
        }

        this._myLastScale = scale;

        return new ExplosionParticle(position, scale, this._myObjectType, this._myNoFog);
    }
}

class FireworkParticles {
    constructor(position, radius, objectScale) {
        this._myPosition = position.slice(0);
        this._myScale = objectScale[0];
        this._myRadius = radius;

        this._myTimer = new PP.Timer(5);
        this._mySpawnTimer = new PP.Timer(0);
        this._myParticles = [];
    }

    update(dt) {
        if (this._myTimer.isRunning()) {
            this._myTimer.update(dt);

            this._mySpawnTimer.update(dt);
            if (this._mySpawnTimer.isDone()) {
                for (let i = 0; i < 5; i++) {
                    this._myParticles.push(this._createParticle());
                }
                this._mySpawnTimer.start(PP.myEasyTuneVariables.get("Explosion Particles Delay"));
            }
        }

        for (let particle of this._myParticles) {
            particle.update(dt);
        }

        this._myParticles.pp_removeAll(element => element.isDone());

    }

    isDone() {
        return this._myTimer.isDone() && this._myParticles.length == 0;
    }

    _createParticle() {
        let direction = [0, 0, 1];
        direction = direction.vec3_rotate([Math.pp_random(-180, 180), Math.pp_random(-180, 180), Math.pp_random(-180, 180)]);

        let radius = Math.pp_random(this._myRadius * 0.2, this._myRadius);
        let position = direction.vec3_scale(radius).vec3_add(this._myPosition);
        let scale = Math.pp_random(this._myScale * 0.1, this._myScale * 0.25);

        let random = 0;
        while (random == 0) {
            random = Math.pp_randomInt(1, 39);
            if (random == 18 || random == 19 || random == 18) {
                random = 0;
            }
        }

        return new ExplosionParticle(position, scale, random, true);
    }
}

class MrNOTParticles {
    constructor(position, radius, objectScale) {
        this._myPosition = position.slice(0);
        this._myScale = objectScale[0];
        this._myRadius = radius;

        this._myTimer = new PP.Timer(1);
        this._mySpawnTimer = new PP.Timer(0);
        this._myParticles = [];

        this._myIsInFrontOfPlayer = 0;
        this._myInFrontOfPlayerCreated = false;
    }

    update(dt) {
        if (this._myTimer.isRunning()) {
            this._myTimer.update(dt);

            this._mySpawnTimer.update(dt);
            if (this._mySpawnTimer.isDone()) {
                let numberOfParticles = 3;
                for (let i = 0; i < numberOfParticles; i++) {
                    this._myParticles.push(this._createParticle(i == numberOfParticles - 1));
                }
                this._mySpawnTimer.start(PP.myEasyTuneVariables.get("Explosion Particles Delay"));

                this._myIsInFrontOfPlayer = (this._myIsInFrontOfPlayer + 1) % 2;
                this._myInFrontOfPlayerCreated = false;
            }
        }

        for (let particle of this._myParticles) {
            particle.update(dt);
        }

        this._myParticles.pp_removeAll(element => element.isDone());

    }

    isDone() {
        return this._myTimer.isDone() && this._myParticles.length == 0;
    }

    _createParticle(isLast) {
        let direction = [0, 0, 1];
        direction = direction.vec3_rotate([Math.pp_random(-180, 180), Math.pp_random(-180, 180), Math.pp_random(-180, 180)]);

        let radius = Math.pp_random(this._myRadius * 0.75, this._myRadius);
        let position = direction.vec3_scale(radius).vec3_add(this._myPosition);
        position.vec3_add([0, -0.6, 0], position);
        let scale = Math.pp_random(this._myScale * 1.5, this._myScale * (1.5 + 0.15));

        if (!this._myInFrontOfPlayerCreated && this._myIsInFrontOfPlayer == 0) {
            let checkFrontVector = position.vec3_sub(Global.myPlayerPosition);
            let angle = checkFrontVector.vec3_angle(Global.myPlayerForward);

            if (angle < 25) {
                this._myInFrontOfPlayerCreated = true;
            } else if (isLast) {
                let attempts = 100;
                while (attempts > 0 && angle >= 25) {
                    attempts--;
                    direction.vec3_set(0, 0, 1);
                    direction.vec3_rotate([Math.pp_random(-180, 180), Math.pp_random(-180, 180), Math.pp_random(-180, 180)], direction);
                    direction.vec3_scale(radius, position).vec3_add(this._myPosition, position);
                    position.vec3_add([0, -0.6, 0], position);

                    position.vec3_sub(Global.myPlayerPosition, checkFrontVector);
                    angle = checkFrontVector.vec3_angle(Global.myPlayerForward);
                }
            }
        }

        return new MrNOTParticle(position, scale, GameObjectType.MR_NOT, true);
    }
}

class ExplosionParticle {
    constructor(position, scale, objectType, noFog) {
        this._myNoFog = noFog;
        this._myObjectType = objectType;
        if (this._myNoFog) {
            this._myObject = Global.myMeshNoFogObjectPoolMap.getObject(objectType);
        } else {
            this._myObject = Global.myMeshObjectPoolMap.getObject(objectType);
        }
        this._myObject.pp_setPosition(position);
        this._myObject.pp_setScale(scale);
        this._myScale = this._myObject.pp_getScale();
        this._myObject.pp_setRotation([Math.pp_random(-180, 180), Math.pp_random(-180, 180), Math.pp_random(-180, 180)]);
        this._myObject.pp_setActive(true);

        this._myTimer = new PP.Timer(PP.myEasyTuneVariables.get("Explosion Particle Life"));
    }

    update(dt) {
        if (this._myTimer.isRunning()) {
            this._myTimer.update(dt);

            let scaleMultiplier = Math.pp_interpolate(1, PP.myEasyTuneVariables.get("Unspawn Menu Scale"), this._myTimer.getPercentage());
            this._myObject.pp_setScale(this._myScale.vec3_scale(scaleMultiplier));

            if (this._myTimer.isDone()) {
                if (this._myNoFog) {
                    Global.myMeshNoFogObjectPoolMap.releaseObject(this._myObjectType, this._myObject);
                } else {
                    Global.myMeshObjectPoolMap.releaseObject(this._myObjectType, this._myObject);
                }
                this._myObject = null;
            }
        }
    }

    isDone() {
        return this._myTimer.isDone();
    }
}

class MrNOTParticle {
    constructor(position, scale, objectType, noFog) {
        this._myNoFog = noFog;
        this._myObjectType = objectType;
        if (this._myNoFog) {
            this._myObject = Global.myMeshNoFogObjectPoolMap.getObject(objectType);
        } else {
            this._myObject = Global.myMeshObjectPoolMap.getObject(objectType);
        }
        this._myObject.pp_setPosition(position);
        this._myObject.pp_setScale(scale);
        this._myScale = this._myObject.pp_getScale();
        this._myObject.pp_lookAt(Global.myPlayerPosition, [0, 1, 0]);
        this._myObject.pp_setActive(true);

        this._myTimer = new PP.Timer(PP.myEasyTuneVariables.get("Explosion Particle Life"));
    }

    update(dt) {
        if (this._myTimer.isRunning()) {
            this._myTimer.update(dt);

            let scaleMultiplier = Math.pp_interpolate(1, PP.myEasyTuneVariables.get("Unspawn Menu Scale"), this._myTimer.getPercentage());
            this._myObject.pp_setScale(this._myScale.vec3_scale(scaleMultiplier));

            if (this._myTimer.isDone()) {
                if (this._myNoFog) {
                    Global.myMeshNoFogObjectPoolMap.releaseObject(this._myObjectType, this._myObject);
                } else {
                    Global.myMeshObjectPoolMap.releaseObject(this._myObjectType, this._myObject);
                }
                this._myObject = null;
            }
        }
    }

    isDone() {
        return this._myTimer.isDone();
    }
}
WL.registerComponent('physx-collector-component', {
}, {
    init: function () {
    },
    start: function () {
        this._myCollisionsCollector = null;
        this._myPhysx = this.object.pp_getComponent("physx");
        if (this._myPhysx) {
            this._myCollisionsCollector = new PP.PhysXCollisionCollector(this._myPhysx);
        }
    },
    getCollisionsCollector() {
        return this._myCollisionsCollector;
    },
    onActivate() {
        if (this._myCollisionsCollector) {
            this._myCollisionsCollector.setActive(true);
        }
    },
    onDeactivate() {
        if (this._myCollisionsCollector) {
            this._myCollisionsCollector.setActive(false);
        }
    },
    pp_clone(clone) {
        if (clone._myCollisionsCollector == null) {
            clone._myPhysx = clone.object.pp_getComponent("physx");
            if (clone._myPhysx) {
                clone._myCollisionsCollector = new PP.PhysXCollisionCollector(clone._myPhysx);
            }
        }
    }
});
WL.registerComponent("pulse-on-grab", {
    _myHandedness: { type: WL.Type.Enum, values: ['left', 'right'], default: 'left' },
}, {
    init: function () {
    },
    start: function () {
        if (this._myHandedness == 0) {
            this._myGamepad = PP.myLeftGamepad;
        } else {
            this._myGamepad = PP.myRightGamepad;
        }

        let grab = this.object.pp_getComponent("pp-grabber-hand");
        grab.registerGrabEventListener(this, this._onGrab.bind(this));
        grab.registerThrowEventListener(this, this._onThrow.bind(this));

        this._myGrabAudio = Global.myAudioManager.createAudioPlayer(SfxID.GRAB);
        this._myThrowAudio = Global.myAudioManager.createAudioPlayer(SfxID.THROW);

        this._myGrabPitch = this._myGrabAudio.getPitch();
        this._myThrowPitch = this._myThrowAudio.getPitch();
    },
    _onGrab() {
        let intensity = 0.2;
        let pulseInfo = this._myGamepad.getPulseInfo();
        if (pulseInfo.myIntensity <= intensity) {
            this._myGamepad.pulse(intensity, 0.1);
        }

        this._myGrabAudio.setPosition(this.object.pp_getPosition());
        this._myGrabAudio.setPitch(Math.pp_random(this._myGrabPitch - 0.15, this._myGrabPitch + 0.05));
        this._myGrabAudio.play();
    },
    _onThrow() {
        let intensity = 0.09;
        let pulseInfo = this._myGamepad.getPulseInfo();
        if (pulseInfo.myIntensity <= intensity) {
            this._myGamepad.pulse(intensity, 0.1);
        }

        this._myThrowAudio.setPosition(this.object.pp_getPosition());
        this._myThrowAudio.setPitch(Math.pp_random(this._myThrowPitch - 0.15, this._myThrowPitch + 0.05));
        this._myThrowAudio.play();
    },
});
WL.registerComponent("random-material", {
    _my1: { type: WL.Type.Material },
    _my2: { type: WL.Type.Material },
    _my3: { type: WL.Type.Material },
    _my4: { type: WL.Type.Material },
    _my5: { type: WL.Type.Material },
    _my6: { type: WL.Type.Material },
    _my7: { type: WL.Type.Material },
    _my8: { type: WL.Type.Material },
    _my9: { type: WL.Type.Material },
    _my10: { type: WL.Type.Material },
    _my11: { type: WL.Type.Material },
    _my12: { type: WL.Type.Material },
    _my13: { type: WL.Type.Material },
    _my14: { type: WL.Type.Material },
    _my15: { type: WL.Type.Material },
    _my16: { type: WL.Type.Material }
}, {
    init: function () {
    },
    start: function () {
        this._myMaterials = [];
        for (let i = 1; i < 17; i++) {
            let material = "_my".concat(i);
            this._myMaterials.push(this[material].clone());
        }
    },
    update: function (dt) {
    },
    onActivate: function () {
        if (Global.myUpdateReady) {
            this._randomMaterial();
        }
    },
    _randomMaterial: function () {
        let meshes = this.object.pp_getComponentsHierarchy("mesh");

        for (let mesh of meshes) {
            let randomMaterial = Math.pp_randomPick(this._myMaterials);
            mesh.material.ambientColor = randomMaterial.ambientColor;
            mesh.material.diffuseColor = randomMaterial.diffuseColor;
        }
    }
});
WL.registerComponent("ring-animator", {
    _myRingHeight: { type: WL.Type.Float, default: 1.0 },
    _myRingOut: { type: WL.Type.Object },
    _myRingMiddle: { type: WL.Type.Object }
}, {
    init: function () {
        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true);
        this._myFSM.addState("move up", this.moveUp.bind(this));
        this._myFSM.addState("done");

        this._myFSM.addTransition("move up", "done", "end");

        Global.myRingHeight = this._myRingHeight;
        Global.myRingRadius = 0.64;
    },
    start: function () {
        this._myRingOut.pp_setPosition([0, -1, 0]);
        this._myRingMiddle.pp_setPosition([0, -1, 0]);

        this._myRingOutAudio = Global.myAudioManager.createAudioPlayer(SfxID.RING_RISE);
    },
    update: function (dt) {
        if (!Global.myUpdateReady) {
            this._myRingOut.pp_setActive(false);
            this._myRingMiddle.pp_setActive(false);
        }

        this._myFSM.update(dt);
    },
    begin: function () {
        this._myFSM.init("move up", this.initMoveUp.bind(this));
    },
    initMoveUp: function () {
        this._myRingOut.pp_setActive(true);
        this._myRingMiddle.pp_setActive(true);

        PP.MeshUtils.setAlpha(this._myRingOut, 0);
        PP.MeshUtils.setAlpha(this._myRingMiddle, 0);

        this._myRingOut.pp_setPosition([0, -this._myRingOut.pp_getScale()[1] - 0.001, 0]);
        this._myRingMiddle.pp_setPosition([0, -this._myRingMiddle.pp_getScale()[1] - 0.001, 0]);

        this._myTimer = new PP.Timer(5.3);
        this._myAudioTimer = new PP.Timer(0.25);
    },
    moveUp: function (dt, fsm) {
        this._myTimer.update(dt);
        this._myAudioTimer.update(dt);
        if (this._myAudioTimer.isDone()) {
            this._myAudioTimer.reset();

            this._myRingOutAudio.play();
        }

        let alphaInterpolationValue = Math.pp_mapToRange(this._myTimer.getPercentage(), 0, 0.5, 0, 1);
        let easing = -(Math.cos(Math.PI * alphaInterpolationValue) - 1) / 2;
        let alphaValue = easing;
        PP.MeshUtils.setAlpha(this._myRingOut, alphaValue);
        PP.MeshUtils.setAlpha(this._myRingMiddle, alphaValue);

        let startPositionRingOut = -0.2;
        let startPositionRingMiddle = -0.6;

        this._myRingOut.pp_setPosition([0, Math.pp_interpolate(startPositionRingOut, this._myRingHeight, this._myTimer.getPercentage(), PP.EasingFunction.easeOut), 0]);
        this._myRingMiddle.pp_setPosition([0, Math.pp_interpolate(startPositionRingMiddle, this._myRingHeight, this._myTimer.getPercentage(), PP.EasingFunction.easeOut), 0]);

        this._myRingOutAudio.updatePosition(this._myRingOut.pp_getPosition());

        if (this._myTimer.isDone()) {
            this._myTimer.reset();

            this._myRingOut.pp_setPosition([0, this._myRingHeight, 0]);
            this._myRingMiddle.pp_setPosition([0, this._myRingHeight, 0]);

            PP.MeshUtils.setAlpha(this._myRingOut, 1);
            PP.MeshUtils.setAlpha(this._myRingMiddle, 1);

            fsm.perform("end");
        }
    },
    isDone: function () {
        return this._myFSM.isInState("done");
    },
    skip: function () {
        this._myRingOut.pp_setActive(true);
        this._myRingMiddle.pp_setActive(true);

        this._myRingOut.pp_setPosition([0, this._myRingHeight, 0]);
        this._myRingMiddle.pp_setPosition([0, this._myRingHeight, 0]);

        PP.MeshUtils.setAlpha(this._myRingOut, 1);
        PP.MeshUtils.setAlpha(this._myRingMiddle, 1);

        this._myRingOutAudio.stop();

        this._myFSM.perform("end");
    }
});
WL.registerComponent("ring-sfx-on-collision", {
}, {
    init: function () {
    },
    start: function () {
        this._myPhysx = this.object.pp_getComponent("physx");
        //this._myPhysx.onCollision(this._onCollision.bind(this));
        this._myPhysxToIgnore = [];

        this._myCollisionAudio = Global.myAudioManager.createAudioPlayer(SfxID.COLLISION);
        this._myCollisionPitch = this._myCollisionAudio.getPitch();
    },
    update: function (dt) {
        if (this._myPhysx.active) {
            this._myPhysx.active = false;
        }

        if (this._myPhysxToIgnore.length > 0) {
            for (let element of this._myPhysxToIgnore) {
                element[1].update(dt);
            }
            this._myPhysxToIgnore.pp_removeAll(element => element[1].isDone());
        }
    },
    _onCollision(type, physx) {
        if (type == WL.CollisionEventType.Touch) {
            let evidence = physx.object.pp_getComponent("evidence-component");
            let timeActive = 1.5;
            //timeActive = 0;
            if (evidence != null && evidence.getTimeActive() >= timeActive) {
                if (!this._myPhysxToIgnore.pp_has(element => element[0].pp_equals(physx.object))) {
                    this._myCollisionAudio.setPosition(physx.object.pp_getPosition());
                    this._myCollisionAudio.setPitch(Math.pp_random(this._myCollisionPitch - 0.15, this._myCollisionPitch + 0.05));
                    this._myCollisionAudio.play();
                }
            }
        } else if (type == WL.CollisionEventType.TouchLost) {
            if (physx.object.pp_getComponent("evidence-component") != null) {
                this._myPhysxToIgnore.push([physx.object, new PP.Timer(0.1)]);
            }
        }
    }
});
WL.registerComponent("set-fog-color", {
    _myAlpha: { type: WL.Type.Float, default: 0 }
}, {
    init: function () {
    },
    start: function () {
        PP.MeshUtils.setClonedMaterials(this.object);
        PP.MeshUtils.setFogColor(this.object, [0, 0, 0, this._myAlpha]);
    },
    update: function (dt) {
    }
});
WL.registerComponent("set-specular-color", {
    _myBrightness: { type: WL.Type.Int, default: 0 }
}, {
    init: function () {
    },
    start: function () {
        PP.MeshUtils.setClonedMaterials(this.object);
        PP.MeshUtils.setSpecularColor(this.object, PP.ColorUtils.hsvToRgb([0, 0, this._myBrightness / 255, 1]));
    },
    update: function (dt) {
    }
});
class StatisticsManager {
    constructor() {

    }

    start() {
        Global.myStatistics = new Statistics();
        Global.myStatistics.load();

        if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
        }
        WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));

        WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));

        this._mySaveTimer = new PP.Timer(20);
        this._myCommitOnEndTimer = new PP.Timer(0);

        Global.mySaveManager.registerClearEventListener(this, this._onClear.bind(this));
    }

    update(dt) {
        this._myCommitOnEndTimer.update(dt);
        this._mySaveTimer.update(dt);
        if (this._mySaveTimer.isDone()) {
            this._mySaveTimer.start();
            Global.myStatistics.save();
        }
    }

    _onXRSessionStart(session) {
        session.addEventListener('visibilitychange', function (event) {
            if (event.session.visibilityState != "visible") {
                this._onXRSessionInterrupt();
            }
        }.bind(this));
    }

    _onXRSessionEnd() {
        this._onXRSessionInterrupt();
    }

    _onXRSessionInterrupt() {
        if (this._myCommitOnEndTimer.isDone()) {
            this._myCommitOnEndTimer.start(20);
            Global.myStatistics.save();
            this._sendAnalytics();
        }
    }

    _onClear() {
        this._myCommitOnEndTimer.start(20);
        this._sendAnalytics();
        Global.myStatistics.load();
    }

    _sendAnalytics() {
        if (Global.myGoogleAnalytics) {
            gtag("event", "play_time", {
                "value": (Global.myStatistics.myTotalPlayTime - Global.myStatistics.myTotalPlayTimeOnLoad).toFixed(2)
            });

            if ((Global.myStatistics.myEvidencesThrown - Global.myStatistics.myEvidencesThrownOnLoad) > 0) {
                gtag("event", "evidences_thrown", {
                    "value": (Global.myStatistics.myEvidencesThrown - Global.myStatistics.myEvidencesThrownOnLoad)
                });
            }

            if ((Global.myStatistics.myEvidencesMissed - Global.myStatistics.myEvidencesMissedOnLoad) > 0) {
                gtag("event", "evidences_missed", {
                    "value": (Global.myStatistics.myEvidencesMissed - Global.myStatistics.myEvidencesMissedOnLoad)
                });
            }

            if ((Global.myStatistics.myEvidencesPunched - Global.myStatistics.myEvidencesPunchedOnLoad) > 0) {
                gtag("event", "evidences_punched", {
                    "value": (Global.myStatistics.myEvidencesPunched - Global.myStatistics.myEvidencesPunchedOnLoad)
                });
            }

            if ((Global.myStatistics.myMrNOTDismissed - Global.myStatistics.myMrNOTDismissedOnLoad) > 0) {
                gtag("event", "mr_NOT_dismissed", {
                    "value": (Global.myStatistics.myMrNOTDismissed - Global.myStatistics.myMrNOTDismissedOnLoad)
                });
            }

            if ((Global.myStatistics.myMrNOTClonesDismissed - Global.myStatistics.myMrNOTClonesDismissedOnLoad) > 0) {
                gtag("event", "mr_NOT_clones_dismissed", {
                    "value": (Global.myStatistics.myMrNOTClonesDismissed - Global.myStatistics.myMrNOTClonesDismissedOnLoad)
                });
            }
        }

        Global.myStatistics.syncOnLoadVariables();
    }
}

class Statistics {

    constructor() {
        this.myTotalPlayTime = 0;
        this.myTrialPlayTime = 0;
        this.myTrialPlayCount = 0;
        this.myTrialPlayCountResettable = 0;
        this.myTrialCompletedCount = 0;
        this.myTrialBestTime = 0;
        this.myChatPlayTime = 0;
        this.myChatPlayCount = 0;
        this.myChatBestTime = 0;
        this.myDisputePlayTime = 0;
        this.myDisputePlayCount = 0;
        this.myDisputeBestTime = 0;
        this.myEvidencesThrown = 0;
        this.myEvidencesMissed = 0;
        this.myEvidencesPunched = 0;
        this.myMrNOTClonesDismissed = 0;
        this.myMrNOTClonesDismissedResettable = 0;
        this.myMrNOTDismissed = 0;

        this.myTotalPlayTimeOnLoad = 0;
        this.myEvidencesThrownOnLoad = 0;
        this.myEvidencesMissedOnLoad = 0;
        this.myEvidencesPunchedOnLoad = 0;
        this.myMrNOTClonesDismissedOnLoad = 0;
        this.myMrNOTDismissedOnLoad = 0;
    }

    load() {
        this.myTotalPlayTime = Global.mySaveManager.loadNumber("total_play_time", 0);

        this.myTrialPlayTime = Global.mySaveManager.loadNumber("trial_play_time", 0);
        this.myTrialPlayCount = Global.mySaveManager.loadNumber("trial_play_count", 0);
        this.myTrialPlayCountResettable = Global.mySaveManager.loadNumber("trial_play_count_resettable", 0);
        this.myTrialCompletedCount = Global.mySaveManager.loadNumber("trial_completed_count", 0);
        this.myTrialBestTime = Global.mySaveManager.loadNumber("trial_best_time", -1);

        this.myChatPlayTime = Global.mySaveManager.loadNumber("chat_play_time", 0);
        this.myChatPlayCount = Global.mySaveManager.loadNumber("chat_play_count", 0);
        this.myChatBestTime = Global.mySaveManager.loadNumber("chat_best_time", -1);

        this.myDisputePlayTime = Global.mySaveManager.loadNumber("dispute_play_time", 0);
        this.myDisputePlayCount = Global.mySaveManager.loadNumber("dispute_play_count", 0);
        this.myDisputeBestTime = Global.mySaveManager.loadNumber("dispute_best_time", -1);

        this.myEvidencesThrown = Global.mySaveManager.loadNumber("evidences_thrown", 0);
        this.myEvidencesMissed = Global.mySaveManager.loadNumber("evidences_missed", 0);
        this.myEvidencesPunched = Global.mySaveManager.loadNumber("evidences_punched", 0);
        this.myMrNOTClonesDismissed = Global.mySaveManager.loadNumber("mr_NOT_clones_dismissed", 0);
        this.myMrNOTClonesDismissedResettable = Global.mySaveManager.loadNumber("mr_NOT_clones_dismissed_resettable", 0);
        this.myMrNOTDismissed = Global.mySaveManager.loadNumber("mr_NOT_dismissed", 0);

        this.syncOnLoadVariables();
    }

    syncOnLoadVariables() {
        this.myTotalPlayTimeOnLoad = this.myTotalPlayTime;
        this.myEvidencesThrownOnLoad = this.myEvidencesThrown;
        this.myEvidencesMissedOnLoad = this.myEvidencesMissed;
        this.myEvidencesPunchedOnLoad = this.myEvidencesPunched;
        this.myMrNOTClonesDismissedOnLoad = this.myMrNOTClonesDismissed;
        this.myMrNOTDismissedOnLoad = this.myMrNOTDismissed;
    }

    save() {
        if (this.myTotalPlayTime < this.myTrialPlayTime + this.myChatPlayTime + this.myDisputePlayTime) {
            this.myTotalPlayTime = this.myTrialPlayTime + this.myChatPlayTime + this.myDisputePlayTime;
        }

        Global.mySaveManager.save("total_play_time", this.myTotalPlayTime);

        Global.mySaveManager.save("trial_play_time", this.myTrialPlayTime);
        Global.mySaveManager.save("trial_play_count", this.myTrialPlayCount);
        Global.mySaveManager.save("trial_play_count_resettable", this.myTrialPlayCountResettable);
        Global.mySaveManager.save("trial_completed_count", this.myTrialCompletedCount);
        Global.mySaveManager.save("trial_best_time", this.myTrialBestTime);

        Global.mySaveManager.save("chat_play_time", this.myChatPlayTime);
        Global.mySaveManager.save("chat_play_count", this.myChatPlayCount);
        Global.mySaveManager.save("chat_best_time", this.myChatBestTime);

        Global.mySaveManager.save("dispute_play_time", this.myDisputePlayTime);
        Global.mySaveManager.save("dispute_play_count", this.myDisputePlayCount);
        Global.mySaveManager.save("dispute_best_time", this.myDisputeBestTime);

        Global.mySaveManager.save("evidences_thrown", this.myEvidencesThrown);
        Global.mySaveManager.save("evidences_missed", this.myEvidencesMissed);
        Global.mySaveManager.save("evidences_punched", this.myEvidencesPunched);
        Global.mySaveManager.save("mr_NOT_clones_dismissed", this.myMrNOTClonesDismissed);
        Global.mySaveManager.save("mr_NOT_clones_dismissed_resettable", this.myMrNOTClonesDismissedResettable);
        Global.mySaveManager.save("mr_NOT_dismissed", this.myMrNOTDismissed);
    }
}
WL.registerComponent("statistics-text-displayer", {
}, {
    init: function () {
    },
    start: function () {
        this._myText = this.object.pp_getComponent("text");
        this._myTextPosition = this._myText.object.pp_getPosition();
        this._myTempDirection1 = [];
        this._myTempDirection2 = [];

        this._myTimer = new PP.Timer(0.5);

        this._mySendAnalytics = true;
        this._myAnalyticsTimer = new PP.Timer(0);
        this._myUp = [0, 1, 0];
    },
    update: function (dt) {
        this._myAnalyticsTimer.update(dt);

        this._myTimer.update(dt);
        if (this._myTimer.isDone()) {
            this._myTimer.start();
            this._updateStatistics();
        }

        this._checkStatisticsViewed(dt);
    },
    _updateStatistics() {
        let text = "";
        text = text.concat("Total Play Time: ", this._convertTimeToString(Global.myStatistics.myTotalPlayTime), "\n\n");
        text = text.concat("Trial Play Time: ", this._convertTimeToString(Global.myStatistics.myTrialPlayTime), "\n");
        text = text.concat("Trial Best Time: ", this._convertTimeToString(Global.myStatistics.myTrialBestTime), "\n");
        text = text.concat("Trial Played: ", Global.myStatistics.myTrialPlayCount, "\n");
        text = text.concat("Trial Completed: ", Global.myStatistics.myTrialCompletedCount, "\n\n");
        text = text.concat("Chat Play Time: ", this._convertTimeToString(Global.myStatistics.myChatPlayTime), "\n");
        text = text.concat("Chat Best Time: ", this._convertTimeToString(Global.myStatistics.myChatBestTime), "\n");
        text = text.concat("Chat Played: ", Global.myStatistics.myChatPlayCount, "\n\n");
        text = text.concat("Dispute Play Time: ", this._convertTimeToString(Global.myStatistics.myDisputePlayTime), "\n");
        text = text.concat("Dispute Best Time: ", this._convertTimeToString(Global.myStatistics.myDisputeBestTime), "\n");
        text = text.concat("Dispute Played: ", Global.myStatistics.myDisputePlayCount, "\n\n");
        text = text.concat("Evidences Thrown: ", Global.myStatistics.myEvidencesThrown, "\n");
        text = text.concat("Evidences Missed: ", Global.myStatistics.myEvidencesMissed, "\n\n");
        text = text.concat("mr NOT Clones Dismissed: ", Global.myStatistics.myMrNOTClonesDismissed, "\n");
        text = text.concat("mr NOT Dismissed: ", Global.myStatistics.myMrNOTDismissed);

        this._myText.text = text;
    },
    _convertTimeToString(time) {
        if (time < 0) {
            return "-";
        }

        time = Math.floor(time);

        let hours = Math.floor(time / 3600);
        time -= hours * 3600;
        let minutes = Math.floor(time / 60);
        time -= minutes * 60;
        let seconds = Math.floor(time);

        let string = "";
        string = string.concat((hours.toFixed(0).length < 2) ? "0".concat(hours.toFixed(0)) : hours.toFixed(0), ":");
        string = string.concat((minutes.toFixed(0).length < 2) ? "0".concat(minutes.toFixed(0)) : minutes.toFixed(0), ":");
        string = string.concat((seconds.toFixed(0).length < 2) ? "0".concat(seconds.toFixed(0)) : seconds.toFixed(0));

        return string;
    },
    _checkStatisticsViewed() {
        if (this._myAnalyticsTimer.isDone()) {
            if (this._mySendAnalytics) {
                let height = Global.myPlayerPosition[1];
                if (height < 0.9) {
                    let angle = Global.myPlayerForward.vec3_angle(this._myUp);
                    if (Math.abs(angle) < 80 && Math.abs(Global.myPlayerPosition[0]) < 0.7 && Math.abs(Global.myPlayerPosition[2]) < 0.7) {
                        this._myTextPosition.vec3_sub(Global.myPlayerPosition, this._myTempDirection1);
                        this._myTempDirection1.vec3_removeComponentAlongAxis(this._myUp, this._myTempDirection1);
                        Global.myPlayerForward.vec3_removeComponentAlongAxis(this._myUp, this._myTempDirection2);

                        let angleToText = Math.abs(this._myTempDirection1.vec3_angle(this._myTempDirection2));
                        if (angleToText < 70) {
                            if (Global.myGoogleAnalytics) {
                                gtag("event", "statistics_viewed", {
                                    "value": 1
                                });
                            }
                            this._mySendAnalytics = false;
                            this._myAnalyticsTimer.start(20);
                        }
                    }
                }
            } else {
                let height = Global.myPlayerPosition[1];
                if (height > 1.2) {
                    this._mySendAnalytics = true;
                }
            }
        }
    }
});
WL.registerComponent("text-color-fog", {
    _myShadeFactorMaxAngle: { type: WL.Type.Float, default: 0 }
}, {
    init: function () {
        this._myDown = [0, -1, 0];
        this._myTempVec3 = vec3_create();
        this._myTempVec4 = vec4_create();
        this._myFogAlpha = 0.33;
    },
    start: function () {
        this._myFirstUpdate = true;
    },
    update: function (dt) {
        if (this._myFirstUpdate) {
            this._myFirstUpdate = false;
            this._myTextComponents = this.object.pp_getComponentsHierarchy("text");
            this._myColor = this._myTextComponents[0].material.color.pp_clone();
        }

        let distance = Global.myPlayerPosition.vec3_sub(this.object.pp_getPosition(this._myTempVec3), this._myTempVec3).vec3_length();
        let fogFactor = this.fogFactorExp2(distance, this._myFogAlpha * 0.2);

        for (let textComponent of this._myTextComponents) {
            let color = this._computeLightColor(this._myTempVec4.pp_copy(this._myColor), textComponent.object.pp_getForward(this._myTempVec3));

            this._myTempVec4[0] = Math.pp_lerp(color[0], 0, fogFactor);
            this._myTempVec4[1] = Math.pp_lerp(color[1], 0, fogFactor);
            this._myTempVec4[2] = Math.pp_lerp(color[2], 0, fogFactor);
            this._myTempVec4[3] = textComponent.material.color[3];

            textComponent.material.color = this._myTempVec4;
        }
    },
    _computeLightColor(color, forward) {
        let angle = forward.vec3_angle(this._myDown);
        let shadeFactor = 1;

        if (this._myShadeFactorMaxAngle > 0.001 && angle < this._myShadeFactorMaxAngle) {
            shadeFactor = Math.pp_lerp(shadeFactor, 0.2, 1 - angle / this._myShadeFactorMaxAngle);
        }

        color[0] = color[0] * shadeFactor;
        color[1] = color[1] * shadeFactor;
        color[2] = color[2] * shadeFactor;

        return color;
    },
    fogFactorExp2(dist, density) {
        let LOG2 = -1.442695;
        let d = density * dist;
        return 1.0 - Math.pp_clamp(Math.pow(2, d * d * LOG2), 0.0, 1.0);
    },
    pp_clone() {
    }
});
WL.registerComponent("toggle-active", {
    _myObject: { type: WL.Type.Object }
}, {
    init: function () {
    },
    start: function () {
        this._myActive = true;
    },
    update: function (dt) {
        if (PP.myLeftGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).isPressEnd()) {
            this._myObject.pp_setActive(!this._myActive);
            this._myActive = !this._myActive;
        }
    }
});
WL.registerComponent("top-down-view", {
    _myHeight: { type: WL.Type.Float, default: 40.0 }
}, {
    start: function () {
        this.object.pp_lookTo([0, 1, 0]);
        this.object.pp_translate([0, this._myHeight, 0]);
    },
});

PP.ToolHandedness = {
    NONE: null,
    LEFT: "left",
    RIGHT: "right",
};

PP.ToolInputSourceType = {
    NONE: null,
    GAMEPAD: 0,
    HAND: 1
};
class ArcadeState extends PP.State {
    constructor(isDispute) {
        super();

        this._myIsDispute = isDispute;

        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "    Arcade");
        this._myFSM.addState("init");
        this._myFSM.addState("first_wait", new PP.TimerState(0, "end"));
        this._myFSM.addState("vent", new VentState(this._buildVentSetup(), this._buildEvidenceSetupList()));
        this._myFSM.addState("defeat", new ArcadeResultState(isDispute));
        this._myFSM.addState("done");

        this._myFSM.addTransition("init", "first_wait", "start");
        this._myFSM.addTransition("first_wait", "vent", "end");
        this._myFSM.addTransition("vent", "defeat", "lost");
        this._myFSM.addTransition("vent", "defeat", "completed");
        this._myFSM.addTransition("defeat", "done", "end", this._backToMenu.bind(this));
        this._myFSM.addTransition("done", "first_wait", "start");

        this._myFSM.init("init");

        this._myParentFSM = null;
    }

    update(dt, fsm) {
        if (!this._myFSM.isInState("defeat")) {
            Global.myArcadeDuration += dt;
            if (this._myIsDispute) {
                Global.myStatistics.myDisputePlayTime += dt;
            } else {
                Global.myStatistics.myChatPlayTime += dt;
            }
        }

        this._myFSM.update(dt);
    }

    init(fsm) {
    }

    start(fsm, transitionID) {
        this._myParentFSM = fsm;
        this._myFSM.perform("start");
        Global.myArcadeDuration = 0;

        if (this._myIsDispute) {
            if (Global.myGoogleAnalytics) {
                gtag("event", "arcade_dispute_started", {
                    "value": 1
                });
            }

            Global.myStatistics.myDisputePlayCount += 1;
        } else {
            if (Global.myGoogleAnalytics) {
                gtag("event", "arcade_chat_started", {
                    "value": 1
                });
            }

            Global.myStatistics.myChatPlayCount += 1;
        }
    }

    end(fsm, transitionID) {
    }

    _backToMenu(fsm) {
        this._myParentFSM.perform(MainTransitions.End);
    }

    _buildVentSetup() {
        if (this._myIsDispute) {
            return this._disputeVentSetup();
        }

        return this._chatVentSetup();
    }

    //Evidences that appear later in the trial appear later in time in the arcade
    _buildEvidenceSetupList() {
        let evidenceSetupList = [];

        evidenceSetupList.push(new EvidenceSetup(GameObjectType.VENT_TIMER, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.ZESTY_MARKET, new ValueOverTime(3, 0, 60, 120, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TUCIA_DRAWING, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.CPLUSPLUS_PRIMER, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PIANO, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.MICCO_THE_BEAR, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WATER_LILY, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.LOL, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.DRINK_ME_EARRING, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.STARING_CUBE, new ValueOverTime(1, 3, 60, 120, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TROPHY, 5));

        let secondStarTime = 40;
        let secondEndTime = 80;
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WONDERMELON, new ValueOverTime(0, 5, secondStarTime, secondEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PSI, new ValueOverTime(0, 5, secondStarTime, secondEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WONDERLAND, new ValueOverTime(0, 5, secondStarTime, secondEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.VR, new ValueOverTime(0, 5, secondStarTime, secondEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.EGGPLANT, new ValueOverTime(0, 5, secondStarTime, secondEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PICO_8, new ValueOverTime(0, 5, secondStarTime, secondEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.EVERYEYE, new ValueOverTime(0, 5, secondStarTime, secondEndTime, true)));

        let thirdStarTime = 90;
        let thirdEndTime = 130;
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.ANT_MAIN_CHARACTER, new ValueOverTime(0, 5, thirdStarTime, thirdEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.SHATTERED_COIN, new ValueOverTime(0, 5, thirdStarTime, thirdEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.HEART, new ValueOverTime(0, 5, thirdStarTime, thirdEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.HALO_SWORD, new ValueOverTime(0, 5, thirdStarTime, thirdEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.FOX, new ValueOverTime(0, 5, thirdStarTime, thirdEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.FAMILY, new ValueOverTime(0, 5, thirdStarTime, thirdEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.MIRROR, new ValueOverTime(0, 5, thirdStarTime, thirdEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.ALOE_VERA, new ValueOverTime(0, 5, thirdStarTime, thirdEndTime, true)));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.MR_NOT_EVIDENCE, new ValueOverTime(0, 5, thirdStarTime, thirdEndTime, true)));

        let lastStarTime = 140;
        let lastEndTime = 180;
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WAYFINDER, new ValueOverTime(0, 5, lastStarTime, lastEndTime, true)));

        return evidenceSetupList;
    }
}
class IntroState extends PP.State {
    constructor() {
        super();
        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "    Intro");
        this._myFSM.addState("wait_session", this.waitSession.bind(this));
        this._myFSM.addState("wait_start", this.waitStart.bind(this));
        this._myFSM.addState("move_ring", this.checkRingCompleted.bind(this));
        this._myFSM.addState("spawn_hands", this.handsUpdate.bind(this));
        this._myFSM.addState("show_title", new ShowTitleState());
        this._myFSM.addState("done");
        //this._myFSM.addState("test");

        this._myFSM.addTransition("wait_session", "wait_start", "end");
        this._myFSM.addTransition("wait_start", "move_ring", "end", this.startRing.bind(this));
        this._myFSM.addTransition("move_ring", "spawn_hands", "end", this.startHands.bind(this));
        this._myFSM.addTransition("spawn_hands", "show_title", "end");
        this._myFSM.addTransition("show_title", "done", "end", this.endIntro.bind(this));

        //skip
        this._myFSM.addTransition("wait_start", "move_ring", "skip");
        this._myFSM.addTransition("move_ring", "spawn_hands", "skip", this.skipRing.bind(this));
        this._myFSM.addTransition("spawn_hands", "show_title", "skip", this.skipHands.bind(this));
        this._myFSM.addTransition("show_title", "done", "skip", this.skipIntro.bind(this));
        //this._myFSM.addTransition("move_ring", "test", "skip", this.skipRing.bind(this));

        this._myTimer = new PP.Timer(2.5);

        this._myIntroDuration = 0;

        if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
        }
        WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
        this._myXRSessionStartCalled = false;
    }

    update(dt, fsm) {
        this._myFSM.update(dt);

        if (!this._myFSM.isInState("wait_session")) {
            this._myIntroDuration += dt;
        }

        let trialStartedOnce = Global.mySaveManager.loadBool("trial_started_once", false);
        let introViewed = Global.mySaveManager.loadNumber("intro_viewed", 0);

        if ((trialStartedOnce && introViewed >= 3) || Global.myDebugShortcutsEnabled) {
            if (!this._myFSM.isInState("wait_session") && PP.myRightGamepad.getButtonInfo(PP.ButtonType.SELECT).isPressEnd((PP.XRUtils.isDeviceEmulated()) ? 1 : 3)) {
                while (!this._myFSM.isInState("done") && !this._myFSM.isInState("test")) {
                    this._myFSM.perform("skip");
                }

                if (Global.myGoogleAnalytics) {
                    gtag("event", "intro_skipped", {
                        "value": 1
                    });

                    gtag("event", "intro_skipped_time", {
                        "value": this._myIntroDuration.toFixed(2)
                    });
                }
            }
        }
    }

    init(fsm) {
        this._myParentFSM = fsm;
        this._myFSM.init("wait_session");
    }

    waitSession(dt, fsm) {
        if (WL.xrSession && Global.myUpdateReady) {
            let currentVersion = Global.mySaveManager.loadNumber("game_version", 0);
            console.log("Game Version:", currentVersion);

            if (Global.myGoogleAnalytics) {
                gtag("event", "xr_enter_session", {
                    "value": 1
                });

                PP.CAUtils.getUser(function () {
                    if (Global.myGoogleAnalytics) {
                        gtag("event", "xr_enter_session_logged_in", {
                            "value": 1
                        });
                    }
                }, null, false);
            }

            fsm.perform("end");
        }
    }

    waitStart(dt, fsm) {
        this._myTimer.update(dt);

        if (this._myTimer.isDone()) {
            fsm.perform("end");
        }
    }

    startRing(fsm) {
        Global.myRingAnimator.begin();
        this._myTimer.start(0.75);
    }

    checkRingCompleted(dt, fsm) {
        if (Global.myRingAnimator.isDone()) {
            this._myTimer.update(dt);
        }

        if (this._myTimer.isDone()) {
            fsm.perform("end");
        }
    }

    startHands(fsm) {
        let timer = Math.pp_random(0.4, 0.8);
        let startFirst = Math.pp_randomInt(0, 1);
        if (startFirst == 0) {
            this._myLeftHandTimer = new PP.Timer(0);
            this._myRightHandTimer = new PP.Timer(timer);
        } else {
            this._myLeftHandTimer = new PP.Timer(timer);
            this._myRightHandTimer = new PP.Timer(0);
        }

        this._myTimer.start(1.25);
    }

    handsUpdate(dt, fsm) {
        this._myLeftHandTimer.update(dt);
        this._myRightHandTimer.update(dt);

        if (this._myLeftHandTimer.isDone()) {
            this._myLeftHandTimer.reset();
            Global.myLeftHandAnimator.begin();
        }

        if (this._myRightHandTimer.isDone()) {
            this._myRightHandTimer.reset();
            Global.myRightHandAnimator.begin();
        }

        if (Global.myLeftHandAnimator.isDone() && Global.myRightHandAnimator.isDone()) {
            this._myTimer.update(dt);
        }

        if (this._myTimer.isDone()) {
            fsm.perform("end");
        }
    }

    skipRing() {
        Global.myRingAnimator.skip();
    }

    skipHands() {
        Global.myLeftHandAnimator.skip();
        Global.myRightHandAnimator.skip();
    }

    endIntro(fsm) {
        this._myParentFSM.perform(MainTransitions.End);

        let introViewed = Global.mySaveManager.loadNumber("intro_viewed", 0);
        introViewed += 1;
        Global.mySaveManager.save("intro_viewed", introViewed);

        if (Global.myGoogleAnalytics) {
            gtag("event", "intro_viewed", {
                "value": 1
            });

            if (!this._myXRSessionStartCalled) {
                gtag("event", "xr_session_not_started", {
                    "value": 1
                });
            }
        }
    }

    skipIntro(fsm, transition) {
        transition.myFromState.myObject.end(fsm, transition);
        this._myParentFSM.perform(MainTransitions.Skip);

        if (Global.myGoogleAnalytics) {
            if (!this._myXRSessionStartCalled) {
                gtag("event", "xr_session_not_started", {
                    "value": 1
                });
            }
        }
    }

    _onXRSessionStart() {
        this._myXRSessionStartCalled = true;
    }
}
class MainFSM {
    constructor() {
        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "Main", true);

        this._buildFSM();

        this._myMusic = Global.myAudioManager.createAudioPlayer(SfxID.YOU_KNOW);
        this._myStartMusicTimer = new PP.Timer(1.8, false);
        this._myStartMusicTimerAfterLoad = new PP.Timer(0.2, false);
        this._myStopMusicTimer = new PP.Timer(0, false);

        this._myIsMusicPlaying = false;
        this._myMusicVolume = this._myMusic.getVolume();
    }

    init() {
        this._myFSM.init(MainStates.Intro);
    }

    update(dt) {
        this._manageMusic(dt);
        this._myFSM.update(dt);
    }

    _buildFSM() {
        this._myFSM.addState(MainStates.Intro, new IntroState());
        this._myFSM.addState(MainStates.Menu, new MenuState());
        this._myFSM.addState(MainStates.Trial, new TrialState());
        this._myFSM.addState(MainStates.ArcadeHard, new ArcadeState(true));
        this._myFSM.addState(MainStates.ArcadeNormal, new ArcadeState(false));

        this._myFSM.addTransition(MainStates.Intro, MainStates.Menu, MainTransitions.End);
        this._myFSM.addTransition(MainStates.Intro, MainStates.Menu, MainTransitions.Skip);

        this._myFSM.addTransition(MainStates.Menu, MainStates.Trial, MainTransitions.StartTrial);
        this._myFSM.addTransition(MainStates.Menu, MainStates.ArcadeHard, MainTransitions.StartArcadeHard);
        this._myFSM.addTransition(MainStates.Menu, MainStates.ArcadeNormal, MainTransitions.StartArcadeNormal);
        this._myFSM.addTransition(MainStates.Menu, MainStates.Menu, MainTransitions.Reset);

        this._myFSM.addTransition(MainStates.Trial, MainStates.Menu, MainTransitions.End);
        this._myFSM.addTransition(MainStates.ArcadeHard, MainStates.Menu, MainTransitions.End);
        this._myFSM.addTransition(MainStates.ArcadeNormal, MainStates.Menu, MainTransitions.End);
    }

    _manageMusic(dt) {
        if (Global.myPlayMusic) {
            Global.myPlayMusic = false;
            if (!this._myIsMusicPlaying) {
                this._myStartMusicTimer.start();
            }
        }

        if (Global.myStopMusic) {
            Global.myStopMusic = false;
            if (this._myIsMusicPlaying) {
                this._myStopMusicTimer.start();
            }
        }

        if (this._myStartMusicTimer.isRunning()) {
            this._myStartMusicTimer.update(dt);
        }

        if (this._myStartMusicTimer.isDone()) {
            if (this._myMusic.isLoaded()) {
                this._myStartMusicTimerAfterLoad.start();
                this._myStartMusicTimer.reset();
            }
        }

        if (this._myStartMusicTimerAfterLoad.isRunning()) {
            this._myStartMusicTimerAfterLoad.update(dt);
            if (this._myStartMusicTimerAfterLoad.isDone()) {
                if (!this._myMusic.isPlaying()) {
                    this._myMusic.play();
                }
                this._myMusic.fade(0, this._myMusicVolume, 6);
                this._myStartMusicTimerAfterLoad.reset();

                this._myIsMusicPlaying = true;
            }
        }

        if (this._myStopMusicTimer.isRunning()) {
            this._myStopMusicTimer.update(dt);
            if (this._myStopMusicTimer.isDone()) {
                this._myMusic.fade(this._myMusicVolume, 0, 0.05);
                //this._myMusic.updateVolume(0);
                this._myStopMusicTimer.reset();
                this._myIsMusicPlaying = false;
            }
        }
    }
}

var MainStates = {
    Intro: "Intro",
    Menu: "Menu",
    Trial: "Trial",
    ArcadeHard: "ArcadeHard",
    ArcadeNormal: "ArcadeNormal",
};

var MainTransitions = {
    End: "End",
    Skip: "Skip",
    StartTrial: "StartTrial",
    StartArcadeHard: "StartArcadeHard",
    StartArcadeNormal: "StartArcadeNormal",
    Reset: "Reset"
};
class MenuState extends PP.State {
    constructor() {
        super();

        this._myResetCount = 0;

        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "    Menu");
        this._myFSM.addState("ready", this._readyUpdate.bind(this));
        this._myFSM.addState("unspawning_reset", this._unspawn.bind(this));
        this._myFSM.addState("unspawning_restart", this._unspawn.bind(this));
        this._myFSM.addState("unspawning_arcade_dispute", this._unspawn.bind(this));
        this._myFSM.addState("unspawning_arcade_chat", this._unspawn.bind(this));
        this._myFSM.addState("unspawning_trial", this._unspawn.bind(this));
        this._myFSM.addState("done");

        this._myFSM.addTransition("ready", "unspawning_arcade_dispute", "unspawn_arcade_dispute", this._startUnspawning.bind(this));
        this._myFSM.addTransition("ready", "unspawning_arcade_chat", "unspawn_arcade_chat", this._startUnspawning.bind(this));
        this._myFSM.addTransition("ready", "unspawning_trial", "unspawn_trial", this._startUnspawning.bind(this));
        this._myFSM.addTransition("ready", "unspawning_reset", "unspawn_reset", this._startUnspawningReset.bind(this));
        this._myFSM.addTransition("ready", "unspawning_restart", "unspawn_restart", this._startUnspawningRestart.bind(this));
        this._myFSM.addTransition("unspawning_arcade_dispute", "done", "end", this._endArcadeHard.bind(this));
        this._myFSM.addTransition("unspawning_arcade_chat", "done", "end", this._endArcadeNormal.bind(this));
        this._myFSM.addTransition("unspawning_trial", "done", "end", this._endTrial.bind(this));
        this._myFSM.addTransition("unspawning_reset", "done", "end", this._endReset.bind(this));
        this._myFSM.addTransition("unspawning_restart", "done", "end", this._endRestart.bind(this));

        this._myMenuItems = [];
        this._myStartTrial = null;
        this._myStartTrialCompleted = null;
        this._myFloppyDisk = null;
        this._myCurrentMenuItems = [];

        this._myMenuTitle = new MenuTitle(Global.myTitlesObject, Global.myTitleObject, Global.mySubtitleObject);

        this._myNotEnough = new NotEnough();

        this._fillMenuItems();

        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Unspawn Menu Time", 0.1, 0.1, 3));
        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Unspawn Menu Scale", 2.5, 1, 3));

        this._myMenuDuration = 0;
        this._myFirstTime = true;

        this._myButtonPressed = Global.mySaveManager.loadBool("button_pressed", false);
    }

    update(dt, fsm) {
        this._myMenuDuration += dt;
        this._myFSM.update(dt);
        this._myNotEnough.update(dt);

        if (!this._myButtonPressed) {
            for (let key in PP.ButtonType) {
                let resultLeft = PP.myLeftGamepad.getButtonInfo(PP.ButtonType[key]).isPressStart();
                let resultRight = PP.myRightGamepad.getButtonInfo(PP.ButtonType[key]).isPressStart();

                if (resultLeft || resultRight) {
                    this._myButtonPressed = true;
                    Global.mySaveManager.save("button_pressed", true);

                    if (Global.myGoogleAnalytics) {
                        gtag("event", "button_pressed", {
                            "value": 1
                        });
                    }

                    break;
                }
            }
        }
    }

    start(fsm, transitionID) {
        this._myParentFSM = fsm;

        let trialStartedOnce = Global.mySaveManager.loadBool("trial_started_once", false);
        let trialPhase = Global.mySaveManager.loadNumber("trial_phase", 1);
        let trialCompleted = Global.mySaveManager.loadBool("trial_completed", false);
        if (trialCompleted || (trialStartedOnce && trialPhase >= 2)) {
            this._myCurrentMenuItems = [];

            if (trialCompleted) {
                this._myCurrentMenuItems.push(this._myStartTrialCompleted);
            } else {
                this._myCurrentMenuItems.push(this._myStartTrial);
            }

            for (let item of this._myMenuItems) {
                this._myCurrentMenuItems.push(item);
            }
        } else {
            this._myCurrentMenuItems = [];
            this._myCurrentMenuItems.push(this._myStartTrial);
        }

        let times = [];
        if (this._myFirstTime) {
            times[0] = 0.35;
            this._myFirstTime = false;
        } else {
            times[0] = Math.pp_random(0.15, 0.55);
        }
        for (let i = 1; i < this._myCurrentMenuItems.length; i++) {
            times[i] = times[i - 1] + Math.pp_random(0.15, 0.55);
        }

        for (let item of this._myCurrentMenuItems) {
            let randomIndex = Math.pp_randomInt(0, times.length - 1);
            let timeBeforeFirstSpawn = times.pp_removeIndex(randomIndex);
            item.init(timeBeforeFirstSpawn);
        }

        this._myMenuTitle.spawn(Math.pp_random(0.35, 0.7));

        this._myFSM = this._myFSM.clone();
        this._myFSM.init("ready");

        this._myResetCount = 0;

        Global.myIsInMenu = true;

        Global.myEnableSelectPhysx = trialCompleted || (trialStartedOnce && trialPhase >= 2);

        Global.myPlayMusic = true;

        this._myMenuDuration = 0;
    }

    end() {
        if (Global.myGoogleAnalytics) {
            gtag("event", "menu_time", {
                "value": this._myMenuDuration.toFixed(2)
            });
        }

        Global.myIsInMenu = false;
    }

    _readyUpdate(dt, fsm) {
        for (let item of this._myCurrentMenuItems) {
            item.update(dt);
        }

        this._myMenuTitle.update(dt);

        if (Global.myDebugShortcutsEnabled) {
            //TEMP REMOVE THIS
            if (PP.myRightGamepad.getButtonInfo(PP.ButtonType.SELECT).isPressEnd(Global.myDebugShortcutsPress)) {
                this._myFSM.perform("unspawn_trial");
            }

            //TEMP REMOVE THIS
            if (PP.myLeftGamepad.getButtonInfo(PP.ButtonType.SQUEEZE).isPressEnd(Global.myDebugShortcutsPress)) {
                this._myFSM.perform("unspawn_arcade_dispute");
                //this._myNotEnough.start();
                //Global.myParticlesManager.mrNOTParticles(Global.myPlayerPosition);
            }

            //TEMP REMOVE THIS
            if (PP.myLeftGamepad.getButtonInfo(PP.ButtonType.SELECT).isPressEnd(Global.myDebugShortcutsPress)) {
                this._myFSM.perform("unspawn_restart");
            }
        }
    }

    _startUnspawning(fsm) {
        this._startUnspawningInternal();
    }


    _startUnspawningInternal(evidenceMinDelay = 0.2, evidenceMaxDelay = 0.25, titleMinDelay = 0.35, titleMaxDelay = 0.7) {
        this._myUnspawnList = [];

        let indexList = [];
        for (let i = 0; i < this._myCurrentMenuItems.length; i++) {
            if (this._myCurrentMenuItems[i].canUnspawn()) {
                indexList.push(i);
            }

            this._myCurrentMenuItems[i].setAutoSpawn(false);
        }

        while (indexList.length > 0) {
            let randomIndex = Math.pp_randomInt(0, indexList.length - 1);
            let index = indexList.pp_removeIndex(randomIndex);

            let randomTimer = Math.pp_random(evidenceMinDelay, evidenceMaxDelay);
            this._myUnspawnList.push([index, new PP.Timer(randomTimer)]);
        }

        this._myMenuTitle.unspawn(Math.pp_random(titleMinDelay, titleMaxDelay));
    }

    _startUnspawningRestart(fsm) {
        this._startUnspawningInternal();
    }

    _startUnspawningReset(fsm) {
        this._myResetCount = 0;

        let fullReset = this._myFloppyDisk.getGrabTime() >= 5;
        if (!fullReset) {

            if (Global.myGoogleAnalytics) {
                gtag("event", "save_reset", {
                    "value": 1
                });
            }

            Global.mySaveManager.save("trial_started_once", false);
            Global.mySaveManager.save("trial_completed", false);
            Global.mySaveManager.save("trial_phase", 1);

            Global.myStatistics.myTrialPlayCountResettable = 0;
            Global.myStatistics.myMrNOTClonesDismissedResettable = 0;
            Global.mySaveManager.save("trial_play_count_resettable", 0);
            Global.mySaveManager.save("mr_NOT_clones_dismissed_resettable", 0);

            this._myNotEnough.start();
        } else {
            if (Global.myGoogleAnalytics) {
                gtag("event", "save_reset_full", {
                    "value": 1
                });
            }

            Global.mySaveManager.clear();
            Global.mySaveManager.save("game_version", Global.myGameVersion);
            this._myNotEnough.start();
            Global.myParticlesManager.mrNOTParticles(Global.myPlayerPosition);
        }

        this._startUnspawningInternal(0, 0, 0, 0);
    }

    _unspawn(dt, fsm) {
        if (this._myUnspawnList.length > 0) {
            let first = this._myUnspawnList[0];
            first[1].update(dt);
            if (first[1].isDone()) {
                this._myCurrentMenuItems[first[0]].unspawn();
                this._myUnspawnList.shift();
            }

            let moreDeleted = false;
            for (let element of this._myUnspawnList) {
                element[1].update(0);
                if (element[1].isDone()) {
                    moreDeleted = true;
                    this._myCurrentMenuItems[element[0]].unspawn();
                }
            }

            if (moreDeleted) {
                this._myUnspawnList.pp_removeAll(element => element[1].isDone());
            }
        }

        for (let item of this._myCurrentMenuItems) {
            item.update(dt);
        }

        this._myMenuTitle.update(dt);

        let done = true;
        for (let item of this._myCurrentMenuItems) {
            done = done && item.isInactive();
        }
        done = done && this._myMenuTitle.isHidden();

        if (done && !this._myNotEnough.isNotEnoughing()) {
            fsm.perform("end");
        }
    }

    _endArcadeHard(fsm) {
        this._myParentFSM.perform(MainTransitions.StartArcadeHard);
    }

    _endArcadeNormal(fsm) {
        this._myParentFSM.perform(MainTransitions.StartArcadeNormal);
    }

    _endTrial(fsm) {
        this._myParentFSM.performDelayed(MainTransitions.StartTrial);
    }

    _endReset(fsm) {
        this._myParentFSM.perform(MainTransitions.Reset);
    }

    _endRestart(fsm) {
        this._myParentFSM.perform(MainTransitions.Reset);
    }

    _fillMenuItems() {
        let positions = [];
        let ringHeight = Global.myRingHeight;
        let ringRadius = Global.myRingRadius;
        let rotation = 45;

        let initialPosition = [0, ringHeight, -ringRadius];
        positions.push(initialPosition.vec3_clone());
        positions.push(initialPosition.vec3_rotateAxis(rotation, [0, 1, 0]));
        positions.push(initialPosition.vec3_rotateAxis(-rotation, [0, 1, 0]));
        positions.push(initialPosition.vec3_rotateAxis(rotation * 2, [0, 1, 0]));
        positions.push(initialPosition.vec3_rotateAxis(-rotation * 2, [0, 1, 0]));
        positions.push(initialPosition.vec3_rotateAxis(rotation * 3, [0, 1, 0]));
        positions.push(initialPosition.vec3_rotateAxis(-rotation * 3, [0, 1, 0]));
        positions.push(initialPosition.vec3_rotateAxis(-rotation * 4, [0, 1, 0]));

        {
            let startTrial = new MenuItem(Global.myGameObjects.get(GameObjectType.COIN), GameObjectType.COIN, positions[0], function () {
                if (this._myFSM.isInState("ready")) {
                    this._myFSM.perform("unspawn_trial");
                    this._myResetCount = 0;
                }
            }.bind(this));
            this._myStartTrial = startTrial;
        }

        {
            let startTrialCompleted = new MenuItem(Global.myGameObjects.get(GameObjectType.NOT_COIN), GameObjectType.NOT_COIN, positions[0], function () {
                if (this._myFSM.isInState("ready")) {
                    this._myFSM.perform("unspawn_trial");
                    this._myResetCount = 0;
                }
            }.bind(this));
            this._myStartTrialCompleted = startTrialCompleted;
        }

        {
            let startArcadeHard = new MenuItem(Global.myGameObjects.get(GameObjectType.ARCADE_STICK_DISPUTE), GameObjectType.ARCADE_STICK_DISPUTE, positions[2], function () {
                if (this._myFSM.isInState("ready")) {
                    this._myFSM.perform("unspawn_arcade_dispute");
                    this._myResetCount = 0;
                }
            }.bind(this));
            this._myMenuItems.push(startArcadeHard);
        }

        {
            let startArcadeNormal = new MenuItem(Global.myGameObjects.get(GameObjectType.ARCADE_STICK_CHAT), GameObjectType.ARCADE_STICK_CHAT, positions[1], function () {
                if (this._myFSM.isInState("ready")) {
                    this._myFSM.perform("unspawn_arcade_chat");
                    this._myResetCount = 0;
                }
            }.bind(this));
            this._myMenuItems.push(startArcadeNormal);
        }

        {
            let leaderboardArcadeHard = new MenuItem(Global.myGameObjects.get(GameObjectType.ARCADE_LEADERBOARD_DISPUTE), GameObjectType.ARCADE_LEADERBOARD_DISPUTE, positions[4], function () {
                if (this._myFSM.isInState("ready")) {
                    //get leaderboard object and component and ask for a refresh
                    this._myResetCount = 0;
                }
            }.bind(this));
            this._myMenuItems.push(leaderboardArcadeHard);
        }

        {
            let leaderboardArcadeNormal = new MenuItem(Global.myGameObjects.get(GameObjectType.ARCADE_LEADERBOARD_CHAT), GameObjectType.ARCADE_LEADERBOARD_CHAT, positions[3], function () {
                if (this._myFSM.isInState("ready")) {
                    //get leaderboard object and component and ask for a refresh
                    this._myResetCount = 0;
                }
            }.bind(this));
            this._myMenuItems.push(leaderboardArcadeNormal);
        }

        {
            let zestyMarket = new MenuItem(Global.myGameObjects.get(GameObjectType.ZESTY_MARKET), GameObjectType.ZESTY_MARKET, positions[6], function () {
                if (this._myFSM.isInState("ready")) {
                    this._myResetCount = 0;
                    let zestyComponent = this._myZestyObject.getObject().pp_getComponentHierarchy("zesty-banner");
                    if (zestyComponent) {
                        Global.myZestyToClick = zestyComponent;
                    }
                }
            }.bind(this));
            this._myMenuItems.push(zestyMarket);
            this._myZestyObject = zestyMarket;
        }

        {
            let floppyDisk = new MenuItem(Global.myGameObjects.get(GameObjectType.FLOPPY_DISK), GameObjectType.FLOPPY_DISK, positions[5], function () {
                if (this._myFSM.isInState("ready")) {
                    this._myResetCount++;

                    if (this._myResetCount >= 5) {
                        this._myFSM.perform("unspawn_reset");
                    }
                }
            }.bind(this));
            this._myMenuItems.push(floppyDisk);
            this._myFloppyDisk = floppyDisk;
        }

        {
            let wondermelon = new MenuItem(Global.myGameObjects.get(GameObjectType.WONDERMELON), GameObjectType.WONDERMELON, positions[7], function () {
                if (Global.myGoogleAnalytics) {
                    gtag("event", "not_enough_opened", {
                        "value": 1
                    });
                }

                if (WL.xrSession) {
                    WL.xrSession.end();
                }
                window.open("https://elia-ducceschi.itch.io/not-enough", "_blank");
            }.bind(this));
            this._myMenuItems.push(wondermelon);
        }
    }
}

class MenuItem {
    constructor(object, objectType, position, callbackOnFall = null) {
        this._myObject = object;
        this._myObjectType = objectType;
        this._myPosition = position.slice(0);
        this._myFacing = [0, 0, 0].vec3_sub(position).vec3_removeComponentAlongAxis([0, 1, 0]);
        this._myPhysx = this._myObject.pp_getComponentHierarchy("physx");
        this._myGrabbable = this._myObject.pp_getComponentHierarchy("pp-grabbable");
        this._myScale = this._myObject.pp_getScale();

        this._myTimer = new PP.Timer(0);
        this._myAudioTimer = new PP.Timer(0);

        this._myCallbackOnFall = callbackOnFall;

        this._myAutoSpawn = true;

        this._myThrowTimer = new PP.Timer(5, false);
        WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));

        this._myFSM = new PP.FSM();

        //this._myFSM.setDebugLogActive(true, "        Menu Item");
        this._myFSM.addState("init");
        this._myFSM.addState("inactive", this._inactiveUpdate.bind(this));
        this._myFSM.addState("spawning", this._spawning.bind(this));
        this._myFSM.addState("ready", this._readyUpdate.bind(this));
        this._myFSM.addState("unspawning", this._unspawning.bind(this));

        this._myFSM.addTransition("init", "inactive", "reset", this._reset.bind(this));
        this._myFSM.addTransition("inactive", "spawning", "spawn", this._startSpawn.bind(this));
        this._myFSM.addTransition("spawning", "ready", "end", this._startReady.bind(this));
        this._myFSM.addTransition("spawning", "unspawning", "unspawn", this._startUnspawn.bind(this));
        this._myFSM.addTransition("ready", "unspawning", "unspawn", this._startUnspawn.bind(this));
        this._myFSM.addTransition("unspawning", "inactive", "end", this._startInactive.bind(this));
        this._myFSM.addTransition("inactive", "inactive", "reset", this._reset.bind(this));

        this._myFSM.init("init");

        this._myParticlesRadius = 0.225;

        this._myAppearAudio = null;
        this._myDisappearAudio = null;

        this._myGrabTime = 0;
        this._myCollisionCallbackID = null;
    }

    init(timeBeforeFirstSpawn) {
        this._myFSM.perform("reset", timeBeforeFirstSpawn);
    }

    update(dt) {
        this._myFSM.update(dt);
        this._myThrowTimer.update(dt);

        if (this._myGrabbable.isGrabbed()) {
            this._myGrabTime += dt;
        }
    }

    setAutoSpawn(autoSpawn) {
        this._myAutoSpawn = autoSpawn;
    }

    unspawn() {
        this._myFSM.perform("unspawn");
    }

    canUnspawn() {
        return this._myFSM.canPerform("unspawn");
    }

    getObject() {
        return this._myObject;
    }

    isInactive() {
        return this._myFSM.isInState("inactive");
    }

    getGrabTime() {
        return this._myGrabTime;
    }

    _reset(fsm, transition, timeBeforeFirstSpawn) {
        this._disableObject();
        this._myTimer.start(timeBeforeFirstSpawn);
        this._myAutoSpawn = true;
    }

    _inactiveUpdate(dt, fsm) {
        this._myTimer.update(dt);
        if (this._myTimer.isDone() && this._myAutoSpawn) {
            fsm.perform("spawn");
        }
    }

    _startSpawn() {
        if (this._myAppearAudio == null) {
            this._myAppearAudio = Global.myAudioManager.createAudioPlayer(SfxID.EVIDENCE_APPEAR);
            this._myDisappearAudio = Global.myAudioManager.createAudioPlayer(SfxID.EVIDENCE_DISAPPEAR);
        }

        let position = this._myPosition.pp_clone();

        let evidenceComponent = this._myObject.pp_getComponentHierarchy("evidence-component");
        if (evidenceComponent) {
            let heightDisplacement = evidenceComponent.getHeightDisplacement();
            if (Math.abs(heightDisplacement) > 0.0001) {
                position.vec3_add([0, heightDisplacement, 0], position);
            }
        }

        this._myObject.pp_setPosition(position);
        this._myObject.pp_setScale(0);
        this._myObject.pp_translate([0, 0.2, 0]);
        this._myObject.pp_lookTo(this._myFacing, [0, 1, 0]);
        this._myObject.pp_setActive(true);

        this._myPhysx.kinematic = true;
        this._myPhysx.linearVelocity = [0, 0, 0];
        this._myPhysx.angularVelocity = [0, 0, 0];

        this._myTimer.start(1);
        this._myThrowTimer.reset();

        this._myAudioTimer.start(0.2);
        this._myAppearAudio.setPosition(position);
        this._myAppearAudio.setPitch(Math.pp_random(0.85, 1.05));

        this._myHitFloor = false;
        this._myGrabTime = 0;

        this._myGrabbable.registerGrabEventListener(this, this._onGrab.bind(this));
        this._myGrabbable.registerThrowEventListener(this, this._onThrow.bind(this));

        this._myCollisionCallbackID = this._myPhysx.onCollision(this._onCollision.bind(this));
    }

    _spawning(dt) {
        if (this._myAudioTimer.isRunning()) {
            this._myAudioTimer.update(dt);
            if (this._myAudioTimer.isDone()) {
                this._myAppearAudio.play();
            }
        }

        this._myTimer.update(dt);

        let scaleMultiplier = PP.EasingFunction.easeInOut(this._myTimer.getPercentage());
        this._myObject.pp_setScale(this._myScale.vec3_scale(scaleMultiplier));

        this._myAppearAudio.updatePosition(this._myObject.pp_getPosition());

        if (this._myTimer.isDone()) {
            this._myFSM.perform("end");
        }
    }

    _startReady() {
        this._myObject.pp_setScale(this._myScale);
        if (!this._myGrabbable.isGrabbed()) {
            this._myPhysx.kinematic = false;
        }
    }

    _readyUpdate(dt) {
        if (this._myObject.pp_getPosition()[1] <= -10 || this._myObject.pp_getPosition()[1] > 20 || this._myObject.pp_getPosition().vec3_length() > 50) {
            this._myHitFloor = true;
            this._myFSM.perform("unspawn");
        }
    }

    _startUnspawn() {
        if (this._myHitFloor) {
            //Global.myStatistics.myEvidencesThrown += 1;
        }

        this._myTimer.start(PP.myEasyTuneVariables.get("Unspawn Menu Time"));

        this._myDisappearAudio.setPosition(this._myObject.pp_getPosition());
        this._myDisappearAudio.setPitch(Math.pp_random(0.85, 1.05));
        this._myDisappearAudio.play();
    }

    _unspawning(dt) {
        this._myTimer.update(dt);

        let scaleMultiplier = Math.pp_interpolate(1, PP.myEasyTuneVariables.get("Unspawn Menu Scale"), this._myTimer.getPercentage());
        this._myObject.pp_setScale(this._myScale.vec3_scale(scaleMultiplier));

        //this._myDisappearAudio.updatePosition(this._myObject.pp_getPosition());

        if (this._myTimer.isDone()) {
            Global.myParticlesManager.explosion(this._myObject.pp_getPosition(), this._myParticlesRadius, this._myScale, this._myObjectType);
            this._myFSM.perform("end");
            if (this._myCallbackOnFall && WL.xrSession && this._myThrowTimer.isRunning()) {
                this._myCallbackOnFall();
            }
        }
    }

    _startInactive() {
        this._disableObject();
        this._myTimer.start(1);
    }

    _onGrab() {
        this._myGrabTime = 0;
        this._myThrowTimer.reset();
    }

    _onThrow() {
        this._myThrowTimer.start();
    }

    _onXRSessionEnd() {
        this._myThrowTimer.reset();
    }

    _disableObject() {
        if (this._myPhysx.active) {
            this._myPhysx.linearVelocity = [0, 0, 0];
            this._myPhysx.angularVelocity = [0, 0, 0];
            this._myObject.pp_setPosition([0, -10, 0]);
        }
        this._myObject.pp_setActive(false);
        this._myGrabbable.unregisterGrabEventListener(this);
        this._myGrabbable.unregisterThrowEventListener(this);
        if (this._myCollisionCallbackID != null) {
            this._myPhysx.removeCollisionCallback(this._myCollisionCallbackID);
            this._myCollisionCallbackID = null;
        }
    }

    _onCollision() {
        if (!this._myGrabbable.isGrabbed() && this._myPhysx.active && this._myPhysx.kinematic &&
            (this._myFSM.getCurrentState().myID == "spawning")) {
            this._myPhysx.kinematic = false;
        }
    }
}

class MenuTitle {
    constructor(titlesObject, titleObject, subtitleObject) {
        this._myTitlesObject = titlesObject;
        this._myTitleObject = titleObject;
        this._mySubtitleObject = subtitleObject;

        this._myTitleText = this._myTitleObject.pp_getComponent("text");
        this._myTitleTextColor = this._myTitleText.material.outlineColor.pp_clone();
        this._mySubtitleText = this._mySubtitleObject.pp_getComponent("text");
        this._mySubtitleTextColor = this._mySubtitleText.material.outlineColor.pp_clone();

        this._myStartTimer = new PP.Timer(1, false);
        this._myStartAppearAudioTimer = new PP.Timer(0.3, false);
        this._myTimer = new PP.Timer(1, false);

        this._myFSM = new PP.FSM();

        //this._myFSM.setDebugLogActive(true, "        Menu Title");
        this._myFSM.addState("spawn", this._spawnUpdate.bind(this));
        this._myFSM.addState("unspawn", this._unspawnUpdate.bind(this));

        this._myFSM.addTransition("spawn", "unspawn", "unspawn");
        this._myFSM.addTransition("unspawn", "spawn", "spawn");

        this._myFSM.init("spawn");

        this._myAppearAudio = Global.myAudioManager.createAudioPlayer(SfxID.TITLE_APPEAR);
        this._myDisappearAudio = Global.myAudioManager.createAudioPlayer(SfxID.TITLE_DISAPPEAR);

        //Setup
        this._mySpawnTime = 1.5;
        this._myHideScale = 0.95;
    }

    spawn(timeToStart) {
        if (!this._myTitleText.active) {
            this._myTitleObject.pp_setActive(true);
            this._mySubtitleObject.pp_setActive(true);
            Global.myTitlePatchObject.pp_setActive(true);

            this._myTitleCenterPosition = [0, 168, -184];
            this._myAppearAudio.setPosition(this._myTitleCenterPosition);
            this._myDisappearAudio.setPosition(this._myTitleCenterPosition);

            this._myTimer.start(this._mySpawnTime);
            this._myStartAppearAudioTimer.start(0.4);
        }

        this._myStartTimer.start(timeToStart + 0.4);
        this._myFSM.perform("spawn");
    }

    unspawn(timeToStart) {
        this._myTimer.start(this._mySpawnTime);
        this._myStartTimer.start(timeToStart);
        this._myFSM.perform("unspawn");

        this._myDisappearAudio.play();
    }

    update(dt) {
        this._myFSM.update(dt);
    }

    isHidden() {
        return !this._myTimer.isRunning();
    }

    _spawnUpdate(dt) {
        if (this._myStartAppearAudioTimer.isRunning()) {
            this._myStartAppearAudioTimer.update(dt);
            if (this._myStartAppearAudioTimer.isDone()) {
                this._myAppearAudio.play();
            }
        }

        this._myStartTimer.update(dt);
        if (this._myStartTimer.isDone()) {
            if (this._myTimer.isRunning()) {
                this._myTimer.update(dt);

                let tempColor = [0, 0, 0, 1];

                tempColor[0] = Math.pp_interpolate(0, this._myTitleTextColor[0], this._myTimer.getPercentage(), PP.EasingFunction.easeInOut);
                tempColor[1] = Math.pp_interpolate(0, this._myTitleTextColor[1], this._myTimer.getPercentage(), PP.EasingFunction.easeInOut);
                tempColor[2] = Math.pp_interpolate(0, this._myTitleTextColor[2], this._myTimer.getPercentage(), PP.EasingFunction.easeInOut);

                this._myTitleText.material.outlineColor = tempColor;

                tempColor[0] = Math.pp_interpolate(0, this._mySubtitleTextColor[0], this._myTimer.getPercentage(), PP.EasingFunction.easeInOut);
                tempColor[1] = Math.pp_interpolate(0, this._mySubtitleTextColor[1], this._myTimer.getPercentage(), PP.EasingFunction.easeInOut);
                tempColor[2] = Math.pp_interpolate(0, this._mySubtitleTextColor[2], this._myTimer.getPercentage(), PP.EasingFunction.easeInOut);

                this._mySubtitleText.material.outlineColor = tempColor;

                let easing = t => t * (2 - t);
                this._myTitlesObject.pp_setScale(Math.pp_interpolate(this._myHideScale, 1, this._myTimer.getPercentage(), easing));
            }

            if (this._myTimer.isDone()) {
                this._myTimer.reset();
            }
        }
    }

    _unspawnUpdate(dt) {
        this._myStartTimer.update(dt);
        if (this._myStartTimer.isDone()) {
            if (this._myTimer.isRunning()) {
                this._myTimer.update(dt);
                let tempColor = [0, 0, 0, 1];

                tempColor[0] = Math.pp_interpolate(this._myTitleTextColor[0], 0, this._myTimer.getPercentage(), PP.EasingFunction.easeInOut);
                tempColor[1] = Math.pp_interpolate(this._myTitleTextColor[1], 0, this._myTimer.getPercentage(), PP.EasingFunction.easeInOut);
                tempColor[2] = Math.pp_interpolate(this._myTitleTextColor[2], 0, this._myTimer.getPercentage(), PP.EasingFunction.easeInOut);

                this._myTitleText.material.outlineColor = tempColor;

                tempColor[0] = Math.pp_interpolate(this._mySubtitleTextColor[0], 0, this._myTimer.getPercentage(), PP.EasingFunction.easeInOut);
                tempColor[1] = Math.pp_interpolate(this._mySubtitleTextColor[1], 0, this._myTimer.getPercentage(), PP.EasingFunction.easeInOut);
                tempColor[2] = Math.pp_interpolate(this._mySubtitleTextColor[2], 0, this._myTimer.getPercentage(), PP.EasingFunction.easeInOut);

                this._mySubtitleText.material.outlineColor = tempColor;

                let easing = t => t * t;
                let scale = Math.pp_interpolate(1, this._myHideScale, this._myTimer.getPercentage(), easing);
                this._myTitlesObject.pp_setScale(scale);
            }

            if (this._myTimer.isDone()) {
                this._myTimer.reset();
                this._myTitleObject.pp_setActive(false);
                this._mySubtitleObject.pp_setActive(false);
                Global.myTitlePatchObject.pp_setActive(false);
            }
        }
    }

}
class ShowTitleState extends PP.State {
    constructor() {
        super();
        this._myTitlesObject = WL.scene.addObject(Global.myScene);
        this._myTitlesRumbleObject = WL.scene.addObject(this._myTitlesObject);
        this._myTitle = WL.scene.addObject(null);
        this._mySubtitle = WL.scene.addObject(null);

        Global.myTitlesObject = this._myTitlesObject;
        Global.myTitlesRumbleObject = this._myTitlesRumbleObject;
        Global.myTitleObject = this._myTitle;
        Global.mySubtitleObject = this._mySubtitle;

        this._myTitleTextComponent = this._myTitle.addComponent('text');
        this._myTitleTextComponent.alignment = WL.Alignment.Left;
        this._myTitleTextComponent.justification = WL.Justification.Line;
        this._myTitleTextComponent.material = Global.myMaterials.myTitle.clone();
        this._myTitleTextComponent.text = " ";
        this._myTitleTextComponent.text = "";
        //this._myTitle.addComponent('pp-easy-transform');
        //this._myTitle.addComponent('pp-easy-text-color', { "_myColorType": 1, "_mySetAsDefault": true });

        //this._mySubtitle.addComponent('pp-easy-transform');
        //this._mySubtitle.addComponent('pp-easy-text-color', { "_myColorType": 1, "_mySetAsDefault": true });
        this._mySubtitleTextComponent = this._mySubtitle.addComponent('text');
        this._mySubtitleTextComponent.alignment = WL.Alignment.Left;
        this._mySubtitleTextComponent.justification = WL.Justification.Line;
        this._mySubtitleTextComponent.material = Global.myMaterials.mySubtitle.clone();
        this._mySubtitleTextComponent.text = " ";
        this._mySubtitleTextComponent.text = "";

        this._myTitlesObjectPosition = [-10, 133, -164];
        this._myTitlesObject.pp_setPosition(this._myTitlesObjectPosition);

        this._myTitle.pp_setPosition([-100, 153, -196]);
        this._myTitle.pp_setScale(550);
        this._myTitle.pp_setRotation([40, 0, 0]);

        this._mySubtitle.pp_setPosition([-108.5, 81.5, -148]);
        this._mySubtitle.pp_setScale(240);
        this._mySubtitle.pp_setRotation([40, 0, 0]);

        this._myTitle.pp_setParent(this._myTitlesRumbleObject);
        this._mySubtitle.pp_setParent(this._myTitlesRumbleObject);
        Global.myTitlePatchObject.pp_setParent(this._myTitlesRumbleObject);

        this._myTitleCenterPosition = [0, 168, -184];
        this._mySubtitleCenterPosition = [0, 87, -144];

        this._myCharAudios = [];
        this._myCharAudios[0] = Global.myAudioManager.createAudioPlayer(SfxID.BLATHER_1);
        this._myCharAudios[1] = Global.myAudioManager.createAudioPlayer(SfxID.BLATHER_0);
        this._myCharAudios[0].setVolume(0.5);
        this._myCharAudios[1].setVolume(0.5);

        this._myNotEnough = new NotEnough(this._mySubtitleCenterPosition);

        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "        Show Title");
        this._myFSM.addState("show_title", this.showTitle.bind(this));
        this._myFSM.addState("show_sub_1", this.showSub1.bind(this));
        this._myFSM.addState("show_sub_IS", this.showSubIS.bind(this));
        this._myFSM.addState("show_sub_2", this.showSub2.bind(this));
        this._myFSM.addState("done");

        this._myFSM.addTransition("show_title", "show_sub_1", "end", this.prepareShowSub1.bind(this));
        this._myFSM.addTransition("show_sub_1", "show_sub_IS", "end", this.prepareShowSubIS.bind(this));
        this._myFSM.addTransition("show_sub_IS", "show_sub_2", "end", this.prepareShowSub2.bind(this));
        this._myFSM.addTransition("show_sub_2", "done", "end");

        this._myCharMinTime = 0.1;
        this._myCharMaxTime = 0.1;
    }

    start() {
        this._myFSM.init("show_title", this.prepareShowTitle.bind(this));
    }

    end(fsm, transition, state) {
        if (transition.myID == "skip") {
            this._skip();
        }
    }

    update(dt, fsm) {
        this._myFSM.update(dt);
        if (this._myFSM.isInState("done")) {
            fsm.perform("end");
        }
    }

    prepareShowTitle(fsm) {
        this._myCharAudios[0].setPosition(this._myTitleCenterPosition);
        this._myCharAudios[1].setPosition(this._myTitleCenterPosition);

        this._myCharMinTime = 0.5;
        this._myCharMaxTime = 0.5;

        this._myCharTimer = new PP.Timer(Math.pp_random(this._myCharMinTime, this._myCharMaxTime));
        this._myWaitTimer = new PP.Timer(1);
        this._myChars = "mr NOT";
        this._myCurrChar = 0;
    }

    showTitle(dt, fsm) {
        if (this._myCurrChar != this._myChars.length) {
            this._myCharTimer.update(dt);
            if (this._myCharTimer.isDone()) {
                this._myCharTimer.start(Math.pp_random(this._myCharMinTime, this._myCharMaxTime));

                let currentCharacter = this._myChars[this._myCurrChar];

                if (currentCharacter != ' ') {
                    let player = this._myCharAudios[this._myCurrChar % 2];
                    player.play();
                }

                this._myTitleTextComponent.text = this._myTitleTextComponent.text.concat(currentCharacter);

                this._myCurrChar++;
            }
        } else {
            this._myWaitTimer.update(dt);
            if (this._myWaitTimer.isDone()) {
                fsm.perform("end");
            }
        }
    }

    prepareShowSub1(fsm) {
        this._myCharAudios[0].setPosition(this._mySubtitleCenterPosition);
        this._myCharAudios[1].setPosition(this._mySubtitleCenterPosition);

        this._myCharMinTime = 0.15;
        this._myCharMaxTime = 0.15;

        this._myCharTimer = new PP.Timer(Math.pp_random(this._myCharMinTime, this._myCharMaxTime));
        this._myWaitTimer = new PP.Timer(0.05);
        this._myChars = "enough";
        this._myCurrChar = 0;
    }

    showSub1(dt, fsm) {
        if (this._myCurrChar != this._myChars.length) {
            this._myCharTimer.update(dt);
            if (this._myCharTimer.isDone()) {
                this._myCharTimer.start(Math.pp_random(this._myCharMinTime, this._myCharMaxTime));

                let currentCharacter = this._myChars[this._myCurrChar];

                if (currentCharacter != ' ') {
                    let player = this._myCharAudios[this._myCurrChar % 2];
                    player.play();
                }

                this._mySubtitleTextComponent.text = this._mySubtitleTextComponent.text.concat(currentCharacter);

                this._myCurrChar++;
            }
        } else {
            this._myWaitTimer.update(dt);
            if (this._myWaitTimer.isDone()) {
                fsm.perform("end");
            }
        }
    }

    prepareShowSubIS(fsm) {
        this._myNotEnough.start();

        this._mySubtitleTextComponent.text = this._mySubtitleTextComponent.text.concat(" IS ");
    }

    showSubIS(dt, fsm) {
        this._myNotEnough.update(dt);
        if (!this._myNotEnough.isNotEnoughing()) {
            fsm.perform("end");
        }
    }

    prepareShowSub2(fsm) {
        this._myCharAudios[0].setPosition(this._mySubtitleCenterPosition);
        this._myCharAudios[1].setPosition(this._mySubtitleCenterPosition);

        this._myCharMinTime = 0.15;
        this._myCharMaxTime = 0.15;

        this._myCharTimer = new PP.Timer(0);
        this._myChars = "enough";
        this._myCurrChar = 0;

        this._myWaitTimer = new PP.Timer(0);
    }

    showSub2(dt, fsm) {
        this.showSub1(dt, fsm);
    }

    _skip() {
        this._myCharAudios[0].stop();
        this._myCharAudios[1].stop();

        this._myNotEnough.stop();

        this._myTitleTextComponent.text = "mr NOT";
        this._mySubtitleTextComponent.text = "enough IS enough";
    }
}
class TrialState extends PP.State {
    constructor() {
        super();

        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "    Trial");
        this._myFSM.addState("init");
        this._myFSM.addState("first_blather", new BlatherState(this._firstBlatherSentences(), false));
        this._myFSM.addState("first_blather_hint", new BlatherState(this._firstBlatherHintSentences(), false));
        this._myFSM.addState("first_vent", new VentState(this._firstVentSetup(), this._firstEvidenceSetupList()));
        this._myFSM.addState("first_defeat_blather", new BlatherState(this._firstDefeatBlatherSentences(), true));
        this._myFSM.addState("second_blather", new BlatherState(this._secondBlatherSentences(), false));
        this._myFSM.addState("second_vent", new VentState(this._secondVentSetup(), this._secondEvidenceSetupList()));
        this._myFSM.addState("second_defeat_blather", new BlatherState(this._secondDefeatBlatherSentences(), true));
        this._myFSM.addState("third_blather", new BlatherState(this._thirdBlatherSentences(), false));
        this._myFSM.addState("third_vent", new VentState(this._thirdVentSetup(), this._thirdEvidenceSetupList()));
        this._myFSM.addState("third_defeat_blather", new BlatherState(this._thirdDefeatBlatherSentences(), true));
        this._myFSM.addState("MrNOT_blather", new BlatherState(this._mrNOTBlatherSentences(), true));
        this._myFSM.addState("MrNOT_vent", new MrNOTVentState());
        this._myFSM.addState("MrNOT_defeat_blather", new BlatherState(this._mrNOTDefeatBlatherSentences(), true));
        this._myFSM.addState("it_will_always_be_not_enough", new BlatherState(this._NOTENOUGHBlatherSentences(), true));
        this._myFSM.addState("done");

        this._myFSM.addTransition("init", "first_blather", "start_1");
        this._myFSM.addTransition("init", "first_blather_hint", "start_1_hint");
        this._myFSM.addTransition("init", "second_blather", "start_2");
        this._myFSM.addTransition("init", "third_blather", "start_3");
        this._myFSM.addTransition("init", "MrNOT_blather", "start_4");

        this._myFSM.addTransition("first_blather", "first_vent", "end");
        this._myFSM.addTransition("first_blather_hint", "first_vent", "end");
        this._myFSM.addTransition("first_vent", "first_defeat_blather", "lost", this._trialPhaseLost.bind(this, 1));
        this._myFSM.addTransition("first_vent", "second_blather", "completed", this._trialPhaseCompleted.bind(this, 1));

        this._myFSM.addTransition("second_blather", "second_vent", "end");
        this._myFSM.addTransition("second_vent", "second_defeat_blather", "lost", this._trialPhaseLost.bind(this, 2));
        this._myFSM.addTransition("second_vent", "third_blather", "completed", this._trialPhaseCompleted.bind(this, 2));

        this._myFSM.addTransition("third_blather", "third_vent", "end");
        this._myFSM.addTransition("third_vent", "third_defeat_blather", "lost", this._trialPhaseLost.bind(this, 3));
        this._myFSM.addTransition("third_vent", "MrNOT_blather", "completed", this._trialPhaseCompleted.bind(this, 3));

        this._myFSM.addTransition("MrNOT_blather", "MrNOT_vent", "end");
        this._myFSM.addTransition("MrNOT_vent", "MrNOT_defeat_blather", "lost", this._trialPhaseLost.bind(this, 4));
        this._myFSM.addTransition("MrNOT_vent", "it_will_always_be_not_enough", "completed", this._trialPhaseCompleted.bind(this, 4));

        this._myFSM.addTransition("it_will_always_be_not_enough", "done", "end", this._gameCompleted.bind(this));

        this._myFSM.addTransition("first_defeat_blather", "done", "end", this._backToMenu.bind(this, 1));
        this._myFSM.addTransition("second_defeat_blather", "done", "end", this._backToMenu.bind(this, 2));
        this._myFSM.addTransition("third_defeat_blather", "done", "end", this._backToMenu.bind(this, 3));
        this._myFSM.addTransition("MrNOT_defeat_blather", "done", "end", this._backToMenu.bind(this, 4));

        this._myFSM.addTransition("done", "first_blather", "start_1");
        this._myFSM.addTransition("done", "first_blather_hint", "start_1_hint");
        this._myFSM.addTransition("done", "second_blather", "start_2");
        this._myFSM.addTransition("done", "third_blather", "start_3");
        this._myFSM.addTransition("done", "MrNOT_blather", "start_4");

        let states = this._myFSM.getStates();
        for (let state of states) {
            this._myFSM.addTransition(state.myID, "done", "skip", this._backToMenu.bind(this, 1));
        }

        this._myFSM.init("init");

        this._myParentFSM = null;
    }

    update(dt, fsm) {
        Global.myTrialDuration += dt;
        Global.myStatistics.myTrialPlayTime += dt;

        this._myFSM.update(dt);
    }

    init(fsm) {
    }

    start(fsm, transitionID) {
        this._myParentFSM = fsm;
        Global.myTrialDuration = 0;
        this._myTrialStartedFromBegin = false;
        Global.myStatistics.myTrialPlayCount += 1;
        Global.myStatistics.myTrialPlayCountResettable += 1;

        let trialPhase = Global.mySaveManager.loadNumber("trial_phase", 1);

        if (trialPhase == 1) {
            this._myTrialStartedFromBegin = true;
        }

        let transition = "start_".concat(trialPhase);

        let giveHint = false;
        giveHint = trialPhase == 1 && Global.myStatistics.myTrialPlayCountResettable >= 7 && Global.myStatistics.myMrNOTClonesDismissedResettable <= 0;
        if (giveHint) {
            transition = transition.concat("_hint");

            if (Global.myGoogleAnalytics) {
                gtag("event", "trial_hint_viewed_phase_".concat(trialPhase), {
                    "value": 1
                });
            }
        }

        if (Global.myGoogleAnalytics) {
            gtag("event", "trial_started", {
                "value": 1
            });

            gtag("event", "trial_started_phase_".concat(trialPhase), {
                "value": 1
            });
        }

        this._myFSM.perform(transition);
    }

    end(fsm, transitionID) {
        Global.mySaveManager.save("trial_started_once", true);
    }

    _trialPhaseCompleted(trialPhase, fsm) {
        if (Global.myGoogleAnalytics) {
            gtag("event", "trial_completed_phase_".concat(trialPhase), {
                "value": 1
            });
        }

        if (trialPhase == 4) {
            if (Global.myGoogleAnalytics) {
                gtag("event", "trial_time", {
                    "value": Global.myTrialDuration.toFixed(2)
                });
            }
        }
    }

    _trialPhaseLost(trialPhase, fsm) {
        if (Global.myGoogleAnalytics) {
            gtag("event", "trial_lost_phase_".concat(trialPhase), {
                "value": 1
            });

            gtag("event", "trial_lost_time_phase_".concat(trialPhase), {
                "value": Global.myVentDuration.toFixed(2)
            });

            gtag("event", "trial_time", {
                "value": Global.myTrialDuration.toFixed(2)
            });

            if (Global.myStatistics.myTrialCompletedCount <= 0) {
                gtag("event", "trial_lost_time_before_completed_phase_".concat(trialPhase), {
                    "value": Global.myVentDuration.toFixed(2)
                });
            }

            if (trialPhase == 1 && Global.myStatistics.myTrialCompletedCount <= 0) {
                let clonesOnlyPunched = Global.myStatistics.myMrNOTClonesDismissed > 0 && Global.myStatistics.myMrNOTClonesDismissed == Global.myStatistics.myEvidencesPunched;
                if (Global.myStatistics.myMrNOTClonesDismissed <= 0 || clonesOnlyPunched) {
                    gtag("event", "trial_lost_before_first_dismiss", {
                        "value": 1
                    });

                    if (clonesOnlyPunched) {
                        gtag("event", "trial_lost_only_punched", {
                            "value": 1
                        });
                    }
                }
            }

            if (trialPhase == 1 && !Global.mySaveManager.loadBool("mr_NOT_clones_seen", false)) {
                gtag("event", "trial_lost_before_first_clone_seen", {
                    "value": 1
                });
            }
        }
    }

    _backToMenu(trialPhase, fsm) {
        Global.mySaveManager.save("trial_phase", trialPhase);
        this._myParentFSM.perform(MainTransitions.End);
    }

    _gameCompleted(fsm) {
        if (this._myTrialStartedFromBegin) {
            if (Global.myStatistics.myTrialBestTime < 0 || Global.myTrialDuration < Global.myStatistics.myTrialBestTime) {
                Global.myStatistics.myTrialBestTime = Global.myTrialDuration;
            }

            if (Global.myGoogleAnalytics) {
                gtag("event", "trial_completed_from_start", {
                    "value": 1
                });

                gtag("event", "trial_completed_from_start_time", {
                    "value": Global.myTrialDuration.toFixed(2)
                });
            }
        }

        Global.mySaveManager.save("trial_phase", 1);
        Global.mySaveManager.save("trial_completed", true);
        Global.myStatistics.myTrialCompletedCount += 1;
        this._myParentFSM.perform(MainTransitions.End);
    }

    _firstBlatherSentences() {
        let sentences = [];

        sentences.push(new Sentence("Glad to see you again"));
        sentences.push(new Sentence("Maybe we could have a little conversation"));
        sentences.push(new Sentence("Why don't you show me what you have learned so far?", 2.5, 1.5));

        return sentences;
    }

    _firstBlatherHintSentences() {
        let sentences = [];

        sentences.push(new Sentence("Glad to see you again"));
        sentences.push(new Sentence("Maybe we could have a little conversation"));
        sentences.push(new Sentence("Why don't you THROW me what you have learned so far?", 2.5, 1.5));

        return sentences;
    }

    _firstDefeatBlatherSentences() {
        let sentences = [];

        sentences.push(new Sentence("Don't even bother", 2.5, 2));

        return sentences;
    }

    _secondBlatherSentences() {
        let sentences = [];

        sentences.push(new Sentence("After our last time together", 1, 0));
        sentences.push(new Sentence("I see you have tried many things"));
        sentences.push(new Sentence("Were they worth your time?", 2.5, 1.5));

        return sentences;
    }

    _secondDefeatBlatherSentences() {
        let sentences = [];

        sentences.push(new Sentence("Stop wasting my time too", 2.5, 2));

        return sentences;
    }

    _thirdBlatherSentences() {
        let sentences = [];

        sentences.push(new Sentence("I've watched you jump from one thing to another", 1, 0));
        sentences.push(new Sentence("hoping to find what's yours"));
        sentences.push(new Sentence("Don't you realize how meaningless this is?", 2.5, 1.5));

        return sentences;
    }

    _thirdDefeatBlatherSentences() {
        let sentences = [];

        sentences.push(new Sentence("There is no purpose left for you", 2.5, 2));

        return sentences;
    }

    _mrNOTBlatherSentences() {
        let sentences = [];

        sentences.push(new Sentence("enough IS enough", 0.1, 0));

        return sentences;
    }

    _mrNOTDefeatBlatherSentences() {
        let sentences = [];

        sentences.push(new Sentence("", 2, 1.5));

        return sentences;
    }

    _NOTENOUGHBlatherSentences() {
        let sentences = [];

        sentences.push(new Sentence("You may think you are stronger now"));
        sentences.push(new Sentence("You may feel free from others' judgment", 2, 0));
        sentences.push(new Sentence("and from your own"));
        sentences.push(new Sentence("You may fool yourself into believing this...", 1.75, 0.75));
        sentences.push(new Sentence("But after all has been said and done", 0.75, 0));
        sentences.push(new Sentence("you KNOW", 0.75, 0));
        sentences.push(new Sentence("it will always be...", 1.75, 0.75));
        sentences.push(new Sentence("NOT ENOUGH", 4, 4, true));

        return sentences;
    }

    _invitationSentences() {
        let sentences = [];

        sentences.push(new Sentence("My dearest puppet", 1.75, 0.75));
        sentences.push(new Sentence("did you miss me?"));
        sentences.push(new Sentence("I did", 2.5, 1.5));

        sentences.push(new Sentence("Why don’t you STAND UP", 1, 0));
        sentences.push(new Sentence("SQUEEZE those buttons", 1, 0));
        sentences.push(new Sentence("and get ready to THROW?"));

        sentences.push(new Sentence("I am here for you", 1.75, 0.75));
        sentences.push(new Sentence("don’t make me wait", 2.5, 1.5));

        return sentences;
    }

    _firstEvidenceSetupList() {
        let evidenceSetupList = [];

        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TRIAL_TIMER, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.ZESTY_MARKET, 3));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TUCIA_DRAWING, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.CPLUSPLUS_PRIMER, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PIANO, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.MICCO_THE_BEAR, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WATER_LILY, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.LOL, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.DRINK_ME_EARRING, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.STARING_CUBE, 1));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TROPHY, 5));

        return evidenceSetupList;
    }

    _secondEvidenceSetupList() {
        let evidenceSetupList = [];

        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TRIAL_TIMER, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.ZESTY_MARKET, 4));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TUCIA_DRAWING, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.CPLUSPLUS_PRIMER, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PIANO, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.MICCO_THE_BEAR, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WATER_LILY, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.LOL, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.DRINK_ME_EARRING, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.STARING_CUBE, 2));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TROPHY, 5));

        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WONDERMELON, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PSI, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WONDERLAND, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.VR, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.EGGPLANT, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PICO_8, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.EVERYEYE, 10));

        return evidenceSetupList;
    }

    _thirdEvidenceSetupList() {
        let evidenceSetupList = [];

        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TRIAL_TIMER, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.ZESTY_MARKET, 4));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TUCIA_DRAWING, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.CPLUSPLUS_PRIMER, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PIANO, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.MICCO_THE_BEAR, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WATER_LILY, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.LOL, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.DRINK_ME_EARRING, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.STARING_CUBE, 3));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TROPHY, 5));

        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WONDERMELON, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PSI, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WONDERLAND, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.VR, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.EGGPLANT, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PICO_8, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.EVERYEYE, 5));

        evidenceSetupList.push(new EvidenceSetup(GameObjectType.ANT_MAIN_CHARACTER, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.SHATTERED_COIN, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.HEART, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.HALO_SWORD, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.FOX, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.FAMILY, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.MIRROR, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.ALOE_VERA, 10));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.MR_NOT_EVIDENCE, 10));

        return evidenceSetupList;
    }
}
//Overall Deep Clone not implemented
WL.MeshComponent.prototype.pp_clone = function (clone, deepCloneParams, extraData) {
    if (deepCloneParams.shouldDeepCloneComponentVariable("mesh", "material")) {
        clone.material = this.material.clone();
    } else {
        clone.material = this.material;
    }

    clone.mesh = this.mesh;
    clone.skin = this.skin;
};

WL.CollisionComponent.prototype.pp_clone = function (clone, deepCloneParams, extraData) {
    clone.collider = this.collider;
    clone.extents = this.extents.slice(0);
    clone.group = this.group;
};

WL.TextComponent.prototype.pp_clone = function (clone, deepCloneParams, extraData) {
    if (deepCloneParams.shouldDeepCloneComponent("text")) {
        clone.text = this.text.slice(0);
    } else {
        clone.text = this.text;
    }

    if (deepCloneParams.shouldDeepCloneComponentVariable("text", "material")) {
        clone.material = this.material.clone();
    } else {
        clone.material = this.material;
    }

    clone.alignment = this.alignment;
    clone.justification = this.justification;
};

//TEMP not complete
WL.PhysXComponent.prototype.pp_clone = function (clone, deepCloneParams, extraData) {
    clone.angularDamping = this.angularDamping;
    clone.angularVelocity = this.angularVelocity.slice(0);

    clone.dynamicFriction = this.dynamicFriction;

    clone.extents = this.extents.slice(0);

    clone.kinematic = this.kinematic;

    clone.linearDamping = this.linearDamping;
    clone.linearVelocity = this.linearVelocity.slice(0);

    clone.mass = this.mass;
    clone.restitution = this.restitution;
    clone.shape = this.shape;
    clone.static = this.static;
    clone.staticFriction = this.staticFriction;
};

Object.defineProperty(WL.MeshComponent.prototype, "pp_clone", { enumerable: false });
Object.defineProperty(WL.CollisionComponent.prototype, "pp_clone", { enumerable: false });
Object.defineProperty(WL.TextComponent.prototype, "pp_clone", { enumerable: false });
Object.defineProperty(WL.PhysXComponent.prototype, "pp_clone", { enumerable: false });
_WL._componentTypes[_WL._componentTypeIndices["cursor"]].proto.init = function () {
    /* VR session cache, in case in VR */
    this.session = null;
    this.collisionMask = (1 << this.collisionGroup);
    this.maxDistance = 100;

    this.doubleClickTimer = 0;
    this.tripleClickTimer = 0;
    this.multipleClickObject = null;
    this.multipleClickDelay = 0.3;
};

_WL._componentTypes[_WL._componentTypeIndices["cursor"]].proto.update = function (dt) {
    if (this.doubleClickTimer > 0) {
        this.doubleClickTimer -= dt;
    }

    if (this.tripleClickTimer > 0) {
        this.tripleClickTimer -= dt;
    }

    this.doUpdate(false);
};

_WL._componentTypes[_WL._componentTypeIndices["cursor"]].proto.hoverBehaviour = function (rayHit, doClick) {
    if (rayHit.hitCount > 0) {
        if (!this.hoveringObject || !this.hoveringObject.equals(rayHit.objects[0])) {
            /* Unhover previous, if exists */
            if (this.hoveringObject) {
                let cursorTarget = this.hoveringObject.getComponent("cursor-target");

                /* Cursor up */
                if (this.isDown && this.isDown == this.lastIsDown) {
                    if (cursorTarget) cursorTarget.onUp(this.hoveringObject, this);
                    this.globalTarget.onUp(this.hoveringObject, this);
                    this.lastIsDown = false;
                }

                if (cursorTarget) cursorTarget.onUnhover(this.hoveringObject, this);
                this.globalTarget.onUnhover(this.hoveringObject, this);
            }

            /* Hover new object */
            this.hoveringObject = rayHit.objects[0];
            if (this.styleCursor) WL.canvas.style.cursor = "pointer";

            let cursorTarget = this.hoveringObject.getComponent("cursor-target");
            if (cursorTarget) {
                this.hoveringObjectTarget = cursorTarget;
                cursorTarget.onHover(this.hoveringObject, this);
            }
            this.globalTarget.onHover(this.hoveringObject, this);
        }

        if (this.hoveringObjectTarget) {
            this.hoveringObjectTarget.onMove(this.hoveringObject, this);
        }

        let cursorTarget = this.hoveringObject.getComponent("cursor-target");

        /* Cursor down */
        if (this.isDown !== this.lastIsDown) {
            if (this.isDown) {
                if (cursorTarget) cursorTarget.onDown(this.hoveringObject, this);
                this.globalTarget.onDown(this.hoveringObject, this);
            }
        }

        /* Click */
        if (doClick) {
            if (this.tripleClickTimer > 0 && this.multipleClickObject && this.multipleClickObject.equals(this.hoveringObject)) {
                if (cursorTarget) cursorTarget.onTripleClick(this.hoveringObject, this);
                this.globalTarget.onTripleClick(this.hoveringObject, this);

                this.tripleClickTimer = 0;
            } else if (this.doubleClickTimer > 0 && this.multipleClickObject && this.multipleClickObject.equals(this.hoveringObject)) {
                if (cursorTarget) cursorTarget.onDoubleClick(this.hoveringObject, this);
                this.globalTarget.onDoubleClick(this.hoveringObject, this);

                this.tripleClickTimer = this.multipleClickDelay;
                this.doubleClickTimer = 0;
            } else {
                if (cursorTarget) cursorTarget.onClick(this.hoveringObject, this);
                this.globalTarget.onClick(this.hoveringObject, this);

                this.tripleClickTimer = 0;
                this.doubleClickTimer = this.multipleClickDelay;
                this.multipleClickObject = this.hoveringObject;
            }
        }

        /* Cursor up */
        if (this.isDown !== this.lastIsDown) {
            if (!this.isDown) {
                if (cursorTarget) cursorTarget.onUp(this.hoveringObject, this);
                this.globalTarget.onUp(this.hoveringObject, this);
            }
        }
    } else if (this.hoveringObject && rayHit.hitCount == 0) {
        let cursorTarget = this.hoveringObject.getComponent("cursor-target");

        /* Cursor up */
        if (this.isDown && this.isDown == this.lastIsDown) {
            if (cursorTarget) cursorTarget.onUp(this.hoveringObject, this);
            this.globalTarget.onUp(this.hoveringObject, this);
            this.lastIsDown = false;
        }

        if (cursorTarget) cursorTarget.onUnhover(this.hoveringObject, this);
        this.globalTarget.onUnhover(this.hoveringObject, this);

        this.hoveringObject = null;
        this.hoveringObjectTarget = null;
        if (this.styleCursor) WL.canvas.style.cursor = "default";
    }

    if (this.hoveringObject) {
        this.lastIsDown = this.isDown;
    }
};
_WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].proto.init = function () {
    this.hoverFunctions = [];
    this.unHoverFunctions = [];
    this.clickFunctions = [];
    this.doubleClickFunctions = [];
    this.tripleClickFunctions = [];
    this.moveFunctions = [];
    this.downFunctions = [];
    this.upFunctions = [];
};

_WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].proto.onDoubleClick = function (object, cursor) {
    for (let f of this.doubleClickFunctions) f(object, cursor);
};

_WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].proto.addDoubleClickFunction = function (f) {
    this._validateCallback(f);
    this.doubleClickFunctions.push(f);
};

_WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].proto.removeDoubleClickFunction = function (f) {
    this._validateCallback(f);
    this._removeItemOnce(this.doubleClickFunctions, f);
};

_WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].proto.onTripleClick = function (object, cursor) {
    for (let f of this.tripleClickFunctions) f(object, cursor);
};

_WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].proto.addTripleClickFunction = function (f) {
    this._validateCallback(f);
    this.tripleClickFunctions.push(f);
};

_WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].proto.removeTripleClickFunction = function (f) {
    this._validateCallback(f);
    this._removeItemOnce(this.tripleClickFunctions, f);
};
WL.registerComponent('pp-console-vr', {
    _myHandedness: { type: WL.Type.Enum, values: ['none', 'left', 'right'], default: 'none' },
    _myOverrideBrowserConsole: { type: WL.Type.Bool, default: true },
    _myShowOnStart: { type: WL.Type.Bool, default: false },
    _myShowVisibilityButton: { type: WL.Type.Bool, default: true },
    _myPulseOnNewMessage: { type: WL.Type.Enum, values: ['never', 'always', 'when hidden'], default: 'when hidden' },
    _myPlaneMaterial: { type: WL.Type.Material, default: null },
    _myTextMaterial: { type: WL.Type.Material, default: null }
}, {
    init: function () {
        this._myWidget = new PP.ConsoleVRWidget();
    },
    start: function () {
        let additionalSetup = {};
        additionalSetup.myHandedness = [null, 'left', 'right'][this._myHandedness];
        additionalSetup.myOverrideBrowserConsole = this._myOverrideBrowserConsole;
        additionalSetup.myShowOnStart = this._myShowOnStart;
        additionalSetup.myShowVisibilityButton = this._myShowVisibilityButton;
        additionalSetup.myPulseOnNewMessage = this._myPulseOnNewMessage;
        additionalSetup.myPlaneMaterial = this._myPlaneMaterial;
        additionalSetup.myTextMaterial = this._myTextMaterial;

        this._myWidget.start(this.object, additionalSetup);
    },
    update: function (dt) {
        this._myWidget.update(dt);
    }
});

/* Doesn't support
    - Placeholder like %d and other similar kind of way to build strings
    - Object to string will result in [Object object]
    - Some messages are not intercepted, like the error from glMatrix.mat4.invert(null, null)
*/

PP.ConsoleVRWidget = class ConsoleVRWidget {

    constructor() {
        this._myWidgetFrame = new PP.WidgetFrame("C", 0);
        this._myWidgetFrame.registerWidgetVisibleChangedEventListener(this, this._widgetVisibleChanged.bind(this));

        this._mySetup = new PP.ConsoleVRWidgetSetup();
        this._myAdditionalSetup = null;

        this._myUI = new PP.ConsoleVRWidgetUI();

        this._myMessages = [];

        this._myOldBrowserConsole = [];
        this._myOldConsoleVR = [];

        this._myTypeFilters = [];
        for (let key in PP.ConsoleVRWidget.MessageType) {
            this._myTypeFilters[PP.ConsoleVRWidget.MessageType[key]] = false;
        }

        this._myScrollUp = false;
        this._myScrollDown = false;
        this._myScrollOffset = 0;
        this._myScrollTimer = 0;
        this._myScrollThumbstickTimer = 0;

        this._myPulseTimer = 0;

        this._myGamepadScrollActive = true;
        if (this._mySetup.myGamepadScrollOnlyOnHover) {
            this._myGamepadScrollActive = false;
        }
    }

    start(parentObject, additionalSetup) {
        this._myLeftGamepad = PP.myLeftGamepad; //@EDIT get gamepad LEFT here based on how you store it in your game
        this._myRightGamepad = PP.myRightGamepad; //@EDIT get gamepad RIGHT here based on how you store it in your game

        this._myAdditionalSetup = additionalSetup;

        this._myWidgetFrame.start(parentObject, additionalSetup);

        this._myUI.build(this._myWidgetFrame.getWidgetObject(), this._mySetup, additionalSetup);
        this._myUI.setVisible(this._myWidgetFrame.myIsWidgetVisible);
        this._setNotifyIconActive(false);

        this._addListeners();

        this._overrideConsolesFunctions();
    }

    //This must be done only when all the setup is complete, to avoid issues with other part of the code calling the console and then triggering the console vr while not ready yet
    _overrideConsolesFunctions() {
        this._myOldBrowserConsole[PP.ConsoleVRWidget.ConsoleFunction.LOG] = console.log;
        this._myOldBrowserConsole[PP.ConsoleVRWidget.ConsoleFunction.ERROR] = console.error;
        this._myOldBrowserConsole[PP.ConsoleVRWidget.ConsoleFunction.WARN] = console.warn;
        this._myOldBrowserConsole[PP.ConsoleVRWidget.ConsoleFunction.INFO] = console.info;
        this._myOldBrowserConsole[PP.ConsoleVRWidget.ConsoleFunction.DEBUG] = console.debug;
        this._myOldBrowserConsole[PP.ConsoleVRWidget.ConsoleFunction.ASSERT] = console.assert;
        this._myOldBrowserConsoleClear = console.clear;

        if (this._myAdditionalSetup.myOverrideBrowserConsole) {
            console.log = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.LOG, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            console.error = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.ERROR, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            console.warn = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.WARN, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            console.info = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.INFO, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            console.debug = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.DEBUG, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            console.assert = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.ASSERT, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            console.clear = this._clearConsole.bind(this, true, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);

            window.addEventListener('error', function (errorEvent) {
                this._consolePrint(PP.ConsoleVRWidget.ConsoleFunction.ERROR, PP.ConsoleVRWidget.Sender.WINDOW, "Uncaught", errorEvent.error.stack);
            }.bind(this));

            window.addEventListener('unhandledrejection', function (errorEvent) {
                this._consolePrint(PP.ConsoleVRWidget.ConsoleFunction.ERROR, PP.ConsoleVRWidget.Sender.WINDOW, "Uncaught (in promise)", errorEvent.reason);
            }.bind(this));
        }

        this._myOldConsoleVR[PP.ConsoleVRWidget.ConsoleFunction.LOG] = PP.ConsoleVR.log;
        this._myOldConsoleVR[PP.ConsoleVRWidget.ConsoleFunction.ERROR] = PP.ConsoleVR.error;
        this._myOldConsoleVR[PP.ConsoleVRWidget.ConsoleFunction.WARN] = PP.ConsoleVR.warn;
        this._myOldConsoleVR[PP.ConsoleVRWidget.ConsoleFunction.INFO] = PP.ConsoleVR.info;
        this._myOldConsoleVR[PP.ConsoleVRWidget.ConsoleFunction.DEBUG] = PP.ConsoleVR.debug;
        this._myOldConsoleVR[PP.ConsoleVRWidget.ConsoleFunction.ASSERT] = PP.ConsoleVR.assert;
        this._myOldConsoleVRClear = PP.ConsoleVR.clear;

        PP.ConsoleVR.log = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.LOG, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
        PP.ConsoleVR.error = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.ERROR, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
        PP.ConsoleVR.warn = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.WARN, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
        PP.ConsoleVR.info = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.INFO, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
        PP.ConsoleVR.debug = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.DEBUG, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
        PP.ConsoleVR.assert = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.ASSERT, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
        PP.ConsoleVR.clear = this._clearConsole.bind(this, true, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
    }

    update(dt) {
        this._myWidgetFrame.update(dt);

        if (this._myWidgetFrame.myIsWidgetVisible) {
            this._updateScroll(dt);
        }

        this._updateGamepadsExtraActions(dt);
    }

    //Text section

    _updateText(messageType) {
        let consoleText = "";

        if (!this._myTypeFilters[messageType]) {
            let linesCount = 0;
            let i = this._myMessages.length - 1;

            let scrollLinesToSkip = Math.round(this._myScrollOffset);

            while (i >= 0 && linesCount < this._mySetup.myMaxLines) {
                let message = this._myMessages[i];

                //skip filtered messages
                if (this._myTypeFilters[message.myType]) {
                    i -= 1;
                    continue;
                }

                let messageLines = message.myLines.length;

                //compute line to skip due to scroll offset
                let linesToSkip = 0;
                if (scrollLinesToSkip > 0) {
                    let additionalEmptyLines = 0;
                    if (i != this._myMessages.length - 1) {
                        additionalEmptyLines = this._mySetup.myLinesBetweenMessages;
                    }

                    if (scrollLinesToSkip >= messageLines + additionalEmptyLines) { // + empty lines between messages
                        scrollLinesToSkip -= messageLines + additionalEmptyLines;
                        linesToSkip = messageLines + additionalEmptyLines;
                    } else {
                        linesToSkip = scrollLinesToSkip;
                        scrollLinesToSkip = 0;
                    }
                }

                //add empty lines between messages
                if (i != this._myMessages.length - 1) {
                    let emptyLinesToSkip = this._mySetup.myLinesBetweenMessages - Math.max(this._mySetup.myLinesBetweenMessages - linesToSkip, 0);
                    let emptyLinesToShow = this._mySetup.myLinesBetweenMessages - emptyLinesToSkip;
                    if (linesCount + emptyLinesToShow > this._mySetup.myMaxLines) {
                        emptyLinesToShow = this._myMaxLines - linesCount;
                    }

                    for (let j = 0; j < emptyLinesToShow; j++) {
                        consoleText = ("\n").concat(consoleText);
                    }

                    linesCount += emptyLinesToShow;
                    linesToSkip -= emptyLinesToSkip;
                }

                //computing the number of message lines to show
                let linesToShow = messageLines - linesToSkip;
                if (linesCount + linesToShow > this._mySetup.myMaxLines) {
                    linesToShow = this._mySetup.myMaxLines - linesCount;
                }

                if (linesToShow > 0) {
                    if (message.myType == messageType) {
                        //if the message is the same type of this message text component, add the message lines

                        let linesToPrint = message.myLines.slice(messageLines - linesToShow - linesToSkip, messageLines - linesToSkip);
                        let text = linesToPrint.join("\n");
                        consoleText = (text.concat("\n")).concat(consoleText);

                        linesCount += linesToShow;
                    } else {
                        //otherwise add empty lines, so that the text component with the correct type will have space to show this message

                        for (let j = 0; j < linesToShow; j++) {
                            consoleText = ("\n").concat(consoleText);
                        }

                        linesCount += linesToShow;
                    }
                }

                i -= 1;
            }
        }

        consoleText = this._mySetup.myMessagesTextStartString.concat(consoleText);

        this._myUI.myMessagesTextComponents[messageType].text = consoleText;
    }

    _consolePrint(consoleFunction, sender, ...args) {
        if (consoleFunction != PP.ConsoleVRWidget.ConsoleFunction.ASSERT || (args.length > 0 && !args[0])) {
            let message = this._argsToMessage(consoleFunction, ...args);
            this._addMessage(message);

            if (this._myMessages.length >= this._mySetup.myMaxMessages + this._mySetup.myMaxMessagesDeletePad) {
                this._myMessages = this._myMessages.slice(this._myMessages.length - this._mySetup.myMaxMessages);
                this._clampScrollOffset();
            }

            this._updateAllTexts();

            this._pulseGamepad();
        }

        switch (sender) {
            case PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE:
                this._myOldBrowserConsole[consoleFunction].apply(console, args);
                break;
            case PP.ConsoleVRWidget.Sender.CONSOLE_VR:
                this._myOldConsoleVR[consoleFunction].apply(PP.ConsoleVR, args);
                break;
            default:
                break;
        }
    }

    _argsToMessage(consoleFunction, ...args) {
        if (consoleFunction == PP.ConsoleVRWidget.ConsoleFunction.ASSERT) {
            args = args.slice(1);
            args.splice(0, 0, this._mySetup.myAssertStartString);
        }

        let messageType = this._consoleFunctionToMessageType(consoleFunction);

        let formattedText = this._formatArgs(...args);

        let lines = this._splitLongLines(formattedText);

        if (messageType == PP.ConsoleVRWidget.MessageType.DEBUG) {
            messageType = PP.ConsoleVRWidget.MessageType.LOG;
        } else if (messageType == PP.ConsoleVRWidget.MessageType.EXCEPTION || messageType == PP.ConsoleVRWidget.MessageType.ASSERT) {
            messageType = PP.ConsoleVRWidget.MessageType.ERROR;
        }


        let message = new PP.ConsoleVRWidget.Message(messageType, lines);

        return message;
    }

    _consoleFunctionToMessageType(consoleFunction) {
        let messageType = PP.ConsoleVRWidget.MessageType.LOG;

        if (consoleFunction < PP.ConsoleVRWidget.ConsoleFunction.DEBUG) {
            messageType = consoleFunction;
        } else if (consoleFunction == PP.ConsoleVRWidget.ConsoleFunction.DEBUG) {
            messageType = PP.ConsoleVRWidget.MessageType.LOG;
        } else {
            messageType = PP.ConsoleVRWidget.MessageType.ERROR;
        }

        return messageType;
    }

    //Here the formatting using placeholder like %d could be implemented in the future
    _formatArgs(...args) {
        let stringifiedArgs = [];
        for (let i = 0; i < args.length; i++) {
            stringifiedArgs.push(this._stringifyItem(args[i]));
        }

        let formattedString = stringifiedArgs.join(" ");

        return formattedString;
    }

    _stringifyItem(item) {
        if (typeof item === 'object') {
            let stringifiedItem = null;
            let linesBetweenItems = this._isArray(item) ? 0 : 2;

            try {
                if (!this._isFloat32Array(item)) {
                    stringifiedItem = JSON.stringify(item, null, linesBetweenItems); //first try with default replacer
                } else {
                    let arrayCopy = []; // I do this just cause Float32Array does not print like normal Array
                    for (let i = 0; i < item.length; i++) {
                        arrayCopy[i] = item[i];
                    }
                    stringifiedItem = JSON.stringify(arrayCopy, null, linesBetweenItems); //first try with default replacer
                }
            } catch (error) {
                let cache = new WeakSet();
                stringifiedItem = JSON.stringify(item, function (key, value) {
                    if (typeof value === 'object' && value !== null) {
                        if (cache.has(value)) {
                            return "<stringify error: object already stringified>"; //try to avoid circular reference, a repeated object will be caught in this check too sadly
                        }
                        cache.add(value);
                    }
                    return value;
                }, linesBetweenItems);
            }

            if (this._isArray(item)) {
                stringifiedItem = stringifiedItem.split(",").join(", ");
            }

            return stringifiedItem;
        }

        return item;
    }

    _splitLongLines(messageText) {
        let linesToSplit = messageText.split("\n");
        let lines = [];
        for (let i = 0; i < linesToSplit.length; i++) {
            let lineToSplit = linesToSplit[i];

            if (lineToSplit.length > this._mySetup.myMaxCharactersPerLine) {
                let spacesAtStart = this._getSpacesAtStart(lineToSplit);
                let spaceToAdd = this._mySetup.myTabString.concat(spacesAtStart);
                let lineSplits = 0;

                while (lineToSplit.length > this._mySetup.myMaxCharactersPerLine && lineSplits < this._mySetup.myMaxLineSplits) {
                    let firstSub = lineToSplit.substr(0, this._mySetup.myMaxCharactersPerLine - 1);
                    let secondSub = lineToSplit.substr(this._mySetup.myMaxCharactersPerLine - 1);
                    secondSub = spaceToAdd.concat(secondSub);

                    lines.push(firstSub);

                    lineToSplit = secondSub;
                    lineSplits++;
                }
                lines.push(lineToSplit);
            } else {
                lines.push(lineToSplit);
            }
        }

        return lines;
    }

    _getSpacesAtStart(text) {
        let spaces = "";
        let i = 0;

        while (i < text.length && text[i] == ' ') {
            spaces = spaces.concat(" ");
            i++;
        }

        return spaces;
    }

    _addMessage(message) {
        let hasSameInfoAsPrev = false;
        if (this._myMessages.length > 0) {
            let lastMessage = this._myMessages[this._myMessages.length - 1];
            if (lastMessage.hasSameInfo(message)) {
                lastMessage.increaseCount();
                hasSameInfoAsPrev = true;
            }
        }

        if (!hasSameInfoAsPrev) {
            this._myMessages.push(message);
        }

        this._adjustScrollOffsetAfterMessageAdded(message, hasSameInfoAsPrev);
        this._updateNotifyIcon(message);
    }

    //if you have scrolled, new messages does not move the scroll position
    _adjustScrollOffsetAfterMessageAdded(message, hasSameInfoAsPrev) {
        if (!hasSameInfoAsPrev && !(this._myTypeFilters[message.myType]) && this._myScrollOffset > 0) {
            this._myScrollOffset += message.myLines.length + this._mySetup.myLinesBetweenMessages;
        }
    }

    _updateAllTexts() {
        if (this._myWidgetFrame.myIsWidgetVisible) {
            for (let key in PP.ConsoleVRWidget.MessageType) {
                this._updateText(PP.ConsoleVRWidget.MessageType[key]);
            }
        }
    }

    _updateNotifyIcon(message) {
        if (!(this._myTypeFilters[message.myType]) && this._myScrollOffset > 0) {
            this._setNotifyIconActive(true);
        }
    }

    _updateScroll(dt) {
        if (this._myScrollUp) {
            this._myScrollTimer += dt;
            while (this._myScrollTimer > this._mySetup.myScrollDelay) {
                this._myScrollTimer -= this._mySetup.myScrollDelay;
                this._myScrollOffset += this._mySetup.myScrollAmount;
            }
        } else if (this._myScrollDown) {
            this._myScrollTimer += dt;
            while (this._myScrollTimer > this._mySetup.myScrollDelay) {
                this._myScrollTimer -= this._mySetup.myScrollDelay;
                this._myScrollOffset -= this._mySetup.myScrollAmount;
            }
        }

        this._clampScrollOffset();

        if (this._myScrollUp || this._myScrollDown) {
            this._updateAllTexts();
        }

        if (this._myScrollOffset == 0) {
            this._setNotifyIconActive(false);
        }
    }

    _clampScrollOffset() {
        let maxScroll = this._getMaxScrollOffset();
        this._myScrollOffset = Math.min(Math.max(this._myScrollOffset, 0), maxScroll); //clamp 
    }

    _getMaxScrollOffset() {
        return Math.max(this._getLinesCount() - this._mySetup.myMaxLines, 0);
    }

    _getLinesCount() {
        let linesCount = 0;
        for (let message of this._myMessages) {
            if (!this._myTypeFilters[message.myType]) {
                linesCount += message.myLines.length + this._mySetup.myLinesBetweenMessages;
            }
        }
        linesCount -= this._mySetup.myLinesBetweenMessages; //empty line is added only between messages
        linesCount = Math.max(linesCount, 0);

        return linesCount;
    }

    //Listener section

    _addListeners() {
        let ui = this._myUI;

        for (let key in PP.ConsoleVRWidget.MessageType) {
            let cursorTarget = ui.myFilterButtonsCursorTargetComponents[PP.ConsoleVRWidget.MessageType[key]];
            let backgroundMaterial = ui.myFilterButtonsBackgroundComponents[PP.ConsoleVRWidget.MessageType[key]].material;
            let textMaterial = ui.myFilterButtonsTextComponents[PP.ConsoleVRWidget.MessageType[key]].material;

            cursorTarget.addTripleClickFunction(this._resetFilters.bind(this, PP.ConsoleVRWidget.MessageType[key]));
            cursorTarget.addDoubleClickFunction(this._filterAllButOne.bind(this, PP.ConsoleVRWidget.MessageType[key], textMaterial));
            cursorTarget.addClickFunction(this._toggleFilter.bind(this, PP.ConsoleVRWidget.MessageType[key], textMaterial));
            cursorTarget.addHoverFunction(this._filterHover.bind(this, PP.ConsoleVRWidget.MessageType[key], backgroundMaterial));
            cursorTarget.addUnHoverFunction(this._filterUnHover.bind(this, PP.ConsoleVRWidget.MessageType[key], backgroundMaterial));
        }

        {
            let cursorTarget = ui.myClearButtonCursorTargetComponent;
            let backgroundMaterial = ui.myClearButtonBackgroundComponent.material;

            cursorTarget.addClickFunction(this._clearConsole.bind(this));
            cursorTarget.addHoverFunction(this._genericHover.bind(this, backgroundMaterial));
            cursorTarget.addUnHoverFunction(this._genericUnHover.bind(this, backgroundMaterial));
        }

        {
            let cursorTarget = ui.myUpButtonCursorTargetComponent;
            let backgroundMaterial = ui.myUpButtonBackgroundComponent.material;

            cursorTarget.addDoubleClickFunction(this._instantScrollUp.bind(this, true));
            cursorTarget.addDownFunction(this._setScrollUp.bind(this, true));
            cursorTarget.addUpFunction(this._setScrollUp.bind(this, false));
            cursorTarget.addHoverFunction(this._genericHover.bind(this, backgroundMaterial));
            cursorTarget.addUnHoverFunction(this._genericUnHover.bind(this, backgroundMaterial));
        }

        {
            let cursorTarget = ui.myDownButtonCursorTargetComponent;
            let backgroundMaterial = ui.myDownButtonBackgroundComponent.material;

            cursorTarget.addDoubleClickFunction(this._instantScrollDown.bind(this));
            cursorTarget.addDownFunction(this._setScrollDown.bind(this, true));
            cursorTarget.addUpFunction(this._setScrollDown.bind(this, false));
            cursorTarget.addHoverFunction(this._genericHover.bind(this, backgroundMaterial));
            cursorTarget.addUnHoverFunction(this._genericUnHover.bind(this, backgroundMaterial));
        }

        {
            let cursorTarget = ui.myNotifyIconCursorTargetComponent;
            let backgroundMaterial = ui.myNotifyIconBackgroundComponent.material;

            cursorTarget.addClickFunction(this._instantScrollDown.bind(this));
            cursorTarget.addHoverFunction(this._genericHover.bind(this, backgroundMaterial));
            cursorTarget.addUnHoverFunction(this._notifyIconUnHover.bind(this));
        }

        ui.myPointerCursorTargetComponent.addHoverFunction(this._setGamepadScrollActive.bind(this, true));
        ui.myPointerCursorTargetComponent.addUnHoverFunction(this._setGamepadScrollActive.bind(this, false));
    }

    _resetFilters(messageType) {
        if (this._myWidgetFrame.myIsWidgetVisible) {
            for (let key in PP.ConsoleVRWidget.MessageType) {
                let backgroundMaterial = this._myUI.myFilterButtonsBackgroundComponents[PP.ConsoleVRWidget.MessageType[key]].material;
                let filterTextMaterial = this._myUI.myFilterButtonsTextComponents[PP.ConsoleVRWidget.MessageType[key]].material;

                this._myTypeFilters[PP.ConsoleVRWidget.MessageType[key]] = false;
                filterTextMaterial.color = this._mySetup.myMessageTypeColors[PP.ConsoleVRWidget.MessageType[key]];
                if (PP.ConsoleVRWidget.MessageType[key] != messageType) {
                    backgroundMaterial.color = this._mySetup.myBackgroundColor;
                }
            }

            this._clampScrollOffset();
            this._updateAllTexts();
        }
    }

    _filterAllButOne(messageType) {
        if (this._myWidgetFrame.myIsWidgetVisible) {
            for (let key in PP.ConsoleVRWidget.MessageType) {
                let backgroundMaterial = this._myUI.myFilterButtonsBackgroundComponents[PP.ConsoleVRWidget.MessageType[key]].material;
                let filterTextMaterial = this._myUI.myFilterButtonsTextComponents[PP.ConsoleVRWidget.MessageType[key]].material;
                if (PP.ConsoleVRWidget.MessageType[key] != messageType) {
                    this._myTypeFilters[PP.ConsoleVRWidget.MessageType[key]] = true;
                    backgroundMaterial.color = this._mySetup.myFilterButtonDisabledBackgroundColor;
                    filterTextMaterial.color = this._mySetup.myFilterButtonDisabledTextColor;
                } else {
                    this._myTypeFilters[PP.ConsoleVRWidget.MessageType[key]] = false;
                    filterTextMaterial.color = this._mySetup.myMessageTypeColors[messageType];
                }
            }

            this._clampScrollOffset();
            this._updateAllTexts();
        }
    }

    _toggleFilter(messageType, textMaterial) {
        if (this._myWidgetFrame.myIsWidgetVisible) {

            this._myTypeFilters[messageType] = !this._myTypeFilters[messageType];
            if (this._myTypeFilters[messageType]) {
                textMaterial.color = this._mySetup.myFilterButtonDisabledTextColor;
            } else {
                textMaterial.color = this._mySetup.myMessageTypeColors[messageType];
            }

            this._clampScrollOffset();
            this._updateAllTexts();
        }
    }

    _clearConsole(codeDrivenClear = false, sender = null) {
        if (this._myWidgetFrame.myIsWidgetVisible || codeDrivenClear) {
            this._myMessages = [];
            this._clampScrollOffset();
            this._updateAllTexts();

            if (codeDrivenClear) {
                switch (sender) {
                    case PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE:
                        this._myOldBrowserConsoleClear.apply(console);
                        break;
                    case PP.ConsoleVRWidget.Sender.CONSOLE_VR:
                        this._myOldConsoleVRClear.apply(PP.ConsoleVR);
                        break;
                    default:
                        break;
                }
            } else if (this._mySetup.myClearBrowserConsoleWhenClearPressed) {
                PP.ConsoleVR._myRealClear();
            }
        }
    }

    _setScrollUp(value) {
        if (this._myWidgetFrame.myIsWidgetVisible || !value) {
            if (value) {
                this._myScrollTimer = 0;
            }

            this._myScrollUp = value;
        }
    }

    _setScrollDown(value) {
        if (this._myWidgetFrame.myIsWidgetVisible || !value) {
            if (value) {
                this._myScrollTimer = 0;
            }

            this._myScrollDown = value;
        }
    }

    _instantScrollUp() {
        if (this._myWidgetFrame.myIsWidgetVisible) {
            this._myScrollOffset = this._getMaxScrollOffset();
            this._updateAllTexts();
        }
    }

    _instantScrollDown() {
        if (this._myWidgetFrame.myIsWidgetVisible) {
            this._myScrollOffset = 0;
            this._setNotifyIconActive(false);
            this._updateAllTexts();
        }
    }

    _setNotifyIconActive(active) {
        this._myUI.myNotifyIconPanel.pp_setActiveHierarchy(active && this._myWidgetFrame.myIsWidgetVisible);
    }

    _notifyIconUnHover() {
        let material = this._myUI.myNotifyIconBackgroundComponent.material;
        material.color = this._mySetup.myNotifyIconColor;
    }

    _filterHover(messageType, material) {
        this._genericHover(material);
    }

    _filterUnHover(messageType, material) {
        if (this._myTypeFilters[messageType]) {
            material.color = this._mySetup.myFilterButtonDisabledBackgroundColor;
        } else {
            material.color = this._mySetup.myBackgroundColor;
        }
    }

    _genericHover(material) {
        material.color = this._mySetup.myButtonHoverColor;
    }

    _genericUnHover(material) {
        material.color = this._mySetup.myBackgroundColor;
    }

    //Gamepad section

    _updateGamepadsExtraActions(dt) {
        if (this._myLeftGamepad && this._myRightGamepad) {
            if ((this._myLeftGamepad.getButtonInfo(PP.ButtonType.THUMBSTICK).isPressStart() && this._myRightGamepad.getButtonInfo(PP.ButtonType.THUMBSTICK).myIsPressed) ||
                (this._myRightGamepad.getButtonInfo(PP.ButtonType.THUMBSTICK).isPressStart() && this._myLeftGamepad.getButtonInfo(PP.ButtonType.THUMBSTICK).myIsPressed)) {
                this._toggleVisibility();
            }

            this._myPulseTimer = Math.max(this._myPulseTimer - dt, 0);

            this._updateScrollWithThumbstick(dt);
        }
    }

    _toggleVisibility() {
        this._myWidgetFrame.toggleVisibility();
    }

    _widgetVisibleChanged(visible) {
        this._myUI.setVisible(visible);
        if (visible) {
            this._updateAllTexts();
        }
    }

    _updateScrollWithThumbstick(dt) {
        if (this._myWidgetFrame.myIsWidgetVisible && this._myGamepadScrollActive) {
            let axes = [0, 0];
            if (this._mySetup.myScrollThumbstickHandedness == PP.ToolHandedness.LEFT) {
                axes = this._myLeftGamepad.getAxesInfo().myAxes;
            } else if (this._mySetup.myScrollThumbstickHandedness == PP.ToolHandedness.RIGHT) {
                axes = this._myRightGamepad.getAxesInfo().myAxes;
            }

            if (Math.abs(axes[1]) > this._mySetup.myScrollThumbstickMinThreshold) {
                this._myScrollThumbstickTimer += dt;

                while (this._myScrollThumbstickTimer > this._mySetup.myScrollThumbstickDelay) {
                    this._myScrollThumbstickTimer -= this._mySetup.myScrollThumbstickDelay;

                    let normalizedScrollAmount = (Math.abs(axes[1]) - this._mySetup.myScrollThumbstickMinThreshold) / (1 - this._mySetup.myScrollThumbstickMinThreshold);
                    this._myScrollOffset += Math.sign(axes[1]) * normalizedScrollAmount * this._mySetup.myScrollThumbstickAmount;
                }

                this._clampScrollOffset();
                this._updateAllTexts();
            } else {
                this._myScrollThumbstickTimer = 0;
            }
        }
    }

    _pulseGamepad() {
        if (this._myLeftGamepad && this._myRightGamepad) {
            let pulseType = this._myAdditionalSetup.myPulseOnNewMessage;
            let pulseEnabled = pulseType == PP.ConsoleVRWidget.PulseOnNewMessage.ALWAYS || (!this._myWidgetFrame.myIsWidgetVisible && pulseType == PP.ConsoleVRWidget.PulseOnNewMessage.WHEN_HIDDEN);
            if (pulseEnabled && this._myPulseTimer == 0) {
                if (this._myAdditionalSetup.myHandedness == PP.ToolHandedness.RIGHT) {
                    this._myRightGamepad.pulse(this._mySetup.myPulseIntensity, this._mySetup.myPulseDuration);
                } else {
                    this._myLeftGamepad.pulse(this._mySetup.myPulseIntensity, this._mySetup.myPulseDuration);
                }
                this._myPulseTimer = this._mySetup.myPulseDelay;
            }
        }
    }

    _isArray(item) {
        return Array.isArray(item) || this._isFloat32Array(item);
    }

    _isFloat32Array(item) {
        return item && item.constructor && item.constructor.name == "Float32Array";
    }

    _setGamepadScrollActive(active) {
        this._myGamepadScrollActive = active;

        if (!this._mySetup.myGamepadScrollOnlyOnHover) {
            this._myGamepadScrollActive = true;
        }
    }
};

PP.ConsoleVRWidget.ConsoleFunction = {
    INFO: 0,
    WARN: 1,
    ERROR: 2,
    LOG: 3,
    DEBUG: 4,
    ASSERT: 5
};

PP.ConsoleVRWidget.Sender = {
    BROWSER_CONSOLE: 0,
    CONSOLE_VR: 1,
    WINDOW: 2
};

PP.ConsoleVRWidget.PulseOnNewMessage = {
    NEVER: 0,
    ALWAYS: 1,
    WHEN_HIDDEN: 2,
};

PP.ConsoleVRWidget.MessageType = {
    INFO: 0,
    WARN: 1,
    ERROR: 2,
    LOG: 3
};

PP.ConsoleVRWidget.Message = class Message {
    constructor(messageType, messageLines) {
        this.myType = messageType;
        this.myLines = messageLines;

        this._myOriginalText = messageLines.join("\n");

        this._myMessagesCount = 1;
    }

    hasSameInfo(message) {
        return this._myOriginalText == message._myOriginalText && this.myType == message.myType;
    }

    increaseCount() {
        this._myMessagesCount += 1;

        let countString = (("(x").concat(this._myMessagesCount)).concat(") ");

        let text = this._myOriginalText.slice(0);
        text = countString.concat(text);
        this.myLines = text.split("\n");
    }
};

PP.ConsoleVR = {
    _myRealLog: console.log,
    _myRealError: console.error,
    _myRealWarn: console.warn,
    _myRealInfo: console.info,
    _myRealDebug: console.debug,
    _myRealAssert: console.assert,
    _myRealClear: console.clear,
    _myAffectBrowserConsole: true,

    log: function (...args) {
        if (this._myAffectBrowserConsole) {
            this._myRealLog.apply(console, args);
        }
    },
    error: function (...args) {
        if (this._myAffectBrowserConsole) {
            this._myRealError.apply(console, args);
        }
    },
    warn: function (...args) {
        if (this._myAffectBrowserConsole) {
            this._myRealWarn.apply(console, args);
        }
    },
    info: function (...args) {
        if (this._myAffectBrowserConsole) {
            this._myRealInfo.apply(console, args);
        }
    },
    debug: function (...args) {
        if (this._myAffectBrowserConsole) {
            this._myRealDebug.apply(console, args);
        }
    },
    assert: function (...args) {
        if (this._myAffectBrowserConsole) {
            this._myRealAssert.apply(console, args);
        }
    },
    clear: function () {
        if (this._myAffectBrowserConsole) {
            this._myRealClear.apply(console);
        }
    },
    setAffectBrowserConsole: function (affectBrowserConsole) {
        this._myAffectBrowserConsole = affectBrowserConsole;
    }
};
PP.ConsoleVRWidgetSetup = class ConsoleVRWidgetSetup {

    constructor() {
        this._initializeBuildSetup();
        this._initializeRuntimeSetup();
    }

    _initializeBuildSetup() {
        //General
        this.myBackgroundColor = [46 / 255, 46 / 255, 46 / 255, 1];

        this.myCursorTargetCollisionCollider = 2; // box
        this.myCursorTargetCollisionGroup = 7; //keep this in sync with ConsoleVRSetup
        this.myCursorTargetCollisionThickness = 0.001;

        this.myDefaultTextColor = [255 / 255, 255 / 255, 255 / 255, 1];

        this.myTextAlignment = 2; // center
        this.myTextJustification = 2; // middle
        this.myTextOutlineRange = [0.45, 0.45];
        this.myTextColor = this.myDefaultTextColor;
        this.myTextOutlineColor = this.myDefaultTextColor;

        this.myMessageTypeColors = [];
        this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.LOG] = this.myDefaultTextColor;
        this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.ERROR] = [255 / 255, 40 / 255, 40 / 255, 1];
        this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.WARN] = [250 / 255, 220 / 255, 40 / 255, 1];
        this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.INFO] = [60 / 255, 200 / 255, 255 / 255, 1];

        //Messages
        this.myMessagesPanelPosition = [0, 0.075, 0];

        this.myMessagesBackgroundScale = [0.34, 0.15, 1];

        {
            let xPaddingPercentage = 0.03;
            let yPaddingPercentage = xPaddingPercentage * this.myMessagesBackgroundScale[0] / this.myMessagesBackgroundScale[1] * 0.8; //a bit less padding
            let xPosition = -this.myMessagesBackgroundScale[0] + this.myMessagesBackgroundScale[0] * xPaddingPercentage;
            let yPosition = this.myMessagesBackgroundScale[1] - this.myMessagesBackgroundScale[1] * yPaddingPercentage;
            this.myMessagesTextsPanelPosition = [xPosition, yPosition, 0.007];
        }
        this.myMessagesTextsPanelScale = [0.1, 0.1, 0.1];

        this.myMessagesTextStartString = ".\n"; // to avoid issue with text component padding
        this.myMessagesTextAlignment = 1; // left
        this.myMessagesTextJustification = 3; // top
        this.myMessagesTextOutlineRange = [0.45, 0.45];

        this.myMessagesTextPositions = [];
        this.myMessagesTextPositions[PP.ConsoleVRWidget.MessageType.LOG] = [0, 0, 0.00001];
        this.myMessagesTextPositions[PP.ConsoleVRWidget.MessageType.ERROR] = [0, 0, 0];
        this.myMessagesTextPositions[PP.ConsoleVRWidget.MessageType.WARN] = [0, 0, 0];
        this.myMessagesTextPositions[PP.ConsoleVRWidget.MessageType.INFO] = [0, 0, 0];

        this.myMessagesTextColors = [];
        this.myMessagesTextColors[PP.ConsoleVRWidget.MessageType.LOG] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.LOG];
        this.myMessagesTextColors[PP.ConsoleVRWidget.MessageType.ERROR] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.ERROR];
        this.myMessagesTextColors[PP.ConsoleVRWidget.MessageType.WARN] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.WARN];
        this.myMessagesTextColors[PP.ConsoleVRWidget.MessageType.INFO] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.INFO];

        this.myMessagesTextOutlineColors = [];
        this.myMessagesTextOutlineColors[PP.ConsoleVRWidget.MessageType.LOG] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.LOG];
        this.myMessagesTextOutlineColors[PP.ConsoleVRWidget.MessageType.ERROR] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.ERROR];
        this.myMessagesTextOutlineColors[PP.ConsoleVRWidget.MessageType.WARN] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.WARN];
        this.myMessagesTextOutlineColors[PP.ConsoleVRWidget.MessageType.INFO] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.INFO];

        //Buttons     
        this.myButtonsPanelPosition = [0, -0.11, 0.015];

        this.myButtonBackgroundScale = [0.04, 0.02, 1];

        this.myButtonTextPosition = [0, 0, 0.0065];
        this.myButtonTextScale = [0.18, 0.18, 0.18];
        this.myButtonTextAlignment = this.myTextAlignment;
        this.myButtonTextJustification = this.myTextJustification;
        this.myButtonTextOutlineRange = this.myTextOutlineRange;
        this.myButtonTextColor = this.myTextColor;
        this.myButtonTextOutlineColor = this.myTextOutlineColor;

        this.myButtonCursorTargetPosition = [0, 0, 0];
        this.myButtonCursorTargetPosition[2] = this.myButtonTextPosition[2];

        this.myButtonsCollisionCollider = this.myCursorTargetCollisionCollider;
        this.myButtonsCollisionGroup = this.myCursorTargetCollisionGroup;
        this.myButtonsCollisionExtents = this.myButtonBackgroundScale.slice(0);
        this.myButtonsCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myClearButtonTextLabel = "clear";
        this.myUpButtonTextLabel = "up";
        this.myDownButtonTextLabel = "down";

        this.myFilterButtonsTextColors = [];
        this.myFilterButtonsTextColors[PP.ConsoleVRWidget.MessageType.LOG] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.LOG];
        this.myFilterButtonsTextColors[PP.ConsoleVRWidget.MessageType.ERROR] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.ERROR];
        this.myFilterButtonsTextColors[PP.ConsoleVRWidget.MessageType.WARN] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.WARN];
        this.myFilterButtonsTextColors[PP.ConsoleVRWidget.MessageType.INFO] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.INFO];

        this.myFilterButtonsTextOutlineColors = [];
        this.myFilterButtonsTextOutlineColors[PP.ConsoleVRWidget.MessageType.LOG] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.LOG];
        this.myFilterButtonsTextOutlineColors[PP.ConsoleVRWidget.MessageType.ERROR] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.ERROR];
        this.myFilterButtonsTextOutlineColors[PP.ConsoleVRWidget.MessageType.WARN] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.WARN];
        this.myFilterButtonsTextOutlineColors[PP.ConsoleVRWidget.MessageType.INFO] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.INFO];

        this.myFilterButtonsTextLabel = [];
        this.myFilterButtonsTextLabel[PP.ConsoleVRWidget.MessageType.LOG] = "log";
        this.myFilterButtonsTextLabel[PP.ConsoleVRWidget.MessageType.ERROR] = "error";
        this.myFilterButtonsTextLabel[PP.ConsoleVRWidget.MessageType.WARN] = "warn";
        this.myFilterButtonsTextLabel[PP.ConsoleVRWidget.MessageType.INFO] = "info";

        //Buttons positioning
        {
            let numberOfButtons = 7;
            let buttonsHorizontalSpace = Math.max(0.68, this.myButtonBackgroundScale[0] * numberOfButtons);
            //2 at start, 3 between filters, 4 spaces between filter and clear and 4 spaces between clear and up/down, 1 space between up and down, 1 at end
            let numberOfSpacesBetweenButtons = 2 + 3 + 4 + 4 + 1 + 2;
            let spaceWidth = Math.max((buttonsHorizontalSpace - numberOfButtons * this.myButtonBackgroundScale[0] * 2) / numberOfSpacesBetweenButtons, 0);
            let halfButtonWidth = this.myButtonBackgroundScale[0];
            let initialPosition = - buttonsHorizontalSpace / 2;

            this.myFilterButtonsPositions = [];
            this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.LOG] = [initialPosition + spaceWidth * 2 + halfButtonWidth, 0, 0];
            this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.ERROR] = [this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.LOG][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
            this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.WARN] = [this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.ERROR][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
            this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.INFO] = [this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.WARN][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];

            this.myClearButtonPosition = [this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.INFO][0] + halfButtonWidth + spaceWidth * 4 + halfButtonWidth, 0, 0];
            this.myUpButtonPosition = [this.myClearButtonPosition[0] + halfButtonWidth + spaceWidth * 4 + halfButtonWidth, 0, 0];
            this.myDownButtonPosition = [this.myUpButtonPosition[0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
        }

        //Notify Icon
        this.myNotifyIconBackgroundScale = [0.01, 0.01, 1];

        this.myNotifyIconPanelPositions = [];
        this.myNotifyIconPanelPositions[PP.ToolHandedness.NONE] = [0, 0, 0];
        this.myNotifyIconPanelPositions[PP.ToolHandedness.NONE][0] = -this.myMessagesBackgroundScale[0] + this.myNotifyIconBackgroundScale[0] + 0.01;
        this.myNotifyIconPanelPositions[PP.ToolHandedness.NONE][1] = -this.myMessagesBackgroundScale[1] + this.myNotifyIconBackgroundScale[1] + 0.01;
        this.myNotifyIconPanelPositions[PP.ToolHandedness.NONE][2] = this.myMessagesTextsPanelPosition[2] - 0.00001; //prevent glitches with text

        this.myNotifyIconPanelPositions[PP.ToolHandedness.LEFT] = this.myNotifyIconPanelPositions[PP.ToolHandedness.NONE];

        this.myNotifyIconPanelPositions[PP.ToolHandedness.RIGHT] = this.myNotifyIconPanelPositions[PP.ToolHandedness.NONE];

        this.myNotifyIconCursorTargetPosition = [0, 0, 0];
        this.myNotifyIconCursorTargetPosition[2] = this.myButtonsPanelPosition[2] + this.myButtonTextPosition[2] - this.myMessagesTextsPanelPosition[2]; // a little behind the button target to avoid hiding it

        this.myNotifyIconCollisionExtents = this.myNotifyIconBackgroundScale.slice(0);
        this.myNotifyIconCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myNotifyIconColor = [210 / 255, 210 / 255, 210 / 255, 1];

        //Pointer
        this.myPointerCollisionCollider = this.myCursorTargetCollisionCollider;
        this.myPointerCollisionGroup = this.myCursorTargetCollisionGroup;

        {
            let spaceBetweenMessagesAndButtons = Math.abs((this.myMessagesPanelPosition[1] - this.myMessagesBackgroundScale[1]) - (this.myButtonsPanelPosition[1] + this.myButtonBackgroundScale[1]));
            let pointerCollisionHalfHeight = this.myMessagesBackgroundScale[1] + this.myButtonBackgroundScale[1] + spaceBetweenMessagesAndButtons / 2;
            this.myPointerCollisionExtents = [this.myMessagesBackgroundScale[0], pointerCollisionHalfHeight, this.myCursorTargetCollisionThickness];
        }

        this.myPointerCursorTargetPosition = [0, 0, 0];
        this.myPointerCursorTargetPosition[1] = (this.myMessagesPanelPosition[1] + this.myMessagesBackgroundScale[1]) - this.myPointerCollisionExtents[1];
        this.myPointerCursorTargetPosition[2] = this.myButtonsPanelPosition[2] + this.myButtonTextPosition[2] - 0.0001; // a little behind the button target to avoid hiding it
    }

    _initializeRuntimeSetup() {
        this.myTabString = "    ";
        this.myAssertStartString = "Assertion failed:";

        this.myMaxCharactersPerLine = 100;
        this.myMaxLineSplits = 10; //prevent infinite splitting
        this.myMaxLines = 22;
        this.myMaxMessages = 2000;
        this.myMaxMessagesDeletePad = 2000; // to prevent deleting at every message, delay the delete after the limit is exceed by this value

        this.myLinesBetweenMessages = 1;

        this.myButtonHoverColor = [150 / 255, 150 / 255, 150 / 255, 1];
        this.myButtonDisabledTextColor = this.myBackgroundColor;
        this.myButtonDisabledBackgroundColor = [110 / 255, 110 / 255, 110 / 255, 1];

        this.myFilterButtonDisabledTextColor = this.myButtonDisabledTextColor;
        this.myFilterButtonDisabledBackgroundColor = this.myButtonDisabledBackgroundColor;

        this.myScrollDelay = 0.1;
        this.myScrollAmount = 1;
        this.myScrollThumbstickHandedness = PP.ToolHandedness.RIGHT;
        this.myScrollThumbstickDelay = 0.1;
        this.myScrollThumbstickMinThreshold = 0.2;
        this.myScrollThumbstickAmount = 3;

        this.myPulseDelay = 5;
        this.myPulseIntensity = 0.3;
        this.myPulseDuration = 0.085;

        this.myClearBrowserConsoleWhenClearPressed = true;

        this.myGamepadScrollOnlyOnHover = true;
    }
};
PP.ConsoleVRWidgetUI = class ConsoleVRWidgetUI {

    build(parentObject, setup, additionalSetup) {
        this._myParentObject = parentObject;
        this._mySetup = setup;
        this._myAdditionalSetup = additionalSetup;

        this._myPlaneMesh = PP.MeshUtils.createPlaneMesh();

        this._createSkeleton();
        this._setTransforms();
        this._addComponents();
    }

    setVisible(visible) {
        this.myPivotObject.pp_setActiveHierarchy(visible);
    }

    //Skeleton
    _createSkeleton() {
        this.myPivotObject = WL.scene.addObject(this._myParentObject);

        this._createMessagesSkeleton();
        this._createButtonsSkeleton();
        this._createPointerSkeleton();
    }

    _createMessagesSkeleton() {
        this.myMessagesPanel = WL.scene.addObject(this.myPivotObject);
        this.myMessagesBackground = WL.scene.addObject(this.myMessagesPanel);
        this.myMessagesTextsPanel = WL.scene.addObject(this.myMessagesPanel);

        this.myMessagesTexts = [];
        for (let key in PP.ConsoleVRWidget.MessageType) {
            this.myMessagesTexts[PP.ConsoleVRWidget.MessageType[key]] = WL.scene.addObject(this.myMessagesTextsPanel);
        }

        this.myNotifyIconPanel = WL.scene.addObject(this.myMessagesPanel);
        this.myNotifyIconBackground = WL.scene.addObject(this.myNotifyIconPanel);
        this.myNotifyIconCursorTarget = WL.scene.addObject(this.myNotifyIconPanel);
    }

    _createButtonsSkeleton() {
        this.myButtonsPanel = WL.scene.addObject(this.myPivotObject);

        this.myFilterButtonsPanels = [];
        this.myFilterButtonsBackgrounds = [];
        this.myFilterButtonsTexts = [];
        this.myFilterButtonsCursorTargets = [];

        for (let key in PP.ConsoleVRWidget.MessageType) {
            this.myFilterButtonsPanels[PP.ConsoleVRWidget.MessageType[key]] = WL.scene.addObject(this.myButtonsPanel);
            this.myFilterButtonsBackgrounds[PP.ConsoleVRWidget.MessageType[key]] = WL.scene.addObject(this.myFilterButtonsPanels[PP.ConsoleVRWidget.MessageType[key]]);
            this.myFilterButtonsTexts[PP.ConsoleVRWidget.MessageType[key]] = WL.scene.addObject(this.myFilterButtonsPanels[PP.ConsoleVRWidget.MessageType[key]]);
            this.myFilterButtonsCursorTargets[PP.ConsoleVRWidget.MessageType[key]] = WL.scene.addObject(this.myFilterButtonsPanels[PP.ConsoleVRWidget.MessageType[key]]);
        }

        this.myClearButtonPanel = WL.scene.addObject(this.myButtonsPanel);
        this.myClearButtonBackground = WL.scene.addObject(this.myClearButtonPanel);
        this.myClearButtonText = WL.scene.addObject(this.myClearButtonPanel);
        this.myClearButtonCursorTarget = WL.scene.addObject(this.myClearButtonPanel);

        this.myUpButtonPanel = WL.scene.addObject(this.myButtonsPanel);
        this.myUpButtonBackground = WL.scene.addObject(this.myUpButtonPanel);
        this.myUpButtonText = WL.scene.addObject(this.myUpButtonPanel);
        this.myUpButtonCursorTarget = WL.scene.addObject(this.myUpButtonPanel);

        this.myDownButtonPanel = WL.scene.addObject(this.myButtonsPanel);
        this.myDownButtonBackground = WL.scene.addObject(this.myDownButtonPanel);
        this.myDownButtonText = WL.scene.addObject(this.myDownButtonPanel);
        this.myDownButtonCursorTarget = WL.scene.addObject(this.myDownButtonPanel);
    }

    _createPointerSkeleton() {
        this.myPointerCursorTarget = WL.scene.addObject(this.myPivotObject);
    }

    //Transforms
    _setTransforms() {
        this.myPivotObject.setDirty();

        this._setMessagesTransforms();
        this._setButtonsTransforms();
        this._setPointerTransform();
    }

    _setMessagesTransforms() {
        this.myMessagesPanel.setTranslationLocal(this._mySetup.myMessagesPanelPosition);
        this.myMessagesBackground.scale(this._mySetup.myMessagesBackgroundScale);

        this.myMessagesTextsPanel.setTranslationLocal(this._mySetup.myMessagesTextsPanelPosition);
        this.myMessagesTextsPanel.scale(this._mySetup.myMessagesTextsPanelScale);
        for (let key in PP.ConsoleVRWidget.MessageType) {
            this.myMessagesTexts[PP.ConsoleVRWidget.MessageType[key]].setTranslationLocal(this._mySetup.myMessagesTextPositions[PP.ConsoleVRWidget.MessageType[key]]);
        }

        this.myNotifyIconPanel.setTranslationLocal(this._mySetup.myNotifyIconPanelPositions[this._myAdditionalSetup.myHandedness]);
        this.myNotifyIconBackground.scale(this._mySetup.myNotifyIconBackgroundScale);
        this.myNotifyIconCursorTarget.setTranslationLocal(this._mySetup.myNotifyIconCursorTargetPosition);
    }

    _setButtonsTransforms() {
        this.myButtonsPanel.setTranslationLocal(this._mySetup.myButtonsPanelPosition);

        //Filter Buttons
        for (let key in PP.ConsoleVRWidget.MessageType) {
            this.myFilterButtonsPanels[PP.ConsoleVRWidget.MessageType[key]].setTranslationLocal(this._mySetup.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType[key]]);

            this.myFilterButtonsBackgrounds[PP.ConsoleVRWidget.MessageType[key]].scale(this._mySetup.myButtonBackgroundScale);

            this.myFilterButtonsTexts[PP.ConsoleVRWidget.MessageType[key]].setTranslationLocal(this._mySetup.myButtonTextPosition);
            this.myFilterButtonsTexts[PP.ConsoleVRWidget.MessageType[key]].scale(this._mySetup.myButtonTextScale);

            this.myFilterButtonsCursorTargets[PP.ConsoleVRWidget.MessageType[key]].setTranslationLocal(this._mySetup.myButtonCursorTargetPosition);
        }

        //Clear
        {
            this.myClearButtonPanel.setTranslationLocal(this._mySetup.myClearButtonPosition);

            this.myClearButtonBackground.scale(this._mySetup.myButtonBackgroundScale);

            this.myClearButtonText.setTranslationLocal(this._mySetup.myButtonTextPosition);
            this.myClearButtonText.scale(this._mySetup.myButtonTextScale);

            this.myClearButtonCursorTarget.setTranslationLocal(this._mySetup.myButtonCursorTargetPosition);
        }

        //Up
        {
            this.myUpButtonPanel.setTranslationLocal(this._mySetup.myUpButtonPosition);

            this.myUpButtonBackground.scale(this._mySetup.myButtonBackgroundScale);

            this.myUpButtonText.setTranslationLocal(this._mySetup.myButtonTextPosition);
            this.myUpButtonText.scale(this._mySetup.myButtonTextScale);

            this.myUpButtonCursorTarget.setTranslationLocal(this._mySetup.myButtonCursorTargetPosition);
        }

        //Down
        {
            this.myDownButtonPanel.setTranslationLocal(this._mySetup.myDownButtonPosition);

            this.myDownButtonBackground.scale(this._mySetup.myButtonBackgroundScale);

            this.myDownButtonText.setTranslationLocal(this._mySetup.myButtonTextPosition);
            this.myDownButtonText.scale(this._mySetup.myButtonTextScale);

            this.myDownButtonCursorTarget.setTranslationLocal(this._mySetup.myButtonCursorTargetPosition);
        }
    }

    _setPointerTransform() {
        this.myPointerCursorTarget.setTranslationLocal(this._mySetup.myPointerCursorTargetPosition);
    }

    //Components
    _addComponents() {
        this._addMessagesComponents();
        this._addButtonsComponents();
        this._addPointerComponents();
    }

    _addMessagesComponents() {
        let messagesBackgroundMeshComp = this.myMessagesBackground.addComponent('mesh');
        messagesBackgroundMeshComp.mesh = this._myPlaneMesh;
        messagesBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        messagesBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;

        this.myMessagesTextComponents = [];
        for (let key in PP.ConsoleVRWidget.MessageType) {
            let textComp = this.myMessagesTexts[PP.ConsoleVRWidget.MessageType[key]].addComponent('text');

            textComp.alignment = this._mySetup.myMessagesTextAlignment;
            textComp.justification = this._mySetup.myMessagesTextJustification;
            textComp.material = this._myAdditionalSetup.myTextMaterial.clone();
            textComp.material.color = this._mySetup.myMessagesTextColors[PP.ConsoleVRWidget.MessageType[key]];
            textComp.material.outlineColor = this._mySetup.myMessagesTextOutlineColors[PP.ConsoleVRWidget.MessageType[key]];
            textComp.material.outlineRange = this._mySetup.myMessagesTextOutlineRange;
            textComp.text = this._mySetup.myMessagesTextStartString;

            this.myMessagesTextComponents[PP.ConsoleVRWidget.MessageType[key]] = textComp;
        }

        this.myNotifyIconBackgroundComponent = this.myNotifyIconBackground.addComponent('mesh');
        this.myNotifyIconBackgroundComponent.mesh = this._myPlaneMesh;
        this.myNotifyIconBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myNotifyIconBackgroundComponent.material.color = this._mySetup.myNotifyIconColor;

        this.myNotifyIconCursorTargetComponent = this.myNotifyIconCursorTarget.addComponent('cursor-target');

        this.myNotifyIconCollisionComponent = this.myNotifyIconCursorTarget.addComponent('collision');
        this.myNotifyIconCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myNotifyIconCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myNotifyIconCollisionComponent.extents = this._mySetup.myNotifyIconCollisionExtents;
    }

    _addButtonsComponents() {
        //worship the code copy pasteness

        this.myFilterButtonsBackgroundComponents = [];
        this.myFilterButtonsTextComponents = [];
        this.myFilterButtonsCursorTargetComponents = [];
        this.myFilterButtonsCollisionComponents = [];

        //Filter Buttons
        for (let key in PP.ConsoleVRWidget.MessageType) {
            let buttonBackgroundMeshComp = this.myFilterButtonsBackgrounds[PP.ConsoleVRWidget.MessageType[key]].addComponent('mesh');
            buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
            buttonBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
            buttonBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;

            let buttonTextComp = this.myFilterButtonsTexts[PP.ConsoleVRWidget.MessageType[key]].addComponent('text');
            this._setupButtonTextComponent(buttonTextComp);
            buttonTextComp.material.color = this._mySetup.myFilterButtonsTextColors[PP.ConsoleVRWidget.MessageType[key]];
            buttonTextComp.material.outlineColor = this._mySetup.myFilterButtonsTextOutlineColors[PP.ConsoleVRWidget.MessageType[key]];
            buttonTextComp.text = this._mySetup.myFilterButtonsTextLabel[PP.ConsoleVRWidget.MessageType[key]];

            let buttonCursorTargetComp = this.myFilterButtonsCursorTargets[PP.ConsoleVRWidget.MessageType[key]].addComponent('cursor-target');

            let buttonCollisionComp = this.myFilterButtonsCursorTargets[PP.ConsoleVRWidget.MessageType[key]].addComponent('collision');
            buttonCollisionComp.collider = this._mySetup.myButtonsCollisionCollider;
            buttonCollisionComp.group = 1 << this._mySetup.myButtonsCollisionGroup;
            buttonCollisionComp.extents = this._mySetup.myButtonsCollisionExtents;

            this.myFilterButtonsBackgroundComponents[PP.ConsoleVRWidget.MessageType[key]] = buttonBackgroundMeshComp;
            this.myFilterButtonsTextComponents[PP.ConsoleVRWidget.MessageType[key]] = buttonTextComp;
            this.myFilterButtonsCursorTargetComponents[PP.ConsoleVRWidget.MessageType[key]] = buttonCursorTargetComp;
            this.myFilterButtonsCollisionComponents[PP.ConsoleVRWidget.MessageType[key]] = buttonCollisionComp;
        }

        //Clear 
        {
            let buttonBackgroundMeshComp = this.myClearButtonBackground.addComponent('mesh');
            buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
            buttonBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
            buttonBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;

            let buttonTextComp = this.myClearButtonText.addComponent('text');
            this._setupButtonTextComponent(buttonTextComp);
            buttonTextComp.text = this._mySetup.myClearButtonTextLabel;

            let buttonCursorTargetComp = this.myClearButtonCursorTarget.addComponent('cursor-target');

            let buttonCollisionComp = this.myClearButtonCursorTarget.addComponent('collision');
            buttonCollisionComp.collider = this._mySetup.myButtonsCollisionCollider;
            buttonCollisionComp.group = 1 << this._mySetup.myButtonsCollisionGroup;
            buttonCollisionComp.extents = this._mySetup.myButtonsCollisionExtents;

            this.myClearButtonBackgroundComponent = buttonBackgroundMeshComp;
            this.myClearButtonTextComponent = buttonTextComp;
            this.myClearButtonCursorTargetComponent = buttonCursorTargetComp;
            this.myClearButtonCollisionComponent = buttonCollisionComp;
        }

        //Up 
        {
            let buttonBackgroundMeshComp = this.myUpButtonBackground.addComponent('mesh');
            buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
            buttonBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
            buttonBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;

            let buttonTextComp = this.myUpButtonText.addComponent('text');
            this._setupButtonTextComponent(buttonTextComp);
            buttonTextComp.text = this._mySetup.myUpButtonTextLabel;

            let buttonCursorTargetComp = this.myUpButtonCursorTarget.addComponent('cursor-target');

            let buttonCollisionComp = this.myUpButtonCursorTarget.addComponent('collision');
            buttonCollisionComp.collider = this._mySetup.myButtonsCollisionCollider;
            buttonCollisionComp.group = 1 << this._mySetup.myButtonsCollisionGroup;
            buttonCollisionComp.extents = this._mySetup.myButtonsCollisionExtents;

            this.myUpButtonBackgroundComponent = buttonBackgroundMeshComp;
            this.myUpButtonTextComponent = buttonTextComp;
            this.myUpButtonCursorTargetComponent = buttonCursorTargetComp;
            this.myUpButtonCollisionComponent = buttonCollisionComp;
        }

        //Down 
        {
            let buttonBackgroundMeshComp = this.myDownButtonBackground.addComponent('mesh');
            buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
            buttonBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
            buttonBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;

            let buttonTextComp = this.myDownButtonText.addComponent('text');
            this._setupButtonTextComponent(buttonTextComp);
            buttonTextComp.text = this._mySetup.myDownButtonTextLabel;

            let buttonCursorTargetComp = this.myDownButtonCursorTarget.addComponent('cursor-target');

            let buttonCollisionComp = this.myDownButtonCursorTarget.addComponent('collision');
            buttonCollisionComp.collider = this._mySetup.myButtonsCollisionCollider;
            buttonCollisionComp.group = 1 << this._mySetup.myButtonsCollisionGroup;
            buttonCollisionComp.extents = this._mySetup.myButtonsCollisionExtents;

            this.myDownButtonBackgroundComponent = buttonBackgroundMeshComp;
            this.myDownButtonTextComponent = buttonTextComp;
            this.myDownButtonCursorTargetComponent = buttonCursorTargetComp;
            this.myDownButtonCollisionComponent = buttonCollisionComp;
        }
    }

    _addPointerComponents() {
        this.myPointerCursorTargetComponent = this.myPointerCursorTarget.addComponent('cursor-target');
        this.myPointerCursorTargetComponent.myPreventPulseOnHover = true;

        let collisionComp = this.myPointerCursorTarget.addComponent('collision');
        collisionComp.collider = this._mySetup.myPointerCollisionCollider;
        collisionComp.group = 1 << this._mySetup.myPointerCollisionGroup;
        collisionComp.extents = this._mySetup.myPointerCollisionExtents;

        this.myPointerCollisionComponent = collisionComp;
    }

    _setupButtonTextComponent(textComponent) {
        textComponent.alignment = this._mySetup.myTextAlignment;
        textComponent.justification = this._mySetup.myTextJustification;
        textComponent.material = this._myAdditionalSetup.myTextMaterial.clone();
        textComponent.material.outlineRange = this._mySetup.myTextOutlineRange;
        textComponent.material.color = this._mySetup.myTextColor;
        textComponent.material.outlineColor = this._mySetup.myTextOutlineColor;
        textComponent.text = "";
    }
};

PP.WidgetFrame = class WidgetFrame {

    constructor(widgetLetterID, buttonsColumnIndex) {
        this.myIsWidgetVisible = true;
        this.myIsPinned = false;

        this._mySetup = new PP.WidgetFrameSetup(widgetLetterID, buttonsColumnIndex);
        this._myAdditionalSetup = null;

        this._myUI = new PP.WidgetFrameUI();

        this._myWidgetVisibleChangedCallbacks = new Map();      // Signature: callback(isWidgetVisible)
        this._myPinChangedCallbacks = new Map();                // Signature: callback(isPinned)
    }

    getWidgetObject() {
        return this._myUI.myWidgetObject;
    }

    toggleVisibility() {
        this._toggleVisibility(false, true);
    }

    togglePin() {
        this._togglePin(false);
    }

    registerWidgetVisibleChangedEventListener(id, callback) {
        this._myWidgetVisibleChangedCallbacks.set(id, callback);
    }

    unregisterWidgetVisibleChangedEventListener(id) {
        this._myWidgetVisibleChangedCallbacks.delete(id);
    }

    registerPinChangedEventListener(id, callback) {
        this._myPinChangedCallbacks.set(id, callback);
    }

    unregisterPinChangedEventListener(id) {
        this._myPinChangedCallbacks.delete(id);
    }

    start(parentObject, additionalSetup) {
        this._myAdditionalSetup = additionalSetup;

        this._myUI.build(parentObject, this._mySetup, additionalSetup);
        this._myUI.setVisibilityButtonVisible(additionalSetup.myShowVisibilityButton);
        if (!additionalSetup.myShowOnStart) {
            this._toggleVisibility(false, false);
        }

        this._addListeners();
    }

    update(dt) {
        this._myUI.update(dt);
    }

    _addListeners() {
        let ui = this._myUI;

        ui.myPinButtonCursorTargetComponent.addClickFunction(this._togglePin.bind(this, true));
        ui.myPinButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPinButtonBackgroundComponent.material));
        ui.myPinButtonCursorTargetComponent.addUnHoverFunction(this._pinUnHover.bind(this, ui.myPinButtonBackgroundComponent.material));

        if (this._myAdditionalSetup.myShowVisibilityButton) {
            ui.myVisibilityButtonCursorTargetComponent.addClickFunction(this._toggleVisibility.bind(this, true, true));
            ui.myVisibilityButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
            ui.myVisibilityButtonCursorTargetComponent.addUnHoverFunction(this._visibilityUnHover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
        }
    }

    _toggleVisibility(isButton, notify) {
        this.myIsWidgetVisible = !this.myIsWidgetVisible;

        this._myUI.setWidgetVisible(this.myIsWidgetVisible);

        let textMaterial = this._myUI.myVisibilityButtonTextComponent.material;
        let backgroundMaterial = this._myUI.myVisibilityButtonBackgroundComponent.material;
        if (this.myIsWidgetVisible) {
            textMaterial.color = this._mySetup.myDefaultTextColor;
            if (!isButton) {
                backgroundMaterial.color = this._mySetup.myBackgroundColor;
            }
        } else {
            textMaterial.color = this._mySetup.myButtonDisabledTextColor;
            if (!isButton) {
                backgroundMaterial.color = this._mySetup.myButtonDisabledBackgroundColor;
            }
        }

        if (notify) {
            for (let callback of this._myWidgetVisibleChangedCallbacks.values()) {
                callback(this.myIsWidgetVisible);
            }
        }
    }

    _togglePin(isButton) {
        if (this.myIsWidgetVisible) {
            this.myIsPinned = !this.myIsPinned;

            this._myUI.setPinned(this.myIsPinned);

            let textMaterial = this._myUI.myPinButtonTextComponent.material;
            let backgroundMaterial = this._myUI.myPinButtonBackgroundComponent.material;
            if (this.myIsPinned) {
                textMaterial.color = this._mySetup.myDefaultTextColor;
                if (!isButton) {
                    backgroundMaterial.color = this._mySetup.myBackgroundColor;
                }
            } else {
                textMaterial.color = this._mySetup.myButtonDisabledTextColor;
                if (!isButton) {
                    backgroundMaterial.color = this._mySetup.myButtonDisabledBackgroundColor;
                }
            }

            for (let callback of this._myPinChangedCallbacks.values()) {
                callback(this.myIsPinned);
            }
        }
    }

    _genericHover(material) {
        material.color = this._mySetup.myButtonHoverColor;
    }

    _visibilityUnHover(material) {
        if (this.myIsWidgetVisible) {
            material.color = this._mySetup.myBackgroundColor;
        } else {
            material.color = this._mySetup.myButtonDisabledBackgroundColor;
        }
    }

    _pinUnHover(material) {
        if (this.myIsPinned) {
            material.color = this._mySetup.myBackgroundColor;
        } else {
            material.color = this._mySetup.myButtonDisabledBackgroundColor;
        }
    }
};
PP.WidgetFrameSetup = class WidgetFrameSetup {

    constructor(widgetLetterID, buttonsColumnIndex) {

        this._initializeBuildSetup(widgetLetterID, buttonsColumnIndex);
        this._initializeRuntimeSetup();
    }

    _initializeBuildSetup(widgetLetterID, buttonsColumnIndex) {
        //General
        this.myBackgroundColor = [46 / 255, 46 / 255, 46 / 255, 1];

        this.myCursorTargetCollisionCollider = 2; // box
        this.myCursorTargetCollisionGroup = 7;
        this.myCursorTargetCollisionThickness = 0.001;

        this.myDefaultTextColor = [255 / 255, 255 / 255, 255 / 255, 1];

        this.myTextAlignment = 2; // center
        this.myTextJustification = 2; // middle
        this.myTextOutlineRange = [0.45, 0.45];
        this.myTextColor = this.myDefaultTextColor;
        this.myTextOutlineColor = this.myDefaultTextColor;


        this.myVisibilityButtonBackgroundScale = [0.015, 0.015, 1];
        this.myVisibilityButtonTextPosition = [0, 0, 0.007];
        this.myVisibilityButtonTextScale = [0.18, 0.18, 0.18];

        let distanceBetweenToolsVisibilityButtons = 0.01;
        let buttonXOffset = this.myVisibilityButtonBackgroundScale[0] * (2 * buttonsColumnIndex) + distanceBetweenToolsVisibilityButtons * buttonsColumnIndex;

        this.myVisibilityButtonPosition = [];
        this.myVisibilityButtonPosition[PP.ToolHandedness.NONE] = {};
        this.myVisibilityButtonPosition[PP.ToolHandedness.NONE].myPosition = [-0.3 + buttonXOffset, -0.205, 0.035];

        this.myVisibilityButtonPosition[PP.ToolHandedness.LEFT] = {};
        this.myVisibilityButtonPosition[PP.ToolHandedness.LEFT].myPosition = [-0.2 + buttonXOffset, 0.025, 0.015];

        this.myVisibilityButtonPosition[PP.ToolHandedness.RIGHT] = {};
        this.myVisibilityButtonPosition[PP.ToolHandedness.RIGHT].myPosition = [0.2 - buttonXOffset, 0.025, 0.015];

        this.myVisibilityButtonText = widgetLetterID;

        this.myVisibilityButtonCursorTargetPosition = [0, 0, 0];
        this.myVisibilityButtonCursorTargetPosition[2] = this.myVisibilityButtonTextPosition[2];
        this.myVisibilityButtonCollisionExtents = this.myVisibilityButtonBackgroundScale.slice(0);
        this.myVisibilityButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myFlagButtonBackgroundScale = [0.0125, 0.0125, 1];
        this.myFlagButtonTextPosition = [0, 0, 0.007];
        this.myFlagButtonTextScale = [0.15, 0.15, 0.15];

        let distanceBetweenFlagButtons = 0.0075;
        let pinFlagIndex = 0;
        let pinButtonYOffset = this.myVisibilityButtonBackgroundScale[1] + this.myFlagButtonBackgroundScale[1] + distanceBetweenFlagButtons +
            this.myFlagButtonBackgroundScale[1] * (2 * pinFlagIndex) + distanceBetweenFlagButtons * pinFlagIndex;

        this.myPinButtonPosition = [];
        this.myPinButtonPosition[PP.ToolHandedness.NONE] = {};
        this.myPinButtonPosition[PP.ToolHandedness.NONE].myPosition = this.myVisibilityButtonPosition[PP.ToolHandedness.NONE].myPosition.slice(0);
        this.myPinButtonPosition[PP.ToolHandedness.NONE].myPosition[1] += pinButtonYOffset;

        this.myPinButtonPosition[PP.ToolHandedness.LEFT] = {};
        this.myPinButtonPosition[PP.ToolHandedness.LEFT].myPosition = this.myVisibilityButtonPosition[PP.ToolHandedness.LEFT].myPosition.slice(0);
        this.myPinButtonPosition[PP.ToolHandedness.LEFT].myPosition[1] += pinButtonYOffset;

        this.myPinButtonPosition[PP.ToolHandedness.RIGHT] = {};
        this.myPinButtonPosition[PP.ToolHandedness.RIGHT].myPosition = this.myVisibilityButtonPosition[PP.ToolHandedness.RIGHT].myPosition.slice(0);
        this.myPinButtonPosition[PP.ToolHandedness.RIGHT].myPosition[1] += pinButtonYOffset;

        this.myPinButtonText = "P";

        this.myPinButtonCursorTargetPosition = [0, 0, 0];
        this.myPinButtonCursorTargetPosition[2] = this.myFlagButtonTextPosition[2];
        this.myPinButtonCollisionExtents = this.myFlagButtonBackgroundScale.slice(0);
        this.myPinButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    }

    _initializeRuntimeSetup() {
        this._initializeObjectsTransforms();

        this.myButtonHoverColor = [150 / 255, 150 / 255, 150 / 255, 1];
        this.myButtonDisabledTextColor = this.myBackgroundColor;
        this.myButtonDisabledBackgroundColor = [110 / 255, 110 / 255, 110 / 255, 1];
    }

    _initializeObjectsTransforms() {
        this.myPivotObjectTransforms = this._createDefaultObjectTransforms();

        this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.LEFT].myRotation = [-0.645, 0.425, 0.25, 0.584];
        glMatrix.quat.normalize(this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.LEFT].myRotation, this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.LEFT].myRotation);

        this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.RIGHT].myRotation = [-0.645, -0.425, -0.25, 0.584];
        glMatrix.quat.normalize(this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.RIGHT].myRotation, this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.RIGHT].myRotation);

        this.myPivotObjectTransforms[PP.ToolInputSourceType.HAND][PP.ToolHandedness.LEFT].myPosition = [-0.04, 0.045, -0.055];
        this.myPivotObjectTransforms[PP.ToolInputSourceType.HAND][PP.ToolHandedness.LEFT].myRotation = [0, 0.536, -0.43, 0.727];
        glMatrix.quat.normalize(this.myPivotObjectTransforms[PP.ToolInputSourceType.HAND][PP.ToolHandedness.LEFT].myRotation, this.myPivotObjectTransforms[PP.ToolInputSourceType.HAND][PP.ToolHandedness.LEFT].myRotation);

        this.myPivotObjectTransforms[PP.ToolInputSourceType.HAND][PP.ToolHandedness.RIGHT].myPosition = [0.04, 0.045, -0.055];
        this.myPivotObjectTransforms[PP.ToolInputSourceType.HAND][PP.ToolHandedness.RIGHT].myRotation = [0, -0.536, 0.43, 0.727];
        glMatrix.quat.normalize(this.myPivotObjectTransforms[PP.ToolInputSourceType.HAND][PP.ToolHandedness.RIGHT].myRotation, this.myPivotObjectTransforms[PP.ToolInputSourceType.HAND][PP.ToolHandedness.RIGHT].myRotation);

        this.myWidgetObjectTransforms = this._createDefaultObjectTransforms();

        this.myWidgetObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.LEFT].myPosition = [0.1, 0.23, -0.02];
        this.myWidgetObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.RIGHT].myPosition = [0.07, 0.23, -0.02];

        this.myWidgetObjectTransforms[PP.ToolInputSourceType.HAND][PP.ToolHandedness.LEFT].myPosition = [0.1, 0.23, -0.02];
        this.myWidgetObjectTransforms[PP.ToolInputSourceType.HAND][PP.ToolHandedness.RIGHT].myPosition = [0.07, 0.23, -0.02];

    }

    _createDefaultObjectTransforms() {
        let defaultObjectTransforms = [];

        for (let inputSourceTypeKey in PP.ToolInputSourceType) {
            let inputSourceType = PP.ToolInputSourceType[inputSourceTypeKey];
            defaultObjectTransforms[inputSourceType] = [];
            for (let handednessKey in PP.ToolHandedness) {
                let handedness = PP.ToolHandedness[handednessKey];
                defaultObjectTransforms[inputSourceType][handedness] = {};
                defaultObjectTransforms[inputSourceType][handedness].myPosition = [0, 0, 0];
                defaultObjectTransforms[inputSourceType][handedness].myRotation = [0, 0, 0, 1];
            }
        }

        return defaultObjectTransforms;
    }
};

PP.WidgetFrameUI = class WidgetFrameUI {

    constructor() {
        this._myInputSourceType = null;

        this._myParentObject = null;
        this._myIsPinned = false;
    }

    build(parentObject, setup, additionalSetup) {
        this._myParentObject = parentObject;
        this._mySetup = setup;
        this._myAdditionalSetup = additionalSetup;
        this._myPlaneMesh = PP.MeshUtils.createPlaneMesh();

        this._createSkeleton();
        this._setTransforms();
        this._addComponents();
    }

    setWidgetVisible(visible) {
        this.myFlagsButtonPanel.pp_setActiveHierarchy(visible);
        if (visible) {
            this._updateObjectsTransforms(true);
        }
    }

    setVisibilityButtonVisible(visible) {
        this.myVisibilityButtonPanel.pp_setActiveHierarchy(visible);
    }

    setPinned(pinned) {
        if (pinned != this._myIsPinned) {
            this._myIsPinned = pinned;
            if (this._myIsPinned) {
                this.myPivotObject.pp_setParent(null);
            } else {
                this.myPivotObject.pp_setParent(this.myFixForwardObject);
                this._updateObjectsTransforms(true);
            }
        }
    }

    update(dt) {
        this._updateObjectsTransforms(false);
    }

    _updateObjectsTransforms(forceRefreshObjectsTransforms) {
        let inputSourceType = PP.InputUtils.getInputSourceType(this._myAdditionalSetup.myHandedness);

        if (inputSourceType != this._myInputSourceType || forceRefreshObjectsTransforms) {
            this._myInputSourceType = inputSourceType;

            if (!this._myIsPinned) {
                this.myPivotObject.setTranslationLocal(this._mySetup.myPivotObjectTransforms[this._myInputSourceType][this._myAdditionalSetup.myHandedness].myPosition);
                this.myPivotObject.resetRotation();
                this.myPivotObject.rotateObject(this._mySetup.myPivotObjectTransforms[this._myInputSourceType][this._myAdditionalSetup.myHandedness].myRotation);
            }

            this.myWidgetObject.setTranslationLocal(this._mySetup.myWidgetObjectTransforms[this._myInputSourceType][this._myAdditionalSetup.myHandedness].myPosition);
            this.myWidgetObject.resetRotation();
            this.myWidgetObject.rotateObject(this._mySetup.myWidgetObjectTransforms[this._myInputSourceType][this._myAdditionalSetup.myHandedness].myRotation);
        }
    }

    //Skeleton
    _createSkeleton() {
        this.myFixForwardObject = WL.scene.addObject(this._myParentObject);
        this.myFixForwardObject.pp_rotateObject([0, 180, 0]);
        this.myPivotObject = WL.scene.addObject(this.myFixForwardObject);
        this.myWidgetObject = WL.scene.addObject(this.myPivotObject);

        this.myVisibilityButtonPanel = WL.scene.addObject(this.myPivotObject);
        this.myVisibilityButtonBackground = WL.scene.addObject(this.myVisibilityButtonPanel);
        this.myVisibilityButtonText = WL.scene.addObject(this.myVisibilityButtonPanel);
        this.myVisibilityButtonCursorTarget = WL.scene.addObject(this.myVisibilityButtonPanel);

        this.myFlagsButtonPanel = WL.scene.addObject(this.myPivotObject);

        this.myPinButtonPanel = WL.scene.addObject(this.myFlagsButtonPanel);
        this.myPinButtonBackground = WL.scene.addObject(this.myPinButtonPanel);
        this.myPinButtonText = WL.scene.addObject(this.myPinButtonPanel);
        this.myPinButtonCursorTarget = WL.scene.addObject(this.myPinButtonPanel);
    }

    //Transforms
    _setTransforms() {
        this.myPivotObject.setDirty();

        this.myVisibilityButtonPanel.setTranslationLocal(this._mySetup.myVisibilityButtonPosition[this._myAdditionalSetup.myHandedness].myPosition);
        this.myVisibilityButtonBackground.scale(this._mySetup.myVisibilityButtonBackgroundScale);
        this.myVisibilityButtonText.setTranslationLocal(this._mySetup.myVisibilityButtonTextPosition);
        this.myVisibilityButtonText.scale(this._mySetup.myVisibilityButtonTextScale);
        this.myVisibilityButtonCursorTarget.setTranslationLocal(this._mySetup.myVisibilityButtonCursorTargetPosition);

        this.myPinButtonPanel.setTranslationLocal(this._mySetup.myPinButtonPosition[this._myAdditionalSetup.myHandedness].myPosition);

        this.myPinButtonBackground.scale(this._mySetup.myFlagButtonBackgroundScale);
        this.myPinButtonText.setTranslationLocal(this._mySetup.myFlagButtonTextPosition);
        this.myPinButtonText.scale(this._mySetup.myFlagButtonTextScale);
        this.myPinButtonCursorTarget.setTranslationLocal(this._mySetup.myPinButtonCursorTargetPosition);
    }

    //Components
    _addComponents() {
        this.myVisibilityButtonBackgroundComponent = this.myVisibilityButtonBackground.addComponent('mesh');
        this.myVisibilityButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myVisibilityButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myVisibilityButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myVisibilityButtonTextComponent = this.myVisibilityButtonText.addComponent('text');
        this._setupButtonTextComponent(this.myVisibilityButtonTextComponent);
        this.myVisibilityButtonTextComponent.text = this._mySetup.myVisibilityButtonText;

        this.myVisibilityButtonCursorTargetComponent = this.myVisibilityButtonCursorTarget.addComponent('cursor-target');
        this.myVisibilityButtonCollisionComponent = this.myVisibilityButtonCursorTarget.addComponent('collision');
        this.myVisibilityButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myVisibilityButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myVisibilityButtonCollisionComponent.extents = this._mySetup.myVisibilityButtonCollisionExtents;

        this.myPinButtonBackgroundComponent = this.myPinButtonBackground.addComponent('mesh');
        this.myPinButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myPinButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myPinButtonBackgroundComponent.material.color = this._mySetup.myButtonDisabledBackgroundColor;

        this.myPinButtonTextComponent = this.myPinButtonText.addComponent('text');
        this._setupButtonTextComponent(this.myPinButtonTextComponent);
        this.myPinButtonTextComponent.material.color = this._mySetup.myButtonDisabledTextColor;
        this.myPinButtonTextComponent.text = this._mySetup.myPinButtonText;

        this.myPinButtonCursorTargetComponent = this.myPinButtonCursorTarget.addComponent('cursor-target');

        this.myPinButtonCollisionComponent = this.myPinButtonCursorTarget.addComponent('collision');
        this.myPinButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPinButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPinButtonCollisionComponent.extents = this._mySetup.myPinButtonCollisionExtents;
    }

    _setupButtonTextComponent(textComponent) {
        textComponent.alignment = this._mySetup.myTextAlignment;
        textComponent.justification = this._mySetup.myTextJustification;
        textComponent.material = this._myAdditionalSetup.myTextMaterial.clone();
        textComponent.material.outlineRange = this._mySetup.myTextOutlineRange;
        textComponent.material.color = this._mySetup.myTextColor;
        textComponent.material.outlineColor = this._mySetup.myTextOutlineColor;
        textComponent.text = "";
    }
};
//Don't move inside easy_object_tuners folder, otherwise it won't resolve the parent class dependency

PP.EasyObjectTuner = class EasyObjectTuner {
    constructor(object, variableName, setAsDefault, useTuneTarget) {
        this._myObject = object;
        this._myUseTuneTarget = useTuneTarget;
        this._mySetAsDefault = setAsDefault;

        this._myEasyObject = this._myObject;
        if (this._myUseTuneTarget) {
            this._myEasyObject = PP.myEasyTuneTarget;
        }
        this._myPrevEasyObject = null;

        let variableNamePrefix = this._getVariableNamePrefix();

        if (variableName == "") {
            this._myEasyTuneVariableName = variableNamePrefix.concat(this._myObject.objectId);
        } else {
            this._myEasyTuneVariableName = variableNamePrefix.concat(variableName);
        }
    }

    start() {
        let easyTuneVariable = this._createEasyTuneVariable(this._myEasyTuneVariableName);

        PP.myEasyTuneVariables.add(easyTuneVariable);
        if (this._mySetAsDefault) {
            PP.setEasyTuneWidgetActiveVariable(this._myEasyTuneVariableName);
        }
    }

    update(dt) {
        if (PP.myEasyTuneVariables.isActive(this._myEasyTuneVariableName)) {
            if (this._myUseTuneTarget) {
                this._myEasyObject = PP.myEasyTuneTarget;
            }

            if (this._myPrevEasyObject != this._myEasyObject) {
                this._myPrevEasyObject = this._myEasyObject;
                if (this._myEasyObject) {
                    let value = this._getObjectValue(this._myEasyObject);
                    PP.myEasyTuneVariables.set(this._myEasyTuneVariableName, value, true);
                } else {
                    let value = this._getDefaultValue();
                    PP.myEasyTuneVariables.set(this._myEasyTuneVariableName, value, true);
                }
            }

            if (this._myEasyObject) {
                this._updateObjectValue(this._myEasyObject, PP.myEasyTuneVariables.get(this._myEasyTuneVariableName));
            }
        }
    }

    updateVariableValue(value) {
        PP.myEasyTuneVariables.set(this._myEasyTuneVariableName, value);
    }
};
WL.registerComponent('pp-easy-tune', {
    _myHandedness: { type: WL.Type.Enum, values: ['none', 'left', 'right'], default: 'none' },
    _myShowOnStart: { type: WL.Type.Bool, default: false },
    _myShowVisibilityButton: { type: WL.Type.Bool, default: true },
    _myEnableAdditionalButtons: { type: WL.Type.Bool, default: false },
    _myEnableChangeVariableShortcut: { type: WL.Type.Bool, default: true },
    _myPlaneMaterial: { type: WL.Type.Material, default: null },
    _myTextMaterial: { type: WL.Type.Material, default: null }
}, {
    init: function () {
        //Examples
        //Number: PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Speed", 10.32, 0.01, 3));
        //Int: PP.myEasyTuneVariables.add(new PP.EasyTuneInt("Lives", 3, 1));
        //Bool: PP.myEasyTuneVariables.add(new PP.EasyTuneBool("Run", false));

        PP.myEasyTuneVariables = new PP.EasyTuneVariables();

        this._myWidget = new PP.EasyTuneWidget();
        PP.setEasyTuneWidgetActiveVariable = function (variableName) {
            this._myWidget.setActiveVariable(variableName);
        }.bind(this);
        PP.refreshEasyTuneWidget = function () {
            this._myWidget.refresh();
        }.bind(this);
    },
    start: function () {

        let additionalSetup = {};
        additionalSetup.myHandedness = [null, 'left', 'right'][this._myHandedness];
        additionalSetup.myShowOnStart = this._myShowOnStart;
        additionalSetup.myShowVisibilityButton = this._myShowVisibilityButton;
        additionalSetup.myEnableAdditionalButtons = this._myEnableAdditionalButtons;
        additionalSetup.myEnableChangeVariableShortcut = this._myEnableChangeVariableShortcut;
        additionalSetup.myPlaneMaterial = this._myPlaneMaterial;
        additionalSetup.myTextMaterial = this._myTextMaterial;

        this._myWidget.start(this.object, additionalSetup, PP.myEasyTuneVariables._getInternalMap());
    },
    update: function (dt) {
        this._myWidget.update(dt);
    }
});

PP.myEasyTuneVariables = null;

PP.myEasyTuneTarget = null;

PP.setEasyTuneWidgetActiveVariable = function () {
    console.log("setEasyTuneWidgetActiveVariable function not initialized yet");
};

PP.refreshEasyTuneWidget = function () {
    console.log("refreshEasyTuneWidget function not initialized yet");
};
//Variable Map
PP.EasyTuneVariables = class EasyTuneVariables {
    constructor() {
        this._myMap = new Map();
    }

    add(variable) {
        this._myMap.set(variable.myName, variable);
    }

    remove(variableName) {
        this._myMap.delete(variableName);
    }

    get(variableName) {
        let variable = this._myMap.get(variableName);
        if (variable) {
            return variable.getValue();
        }

        return null;
    }

    set(variableName, value, resetInitialValue = false) {
        let variable = this._myMap.get(variableName);
        if (variable) {
            variable.setValue(value, resetInitialValue);
        }
    }

    isActive(variableName) {
        let variable = this._myMap.get(variableName);
        if (variable) {
            return variable.myIsActive;
        }

        return false;
    }

    getEasyTuneVariable(variableName) {
        return this._myMap.get(variableName);
    }

    _getInternalMap() {
        return this._myMap;
    }

    registerValueChangedEventListener(variableName, callbackID, callback) {
        this._myMap.get(variableName).registerValueChangedEventListener(callbackID, callback);
    }

    unregisterValueChangedEventListener(variableName, callbackID, callback) {
        this._myMap.get(variableName).unregisterValueChangedEventListener(callbackID);
    }
};

//Variable Types
PP.EasyTuneVariableType = {
    NONE: 0,
    NUMBER: 1,
    BOOL: 2,
    EASY_TRANSFORM: 3
};

PP.EasyTuneVariable = class EasyTuneVariable {
    constructor(name, type) {
        this.myName = name.slice(0);
        this.myType = type;

        this.myValue = null;
        this.myInitialValue = null;

        this.myIsActive = false;

        this._myValueChangedCallbacks = new Map();      // Signature: callback(name, value)
    }

    getValue() {
        return this.myValue;
    }

    setValue(value, resetInitialValue = false) {
        let oldValue = this.myValue;
        this.myValue = value;

        if (resetInitialValue) {
            PP.EasyTuneVariable.prototype.setInitialValue.call(this, value);
        }

        PP.refreshEasyTuneWidget();

        if (oldValue != value) {
            this._triggerValueChangedCallback();
        }
    }

    setInitialValue(value) {
        this.myInitialValue = value;
    }

    registerValueChangedEventListener(id, callback) {
        this._myValueChangedCallbacks.set(id, callback);
    }

    unregisterValueChangedEventListener(id) {
        this._myValueChangedCallbacks.delete(id);
    }

    _triggerValueChangedCallback() {
        if (this._myValueChangedCallbacks.size > 0) {
            this._myValueChangedCallbacks.forEach(function (callback) { callback(this.myName, this.getValue()); }.bind(this));
        }
    }
};

PP.EasyTuneVariableArray = class EasyTuneVariableArray extends PP.EasyTuneVariable {
    constructor(name, type, value) {
        super(name, type);

        PP.EasyTuneVariableArray.prototype.setValue.call(this, value, true);
    }

    getValue() {
        return this.myValue.slice(0);
    }

    setValue(value, resetInitialValue = false) {
        let oldValue = this.myValue;
        this.myValue = value.slice(0);

        if (resetInitialValue) {
            PP.EasyTuneVariableArray.prototype.setInitialValue.call(this, value);
        }

        PP.refreshEasyTuneWidget();

        if (oldValue == null || !oldValue.pp_equals(value)) {
            this._triggerValueChangedCallback();
        }
    }

    setInitialValue(value) {
        this.myInitialValue = value.slice(0);
    }
};

//NUMBER

PP.EasyTuneNumberArray = class EasyTuneNumberArray extends PP.EasyTuneVariableArray {
    constructor(name, value, stepPerSecond, decimalPlaces, min = null, max = null, editAllValuesTogether = false) {
        super(name, PP.EasyTuneVariableType.NUMBER, value);

        this.myDecimalPlaces = decimalPlaces;
        this.myStepPerSecond = stepPerSecond;

        this.myInitialStepPerSecond = this.myStepPerSecond;

        this.myMin = min;
        this.myMax = max;

        this.myEditAllValuesTogether = editAllValuesTogether;

        this._clampValue(true);
    }

    setMax(max) {
        this.myMax = max;
        this._clampValue(false);
    }

    setMin(min) {
        this.myMin = min;
        this._clampValue(false);
    }

    _clampValue(resetInitialValue) {
        let clampedValue = this.myValue.vec_clamp(this.myMin, this.myMax);

        if (!resetInitialValue) {
            let clampedInitialValue = this.myInitialValue.vec_clamp(this.myMin, this.myMax);
            let initialValueChanged = !clampedInitialValue.vec_equals(this.myInitialValue);
            if (initialValueChanged) {
                PP.EasyTuneVariableArray.prototype.setInitialValue.call(this, clampedInitialValue);
            }
        }

        PP.EasyTuneVariableArray.prototype.setValue.call(this, clampedValue, resetInitialValue);
    }
};

PP.EasyTuneNumber = class EasyTuneNumber extends PP.EasyTuneNumberArray {
    constructor(name, value, stepPerSecond, decimalPlaces, min, max) {
        super(name, [value], stepPerSecond, decimalPlaces, min, max);
    }

    getValue() {
        return this.myValue[0];
    }

    setValue(value, resetInitialValue = false) {
        super.setValue([value], resetInitialValue);
    }

    setInitialValue(value) {
        super.setValue([value]);
    }
};

PP.EasyTuneInt = class EasyTuneInt extends PP.EasyTuneNumber {
    constructor(name, value, stepPerSecond, min, max) {
        super(name, value, stepPerSecond, 0, min, max);
    }
};

PP.EasyTuneIntArray = class EasyTuneIntArray extends PP.EasyTuneNumberArray {
    constructor(name, value, stepPerSecond, min, max) {
        let tempValue = value.slice(0);

        for (let i = 0; i < value.length; i++) {
            tempValue[i] = Math.round(tempValue[i]);
        }

        super(name, tempValue, stepPerSecond, 0, Math.round(min), Math.round(max));
    }
};

//BOOL

PP.EasyTuneBoolArray = class EasyTuneBoolArray extends PP.EasyTuneVariableArray {
    constructor(name, value) {
        super(name, PP.EasyTuneVariableType.BOOL, value);
    }
};

PP.EasyTuneBool = class EasyTuneBool extends PP.EasyTuneBoolArray {
    constructor(name, value) {
        super(name, [value]);
    }

    getValue() {
        return this.myValue[0];
    }

    setValue(value, resetInitialValue = false) {
        super.setValue([value], resetInitialValue);
    }

    setInitialValue(value) {
        super.setValue([value]);
    }
};

//EASY TUNE EASY TRANSFORM

PP.EasyTuneSimpleTransform = class EasyTuneSimpleTransform extends PP.EasyTuneVariable {
    constructor(name, value, scaleAsOne = true, positionStepPerSecond = 1, rotationStepPerSecond = 50, scaleStepPerSecond = 1) {
        super(name, PP.EasyTuneVariableType.EASY_TRANSFORM);

        this.myDecimalPlaces = 3;

        this.myPosition = value.mat4_getPosition();
        this.myRotation = value.mat4_getRotationDegrees();
        this.myScale = value.mat4_getScale();

        let decimalPlacesMultiplier = Math.pow(10, this.myDecimalPlaces);
        for (let i = 0; i < 3; i++) {
            this.myScale[i] = Math.max(this.myScale[i], 1 / decimalPlacesMultiplier);
        }

        this.myScaleAsOne = scaleAsOne;

        this.myPositionStepPerSecond = positionStepPerSecond;
        this.myRotationStepPerSecond = rotationStepPerSecond;
        this.myScaleStepPerSecond = scaleStepPerSecond;

        this.myInitialPosition = this.myPosition.vec3_clone();
        this.myInitialRotation = this.myRotation.vec3_clone();
        this.myInitialScale = this.myScale.vec3_clone();

        this.myInitialPositionStepPerSecond = this.myPositionStepPerSecond;
        this.myInitialRotationStepPerSecond = this.myRotationStepPerSecond;
        this.myInitialScaleStepPerSecond = this.myScaleStepPerSecond;

        this.myTransform = mat4_create();
        this.myTransform.mat4_setPositionRotationDegreesScale(this.myPosition, this.myRotation, this.myScale);

        this.myTempTransform = mat4_create();
    }

    getValue() {
        this.myTransform.mat4_setPositionRotationDegreesScale(this.myPosition, this.myRotation, this.myScale);
        return this.myTransform.slice(0);
    }

    setValue(value, resetInitialValue = false) {
        this.myTempTransform.mat4_setPositionRotationDegreesScale(this.myPosition, this.myRotation, this.myScale);

        value.mat4_getPosition(this.myPosition);
        value.mat4_getRotationDegrees(this.myRotation);
        value.mat4_getScale(this.myScale);

        this.myTransform.mat4_setPositionRotationDegreesScale(this.myPosition, this.myRotation, this.myScale);

        if (resetInitialValue) {
            PP.EasyTuneSimpleTransform.prototype.setInitialValue.call(this, value);
        }

        PP.refreshEasyTuneWidget();

        if (!this.myTempTransform.pp_equals(this.myTransform)) {
            this._triggerValueChangedCallback();
        }
    }

    setInitialValue(value) {
        this.myInitialPosition = value.mat4_getPosition();
        this.myInitialRotation = value.mat4_getRotationDegrees();
        this.myInitialScale = value.mat4_getScale();
    }
};
PP.TimerState = class TimerState extends PP.State {
    constructor(duration = 0, transitionToPerformOnEnd = null, ...transitionArgs) {
        super();

        this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
        this._myTransitionArgs = transitionArgs;

        this._myTimer = new PP.Timer(duration, false);
    }

    setDuration(duration) {
        this._myTimer.setDuration(duration);
    }

    setTransitionToPerformOnEnd(transitionToPerformOnEnd, ...transitionArgs) {
        this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
        this._myTransitionArgs = transitionArgs;
    }

    onEnd(callback, id = null) {
        this._myTimer.onEnd(callback, id);
    }

    unregisterOnEnd(id = null) {
        this._myTimer.unregisterOnEnd(id);
    }

    update(dt, fsm) {
        this._myTimer.update(dt);
        if (this._myTimer.isDone()) {
            if (this._myTransitionToPerformOnEnd != null) {
                fsm.perform(this._myTransitionToPerformOnEnd, ...this._myTransitionArgs);
            }
        }
    }

    start(fsm, transition, duration = null, transitionToPerformOnEnd = null, ...transitionArgs) {
        this._myTimer.start(duration);
        if (transitionToPerformOnEnd != null) {
            this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
            this._myTransitionArgs = transitionArgs;
        }
    }
};
class ArcadeResultState extends PP.State {
    constructor(isDispute) {
        super();

        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "        Result");
        this._myFSM.addState("init");
        this._myFSM.addState("first_wait", new PP.TimerState(1.5, "end"));
        this._myFSM.addState("result");
        this._myFSM.addState("clean", this._updateClean.bind(this));
        this._myFSM.addState("second_wait", new PP.TimerState(2, "end"));
        this._myFSM.addState("done");

        this._myFSM.addTransition("init", "first_wait", "start", this._prepareState.bind(this));
        this._myFSM.addTransition("first_wait", "result", "end", this._prepareResult.bind(this));
        this._myFSM.addTransition("result", "clean", "end", this._prepareClean.bind(this));
        this._myFSM.addTransition("clean", "second_wait", "end");
        this._myFSM.addTransition("second_wait", "done", "end", this._resultCompleted.bind(this));
        this._myFSM.addTransition("done", "first_wait", "start", this._prepareState.bind(this));

        this._myFSM.addTransition("init", "done", "skip");
        this._myFSM.addTransition("first_wait", "done", "skip");
        this._myFSM.addTransition("second_wait", "done", "skip");
        this._myFSM.addTransition("result", "done", "skip", this._hideEvidences.bind(this));
        this._myFSM.addTransition("clean", "done", "skip", this._hideEvidences.bind(this));

        this._myFSM.init("init");

        this._myParentFSM = null;

        let evidenceSetupList = [];
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.VENT_TIMER, 5, null, null, [CardinalPosition.NORTH], this._onTimerUnspawned.bind(this)));
        this._myEvidenceManager = new EvidenceManager(evidenceSetupList);

        this._myIsDispute = isDispute;
    }

    update(dt, fsm) {
        this._myFSM.update(dt);
        this._myEvidenceManager.update(dt);

        if (Global.myDebugShortcutsEnabled) {
            //TEMP REMOVE THIS
            if (PP.myRightGamepad.getButtonInfo(PP.ButtonType.SELECT).isPressEnd(Global.myDebugShortcutsPress)) {
                this._myFSM.perform("skip");
                this._resultCompleted();
            }
        }
    }

    _prepareState(fsm, transition) {
    }

    _prepareResult() {
        this._myEvidenceManager.start();
    }

    _prepareClean() {
        this._myEvidenceManager.clean();
    }

    _updateClean(dt, fsm) {
        if (this._myEvidenceManager.isDone()) {
            this._myFSM.perform("end");
        }
    }

    _resultCompleted() {
        this._myParentFSM.perform("end");
    }

    _hideEvidences() {
        this._myEvidenceManager.hide();
    }

    start(fsm, transition) {
        this._myParentFSM = fsm;
        this._myFSM.perform("start");

        if (this._myIsDispute) {
            if (Global.myStatistics.myDisputeBestTime < 0 || Global.myVentDuration > Global.myStatistics.myDisputeBestTime) {
                Global.myStatistics.myDisputeBestTime = Global.myVentDuration;
            }

            if (Global.myGoogleAnalytics) {
                gtag("event", "arcade_dispute_time", {
                    "value": Global.myVentDuration.toFixed(2)
                });
            }
        } else {
            if (Global.myStatistics.myChatBestTime < 0 || Global.myVentDuration > Global.myStatistics.myChatBestTime) {
                Global.myStatistics.myChatBestTime = Global.myVentDuration;
            }

            if (Global.myGoogleAnalytics) {
                gtag("event", "arcade_chat_time", {
                    "value": Global.myVentDuration.toFixed(2)
                });
            }
        }

        let leaderboardID = "enough-is-enough";
        if (this._myIsDispute) {
            leaderboardID = leaderboardID.concat("-dispute");
        } else {
            leaderboardID = leaderboardID.concat("-chat");
        }

        let score = Math.floor(Global.myVentDuration * 1000);

        PP.CAUtils.submitScore(leaderboardID, score);

        Global.myIsInArcadeResult = true;
    }

    end(fsm, transitionID) {
        if (!this._myFSM.isInState("done")) {
            this._myFSM.perform("skip");
        }

        Global.myIsInArcadeResult = false;
    }

    _onTimerUnspawned(evidence) {
        if (PP.XRUtils.isXRSessionActive() && evidence.hasBeenThrown()) {
            this._myFSM.perform("end");
        }
    }
}
class BlatherState extends PP.State {
    constructor(sentences, isDefeat) {
        super();

        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "        Blather");
        this._myFSM.addState("init");
        this._myFSM.addState("first_wait", new PP.TimerState(1.5, "end"));
        //this._myFSM.addState("first_wait", new PP.TimerState(5, "end")); // for trailer, emulator distance [0, 1.65, 1.7], speaker monitor volume 0.5
        this._myFSM.addState("mr_not_appear", this._updateMrNOTAppear.bind(this));
        this._myFSM.addState("blather", this._updateBlather.bind(this));
        this._myFSM.addState("mr_not_disappear", this._updateMrNOTDisappear.bind(this));
        this._myFSM.addState("second_wait", new PP.TimerState(0, "end"));
        //this._myFSM.addState("second_wait", new PP.TimerState(5, "end")); // for trailer
        this._myFSM.addState("done");

        if (isDefeat) {
            this._myFSM.addTransition("init", "first_wait", "start", this._prepareState.bind(this));
            this._myFSM.addTransition("first_wait", "blather", "end", this._prepareBlather.bind(this));
            this._myFSM.addTransition("blather", "second_wait", "end");
            this._myFSM.addTransition("second_wait", "done", "end", this._startFight.bind(this));
            this._myFSM.addTransition("done", "first_wait", "start", this._prepareState.bind(this));
        } else {
            this._myFSM.addTransition("init", "first_wait", "start", this._prepareState.bind(this));
            this._myFSM.addTransition("first_wait", "mr_not_appear", "end", this._prepareMrNOTAppear.bind(this));
            this._myFSM.addTransition("mr_not_appear", "blather", "end", this._prepareBlather.bind(this));
            this._myFSM.addTransition("blather", "mr_not_disappear", "end", this._prepareMrNOTDisappear.bind(this));
            this._myFSM.addTransition("mr_not_disappear", "second_wait", "end");
            this._myFSM.addTransition("second_wait", "done", "end", this._startFight.bind(this));
            this._myFSM.addTransition("done", "first_wait", "start", this._prepareState.bind(this));
        }

        this._myFSM.addTransition("init", "done", "skip");
        this._myFSM.addTransition("first_wait", "done", "skip");
        this._myFSM.addTransition("mr_not_appear", "done", "skip", this._hideMrNOT.bind(this));
        this._myFSM.addTransition("blather", "done", "skip", this._hideBlather.bind(this));
        this._myFSM.addTransition("mr_not_disappear", "done", "skip", this._hideMrNOT.bind(this));
        this._myFSM.addTransition("second_wait", "done", "skip");

        this._myFSM.init("init");

        this._myParentFSM = null;

        this._myTimer = new PP.Timer(1);

        this._myBlather = new Blather(sentences, isDefeat);

        this._myMrNOTAppearAudio = Global.myAudioManager.createAudioPlayer(SfxID.MR_NOT_APPEAR);
        this._myMrNOTDisappearAudio = Global.myAudioManager.createAudioPlayer(SfxID.MR_NOT_DISAPPEAR);

        //Setup
        this._myFogAlphaMax = 0.7;
        this._myFogAlphaMin = 0;
        this._mySpawnTime = 3;
        this._myUnspawnTime = 3.5;
        this._myHideScale = 0.9;

        this._myMrNOT = Global.myGameObjects.get(GameObjectType.MR_NOT);
    }

    update(dt, fsm) {
        this._myFSM.update(dt);

        if (Global.myDebugShortcutsEnabled) {
            //TEMP REMOVE THIS
            if (PP.myRightGamepad.getButtonInfo(PP.ButtonType.SELECT).isPressEnd(Global.myDebugShortcutsPress)) {
                this._myFSM.perform("skip");
                this._startFight();
            }
        }
    }

    _prepareState(fsm, transition) {
        transition.myToState.myObject.start(fsm, transition);
    }

    _prepareMrNOTAppear() {
        this._myMrNOT.pp_setPosition([0, 11, -18]);
        this._myMrNOT.pp_setRotation([40, 0, 0]);
        //this._myMrNOT.pp_setRotation([30, 0, 0]);
        this._myMrNOT.pp_setScale([5, 5, 5]);
        PP.MeshUtils.setFogColor(this._myMrNOT, [0, 0, 0, this._myFogAlphaMax]);

        Global.myLightFadeInTime = this._mySpawnTime * 2 / 3;

        this._myTimer.start(this._mySpawnTime);

        this._myMrNOT.pp_setActive(true);

        this._myMrNOTAppearAudio.setPosition(this._myMrNOT.pp_getPosition());
        this._myMrNOTDisappearAudio.setPosition(this._myMrNOT.pp_getPosition());
        this._myMrNOTAppearAudio.play();
    }

    _updateMrNOTAppear(dt, fsm) {
        if (this._myTimer.isRunning()) {
            this._myTimer.update(dt);
            let easing = t => t * (2 - t);
            PP.MeshUtils.setFogColor(this._myMrNOT, [0, 0, 0, Math.pp_mapToRange(easing(this._myTimer.getPercentage()), 0, 1, this._myFogAlphaMax, this._myFogAlphaMin)]);
            let currentScaleFactor = Math.pp_interpolate(this._myHideScale, 1, this._myTimer.getPercentage(), PP.EasingFunction.easeOut);

            this._myMrNOT.pp_setScale([5, 5, 5]);
            this._myMrNOT.pp_scaleObject([currentScaleFactor, currentScaleFactor, 1]);

            if (this._myTimer.isDone()) {
                this._myTimer.reset();
                fsm.perform("end");
            }
        }
    }

    _prepareBlather() {
        this._myBlather.start();
    }

    _updateBlather(dt, fsm) {
        this._myBlather.update(dt);
        if (this._myBlather.isDone()) {
            fsm.perform("end");
        }
    }

    _prepareMrNOTDisappear() {
        this._myTimer.start(this._myUnspawnTime);
        Global.myLightFadeInTime = this._myUnspawnTime;
        Global.myStartFadeOut = true;
        this._myMrNOTDisappearAudio.play();
    }

    _updateMrNOTDisappear(dt, fsm) {
        if (this._myTimer.isRunning()) {
            this._myTimer.update(dt);
            let easing = t => t * t;
            PP.MeshUtils.setFogColor(this._myMrNOT, [0, 0, 0, Math.pp_mapToRange(this._myTimer.getPercentage(), 0.05, 0.8, this._myFogAlphaMin, this._myFogAlphaMax)]);
            let currentScaleFactor = Math.pp_interpolate(1, this._myHideScale, this._myTimer.getPercentage(), easing);

            this._myMrNOT.pp_setScale([5, 5, 5]);
            this._myMrNOT.pp_scaleObject([currentScaleFactor, currentScaleFactor, 1]);

            if (this._myTimer.isDone()) {
                this._myTimer.reset();
                this._hideMrNOT();
                fsm.perform("end");
            }
        }
    }

    _startFight() {
        Global.myStartFadeOut = false;
        this._myParentFSM.perform("end");
    }

    _hideMrNOT() {
        this._myMrNOT.pp_setActive(false);
        Global.myStartFadeOut = false;
    }

    _hideBlather() {
        this._hideMrNOT();
        this._myBlather.skip();
    }

    start(fsm, transition) {
        this._myParentFSM = fsm;
        this._myFSM.perform("start");
    }

    end(fsm, transitionID) {
        if (!this._myFSM.isInState("done")) {
            this._myFSM.perform("skip");
        }
    }
}

class Blather {
    constructor(sentences, isDefeat) {
        this._myBlatherTextObject = WL.scene.addObject(Global.myScene);
        this._myBlatherTextComponent = this._myBlatherTextObject.pp_addComponent("text");
        this._myBlatherTextComponent.text = " ";
        this._myBlatherTextComponent.text = "";
        this._myBlatherTextComponent.alignment = WL.Alignment.Left;
        this._myBlatherTextComponent.justification = WL.Justification.Line;
        this._myBlatherTextComponent.material = Global.myMaterials.myText.clone();
        //this._myBlatherTextComponent.material.outlineRange = [0.5, 0.5];
        //this._myBlatherTextComponent.material.color = Global.myMaterials.myBigText.color;
        //this._myBlatherTextObject.pp_addComponent("pp-easy-text-color", { "_myVariableName": "ciao", "_myColorType": 0, "_myColorModel": 1 });


        //this._myBlatherTextComponent.material.color = [90 / 255, 90 / 255, 100 / 255, 1];
        //this._myBlatherTextComponent.material.outlineColor = [90 / 255, 90 / 255, 100 / 255, 1];
        this._myBlatherTextObject.pp_setActive(false);

        this._myBigBlatherTextObject = WL.scene.addObject(Global.myScene);
        this._myBigBlatherTextComponent = this._myBigBlatherTextObject.pp_addComponent("text");
        this._myBigBlatherTextComponent.text = " ";
        this._myBigBlatherTextComponent.text = "";
        this._myBigBlatherTextComponent.alignment = WL.Alignment.Left;
        this._myBigBlatherTextComponent.justification = WL.Justification.Line;
        this._myBigBlatherTextComponent.material = Global.myMaterials.myTitle.clone();
        //this._myBigBlatherTextComponent.material.outlineRange = [0.5, 0.375];
        //this._myBigBlatherTextComponent.material.outlineColor = this._myBigBlatherTextComponent.material.color;
        //this._myBigBlatherTextComponent.material.color = [0, 0, 0, 0];
        //this._myBigBlatherTextObject.pp_addComponent("pp-easy-text-color", { "_myVariableName": "ciao2", "_myColorType": 0, "_myColorModel": 1 });
        //this._myBigBlatherTextComponent.material.color = [90 / 255, 90 / 255, 100 / 255, 1];
        //this._myBigBlatherTextComponent.material.outlineColor = [90 / 255, 90 / 255, 100 / 255, 1];

        this._myBigBlatherTextObject.pp_setPosition([0, 4, -10.5]);
        this._myBigBlatherTextObject.pp_setRotation([20, 0, 0]);
        this._myBigBlatherTextObject.pp_setScale(19);

        this._myBigBlatherPatchObject = Global.myBigBlatherPatchObject.pp_clone();
        this._myBigBlatherPatchObject.pp_resetTransform();
        this._myBigBlatherPatchObject.pp_setParent(this._myBigBlatherTextObject, false);
        this._myBigBlatherPatchObject.pp_setScale(1);
        this._myBigBlatherTextObject.pp_setActive(false);
        this._myBigBlatherPatchObject.pp_setActive(false);

        this._mySentences = sentences;

        this._myTimerState = new PP.TimerState(1, "end");

        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "            Blather");
        this._myFSM.addState("init");
        this._myFSM.addState("first_wait", new PP.TimerState(isDefeat ? 1 : 1.25, "end"));
        this._myFSM.addState("blather", this._updateBlather.bind(this));
        this._myFSM.addState("wait", this._myTimerState);
        this._myFSM.addState("second_wait", this._myTimerState);
        this._myFSM.addState("done");

        this._myFSM.addTransition("init", "first_wait", "start", this._prepareState.bind(this));
        this._myFSM.addTransition("first_wait", "blather", "end", this._nextBlather.bind(this, true));
        this._myFSM.addTransition("blather", "wait", "next");
        this._myFSM.addTransition("wait", "blather", "end", this._nextBlather.bind(this, false));
        this._myFSM.addTransition("blather", "second_wait", "end");
        this._myFSM.addTransition("second_wait", "done", "end", this._done.bind(this));
        this._myFSM.addTransition("done", "first_wait", "start", this._prepareState.bind(this));

        this._myFSM.addTransition("init", "done", "skip", this._done.bind(this));
        this._myFSM.addTransition("first_wait", "done", "skip", this._done.bind(this));
        this._myFSM.addTransition("blather", "done", "skip", this._done.bind(this));
        this._myFSM.addTransition("wait", "done", "skip", this._done.bind(this));
        this._myFSM.addTransition("blather", "done", "skip", this._done.bind(this));
        this._myFSM.addTransition("second_wait", "done", "skip", this._done.bind(this));

        this._myIsDone = false;
        this._myCurrentSenteceIndex = 0;
        this._myCurrentCharacterIndex = 0;

        this._myCharacterTimer = new PP.Timer(0.1);
        this._myNextTimer = new PP.Timer(0.1);

        this._myCharAudios = [];
        this._myCharAudios[0] = Global.myAudioManager.createAudioPlayer(SfxID.BLATHER_1);
        this._myCharAudios[1] = Global.myAudioManager.createAudioPlayer(SfxID.BLATHER_0);

        this._myFSM.init("init");
    }

    start() {
        this._myFSM.perform("start");
    }

    skip(dt) {
        this._myFSM.perform("skip");
    }

    update(dt) {
        this._myFSM.update(dt);
    }

    isDone() {
        return this._myIsDone;
    }

    _prepareState() {
        this._myIsDone = false;
        this._myCurrentSenteceIndex = -1;
        this._myBlatherTextObject.pp_setActive(true);
        this._myBigBlatherTextObject.pp_setActive(true);
        this._myBigBlatherPatchObject.pp_setActive(false);
    }

    _nextBlather(speedStart) {
        this._myIsDone = false;
        this._myCurrentSenteceIndex++;
        this._myCurrentCharacterIndex = 0;

        if (this._mySentences[this._myCurrentSenteceIndex].myIsBigBlather) {
            this._setBigBlatherPosition();
            this._myBigBlatherPatchObject.pp_setActive(true);
        } else {
            this._setBlatherPosition();
            this._myBigBlatherPatchObject.pp_setActive(false);
        }

        this._myCharacterTimer.start(speedStart ? 0 : 0.13);
        this._myNextTimer.reset(1);
    }

    _updateBlather(dt, fsm) {
        let sentence = this._mySentences[this._myCurrentSenteceIndex];

        let textComponent = this._myBlatherTextComponent;
        if (sentence.myIsBigBlather) {
            textComponent = this._myBigBlatherTextComponent;
        }

        if (!this._myNextTimer.isRunning()) {
            this._myCharacterTimer.update(dt);

            if (this._myCurrentCharacterIndex != sentence.mySentence.length && this._myCharacterTimer.isDone()) {
                let character = sentence.mySentence[this._myCurrentCharacterIndex];
                textComponent.text = textComponent.text.concat(character);

                if (character != ' ') {
                    let player = this._myCharAudios[this._myCurrentCharacterIndex % 2];
                    player.play();
                }

                if (sentence.myIsBigBlather) {
                    this._myCharacterTimer.start(0.5);
                } else {
                    if (this._myCurrentCharacterIndex + 1 < sentence.mySentence.length &&
                        (sentence.mySentence[this._myCurrentCharacterIndex + 1] == '.') ||
                        (sentence.mySentence.includes("KNOW") && this._myCurrentCharacterIndex > 2) ||
                        (sentence.mySentence.includes("Why don't you THROW me what you have learned so far?") && this._myCurrentCharacterIndex > 12 && this._myCurrentCharacterIndex < 20)) {
                        this._myCharacterTimer.start(0.3);
                    } else {
                        this._myCharacterTimer.start(0.13);
                    }
                }

                this._myCurrentCharacterIndex++;
            }

            if (this._myCurrentCharacterIndex == sentence.mySentence.length) {
                this._myNextTimer.start(sentence.myTimeToWaitBeforeDisappearing);
            }
        } else {
            this._myNextTimer.update(dt);
            if (this._myNextTimer.isDone()) {
                this._myTimerState.setDuration(sentence.myTimeToWaitAfterDisappearing);
                if (this._myCurrentSenteceIndex < this._mySentences.length - 1) {
                    textComponent.text = "";
                    this._myBigBlatherPatchObject.pp_setActive(false);
                    fsm.perform("next");
                } else {
                    textComponent.text = "";
                    this._myBigBlatherPatchObject.pp_setActive(false);
                    fsm.perform("end");
                }
            }
        }
    }

    _done() {
        this._myBlatherTextComponent.text = "";
        this._myBigBlatherTextComponent.text = "";
        this._myBlatherTextObject.pp_setActive(false);
        this._myBigBlatherTextObject.pp_setActive(false);
        this._myBigBlatherPatchObject.pp_setActive(false);
        this._myIsDone = true;
    }

    _setBlatherPosition() {
        this._myBlatherTextObject.pp_setPosition([0, 2.074, -9]);
        this._myBlatherTextObject.pp_setRotation([0, 0, 0]);
        this._myBlatherTextObject.pp_setScale([3.5, 3.5, 3.5]);
        //this._myBlatherTextObject.pp_setScale([5, 5, 5]); // for trailer

        this._myCharAudios[0].setPosition(this._myBlatherTextObject.pp_getPosition());
        this._myCharAudios[1].setPosition(this._myBlatherTextObject.pp_getPosition());

        let multiplier = 1;
        //multiplier = 5 / 3.5; // for trailer
        let sentenceLength = this._mySentences[this._myCurrentSenteceIndex].mySentence.length;
        let displacement = sentenceLength * 0.094 * multiplier;
        if (this._mySentences[this._myCurrentSenteceIndex].mySentence.includes("enough IS enough")) {
            displacement = sentenceLength * 0.096 * multiplier;
        } else if (this._mySentences[this._myCurrentSenteceIndex].mySentence.includes("it will always be...")) {
            displacement = sentenceLength * 0.09 * multiplier;
        } else if (this._mySentences[this._myCurrentSenteceIndex].mySentence.includes("...")) {
            displacement = (sentenceLength - 1.5) * 0.094 * multiplier;
        }
        this._myBlatherTextObject.translateObject([-displacement, 0, 0]);
    }

    _setBigBlatherPosition() {
        this._myBigBlatherTextObject.pp_setPosition([0, 4, -10.5]);
        this._myBigBlatherTextObject.pp_setRotation([20, 0, 0]);
        this._myBigBlatherTextObject.pp_setScale(19);

        this._myCharAudios[0].setPosition(this._myBigBlatherTextObject.pp_getPosition());
        this._myCharAudios[1].setPosition(this._myBigBlatherTextObject.pp_getPosition());

        let sentenceLength = this._mySentences[this._myCurrentSenteceIndex].mySentence.length;
        let displacement = sentenceLength * 0.6;
        this._myBigBlatherTextObject.translateObject([-displacement, 0, 0]);

        this._myBigBlatherPatchObject.pp_setPositionLocal([0, 0, 0]);
        this._myBigBlatherPatchObject.pp_translateLocal([displacement / 19, 0, 0]);
    }
}

class Sentence {
    constructor(sentence, timeToWaitBeforeDisappearing = 1.75, timeToWaitAfterDisappearing = 1.5, isBigBlather = false) {
        this.mySentence = sentence;
        this.myTimeToWaitBeforeDisappearing = timeToWaitBeforeDisappearing;
        this.myTimeToWaitAfterDisappearing = timeToWaitAfterDisappearing;
        this.myIsBigBlather = isBigBlather;
    }
}
class EvidenceSetup {
    constructor(objectType, randomChance, startSpawnTime = null, endSpawnTime = null, cardinalPositions = null, callbackOnUnspawned = null) {
        this.myObjectType = objectType;
        this.myRandomChance = randomChance;
        this.myStartSpawnTime = startSpawnTime;
        this.myEndSpawnTime = endSpawnTime;
        this.myCardinalPositions = cardinalPositions;
        this.myCallbackOnUnspawned = callbackOnUnspawned;
    }
}

class Evidence {
    constructor(evidenceSetup, callbackOnUnspawned) {
        this._myEvidenceSetup = evidenceSetup;
        this._myCallbackOnUnspawned = callbackOnUnspawned;

        this._myObject = Global.myGameObjects.get(this._myEvidenceSetup.myObjectType);
        this._myObjectType = this._myEvidenceSetup.myObjectType;
        this._myPhysx = this._myObject.pp_getComponentHierarchy("physx");
        this._myGrabbable = this._myObject.pp_getComponentHierarchy("pp-grabbable");
        this._myScale = this._myObject.pp_getScale();

        this._myCurrentCardinalPosition = null;
        this._myPosition = null;
        this._myFacing = null;

        this._myTimer = new PP.Timer(0);
        this._mySpawnTimer = new PP.Timer(0);
        this._myThrowTimer = new PP.Timer(5, false);
        WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));

        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "                Evidence Item");
        this._myFSM.addState("init");
        this._myFSM.addState("inactive");
        this._myFSM.addState("spawning", this._spawning.bind(this));
        this._myFSM.addState("ready", this._readyUpdate.bind(this));
        this._myFSM.addState("unspawning", this._unspawning.bind(this));

        this._myFSM.addTransition("init", "inactive", "reset", this._reset.bind(this));
        this._myFSM.addTransition("inactive", "spawning", "spawn", this._startSpawn.bind(this));
        this._myFSM.addTransition("spawning", "ready", "end", this._startReady.bind(this));
        this._myFSM.addTransition("spawning", "unspawning", "unspawn", this._startUnspawn.bind(this));
        this._myFSM.addTransition("ready", "unspawning", "unspawn", this._startUnspawn.bind(this));
        this._myFSM.addTransition("unspawning", "inactive", "end", this._startInactive.bind(this));
        this._myFSM.addTransition("inactive", "inactive", "reset", this._reset.bind(this));

        this._myFSM.init("init");
        this.init();

        this._myCollisionCount = 0;
        this._myHasBeenThrown = false;

        this._myParticlesRadius = 0.225;

        this._myAudioTimer = new PP.Timer(0);
        this._myAppearAudio = null;
        this._myDisappearAudio = null;

        this._myCollisionCallbackID = null;
    }

    getEvidenceSetup() {
        return this._myEvidenceSetup;
    }

    init() {
        this._myFSM.perform("reset");
    }

    update(dt) {
        if (this._myHasBeenThrown) {
            this._myThrowTimer.update(dt);
            if (this._myThrowTimer.isDone()) {
                this._myHasBeenThrown = false;
            }
        }

        this._myFSM.update(dt);
    }

    spawn(position) {
        this._myPosition = position.slice(0);
        this._myFacing = [0, 0, 0].vec3_sub(position).vec3_removeComponentAlongAxis([0, 1, 0]);
        this._myFSM.perform("spawn");
    }

    unspawn(avoidParticles = false) {
        this._myAvoidParticles = avoidParticles;
        this._myFSM.perform("unspawn");
    }

    canUnspawn() {
        return this._myFSM.canPerform("unspawn");
    }

    isInactive() {
        return this._myFSM.isInState("inactive");
    }

    hide() {
        this._myFSM.init("inactive");
        this._disableObject();
    }

    canHit() {
        let distanceFromCenter = this._myObject.pp_getPosition().vec3_removeComponentAlongAxis([0, 1, 0]).vec3_length();
        let isHitState = this._myFSM.isInState("spawning") || this._myFSM.isInState("ready");
        return isHitState && /*this._myHasBeenThrown &&*/ WL.xrSession && /*!this._myGrabbable.isGrabbed() &&*/ distanceFromCenter > Global.myRingRadius * 1.5/*(this._myGrabbable.isGrabbed() || this._myCollisionCount == 0)*/;
    }

    hasBeenThrown() {
        return this._myHasBeenThrown;
    }

    _reset(fsm, transition) {
        this._disableObject();
    }

    _startSpawn() {
        if (this._myAppearAudio == null) {
            this._myAppearAudio = Global.myAudioManager.createAudioPlayer(SfxID.EVIDENCE_APPEAR);
            this._myDisappearAudio = Global.myAudioManager.createAudioPlayer(SfxID.EVIDENCE_DISAPPEAR);
        }

        this._myEvidenceComponent = this._myObject.pp_getComponentHierarchy("evidence-component");
        this._myEvidenceComponent.setCallbackOnHit(this._onHit.bind(this));
        this._myEvidenceComponent.setCallbackOnBigHit(this._onBigHit.bind(this));
        this._myEvidenceComponent.setEvidence(this);
        this._myHasBeenThrown = false;
        this._myThrowTimer.reset();

        let position = this._myPosition.pp_clone();
        let heightDisplacement = this._myEvidenceComponent.getHeightDisplacement();
        if (Math.abs(heightDisplacement) > 0.0001) {
            position.vec3_add([0, heightDisplacement, 0], position);
        }

        this._myObject.pp_setPosition(position);
        this._myObject.pp_setScale(0);
        this._myObject.pp_translate([0, 0.2, 0]);
        this._myObject.pp_lookTo(this._myFacing, [0, 1, 0]);
        this._myObject.pp_setActive(true);

        this._myPhysx.kinematic = true;
        this._myPhysx.linearVelocity = [0, 0, 0];
        this._myPhysx.angularVelocity = [0, 0, 0];

        this._mySpawnTimer.start(1);
        this._myHitExplosion = false;
        this._myBigHitExplosion = false;
        this._myHitFloor = false;
        this._myAvoidParticles = false;

        this._myAudioTimer.start(0.2);
        this._myAppearAudio.setPosition(position);
        this._myAppearAudio.setPitch(Math.pp_random(0.85, 1.05));

        this._myGrabbable.registerThrowEventListener(this, this._onThrow.bind(this));
        this._myCollisionCallbackID = this._myPhysx.onCollision(this._onCollision.bind(this));
    }

    _spawning(dt) {
        if (this._myAudioTimer.isRunning()) {
            this._myAudioTimer.update(dt);
            if (this._myAudioTimer.isDone()) {
                this._myAppearAudio.play();
            }
        }

        this._mySpawnTimer.update(dt);

        let scaleMultiplier = PP.EasingFunction.easeInOut(this._mySpawnTimer.getPercentage());
        this._myObject.pp_setScale(this._myScale.vec3_scale(scaleMultiplier));

        this._myAppearAudio.updatePosition(this._myObject.pp_getPosition());

        if (this._mySpawnTimer.isDone()) {
            this._myFSM.perform("end");
        }
    }

    _startReady() {
        this._myObject.pp_setScale(this._myScale);
        if (!this._myGrabbable.isGrabbed()) {
            this._myPhysx.kinematic = false;
        }
    }

    _readyUpdate(dt) {
        if (this._myObject.pp_getPosition()[1] <= -10 || this._myObject.pp_getPosition()[1] > 20 || this._myObject.pp_getPosition().vec3_length() > 50) {
            this._myHitFloor = true;
            this._myFSM.perform("unspawn");
        }
    }

    _startUnspawn() {
        if ((this._myHitFloor || this._myHitExplosion || this._myBigHitExplosion) && !Global.myIsInArcadeResult) {
            Global.myStatistics.myEvidencesThrown += 1;
            if ((this._myHitExplosion || this._myBigHitExplosion) && this._myGrabbable.isGrabbed()) {
                Global.myStatistics.myEvidencesPunched += 1;
            }

            if (this._myHitFloor) {
                Global.myStatistics.myEvidencesMissed += 1;
            }

        }

        if (this._myBigHitExplosion) {
            this._myPhysx.kinematic = true;
        }

        this._mySetKinematicTimer = this._myHitExplosion;

        this._myTimer.start(PP.myEasyTuneVariables.get("Unspawn Menu Time"));

        if (!this._myHitExplosion && !this._myBigHitExplosion) {
            this._myDisappearAudio.setPosition(this._myObject.pp_getPosition());
            this._myDisappearAudio.setPitch(Math.pp_random(0.85, 1.05));
            this._myDisappearAudio.play();
        }
    }

    _unspawning(dt) {
        this._myTimer.update(dt);

        if (this._mySetKinematicTimer && this._myTimer.getPercentage() >= 0.7) {
            this._myPhysx.kinematic = true;
            this._mySetKinematicTimer = false;
        }

        let scaleMultiplier = Math.pp_interpolate(1, PP.myEasyTuneVariables.get("Unspawn Menu Scale"), this._myTimer.getPercentage());
        this._myObject.pp_setScale(this._myScale.vec3_scale(scaleMultiplier));

        if (this._myTimer.isDone()) {
            let scaleMultiplier = 1;
            let radiusMultiplier = 1;
            if (this._myHitExplosion) {
                scaleMultiplier = 3;
                radiusMultiplier = 1.5;
            } else if (this._myBigHitExplosion) {
                scaleMultiplier = 3;
                radiusMultiplier = 2;
            }

            if (!this._myAvoidParticles) {
                Global.myParticlesManager.explosion(this._myObject.pp_getPosition(), this._myParticlesRadius * radiusMultiplier, this._myScale.vec3_scale(scaleMultiplier), this._myObjectType);
            }
            this._myFSM.perform("end");
            this._myCallbackOnUnspawned(this);
            if (this._myEvidenceSetup.myCallbackOnUnspawned) {
                this._myEvidenceSetup.myCallbackOnUnspawned(this);
            }
        }
    }

    _startInactive() {
        this._disableObject();
    }

    _disableObject() {
        if (this._myPhysx.active) {
            this._myPhysx.linearVelocity = [0, 0, 0];
            this._myPhysx.angularVelocity = [0, 0, 0];
            this._myObject.pp_setPosition([0, -10, 0]);
        }
        this._myObject.pp_setActive(false);
        this._myGrabbable.unregisterThrowEventListener(this);
        if (this._myCollisionCallbackID != null) {
            this._myPhysx.removeCollisionCallback(this._myCollisionCallbackID);
            this._myCollisionCallbackID = null;
        }
    }

    _onCollision(type) {
        if (!this._myGrabbable.isGrabbed() && this._myPhysx.active && this._myPhysx.kinematic &&
            (this._myFSM.getCurrentState().myID == "spawning")) {
            this._myPhysx.kinematic = false;
        }

        if (type == WL.CollisionEventType.Touch || type == WL.CollisionEventType.TriggerTouch) {
            this._myCollisionCount += 1;
        } else if (type == WL.CollisionEventType.TouchLost || type == WL.CollisionEventType.TriggerTouchLost) {
            this._myCollisionCount -= 1;
        }
    }

    _onHit() {
        this._myHitExplosion = true;
        this._myFSM.perform("unspawn");
    }

    _onBigHit() {
        this._myBigHitExplosion = true;
        this._myFSM.perform("unspawn");
    }

    _onThrow() {
        this._myHasBeenThrown = true;
        this._myThrowTimer.start();
    }

    _onXRSessionEnd() {
        this._myHasBeenThrown = false;
    }
}

var CardinalPosition = {
    NORTH: 0,
    NORTH_EAST: 1,
    NORTH_WEST: 2,
    EAST: 3,
    WEST: 4,
    SOUTH_EAST: 5,
    SOUTH_WEST: 6,
    SOUTH: 7
};
WL.registerComponent('evidence-component', {
    _myHeightDisplacement: { type: WL.Type.Float, default: 0.0 }
}, {
    init: function () {
        this._myCallbackOnHit = null;
        this._myCallbackOnBigHit = null;
        this._myEvidence = null;
    },
    start: function () {
        this._myTimeActive = 0;
    },
    update: function (dt) {
        this._myTimeActive += dt;
    },
    setCallbackOnHit: function (callback) {
        this._myCallbackOnHit = callback;
    },
    setCallbackOnBigHit: function (callback) {
        this._myCallbackOnBigHit = callback;
    },
    setEvidence: function (evidence) {
        this._myEvidence = evidence;
    },
    getEvidence: function () {
        return this._myEvidence;
    },
    getHeightDisplacement: function () {
        return this._myHeightDisplacement;
    },
    hit: function (objectHit) {
        if (this._myCallbackOnHit) {
            this._myCallbackOnHit(objectHit, this);
        }
    },
    bigHit: function (objectHit) {
        if (this._myCallbackOnBigHit) {
            this._myCallbackOnBigHit(objectHit, this);
        }
    },
    getTimeActive() {
        return this._myTimeActive;
    },
    onActivate() {
        this._myTimeActive = 0;
    },
    onDeactivate() {
        this._myTimeActive = 0;
    }
});


class EvidenceManager {
    constructor(evidenceSetupList) {
        this._myInactiveEvidences = [];
        this._myToUnspawnEvidences = [];
        this._myActiveEvidences = [];
        this._myToSpawnEvidences = [];

        this._buildEvidences(evidenceSetupList);

        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "            Evidence");
        this._myFSM.addState("init");
        this._myFSM.addState("manage", this._updateManage.bind(this));
        this._myFSM.addState("clean", this._updateClean.bind(this));
        this._myFSM.addState("explode", this._updateExplode.bind(this));
        this._myFSM.addState("done");

        this._myFSM.addTransition("init", "manage", "start", this._prepareManage.bind(this));
        this._myFSM.addTransition("manage", "clean", "startClean", this._prepareClean.bind(this));
        this._myFSM.addTransition("manage", "explode", "startExplode", this._prepareExplode.bind(this));
        this._myFSM.addTransition("clean", "done", "end", this._evidencesHidden.bind(this));
        this._myFSM.addTransition("explode", "done", "end", this._evidencesHidden.bind(this));
        this._myFSM.addTransition("done", "manage", "start", this._prepareManage.bind(this));

        this._myFSM.init("init");

        this._myCardinalPositionsMap = new Map();
        this._buildCardinalPositionsMap();
    }

    start() {
        this._myFSM.perform("start");
    }

    update(dt) {
        this._myFSM.update(dt);

        if (Global.myDebugShortcutsEnabled) {
            //TEMP REMOVE THIS
            if (PP.myLeftGamepad.getButtonInfo(PP.ButtonType.SELECT).isPressEnd(Global.myDebugShortcutsPress)) {
                for (let evidence of this._myActiveEvidences) {
                    evidence[0].unspawn();
                }
            }
        }
    }

    explode() {
        this._myFSM.perform("startExplode");
    }

    clean() {
        this._myFSM.perform("startClean");
    }

    hide() {
        this._myFSM.init("done");

        for (let evidence of this._myActiveEvidences) {
            evidence[0].hide();
        }

        this._evidencesHidden();
    }

    isDone() {
        return this._myFSM.isInState("done");
    }

    _prepareManage(fsm) {
        let cardinalPositions = [];
        for (let key in CardinalPosition) {
            cardinalPositions.push(CardinalPosition[key]);
        }

        let times = [];
        times[0] = Math.pp_random(0.15, 0.55);
        for (let i = 1; i < cardinalPositions.length; i++) {
            times[i] = times[i - 1] + Math.pp_random(0.15, 0.55);
        }

        this._myToSpawnEvidences = [];

        while (cardinalPositions.length > 0) {
            let randomIndex = Math.pp_randomInt(0, cardinalPositions.length - 1);
            let cardinalPosition = cardinalPositions.pp_removeIndex(randomIndex);

            let evidence = this._getInactiveEvidence(cardinalPosition);
            if (evidence) {
                let time = times.shift();
                this._myToSpawnEvidences.push([evidence, cardinalPosition, new PP.Timer(time)]);
            }
        }
    }

    _updateManage(dt, fsm) {
        for (let evidenceToSpawn of this._myToSpawnEvidences) {
            evidenceToSpawn[2].update(dt);
            if (evidenceToSpawn[2].isDone()) {
                let evidence = evidenceToSpawn[0];
                let cardinalPosition = evidenceToSpawn[1];
                evidence.spawn(this._myCardinalPositionsMap.get(cardinalPosition));
                this._myActiveEvidences.push([evidence, cardinalPosition]);
            }
        }

        this._myToSpawnEvidences.pp_removeAll(element => element[2].isDone());

        for (let evidenceToUnspawn of this._myToUnspawnEvidences) {
            evidenceToUnspawn[1].update(dt);
            if (evidenceToUnspawn[1].isDone()) {
                let evidence = evidenceToUnspawn[0];
                this._myInactiveEvidences.push(evidence);
            }
        }

        this._myToUnspawnEvidences.pp_removeAll(element => element[1].isDone());

        for (let evidence of this._myActiveEvidences) {
            evidence[0].update(dt);
        }
    }

    _prepareExplode(fsm) {
        for (let evidence of this._myActiveEvidences) {
            evidence[0].unspawn();
        }
    }

    _updateExplode(dt, fsm) {
        for (let evidence of this._myActiveEvidences) {
            evidence[0].update(dt);
        }

        let done = true;
        for (let item of this._myActiveEvidences) {
            done = done && item[0].isInactive();
        }

        if (done) {
            fsm.perform("end");
        }
    }

    _prepareClean(fsm) {
        this._myUnspawnList = [];

        let indexList = [];
        for (let i = 0; i < this._myActiveEvidences.length; i++) {
            if (this._myActiveEvidences[i][0].canUnspawn()) {
                indexList.push(i);
            }
        }

        while (indexList.length > 0) {
            let randomIndex = Math.pp_randomInt(0, indexList.length - 1);
            let index = indexList.pp_removeIndex(randomIndex);

            let randomTimer = Math.pp_random(0.20, 0.25);
            if (this._myUnspawnList.length == 0) {
                randomTimer += 0.2;
            }
            this._myUnspawnList.push([this._myActiveEvidences[index][0], new PP.Timer(randomTimer)]);
        }
    }

    _updateClean(dt, fsm) {
        if (this._myUnspawnList.length > 0) {
            let first = this._myUnspawnList[0];
            first[1].update(dt);
            if (first[1].isDone()) {
                first[0].unspawn();
                this._myUnspawnList.shift();
            }
        }

        for (let evidence of this._myActiveEvidences) {
            evidence[0].update(dt);
        }

        let done = true;
        for (let item of this._myActiveEvidences) {
            done = done && item[0].isInactive();
        }

        if (done) {
            fsm.perform("end");
        }
    }

    _buildEvidences(evidenceSetupList) {
        for (let evidenceSetup of evidenceSetupList) {
            this._myInactiveEvidences.push(new Evidence(evidenceSetup, this._evidenceUnspawned.bind(this)));
        }
    }

    _evidenceUnspawned(evidence) {
        let evidenceRemoved = this._myActiveEvidences.pp_remove(element => element[0] === evidence);
        this._myToUnspawnEvidences.push([evidenceRemoved[0], new PP.Timer(1)]);

        let evidenceToSpawn = this._getInactiveEvidence(evidenceRemoved[1]);
        this._myToSpawnEvidences.push([evidenceToSpawn, evidenceRemoved[1], new PP.Timer(0.5)]);
    }

    _evidencesHidden() {
        for (let activeEvidence of this._myActiveEvidences) {
            this._myInactiveEvidences.push(activeEvidence[0]);
        }

        for (let toUnspawnEvidence of this._myToUnspawnEvidences) {
            this._myInactiveEvidences.push(toUnspawnEvidence[0]);
        }

        for (let toSpawnEvidence of this._myToSpawnEvidences) {
            this._myInactiveEvidences.push(toSpawnEvidence[0]);
        }

        this._myToUnspawnEvidences = [];
        this._myToSpawnEvidences = [];
        this._myActiveEvidences = [];
    }

    _buildCardinalPositionsMap() {
        let ringHeight = Global.myRingHeight;
        let ringRadius = Global.myRingRadius;
        let rotation = 45;

        let initialPosition = [0, ringHeight, -ringRadius];

        this._myCardinalPositionsMap.set(CardinalPosition.NORTH, initialPosition.vec3_clone());
        this._myCardinalPositionsMap.set(CardinalPosition.NORTH_WEST, initialPosition.vec3_rotateAxis(rotation, [0, 1, 0]));
        this._myCardinalPositionsMap.set(CardinalPosition.NORTH_EAST, initialPosition.vec3_rotateAxis(-rotation, [0, 1, 0]));
        this._myCardinalPositionsMap.set(CardinalPosition.WEST, initialPosition.vec3_rotateAxis(rotation * 2, [0, 1, 0]));
        this._myCardinalPositionsMap.set(CardinalPosition.EAST, initialPosition.vec3_rotateAxis(-rotation * 2, [0, 1, 0]));
        this._myCardinalPositionsMap.set(CardinalPosition.SOUTH_WEST, initialPosition.vec3_rotateAxis(rotation * 3, [0, 1, 0]));
        this._myCardinalPositionsMap.set(CardinalPosition.SOUTH_EAST, initialPosition.vec3_rotateAxis(-rotation * 3, [0, 1, 0]));
        this._myCardinalPositionsMap.set(CardinalPosition.SOUTH, initialPosition.vec3_rotateAxis(-rotation * 4, [0, 1, 0]));
    }

    _getInactiveEvidence(cardinalPosition) {
        let randomEvidence = null;

        let validEvidences = [];
        for (let evidence of this._myInactiveEvidences) {
            let setup = evidence.getEvidenceSetup();
            if ((setup.myCardinalPositions == null || setup.myCardinalPositions.includes(cardinalPosition)) &&
                (setup.myStartSpawnTime == null || setup.myStartSpawnTime < Global.myVentDuration) &&
                (setup.myEndSpawnTime == null || setup.myEndSpawnTime > Global.myVentDuration) &&
                setup.myRandomChance.get(Global.myVentDuration) > 0) {
                validEvidences.push(evidence);
            }
        }

        // TEMP change with random unspawn instead of first one
        if (validEvidences.length == 0) {
            for (let unspawnEvidence of this._myToUnspawnEvidences) {
                let setup = unspawnEvidence[0].getEvidenceSetup();
                if ((setup.myCardinalPositions == null || setup.myCardinalPositions.includes(cardinalPosition)) &&
                    (setup.myStartSpawnTime == null || setup.myStartSpawnTime < Global.myVentDuration) &&
                    (setup.myEndSpawnTime == null || setup.myEndSpawnTime > Global.myVentDuration) &&
                    setup.myRandomChance.get(Global.myVentDuration) > 0) {
                    validEvidences.push(unspawnEvidence[0]);
                }
            }
        }

        let randomChanceSum = 0;
        for (let evidence of validEvidences) {
            randomChanceSum += evidence.getEvidenceSetup().myRandomChance.get(Global.myVentDuration);
        }

        let random = Math.pp_randomInt(1, randomChanceSum);
        let currentSum = 0;
        for (let evidence of validEvidences) {
            currentSum += evidence.getEvidenceSetup().myRandomChance.get(Global.myVentDuration);
            if (random <= currentSum) {
                randomEvidence = evidence;
                break;
            }
        }

        this._myInactiveEvidences.pp_removeEqual(randomEvidence);
        this._myToUnspawnEvidences.pp_remove(element => element[0] == randomEvidence);

        return randomEvidence;
    }
}
class MrNOT {
    constructor(callbackOnPatienceOver, callbackOnReach, callbackOnExplosionDone) {
        this._myObject = Global.myGameObjects.get(GameObjectType.MR_NOT);

        this._myStartPosition = [0, 11, -18];
        this._myRotation = [40, 0, 0];
        this._myScale = [5, 5, 5];

        this._myTargetPosition = [0, 1, 0];
        this._myDirection = this._myTargetPosition.vec3_sub(this._myStartPosition);

        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Time To Reach Target", 60, 10, 3));
        PP.myEasyTuneVariables.add(new PP.EasyTuneInt("Max Patience", 25, 10));
        PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Reach Distance", 5, 10, 3));

        this._myCallbackOnPatienceOver = callbackOnPatienceOver;
        this._myCallbackOnReach = callbackOnReach;
        this._myCallbackOnExplosionDone = callbackOnExplosionDone;

        this._myFSM = new PP.FSM();

        //this._myFSM.setDebugLogActive(true, "        Mr NOT Clone");
        this._myFSM.addState("init");
        this._myFSM.addState("first_wait", new PP.TimerState(0.05, "end"));
        this._myFSM.addState("move", this._move.bind(this));
        this._myFSM.addState("explode", this._exploding.bind(this));
        this._myFSM.addState("disappear", this._disappear.bind(this));
        this._myFSM.addState("inactive");

        this._myFSM.addTransition("init", "first_wait", "start", this._prepareMove.bind(this));
        this._myFSM.addTransition("first_wait", "move", "end", this._startMove.bind(this));
        this._myFSM.addTransition("move", "explode", "explode", this._prepareExplode.bind(this));
        this._myFSM.addTransition("explode", "disappear", "end", this._prepareDisappear.bind(this));
        this._myFSM.addTransition("disappear", "inactive", "end");
        this._myFSM.addTransition("move", "inactive", "hide");
        this._myFSM.addTransition("explode", "inactive", "hide");
        this._myFSM.addTransition("disappear", "inactive", "hide");
        this._myFSM.addTransition("inactive", "first_wait", "start", this._prepareMove.bind(this));

        this._myFSM.init("init");

        this._myCollisions = this._myObject.pp_getComponentsHierarchy("collision");
        this._myPhysx = this._myObject.pp_getComponentHierarchy("physx");
        this._myCollisionsCollector = this._myObject.pp_getComponentHierarchy("physx-collector-component").getCollisionsCollector();

        this._myExplodeAudio = Global.myAudioManager.createAudioPlayer(SfxID.MR_NOT_EXPLODE);
        this._myHitAudio = Global.myAudioManager.createAudioPlayer(SfxID.CLONE_EXPLODE);
        this._myAppearAudio = Global.myAudioManager.createAudioPlayer(SfxID.MR_NOT_FAST_APPEAR);

        this._myRumbleScreen = new RumbleScreen();

        //Setup
        this._myReachTargetDistance = 5;
        this._myMinTargetDistance = 7;
        this._myMinParticleDistance = this._myScale[0] * 0.55;
        this._myParticlesSize = 6.5;
        this._myParticlesSizeMrNot = 0.9;
        this._myMaxPatience = 1;
        this._myPatienceRefill = 1;

        this._myReachTargetDistance = PP.myEasyTuneVariables.get("Reach Distance");

        let directionAngle = this._myDirection.vec3_angle(this._myDirection.vec3_removeComponentAlongAxis([0, 1, 0]));
        let distanceToIgnore = this._myReachTargetDistance / Math.cos(Math.pp_toRadians(directionAngle));

        this._mySpeed = (this._myTargetPosition.vec3_sub(this._myStartPosition).vec3_length() - distanceToIgnore) / PP.myEasyTuneVariables.get("Time To Reach Target");
        this._myMaxPatience = PP.myEasyTuneVariables.get("Max Patience");

        this._myDebugActive = false;
    }

    start(dt) {
        this._myFSM.perform("start");
    }

    update(dt) {
        if (Global.myDebugShortcutsEnabled) {
            if (PP.myLeftGamepad.getButtonInfo(PP.ButtonType.SELECT).isPressEnd(Global.myDebugShortcutsPress)) {
                //this._myCallbackOnPatienceOver();
                //this._myFSM.perform("explode");
            }
        }

        this._myCollisionsCollector.update(dt);

        this._myFSM.update(dt);

        this._myRumbleScreen.update(dt);
    }

    isDone() {
        return this._myFSM.isInState("inactive");
    }

    hide() {
        this._myRumbleScreen.stop();
        this._myObject.pp_setActive(false);
        this._myFSM.perform("hide");
    }

    _prepareMove() {
        PP.MeshUtils.setFogColor(this._myObject, [0, 0, 0, 0]);
        this._myObject.pp_setPosition(this._myStartPosition);
        this._myObject.pp_setScale(this._myScale);
        this._myObject.pp_setRotation(this._myRotation);

        for (let collision of this._myCollisions) {
            if (collision.collider == WL.Collider.Sphere) {
                collision.extents = [this._myScale[0] * 1.1, this._myScale[0] * 1.1, this._myScale[0] * 1.1];
            } else {
                collision.extents = [this._myScale[0], this._myScale[1], this._myScale[2] * 0.2];
            }
        }

        this._myPhysx.extents = [this._myScale[0] * 0.018, this._myScale[1] * 0.018, this._myScale[2] * 0.025];

        this._myCurrentPosition = [];
        this._myObject.pp_getPosition(this._myCurrentPosition);

        this._myPatience = this._myMaxPatience;

        this._myAppearAudio.setPosition(this._myObject.pp_getPosition());
        this._myAppearAudio.play();

        this._myRumbleScreen.stop();

        this._myRumbleScreen.start(0.3, 1.5);
        PP.myRightGamepad.pulse(0.6, 0.3);
        PP.myLeftGamepad.pulse(0.6, 0.3);
    }

    _startMove() {
        this._myObject.pp_setActive(true);
    }

    _move(dt) {
        this._myTargetPosition.vec3_sub(this._myStartPosition, this._myDirection);
        this._myDirection.vec3_normalize(this._myDirection);
        this._myDirection.vec3_scale(this._mySpeed * dt, this._myDirection);
        this._myObject.pp_translateWorld(this._myDirection);

        this._myObject.pp_getPosition(this._myCurrentPosition);
        let distanceToTarget = this._myTargetPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myCurrentPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();
        let distanceToTargetFromStart = this._myTargetPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myStartPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();
        let distanceToCurrentFromStart = this._myStartPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myCurrentPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();

        if (distanceToTarget < this._myReachTargetDistance || distanceToTargetFromStart < distanceToCurrentFromStart) {
            if (this._myCallbackOnReach) {
                this._myCallbackOnReach(this);
            }
        } else {
            this._checkHit();

            /*
            let distanceToTarget = this._myTargetPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myCurrentPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();
            if (distanceToTarget < 7) {
                this._myCallbackOnPatienceOver();
                this._myFSM.perform("explode");
            } 
            */
        }
    }

    _checkHit(avoidCallbacks = false) {
        let hit = false;
        let hittingObjects = [];

        let useCollider = false;
        if (useCollider) {
            let collidingComps = [];
            for (let collision of this._myCollisions) {
                collidingComps.push(collision.queryOverlaps());
            }

            if (collidingComps.length > 0) {
                for (let i = 0; i < collidingComps[0].length; ++i) {
                    let collidingComponent = collidingComps[0][i];
                    if (collidingComponent.object.pp_getComponent("evidence-component") != null) {
                        let isColliding = true;
                        for (let j = 1; j < collidingComps.length; ++j) {
                            if (collidingComps[j].pp_find(element => element.equals(collidingComponent)) == null) {
                                isColliding = false;
                                break;
                            }
                        }

                        if (isColliding) {
                            let evidenceComponent = collidingComponent.object.pp_getComponent("evidence-component");
                            if (evidenceComponent && evidenceComponent.getEvidence() && evidenceComponent.getEvidence().canHit()) {
                                hit = true;
                                hittingObjects.push(collidingComponent.object);
                            }
                        }
                    }
                }
            }
        }

        let usePhysx = true;
        if (usePhysx) {
            let collisionsStart = this._myCollisionsCollector.getCollisionsStart();
            if (collisionsStart.length > 0) {
                for (let collision of collisionsStart) {
                    let evidenceComponent = collision.pp_getComponent("evidence-component");
                    if (evidenceComponent && evidenceComponent.getEvidence() && evidenceComponent.getEvidence().canHit()) {
                        hit = true;
                        hittingObjects.push(collision);
                    }
                }
            }
        }

        if (hit) {
            let patienceToRemove = 0;
            for (let object of hittingObjects) {
                this._myHitAudio.setPosition(object.pp_getPosition());
                this._myHitAudio.setPitch(Math.pp_random(0.85, 1.05));
                this._myHitAudio.play();

                let evidence = object.pp_getComponent("evidence-component");
                evidence.bigHit(this._myObject);

                patienceToRemove++;
            }

            if (!avoidCallbacks) {
                this._myPatience -= patienceToRemove;

                let distanceToTarget = this._myTargetPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myCurrentPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();

                if (distanceToTarget > this._myMinTargetDistance) {
                    this._myPatience = Math.max(this._myPatience, this._myPatienceRefill);
                }

                if (this._myPatience <= 0) {
                    if (this._myDebugActive) {
                        console.log("mr NOT dismissed - Duration -", Global.myVentDuration.toFixed(3));
                    }

                    Global.myStatistics.myMrNOTDismissed += 1;
                    this._myFSM.perform("explode");
                    this._myCallbackOnPatienceOver();
                }
            }
        }
    }

    _prepareExplode() {
        this._mySpawnDelays = [2.5, 2.3, 2.0, 1.5, 1.0, 0.7, 0.6, 0.5, 0.4, 0.3];
        this._myExplodeTimer = new PP.Timer(20);
        this._mySpawnParticlesTimer = new PP.Timer(this._mySpawnDelays[0]);

        this._myMrNotUp = this._myObject.pp_getUp();
        this._myMrNotRight = this._myObject.pp_getRight();
        this._myMrNotForward = this._myObject.pp_getForward();

        this._myObject.pp_getPosition(this._myCurrentPosition);
        this._myParticlesPosition = null;
        this._myParticlesPosition = this._getNextParticlePosition();

        this._myPossibleGameObjectTypes = [
            //GameObjectType.TRIAL_TIMER,
            //GameObjectType.ZESTY_MARKET,
            GameObjectType.TUCIA_DRAWING,
            GameObjectType.CPLUSPLUS_PRIMER,
            GameObjectType.PIANO,
            GameObjectType.MICCO_THE_BEAR,
            GameObjectType.WATER_LILY,
            GameObjectType.LOL,
            GameObjectType.DRINK_ME_EARRING,
            GameObjectType.WONDERMELON,
            GameObjectType.SHATTERED_COIN,
            GameObjectType.PSI,
            GameObjectType.WONDERLAND,
            GameObjectType.ANT_MAIN_CHARACTER,
            GameObjectType.HEART,
            GameObjectType.HALO_SWORD,
            GameObjectType.FOX,
            GameObjectType.PICO_8,
            GameObjectType.EGGPLANT,
            GameObjectType.VR,
            GameObjectType.TROPHY,
            GameObjectType.FAMILY,
            GameObjectType.MIRROR,
            GameObjectType.WAYFINDER,
            GameObjectType.EVERYEYE,
            GameObjectType.ALOE_VERA,
            //GameObjectType.MR_NOT_EVIDENCE,
            //GameObjectType.STARING_CUBE,
        ];
    }

    _exploding(dt) {
        this._checkHit(true);

        this._myExplodeTimer.update(dt);
        if (this._myExplodeTimer.isDone()) {
            this._myFSM.perform("end");
        }

        this._mySpawnParticlesTimer.update(dt);
        if (this._mySpawnParticlesTimer.isDone()) {
            let delay = this._mySpawnDelays[0];
            if (this._mySpawnDelays.length > 1) {
                this._mySpawnDelays.shift();
            }
            this._mySpawnParticlesTimer.start(delay);
            let type = Math.pp_randomPick(this._myPossibleGameObjectTypes);
            Global.myParticlesManager.explosion(this._myParticlesPosition, 1.25, [this._myParticlesSize, this._myParticlesSize, this._myParticlesSize], type, true);

            this._addPulse(this._myParticlesPosition, this._mySpawnDelays.length <= 1);

            this._myExplodeAudio.setPosition(this._myParticlesPosition.pp_clone());
            this._myExplodeAudio.setPitch(Math.pp_random(0.85, 1.05));
            this._myExplodeAudio.play();

            this._myParticlesPosition = this._getNextParticlePosition();

            this._myRumbleScreen.start(Math.pp_random(0.4, 0.6), 1);
        }
    }

    _addPulse(position, justRandom) {
        let gamepad = PP.myLeftGamepad;
        if (position.vec3_isConcordant([1, 0, 0])) {
            gamepad = PP.myRightGamepad;
        }

        if (justRandom) {
            gamepad = (Math.pp_random() < 0.5) ? PP.myLeftGamepad : PP.myRightGamepad;
            if (gamepad == PP.myLeftGamepad && !PP.myRightGamepad.isPulsing()) {
                gamepad = PP.myRightGamepad;
            } else if (gamepad == PP.myRightGamepad && !PP.myLeftGamepad.isPulsing()) {
                gamepad = PP.myLeftGamepad;
            }
        }

        gamepad.pulse(Math.pp_random(0.4, 0.8), Math.pp_random(0.4, 0.6));
    }

    _prepareDisappear() {
        this._myDisappearTimer = new PP.Timer(3);
        this._myDisappearEndTimer = new PP.Timer(3, false);
    }

    _disappear(dt) {
        if (this._myDisappearTimer.isRunning()) {
            this._myDisappearTimer.update(dt);
            if (this._myDisappearTimer.isDone()) {
                this._myObject.pp_setActive(false);

                Global.myParticlesManager.explosion(this._myCurrentPosition, 1.6, [this._myParticlesSizeMrNot, this._myParticlesSizeMrNot, this._myParticlesSizeMrNot], GameObjectType.MR_NOT, true);
                this._myDisappearEndTimer.start();

                let audioPosition = this._myMrNotForward.vec3_scale(this._myScale[2] * 0.675).vec3_add(this._myCurrentPosition);
                //this._myMrNotUp.vec3_scale(1.35).vec3_add(audioPosition, audioPosition);
                this._myExplodeAudio.setPosition(audioPosition);
                this._myExplodeAudio.setPitch(1);
                this._myExplodeAudio.play();

                this._myRumbleScreen.start(Math.pp_random(0.4, 0.6), 1);
                PP.myRightGamepad.pulse(0.6, 0.5);
                PP.myLeftGamepad.pulse(0.6, 0.5);
            }
        }

        if (this._myDisappearEndTimer.isRunning()) {
            this._myDisappearEndTimer.update(dt);
            if (this._myDisappearEndTimer.isDone()) {
                this._myObject.pp_setActive(false);
                this._myRumbleScreen.stop();
                this._myFSM.perform("end");
            }
        }
    }

    _getNextParticlePosition() {
        let attempts = 100;
        let distance = 0;

        let position = [0, 0, 0];

        while (attempts > 0) {
            let randomX = Math.pp_random(0, this._myScale[0] * 0.6) * Math.pp_randomSign();
            let randomY = Math.pp_random(0, this._myScale[1] * 0.6) * Math.pp_randomSign();
            let randomZ = Math.pp_random(this._myScale[2] * 0.65, this._myScale[2] * 0.7);

            this._myMrNotUp.vec3_scale(randomY, position);
            this._myMrNotRight.vec3_scale(randomX).vec3_add(position, position);
            if (position.vec3_length() > this._myScale[0] * 0.65) {
                position.vec3_normalize(position).vec3_scale(Math.pp_random(this._myScale[0] * 0.6, this._myScale[0] * 0.65));
            }
            this._myMrNotForward.vec3_scale(randomZ).vec3_add(position, position);

            this._myMrNotUp.vec3_scale(Math.pp_random(1.25, 1.5)).vec3_add(position, position);
            this._myCurrentPosition.vec3_add(position, position);

            if (this._myParticlesPosition == null) {
                attempts = 0;
            } else {
                let relativeParticlePosition = this._myParticlesPosition.vec3_sub(this._myCurrentPosition);
                let relativeNewPosition = position.vec3_sub(this._myCurrentPosition);
                distance = position.vec3_distance(this._myParticlesPosition);
                if (distance > this._myMinParticleDistance &&
                    relativeNewPosition.vec3_isConcordant([1, 0, 0]) != relativeParticlePosition.vec3_isConcordant([1, 0, 0])) {
                    attempts = 0;
                } else {
                    attempts -= 1;
                }
            }
        }

        return position;
    }
}

class RumbleScreen {
    constructor() {
        this._myTimer = new PP.Timer(0, false);
    }

    start(duration, intensity) {
        this._myTimer.start(duration);
        this._myIntensity = intensity;
    }

    update(dt) {
        if (this._myTimer.isRunning()) {
            this._myTimer.update(dt);

            let rumbleValue = 0.04 * this._myIntensity;
            Global.myPlayerRumbleObject.pp_setPositionLocal([Math.pp_random(-rumbleValue, rumbleValue), Math.pp_random(-rumbleValue, rumbleValue), Math.pp_random(-rumbleValue, rumbleValue)]);

            if (this._myTimer.isDone()) {
                this.stop();
            }
        }
    }

    stop() {
        Global.myPlayerRumbleObject.pp_resetPositionLocal();
    }
}
class MrNOTCloneSetup {
    constructor() {
        this.myStartHeight = 4;
        this.myEndHeight = 1.4;
        this.myTimeToReachTarget = 7;
        this.myStartDistance = 30;

        this.myDirection = [0, 0, 1];
    }
}

class CloneRotationSetup {
    constructor() {
        this.mySpinSpeed = new RangeValue([0, 0], false);
        this.mySpinChance = new RangeValueOverTime([2, 2], [2, 2], 0, 0, true);
        this.mySpinStartTime = -1;

        this.myTiltAngle = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.myTiltChance = new RangeValueOverTime([2, 2], [2, 2], 0, 0, true);
        this.myTiltStartTime = -1;

        /* 
         this.mySpinSpeed = new RangeValue([4, 6], false);
         this.mySpinChance = new RangeValueOverTime([1, 30], [1, 15], 60, 120, true);
         this.mySpinStartTime = 60;
 
         this.myTiltAngle = new RangeValueOverTime([0, 0], [0, 15], 20, 60, false);
         */
    }
}

class MrNOTClone {
    constructor(position, targetPosition, timeToReachTarget, rotationSetup, callbackOnDismiss, callbackOnReach) {
        this._myObject = Global.myGameObjectPoolMap.getObject(GameObjectType.MR_NOT_CLONE);
        PP.MeshUtils.setAlpha(this._myObject, 0);
        this._myObject.pp_setPosition(position);
        this._myFacing = targetPosition.vec3_sub(position);
        this._myObject.pp_lookTo(this._myFacing, [0, 1, 0]);
        this._myObject.pp_setScale([1, 1, 1]);
        this._myObject.pp_setActive(true);
        this._myScale = this._myObject.pp_getScale();

        this._myStartPosition = position;

        this._myTargetPosition = targetPosition;

        this._myTimeToReachTarget = timeToReachTarget;

        this._myCallbackOnDismiss = callbackOnDismiss;
        this._myCallbackOnReach = callbackOnReach;

        this._myCurrentPosition = [];
        this._myObject.pp_getPosition(this._myCurrentPosition);

        this._mySpeed = this._myTargetPosition.vec3_sub(this._myCurrentPosition).vec3_length() / this._myTimeToReachTarget;
        this._myTempTranslation = [0, 0, 0];

        this._mySpawnTimer = new PP.Timer(0.5);

        this._myFSM = new PP.FSM();

        //this._myFSM.setDebugLogActive(true, "        Mr NOT Clone"); 
        this._myFSM.addState("init");
        this._myFSM.addState("move", this._move.bind(this));
        this._myFSM.addState("stop", this._stopUpdate.bind(this));
        this._myFSM.addState("unspawning", this._unspawning.bind(this));
        this._myFSM.addState("inactive");

        this._myFSM.addTransition("init", "move", "start");
        this._myFSM.addTransition("move", "unspawning", "unspawn");
        this._myFSM.addTransition("move", "stop", "startStop");
        this._myFSM.addTransition("stop", "unspawning", "unspawn");
        this._myFSM.addTransition("unspawning", "inactive", "end");
        this._myFSM.addTransition("move", "inactive", "hide");
        this._myFSM.addTransition("stop", "inactive", "hide");
        this._myFSM.addTransition("unspawning", "inactive", "hide");

        this._myFSM.init("init");
        this._myFSM.perform("start");

        this._myCollisions = this._myObject.pp_getComponentsHierarchy("collision");

        this._myHitAudio = Global.myAudioManager.createAudioPlayer(SfxID.CLONE_EXPLODE);
        this._myAppearAudio = Global.myAudioManager.createAudioPlayer(SfxID.CLONE_APPEAR);

        this._myAppearAudioDelay = new PP.Timer(0.2);

        if (rotationSetup.myTiltStartTime >= 0 && Global.myVentDuration >= rotationSetup.myTiltStartTime) {
            if (rotationSetup.myTiltChance.get(Global.myVentDuration) == 1) {
                let tiltAngle = rotationSetup.myTiltAngle.get(Global.myVentDuration) * Math.pp_randomSign();
                this._myObject.pp_rotateObject([0, 0, tiltAngle]);
            }
        }

        this._mySpin = false;
        if (rotationSetup.mySpinStartTime >= 0 && Global.myVentDuration >= rotationSetup.mySpinStartTime) {
            this._mySpin = rotationSetup.mySpinChance.get(Global.myVentDuration) == 1;
        }
        this._mySpinSpeed = rotationSetup.mySpinSpeed.get(Global.myVentDuration) * Math.pp_randomSign();

        this._myTimerBeforeCheckingSeen = new PP.Timer(3);
        this._myTimerBeforeSettingSeen = new PP.Timer(0.75, false);
        this._myMrNOTClonesSeen = Global.mySaveManager.loadBool("mr_NOT_clones_seen", false);

        //Setup
        this._myReachTargetDistance = Global.myRingRadius * 2;
    }

    update(dt) {
        this._myFSM.update(dt);

        if (!this._myMrNOTClonesSeen && this._myFSM.isInState("move") && this._myObject != null) {
            this._myTimerBeforeCheckingSeen.update(dt);
            if (this._myTimerBeforeCheckingSeen.isDone()) {
                if (!this._myTimerBeforeSettingSeen.isRunning()) {
                    let directionToClone = this._myObject.pp_getPosition();
                    directionToClone.vec3_sub(Global.myPlayerPosition, directionToClone).vec3_normalize(directionToClone);

                    let angle = Global.myPlayerForward.vec3_angle(directionToClone);
                    if (angle < 20) {
                        this._myTimerBeforeSettingSeen.start();
                    }
                } else {
                    this._myTimerBeforeSettingSeen.update(dt);
                    if (this._myTimerBeforeSettingSeen.isDone()) {
                        this._myMrNOTClonesSeen = true;
                        Global.mySaveManager.save("mr_NOT_clones_seen", true);
                    }
                }
            }
        }
    }

    canUnspawn() {
        return this._myFSM.canPerform("unspawn");
    }

    unspawn() {
        if (this._myFSM.canPerform("unspawn")) {
            this._mySpawnTimer.start(PP.myEasyTuneVariables.get("Unspawn Menu Time"));
        }
        this._myFSM.perform("unspawn");
    }

    stop() {
        this._myFSM.perform("startStop");
    }

    isDone() {
        return this._myFSM.isInState("inactive");
    }

    hide() {
        Global.myGameObjectPoolMap.releaseObject(GameObjectType.MR_NOT_CLONE, this._myObject);
        this._myObject = null;
        this._myFSM.perform("hide");
    }

    _move(dt) {
        if (this._mySpin) {
            this._myObject.pp_rotateObject([0, 0, Math.sin(dt * this._mySpinSpeed) * 180]);
        }

        if (this._myAppearAudioDelay.isRunning()) {
            this._myAppearAudioDelay.update(dt);
            if (this._myAppearAudioDelay.isDone()) {
                this._myAppearAudio.setPosition(this._myObject.pp_getPosition());
                this._myAppearAudio.setPitch(Math.pp_random(0.85, 1.05));
                this._myAppearAudio.play();
            }
        }

        if (this._mySpawnTimer.isRunning()) {
            this._mySpawnTimer.update(dt);
            PP.MeshUtils.setAlpha(this._myObject, this._mySpawnTimer.getPercentage());
        }

        this._myObject.pp_getPosition(this._myCurrentPosition);
        this._myTargetPosition.vec3_sub(this._myCurrentPosition, this._myFacing);

        this._myObject.pp_lookTo(this._myFacing);

        this._myTempTranslation[2] = this._mySpeed * dt;
        this._myObject.pp_translateObject(this._myTempTranslation);

        this._myObject.pp_getPosition(this._myCurrentPosition);
        let distanceToTarget = this._myTargetPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myCurrentPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();
        let distanceToTargetFromStart = this._myTargetPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myStartPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();
        let distanceToCurrentFromStart = this._myStartPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myCurrentPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();

        if (distanceToTarget < this._myReachTargetDistance || distanceToTargetFromStart < distanceToCurrentFromStart) {
            if (PP.myEasyTuneVariables.get("Prevent Vent Lost")) {
                this._myCallbackOnDismiss(this, null);
                this.unspawn();
            } else {
                if (this._myCallbackOnReach) {
                    this._myCallbackOnReach(this);
                }
            }
        } else {
            this._checkHit();
        }
    }

    _stopUpdate() {
        this._checkHit(true);
    }

    _checkHit(avoidCallbacks = false) {
        let hit = false;
        let hittingObject = null;

        let collidingComps = [];
        for (let collision of this._myCollisions) {
            collidingComps.push(collision.queryOverlaps());
        }

        if (collidingComps.length > 0) {
            for (let i = 0; i < collidingComps[0].length; ++i) {
                let collidingComponent = collidingComps[0][i];
                if (collidingComponent.object.pp_getComponent("evidence-component") != null) {
                    let isColliding = true;
                    for (let j = 1; j < collidingComps.length; ++j) {
                        if (collidingComps[j].pp_find(element => element.equals(collidingComponent)) == null) {
                            isColliding = false;
                            break;
                        }
                    }

                    if (isColliding) {
                        let evidenceComponent = collidingComponent.object.pp_getComponent("evidence-component");
                        if (evidenceComponent && evidenceComponent.getEvidence() && evidenceComponent.getEvidence().canHit()) {
                            hit = true;
                            hittingObject = collidingComponent.object;
                            break;
                        }
                    }
                }
            }
        }

        if (hit) {
            let evidence = hittingObject.pp_getComponent("evidence-component");
            evidence.hit(this._myObject);
            this.unspawn();
            this._myHitAudio.setPosition(this._myObject.pp_getPosition());
            this._myHitAudio.setPitch(Math.pp_random(0.85, 1.05));
            this._myHitAudio.play();
            if (this._myCallbackOnDismiss && !avoidCallbacks) {
                this._myCallbackOnDismiss(this, hittingObject);
            }

            Global.myStatistics.myMrNOTClonesDismissed += 1;
            Global.myStatistics.myMrNOTClonesDismissedResettable += 1;
        }
    }

    _unspawning(dt) {
        this._mySpawnTimer.update(dt);

        let scaleMultiplier = Math.pp_interpolate(1, PP.myEasyTuneVariables.get("Unspawn Menu Scale"), this._mySpawnTimer.getPercentage());
        this._myObject.pp_setScale(this._myScale.vec3_scale(scaleMultiplier));

        if (this._mySpawnTimer.isDone()) {
            Global.myParticlesManager.explosion(this._myObject.pp_getPosition(), 0.75, this._myScale.vec3_scale(PP.myEasyTuneVariables.get("mr NOT Clone Scale")), GameObjectType.MR_NOT_CLONE);
            this.hide();
        }
    }
}
class MrNOTVentSetup {
    constructor() {
        this.myDirection = [0, 0, -1];

        this.myTimeToReachTarget = 50;
        this.myMaxPatience = 15;
        this.myReachTargetDistance = 5;
    }
}

class MrNOTVent {
    constructor(mrNOTSetup, ventRuntimeSetup, callbackOnPatienceOver, callbackOnReach) {
        this._myMrNOTSetup = mrNOTSetup;
        this._myObject = Global.myGameObjects.get(GameObjectType.MR_NOT);

        this._myStartPosition = [0, 11, -18];
        this._myRotation = [40, 0, 0];
        this._myScale = [5, 5, 5];


        this._myTargetPosition = [0, 1, 0];
        this._myDirection = this._myTargetPosition.vec3_sub(this._myStartPosition);

        this._myCallbackOnPatienceOver = callbackOnPatienceOver;
        this._myCallbackOnReach = callbackOnReach;

        this._myFSM = new PP.FSM();

        //this._myFSM.setDebugLogActive(true, "        Mr NOT Clone");
        this._myFSM.addState("init");
        this._myFSM.addState("first_wait", new PP.TimerState(0.05, "end"));
        this._myFSM.addState("move", this._move.bind(this));
        this._myFSM.addState("stop", this._stopUpdate.bind(this));
        this._myFSM.addState("disappear", this._disappear.bind(this));
        this._myFSM.addState("inactive");

        this._myFSM.addTransition("init", "first_wait", "start", this._prepareMove.bind(this));
        this._myFSM.addTransition("first_wait", "move", "end", this._startMove.bind(this));
        this._myFSM.addTransition("move", "disappear", "disappear", this._prepareDisappear.bind(this));
        this._myFSM.addTransition("move", "stop", "startStop");
        this._myFSM.addTransition("stop", "disappear", "disappear", this._prepareDisappear.bind(this));
        this._myFSM.addTransition("disappear", "inactive", "end");
        this._myFSM.addTransition("move", "inactive", "hide");
        this._myFSM.addTransition("disappear", "inactive", "hide");
        this._myFSM.addTransition("stop", "inactive", "hide");
        this._myFSM.addTransition("inactive", "first_wait", "start", this._prepareMove.bind(this));

        this._myFSM.init("init");

        this._myCollisions = this._myObject.pp_getComponentsHierarchy("collision");
        this._myPhysx = this._myObject.pp_getComponentHierarchy("physx");
        this._myCollisionsCollector = this._myObject.pp_getComponentHierarchy("physx-collector-component").getCollisionsCollector();

        this._myExplodeAudio = Global.myAudioManager.createAudioPlayer(SfxID.MR_NOT_EXPLODE);
        this._myHitAudio = Global.myAudioManager.createAudioPlayer(SfxID.CLONE_EXPLODE);
        this._myAppearAudio = Global.myAudioManager.createAudioPlayer(SfxID.MR_NOT_FAST_APPEAR);

        this._myRumbleScreen = new RumbleScreen();

        //Setup
        this._myReachTargetDistance = 5;
        this._myMinTargetDistance = 10;
        this._myMinParticleDistance = this._myScale[0] * 0.55;
        this._myParticlesSize = 6.5;
        this._myParticlesSizeMrNot = 0.9;
        this._myMaxPatience = 1;
        this._myPatienceRefill = 0;

        this._myReachTargetDistance = this._myMrNOTSetup.myReachTargetDistance;

        let directionAngle = this._myDirection.vec3_angle(this._myDirection.vec3_removeComponentAlongAxis([0, 1, 0]));
        let distanceToIgnore = this._myReachTargetDistance / Math.cos(Math.pp_toRadians(directionAngle));

        this._mySpeed = (this._myTargetPosition.vec3_sub(this._myStartPosition).vec3_length() - distanceToIgnore) / this._myMrNOTSetup.myTimeToReachTarget;
        this._myMaxPatience = this._myMrNOTSetup.myMaxPatience;

        this._myFSM.perform("start");
    }

    update(dt) {
        this._myCollisionsCollector.update(dt);

        this._myFSM.update(dt);

        this._myRumbleScreen.update(dt);
    }

    isDone() {
        return this._myFSM.isInState("inactive");
    }

    hide() {
        this._myRumbleScreen.stop();
        this._myObject.pp_setActive(false);
        this._myFSM.perform("hide");
    }

    stop() {
        this._myFSM.perform("startStop");
    }

    _prepareMove() {
        PP.MeshUtils.setFogColor(this._myObject, [0, 0, 0, 0]);
        this._myObject.pp_setPosition(this._myStartPosition);
        this._myObject.pp_setScale(this._myScale);
        this._myObject.pp_setRotation(this._myRotation);

        let angle = -this._myMrNOTSetup.myDirection.vec3_angleSigned([0, 0, -1], [0, 1, 0]);
        this._myObject.pp_rotateAroundAxis(angle, [0, 1, 0], [0, 0, 0]);
        this._myObject.pp_getPosition(this._myStartPosition);
        this._myDirection = this._myTargetPosition.vec3_sub(this._myStartPosition);

        for (let collision of this._myCollisions) {
            if (collision.collider == WL.Collider.Sphere) {
                collision.extents = [this._myScale[0] * 1.1, this._myScale[0] * 1.1, this._myScale[0] * 1.1];
            } else {
                collision.extents = [this._myScale[0], this._myScale[1], this._myScale[2] * 0.2];
            }
        }

        this._myPhysx.extents = [this._myScale[0] * 0.018, this._myScale[1] * 0.018, this._myScale[2] * 0.025];

        this._myCurrentPosition = [];
        this._myObject.pp_getPosition(this._myCurrentPosition);

        this._myPatience = this._myMaxPatience;

        this._myAppearAudio.setPosition(this._myObject.pp_getPosition());
        this._myAppearAudio.play();

        this._myRumbleScreen.stop();

        this._myRumbleScreen.start(0.3, 1.5);
        PP.myRightGamepad.pulse(0.6, 0.3);
        PP.myLeftGamepad.pulse(0.6, 0.3);

        this._myHitsReceived = 0;
    }

    _startMove() {
        this._myObject.pp_setActive(true);
    }

    _move(dt) {
        this._myTargetPosition.vec3_sub(this._myStartPosition, this._myDirection);
        this._myDirection.vec3_normalize(this._myDirection);
        this._myDirection.vec3_scale(this._mySpeed * dt, this._myDirection);
        this._myObject.pp_translateWorld(this._myDirection);

        this._myObject.pp_getPosition(this._myCurrentPosition);
        let distanceToTarget = this._myTargetPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myCurrentPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();
        let distanceToTargetFromStart = this._myTargetPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myStartPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();
        let distanceToCurrentFromStart = this._myStartPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myCurrentPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();

        if (distanceToTarget < this._myReachTargetDistance || distanceToTargetFromStart < distanceToCurrentFromStart) {
            //console.log("mr NOT Hits Received -", this._myHitsReceived);
            if (this._myCallbackOnReach) {
                this._myCallbackOnReach(this);
            }
        } else {
            this._checkHit();

            /*
            let distanceToTarget = this._myTargetPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myCurrentPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();
            if (distanceToTarget < this._myMinTargetDistance) {
                this._myCallbackOnPatienceOver();
                this._myFSM.perform("explode");
            }
            */
        }
    }

    _stopUpdate() {
        this._checkHit(true);
    }

    _checkHit(avoidCallbacks = false) {
        let hit = false;
        let hittingObjects = [];

        let useCollider = false;
        if (useCollider) {
            let collidingComps = [];
            for (let collision of this._myCollisions) {
                collidingComps.push(collision.queryOverlaps());
            }

            if (collidingComps.length > 0) {
                for (let i = 0; i < collidingComps[0].length; ++i) {
                    let collidingComponent = collidingComps[0][i];
                    if (collidingComponent.object.pp_getComponent("evidence-component") != null) {
                        let isColliding = true;
                        for (let j = 1; j < collidingComps.length; ++j) {
                            if (collidingComps[j].pp_find(element => element.equals(collidingComponent)) == null) {
                                isColliding = false;
                                break;
                            }
                        }

                        if (isColliding) {
                            let evidenceComponent = collidingComponent.object.pp_getComponent("evidence-component");
                            if (evidenceComponent && evidenceComponent.getEvidence() && evidenceComponent.getEvidence().canHit()) {
                                hit = true;
                                hittingObjects.push(collidingComponent.object);
                            }
                        }
                    }
                }
            }
        }

        let usePhysx = true;
        if (usePhysx) {
            let collisionsStart = this._myCollisionsCollector.getCollisionsStart();
            if (collisionsStart.length > 0) {
                for (let collision of collisionsStart) {
                    let evidenceComponent = collision.pp_getComponent("evidence-component");
                    if (evidenceComponent && evidenceComponent.getEvidence() && evidenceComponent.getEvidence().canHit()) {
                        hit = true;
                        hittingObjects.push(collision);
                    }
                }
            }
        }

        if (hit) {
            let patienceToRemove = 0;
            for (let object of hittingObjects) {
                this._myHitAudio.setPosition(object.pp_getPosition());
                this._myHitAudio.setPitch(Math.pp_random(0.85, 1.05));
                this._myHitAudio.play();

                let evidence = object.pp_getComponent("evidence-component");
                evidence.bigHit(this._myObject);

                patienceToRemove++;
            }


            this._myHitsReceived += patienceToRemove;

            if (!avoidCallbacks) {
                this._myPatience -= patienceToRemove;

                let distanceToTarget = this._myTargetPosition.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_sub(this._myCurrentPosition.vec3_removeComponentAlongAxis([0, 1, 0])).vec3_length();

                if (distanceToTarget > this._myMinTargetDistance) {
                    this._myPatience = Math.max(this._myPatience, this._myPatienceRefill);
                }

                if (this._myPatience <= 0) {
                    Global.myStatistics.myMrNOTDismissed += 1;
                    this._myFSM.perform("disappear");
                    this._myCallbackOnPatienceOver();
                }
            }
        }
    }

    disappear() {
        this._myFSM.perform("disappear");
    }

    _prepareDisappear() {
        this._myDisappearTimer = new PP.Timer(0);
        this._myDisappearEndTimer = new PP.Timer(0.7, false);
        this._myObject.pp_getPosition(this._myCurrentPosition);
    }

    _disappear(dt) {
        if (this._myDisappearTimer.isRunning()) {
            this._myDisappearTimer.update(dt);
            if (this._myDisappearTimer.isDone()) {
                this._myObject.pp_setActive(false);
                Global.myParticlesManager.explosion(this._myCurrentPosition, 1.6, [this._myParticlesSizeMrNot, this._myParticlesSizeMrNot, this._myParticlesSizeMrNot], GameObjectType.MR_NOT, true);
                this._myDisappearEndTimer.start();

                this._myMrNotUp = this._myObject.pp_getUp();
                this._myMrNotForward = this._myObject.pp_getForward();
                let audioPosition = this._myMrNotForward.vec3_scale(this._myScale[2] * 0.675).vec3_add(this._myCurrentPosition);
                //this._myMrNotUp.vec3_scale(1.35).vec3_add(audioPosition, audioPosition);
                this._myExplodeAudio.setPosition(audioPosition);
                this._myExplodeAudio.setPitch(1);
                this._myExplodeAudio.play();

                this._myRumbleScreen.start(Math.pp_random(0.4, 0.6), 1);
                PP.myRightGamepad.pulse(0.6, 0.5);
                PP.myLeftGamepad.pulse(0.6, 0.5);
            }
        }

        if (this._myDisappearEndTimer.isRunning()) {
            this._myDisappearEndTimer.update(dt);
            if (this._myDisappearEndTimer.isDone()) {
                this._myRumbleScreen.stop();
                this._myFSM.perform("end");
            }
        }
    }
}
class MrNOTVentState extends PP.State {
    constructor() {
        super();

        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "        mr NOT Vent");
        this._myFSM.addState("init");
        this._myFSM.addState("first_wait", new PP.TimerState(0, "end"));
        this._myFSM.addState("vent", this._updateVent.bind(this));
        this._myFSM.addState("clean", this._updateClean.bind(this));
        this._myFSM.addState("defeat", this._updateDefeat.bind(this));
        this._myFSM.addState("second_wait_clean", new PP.TimerState(0, "end"));
        this._myFSM.addState("second_wait_defeat", new PP.TimerState(0, "end"));
        this._myFSM.addState("done");

        this._myFSM.addTransition("init", "first_wait", "start", this._prepareState.bind(this));
        this._myFSM.addTransition("first_wait", "vent", "end", this._prepareVent.bind(this));
        this._myFSM.addTransition("vent", "clean", "completed", this._prepareClean.bind(this));
        this._myFSM.addTransition("vent", "defeat", "lost", this._prepareDefeat.bind(this));
        this._myFSM.addTransition("clean", "second_wait_clean", "end");
        this._myFSM.addTransition("defeat", "second_wait_defeat", "end");
        this._myFSM.addTransition("second_wait_clean", "done", "end", this._ventCompleted.bind(this));
        this._myFSM.addTransition("second_wait_defeat", "done", "end", this._ventLost.bind(this));
        this._myFSM.addTransition("done", "first_wait", "start", this._prepareState.bind(this));

        this._myFSM.addTransition("init", "done", "skip");
        this._myFSM.addTransition("first_wait", "done", "skip");
        this._myFSM.addTransition("second_wait_clean", "done", "skip");
        this._myFSM.addTransition("second_wait_defeat", "done", "skip");
        this._myFSM.addTransition("vent", "done", "skip", this._hideVent.bind(this));
        this._myFSM.addTransition("clean", "done", "skip", this._hideVent.bind(this));
        this._myFSM.addTransition("defeat", "done", "skip", this._hideVent.bind(this));

        this._myFSM.init("init");

        this._myParentFSM = null;

        this._myEvidenceManager = new EvidenceManager(this._buildEvidenceSetupList());
        this._myMrNOT = new MrNOT(this._onPatienceOver.bind(this), this._onMrNOTReach.bind(this), this._onExplosionDone.bind(this));
        this._myVent = new Vent(this._buildVentSetup());
        this._myVent.onVentLost(this._onVentReach.bind(this));
        this._myNotEnough = new NotEnough();

        this._myCleanTimer = new PP.Timer(2.75);
        this._myEvidenceTimer = new PP.Timer(1);
    }

    update(dt, fsm) {
        Global.myVentDuration += dt;

        this._myFSM.update(dt);
        this._myEvidenceManager.update(dt);
        this._myVent.update(dt);
        this._myMrNOT.update(dt);

        if (Global.myDebugShortcutsEnabled) {
            //TEMP REMOVE THIS
            if (PP.myRightGamepad.getButtonInfo(PP.ButtonType.SELECT).isPressEnd(Global.myDebugShortcutsPress)) {
                Global.myStopMusic = true;
                this._myFSM.perform("skip");
                this._myVent.ventCompletedDebug();
                this._ventCompleted();
            }

            //TEMP REMOVE THIS
            if (PP.myLeftGamepad.getButtonInfo(PP.ButtonType.SQUEEZE).isPressEnd(Global.myDebugShortcutsPress)) {
                Global.myStopMusic = true;
                this._myFSM.perform("skip");
                this._myVent.ventLostDebug();
                this._ventLost();
            }
        }
    }

    _prepareState(fsm, transition) {
        Global.myLightFadeInTime = 0;
        Global.myVentDuration = 0;
        this._myNotEnough.stop();
    }

    _prepareVent() {
        this._myMrNOT.start();
        this._myEvidenceTimer.start();
        this._myVent.start();

        Global.mySaveManager.save("mr_NOT_encountered", true);
    }

    _updateVent(dt, fsm) {
        if (this._myEvidenceTimer.isRunning()) {
            this._myEvidenceTimer.update(dt);
            if (this._myEvidenceTimer.isDone()) {
                this._myEvidenceManager.start();
            }
        }

    }

    _prepareClean() {
        this._myCleanTimer.start();
        this._myVent.clean(this._myCleanTimer.getDuration());

        Global.myStopMusic = true;
    }

    _updateClean(dt, fsm) {
        if (this._myCleanTimer.isRunning()) {
            this._myCleanTimer.update(dt);
            if (this._myCleanTimer.isDone()) {
                this._myEvidenceManager.clean();
            }
        }

        if (this._myMrNOT.isDone() && this._myEvidenceManager.isDone() && this._myVent.isDone()) {
            this._myFSM.perform("end");
        }
    }

    _prepareDefeat() {
        let zestyObject = Global.myGameObjects.get(GameObjectType.ZESTY_MARKET);
        let grabbable = zestyObject.pp_getComponentHierarchy("pp-grabbable");
        if (grabbable.isGrabbed()) {
            let zestyComponent = zestyObject.pp_getComponentHierarchy("zesty-banner");
            if (zestyComponent) {
                //Global.myZestyToClick = zestyComponent;
            }
        }

        this._myVent.stop();
        this._myEvidenceManager.explode();
        this._myMrNOT.hide();
        this._myNotEnough.start();
        Global.myParticlesManager.mrNOTParticles(Global.myPlayerPosition);

        Global.myStopMusic = true;
    }

    _updateDefeat(dt, fsm) {
        this._myNotEnough.update(dt);

        if (this._myEvidenceManager.isDone() && !this._myNotEnough.isNotEnoughing()) {
            this._myFSM.perform("end");
        }
    }

    _ventCompleted() {
        this._myParentFSM.perform("completed");
    }

    _ventLost(dt, fsm) {
        this._myParentFSM.perform("lost");
    }

    _hideVent() {
        this._hideEvidences();
        this._myMrNOT.hide();
        this._myVent.stop();
        this._myNotEnough.stop();
    }

    _hideEvidences() {
        this._myEvidenceManager.hide();
    }

    start(fsm, transition) {
        this._myParentFSM = fsm;
        this._myFSM.perform("start");
    }

    end(fsm, transitionID) {
        if (!this._myFSM.isInState("done")) {
            this._myFSM.perform("skip");
        }
    }

    _buildEvidenceSetupList() {
        let evidenceSetupList = [];

        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TRIAL_TIMER, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.ZESTY_MARKET, 4));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TUCIA_DRAWING, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.CPLUSPLUS_PRIMER, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PIANO, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.MICCO_THE_BEAR, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WATER_LILY, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.LOL, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.DRINK_ME_EARRING, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.STARING_CUBE, 3));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.TROPHY, 5));

        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WONDERMELON, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PSI, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WONDERLAND, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.VR, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.EGGPLANT, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.PICO_8, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.EVERYEYE, 5));

        evidenceSetupList.push(new EvidenceSetup(GameObjectType.ANT_MAIN_CHARACTER, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.SHATTERED_COIN, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.HEART, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.HALO_SWORD, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.FOX, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.FAMILY, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.MIRROR, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.ALOE_VERA, 5));
        evidenceSetupList.push(new EvidenceSetup(GameObjectType.MR_NOT_EVIDENCE, 5));

        evidenceSetupList.push(new EvidenceSetup(GameObjectType.WAYFINDER, 25, null, null,
            [CardinalPosition.NORTH, CardinalPosition.NORTH_EAST, CardinalPosition.NORTH_WEST, CardinalPosition.EAST, CardinalPosition.WEST]));

        return evidenceSetupList;
    }

    _onPatienceOver() {
        this._myFSM.perform("completed");
    }

    _onMrNOTReach() {
        this._myVent.ventLostDebug();
        this._myFSM.perform("lost");
    }

    _onVentReach() {
        this._myFSM.perform("lost");
    }

    _onExplosionDone() {
    }

    _buildVentSetup() {
        let ventSetup = new VentSetup();

        ventSetup.myIsEndless = true;

        ventSetup.myBreakSetup.myBreakDuration = new RangeValue([2, 3]);
        ventSetup.myBreakSetup.myBreakTimeCooldown = new RangeValueOverTime([20, 25], [20, 25], 10, 30, false);
        ventSetup.myBreakSetup.myBreakCloneCooldown = 5;

        ventSetup.mySmallBreakSetup.myBreakDuration = new RangeValueOverTime([1, 2], [1, 2], 10, 30, false);
        ventSetup.mySmallBreakSetup.myBreakTimeCooldown = new RangeValueOverTime([800, 1200], [800, 1200], 10, 30, false);
        ventSetup.mySmallBreakSetup.myBreakCloneCooldown = 3;

        ventSetup.myCloneRotationSetup.mySpinSpeed = new RangeValue([4, 6], false);
        ventSetup.myCloneRotationSetup.mySpinChance = new RangeValueOverTime([1, 8], [1, 4], 20, 40, true);
        ventSetup.myCloneRotationSetup.mySpinStartTime = 20;

        ventSetup.myCloneRotationSetup.myTiltAngle = new RangeValueOverTime([0, 10], [0, 15], 15, 35, false);
        ventSetup.myCloneRotationSetup.myTiltChance = new RangeValueOverTime([1, 5], [1, 2], 15, 35, true);
        ventSetup.myCloneRotationSetup.myTiltStartTime = 15;

        ventSetup.myValidAngleRanges =
            [[new RangeValueOverTime([30, 180], [90, 180], PP.myEasyTuneVariables.get("Time To Reach Target") / 5, PP.myEasyTuneVariables.get("Time To Reach Target")), [0, 0, -1]],
            [new RangeValueOverTime([-180, -30], [-180, -90], PP.myEasyTuneVariables.get("Time To Reach Target") / 5, PP.myEasyTuneVariables.get("Time To Reach Target")), [0, 0, -1]]];

        let multipliers = new VentRuntimeMultipliers();

        multipliers.mySpawnTimeMultiplier = 1;
        multipliers.myDoneTimeMultiplier = 1;
        multipliers.myBreakTimeMultiplier = 1;
        multipliers.myBreakDelayTimeMultiplier = 1;
        multipliers.mySmallBreakTimeMultiplier = 1;
        multipliers.mySmallBreakDelayTimeMultiplier = 1;

        ventSetup.myVentMultipliers = multipliers;

        ventSetup.myDelayBeforeStart = 7;

        let timeBetweenClones = new RangeValueOverTime([2, 3], [1.5, 2.5], 10, 30, false);
        let doneDelay = new RangeValueOverTime([2.5, 4], [2, 3], 10, 30, false);

        {
            let wave = new IAmHereWaveSetup();

            wave.myClonesCount = new RangeValue([2, 3], true);
            wave.myWaveStartAngle = new RangeValue([45, 55]);
            wave.mySpawnConeAngle = new RangeValue([20, 30]);
            wave.myMinAngleBetweenClones = 10;
            wave.myTimeBetweenClones = timeBetweenClones;
            wave.myDoneDelay = doneDelay;
            wave.myFirstCloneInTheMiddle = true;
            wave.myRefDirection = [0, 0, -1];

            let nextWavesSetup = new NextWavesSetup();
            nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
            nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
            nextWavesSetup.addWave("I_Am_Here", 100);
            nextWavesSetup.addWave("Queue_For_You", 100);
            nextWavesSetup.addWave("Give_Us_A_Hug", 100);
            nextWavesSetup.addWave("I_Am_Everywhere", 100);
            nextWavesSetup.addWave("Man_In_The_Middle", 100);

            ventSetup.myWavesMap.set("I_Am_Here_mr_NOT_Side", wave);
            ventSetup.myNextWavesMap.set("I_Am_Here_mr_NOT_Side", nextWavesSetup);
        }

        {
            let wave = new IAmHereWaveSetup();

            wave.myClonesCount = new RangeValueOverTime([1, 3], [1, 5], 10, 30, true);
            wave.myWaveStartAngle = new RangeValue([10, 175]);
            wave.mySpawnConeAngle = new RangeValue([20, 40]);
            wave.myMinAngleBetweenClones = 10;
            wave.myTimeBetweenClones = timeBetweenClones;
            wave.myDoneDelay = doneDelay;
            wave.myFirstCloneInTheMiddle = true;

            let nextWavesSetup = new NextWavesSetup();
            nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
            nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
            nextWavesSetup.addWave("I_Am_Here", 100);
            nextWavesSetup.addWave("Queue_For_You", 100);
            nextWavesSetup.addWave("Give_Us_A_Hug", 100);
            nextWavesSetup.addWave("I_Am_Everywhere", 100);
            nextWavesSetup.addWave("Man_In_The_Middle", 100);

            ventSetup.myWavesMap.set("I_Am_Here", wave);
            ventSetup.myNextWavesMap.set("I_Am_Here", nextWavesSetup);
        }

        {
            let wave = new IAmEverywhereWaveSetup();

            wave.myWavesCount = new RangeValueOverTime([3, 4], [3, 5], 10, 30, true);
            wave.myAngleBetweenWaves = new RangeValueOverTime([60, 110], [60, 150], 10, 30, false);
            wave.myTimeBetweenWaves = timeBetweenClones;
            wave.myDoneDelay = new RangeValueOverTime([3, 4], [2.5, 3], 10, 30, false);
            wave.myWaveStartAngle = new RangeValue([10, 175]);

            let nextWavesSetup = new NextWavesSetup();
            nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
            nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
            nextWavesSetup.addWave("I_Am_Here", 100);
            nextWavesSetup.addWave("Queue_For_You", 100);
            nextWavesSetup.addWave("Give_Us_A_Hug", 100);
            nextWavesSetup.addWave("Man_In_The_Middle", 100);

            ventSetup.myWavesMap.set("I_Am_Everywhere", wave);
            ventSetup.myNextWavesMap.set("I_Am_Everywhere", nextWavesSetup);
        }

        {
            let wave = new MerryGoRoundSetup();

            wave.myWavesCount = new RangeValueOverTime([3, 5], [4, 6], 10, 30, true);
            wave.myAngleBetweenWaves = new RangeValue([15, 25]);
            wave.myTimeBetweenWaves = new RangeValueOverTime([2, 3], [1.5, 2], 10, 30, false);
            wave.myWaveStartAngle = new RangeValue([10, 175]);
            wave.mySameTimeBetweenWaves = 1;
            wave.myDoneDelay = doneDelay;
            wave.myWaveDirection = 1;

            let nextWavesSetup = new NextWavesSetup();
            nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
            nextWavesSetup.addWave("I_Am_Here", 100);
            nextWavesSetup.addWave("Queue_For_You", 100);
            nextWavesSetup.addWave("Give_Us_A_Hug", 100);
            nextWavesSetup.addWave("I_Am_Everywhere", 100);
            nextWavesSetup.addWave("Man_In_The_Middle", 100);

            ventSetup.myWavesMap.set("Merry_Go_Round_Left", wave);
            ventSetup.myNextWavesMap.set("Merry_Go_Round_Left", nextWavesSetup);
        }

        {
            let wave = new MerryGoRoundSetup();

            wave.myWavesCount = new RangeValueOverTime([3, 5], [4, 6], 10, 30, true);
            wave.myAngleBetweenWaves = new RangeValue([15, 25]);
            wave.myTimeBetweenWaves = new RangeValueOverTime([2, 3], [1.5, 2], 10, 30, false);
            wave.myWaveStartAngle = new RangeValue([10, 175]);
            wave.mySameTimeBetweenWaves = 1;
            wave.myDoneDelay = doneDelay;
            wave.myWaveDirection = -1;

            let nextWavesSetup = new NextWavesSetup();
            nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
            nextWavesSetup.addWave("I_Am_Here", 100);
            nextWavesSetup.addWave("Queue_For_You", 100);
            nextWavesSetup.addWave("Give_Us_A_Hug", 100);
            nextWavesSetup.addWave("I_Am_Everywhere", 100);
            nextWavesSetup.addWave("Man_In_The_Middle", 100);

            ventSetup.myWavesMap.set("Merry_Go_Round_Right", wave);
            ventSetup.myNextWavesMap.set("Merry_Go_Round_Right", nextWavesSetup);
        }

        {
            let wave = new QueueForYouWaveSetup();

            wave.myClonesCount = new RangeValueOverTime([2, 3], [2, 5], 10, 30, true);
            wave.myWaveStartAngle = new RangeValue([10, 175]);
            wave.myTimeBetweenClones = timeBetweenClones;
            wave.myDoneDelay = doneDelay;
            wave.mySameTimeBetweenClones = new RangeValueOverTime([1, 1], [-1, 1], 10, 30, false); // >= 0 means true

            let nextWavesSetup = new NextWavesSetup();
            nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
            nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
            nextWavesSetup.addWave("I_Am_Here", 100);
            nextWavesSetup.addWave("Queue_For_You", 100);
            nextWavesSetup.addWave("Give_Us_A_Hug", 100);
            nextWavesSetup.addWave("I_Am_Everywhere", 100);
            nextWavesSetup.addWave("Man_In_The_Middle", 100);

            ventSetup.myWavesMap.set("Queue_For_You", wave);
            ventSetup.myNextWavesMap.set("Queue_For_You", nextWavesSetup);
        }

        {
            let wave = new GiveUsAHugSetup();

            wave.myClonesCount = new RangeValueOverTime([1, 2], [2, 3], 10, 30, true);
            wave.mySpawnConeAngle = new RangeValue([20, 40]);
            wave.myMinAngleBetweenClones = 10;
            wave.myWaveStartAngle = new RangeValue([10, 175]);
            wave.myTimeBetweenClones = timeBetweenClones;
            wave.myDoneDelay = doneDelay;
            wave.myFirstCloneInTheMiddle = true;

            wave.myHugSize = new RangeValueOverTime([2, 2], [2, 2], 10, 30, true);
            wave.myHugAngle = new RangeValueOverTime([30, 40], [30, 50], 10, 30, false);

            let nextWavesSetup = new NextWavesSetup();
            nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
            nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
            nextWavesSetup.addWave("I_Am_Here", 100);
            nextWavesSetup.addWave("Queue_For_You", 100);
            nextWavesSetup.addWave("I_Am_Everywhere", 100);
            nextWavesSetup.addWave("Man_In_The_Middle", 100);

            ventSetup.myWavesMap.set("Give_Us_A_Hug", wave);
            ventSetup.myNextWavesMap.set("Give_Us_A_Hug", nextWavesSetup);
        }

        {
            let wave = new ManInTheMiddleSetup();

            wave.myWavesCount = new RangeValueOverTime([3, 3], [2, 4], 10, 30, true);
            wave.myTimeBeforeStart = new RangeValueOverTime([1, 1.5], [1, 1.5], 10, 30, false);
            wave.myTimeBetweenWaves = new RangeValueOverTime([1.5, 2], [1, 2], 10, 30, false);
            wave.myWaveStartAngle = new RangeValue([10, 175]);
            wave.myDoneDelay = new RangeValueOverTime([3, 4], [2.5, 3], 10, 30, false);

            let nextWavesSetup = new NextWavesSetup();
            nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
            nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
            nextWavesSetup.addWave("I_Am_Here", 100);
            nextWavesSetup.addWave("Queue_For_You", 100);
            nextWavesSetup.addWave("Give_Us_A_Hug", 100);
            nextWavesSetup.addWave("I_Am_Everywhere", 100);

            ventSetup.myWavesMap.set("Man_In_The_Middle", wave);
            ventSetup.myNextWavesMap.set("Man_In_The_Middle", nextWavesSetup);
        }

        ventSetup.myFirstWave = "I_Am_Here_mr_NOT_Side";

        return ventSetup;
    }
}
class PulseRadar {
    constructor() {
        this._myPulseIntensity = 0.35;

        this._myDownDuration = 1.5;
        this._myPulseDuration = 0.35;

        this._myMinAngle = 45;
        this._myBehindMinAngle = 160;

        this._myLeftPulseDownTimer = new PP.Timer(this._myDownDuration, false);
        this._myLeftPulseActiveTimer = new PP.Timer(this._myPulseDuration, false);
        this._myRightPulseDownTimer = new PP.Timer(this._myDownDuration, false);
        this._myRightPulseActiveTimer = new PP.Timer(this._myPulseDuration, false);

        this._myPositionsDelayed = [];
    }

    start() {
        this._myLeftPulseDownTimer.reset();
        this._myLeftPulseActiveTimer.reset();
        this._myRightPulseDownTimer.reset();
        this._myRightPulseActiveTimer.reset();
    }

    addSignal(position) {
        this._myPositionsDelayed.push([position.pp_clone(), 0.35]);
    }

    update(dt) {
        for (let positionDelayed of this._myPositionsDelayed) {
            positionDelayed[1] -= dt;
            if (positionDelayed[1] < 0) {
                this._addSignal(positionDelayed[0]);
            }
        }
        this._myPositionsDelayed.pp_removeAll(element => element[1] < 0);

        this._myLeftPulseDownTimer.update(dt);
        this._myRightPulseDownTimer.update(dt);

        if (this._myLeftPulseActiveTimer.isRunning()) {
            this._myLeftPulseActiveTimer.update(dt);
            PP.myLeftGamepad.pulse(this._myPulseIntensity, 0);
            if (this._myLeftPulseActiveTimer.isDone()) {
                this._myLeftPulseDownTimer.start();
            }
        }

        if (this._myRightPulseActiveTimer.isRunning()) {
            this._myRightPulseActiveTimer.update(dt);
            PP.myRightGamepad.pulse(this._myPulseIntensity, 0);
            if (this._myRightPulseActiveTimer.isDone()) {
                this._myRightPulseDownTimer.start();
            }
        }
    }

    _addSignal(position) {
        let playerDirection = position.vec3_sub(Global.myPlayerPosition);
        playerDirection.vec3_removeComponentAlongAxis([0, 1, 0], playerDirection);
        let flatPlayerForward = Global.myPlayerForward.vec3_removeComponentAlongAxis([0, 1, 0]);

        let angleSigned = flatPlayerForward.vec3_angleSigned(playerDirection, [0, 1, 0]);
        if (angleSigned >= this._myBehindMinAngle || angleSigned <= -this._myBehindMinAngle) {
            if (!this._myLeftPulseActiveTimer.isRunning() && !this._myLeftPulseDownTimer.isRunning()) {
                this._myLeftPulseActiveTimer.start();
                this._myRightPulseActiveTimer.start();
            } else if (!this._myRightPulseActiveTimer.isRunning() && !this._myRightPulseDownTimer.isRunning()) {
                this._myLeftPulseActiveTimer.start();
                this._myRightPulseActiveTimer.start();
            }
        } else if (angleSigned >= this._myMinAngle) {
            if (!this._myLeftPulseActiveTimer.isRunning() && !this._myLeftPulseDownTimer.isRunning()) {
                this._myLeftPulseActiveTimer.start();
            }
        } else if (angleSigned <= -this._myMinAngle) {
            if (!this._myRightPulseActiveTimer.isRunning() && !this._myRightPulseDownTimer.isRunning()) {
                this._myRightPulseActiveTimer.start();
            }
        }
    }
}
WL.registerComponent("timer", {
    _myIsTrial: { type: WL.Type.Bool, default: false },
    _mySeconds: { type: WL.Type.Object },
    _myMinutes: { type: WL.Type.Object },
    _myHours: { type: WL.Type.Object },
}, {
    init: function () {
    },
    start: function () {
        this._mySecondsTextComponent = this._mySeconds.pp_getComponent("text");
        this._myMinutesTextComponent = this._myMinutes.pp_getComponent("text");
        this._myHoursTextComponent = this._myHours.pp_getComponent("text");
    },
    update: function (dt) {
        let time = Global.myVentDuration;
        if (this._myIsTrial) {
            time = Global.myTrialDuration;
        }

        time = Math.floor(time);

        let hours = Math.floor(time / 3600);
        time -= hours * 3600;
        let minutes = Math.floor(time / 60);
        time -= minutes * 60;
        let seconds = Math.floor(time);

        this._mySecondsTextComponent.text = (seconds.toFixed(0).length < 2) ? "0".concat(seconds.toFixed(0)) : seconds.toFixed(0);
        this._myMinutesTextComponent.text = (minutes.toFixed(0).length < 2) ? "0".concat(minutes.toFixed(0)) : minutes.toFixed(0);
        this._myHoursTextComponent.text = (hours.toFixed(0).length < 2) ? "0".concat(hours.toFixed(0)) : hours.toFixed(0);
    }
});
class BreakSetup {
    constructor() {
        this.myBreakDuration = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.myBreakTimeCooldown = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.myBreakCloneCooldown = new RangeValueOverTime([0, 0], [0, 0], 0, 0, true);
    }
}

class VentSetup {
    constructor() {
        this.myValidAngleRanges = [[new RangeValue([-180, 180]), [0, 0, -1]]];
        this.myVentMultipliers = new VentRuntimeMultipliers();

        this.myBreakSetup = new BreakSetup();
        this.mySmallBreakSetup = new BreakSetup();

        this.myIsEndless = true;
        this.myClonesToDismiss = 0;
        this.myVentDuration = 0;

        this.myWavesMap = new Map();
        this.myNextWavesMap = new Map();

        this.myFirstWave = "";

        this.myCloneRotationSetup = new CloneRotationSetup();

        this.myRefDirection = null;

        this.mySkipBreakWhenTimerBelow = 15;
        this.mySkipSmallBreakWhenTimerBelow = 7;
        this.mySkipSmallBreakWhenBreakTimerBelow = 5;

        this.myResetBreakWhenBreakTimerBelow = 10;
        this.myResetBreakAmount = new RangeValue([10, 12]);

        this.myDelayBeforeStart = 4.5;

        this.myMrNOTSetup = new VentMrNOTSetup();

        this.myNextWaveChanceBoosterSetupMap = new Map();
    }
}

class VentMrNOTSetup {
    constructor() {
        this.myMrNOTAppearenceEnabled = false;
        this.myMrNOTTimeCooldown = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.myVentMultipliers = new VentRuntimeMultipliers();

        this.myBreakDuration = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);

        this.myResetMrNOTTimerWhenBelowBreak = 8;
        this.myResetTimerAmountBreak = new RangeValue([8, 10]);
        this.myResetMrNOTTimerWhenBelowSmallBreak = 4;
        this.myResetTimerAmountSmallBreak = new RangeValue([4, 6]);

        this.myStartAngle = new RangeValueOverTime([180, 180], [180, 180], 0, 0, false);
        this.myTimeToReachTarget = new RangeValueOverTime([50, 50], [50, 50], 0, 0, false);
        this.myMaxPatience = new ValueOverTime(15, 15, 0, 0, true);
    }
}

class VentRuntimeSetup {
    constructor() {
        this.myValidAngleRanges = [[new RangeValue([-180, 180]), [0, 0, -1]]];

        this.myVentMultipliers = new VentRuntimeMultipliers();
    }
}

class VentRuntimeMultipliers {
    constructor() {
        this.mySpawnTimeMultiplier = 1;
        this.myDoneTimeMultiplier = 1;
        this.myBreakTimeMultiplier = 1;
        this.myBreakDelayTimeMultiplier = 1;
        this.mySmallBreakTimeMultiplier = 1;
        this.mySmallBreakDelayTimeMultiplier = 1;
    }
}

class Vent {
    constructor(ventSetup) {
        this._myVentSetup = ventSetup;
        this._myPulseRadar = new PulseRadar();

        this._myMrNOTClones = [];

        this._myOnVentLostCallback = null;
        this._myOnVentCompletedCallback = null;

        this._myFSM = new PP.FSM();

        //this._myFSM.setDebugLogActive(true, "        Vent");
        this._myFSM.addState("init");
        this._myFSM.addState("first_wait", new PP.TimerState(ventSetup.myDelayBeforeStart, "end"));
        this._myFSM.addState("wave", this._updateWave.bind(this));
        this._myFSM.addState("break", this._break.bind(this));
        this._myFSM.addState("smallBreak", this._break.bind(this));
        this._myFSM.addState("clean", this._clean.bind(this));
        this._myFSM.addState("done");

        this._myFSM.addTransition("init", "first_wait", "start");
        this._myFSM.addTransition("done", "first_wait", "start");
        this._myFSM.addTransition("first_wait", "wave", "end", this._startVent.bind(this));
        this._myFSM.addTransition("wave", "break", "startBreak", this._startBreak.bind(this));
        this._myFSM.addTransition("wave", "smallBreak", "startSmallBreak", this._startSmallBreak.bind(this));
        this._myFSM.addTransition("break", "wave", "end", this._endBreak.bind(this));
        this._myFSM.addTransition("smallBreak", "wave", "end", this._endSmallBreak.bind(this));
        this._myFSM.addTransition("smallBreak", "break", "startBreak", this._startBreak.bind(this));

        this._myFSM.addTransition("break", "break", "startBreak", this._startBreak.bind(this));
        this._myFSM.addTransition("smallBreak", "break", "startBreak", this._startBreak.bind(this));

        this._myFSM.addTransition("break", "wave", "forceEnd");
        this._myFSM.addTransition("smallBreak", "wave", "forceEnd");

        this._myFSM.addTransition("first_wait", "done", "stop", this._stop.bind(this));
        this._myFSM.addTransition("wave", "done", "stop", this._stop.bind(this));
        this._myFSM.addTransition("break", "done", "stop", this._stop.bind(this));
        this._myFSM.addTransition("smallBreak", "done", "stop", this._stop.bind(this));
        this._myFSM.addTransition("clean", "done", "stop", this._stop.bind(this));

        this._myFSM.addTransition("first_wait", "clean", "startClean", this._startClean.bind(this));
        this._myFSM.addTransition("wave", "clean", "startClean", this._startClean.bind(this));
        this._myFSM.addTransition("break", "clean", "startClean", this._startClean.bind(this));
        this._myFSM.addTransition("smallBreak", "clean", "startClean", this._startClean.bind(this));

        this._myFSM.addTransition("clean", "done", "end");

        this._myFSM.init("init");

        this._myDebugActive = false;
        this._myDebugActiveNextWave = false;
        this._myDebugActiveBreak = false;
        this._myDebugActivePreviousWaveStats = false;
        this._myDebugActiveWaveStats = false;
        this._myDebugActiveVentStats = false;
        this._myDebugActiveMrNOT = false;
        this._myDebugActiveBoosterGroup = true;

        this._myOncePerFrame = false;

        this._myCurrentVentRuntimeSetup = new VentRuntimeSetup();

        this._myMrNOT = null;

        this._myNextWaveChanceBooster = new NextWaveChanceBooster();
        for (let entry of this._myVentSetup.myNextWaveChanceBoosterSetupMap.entries()) {
            this._myNextWaveChanceBooster.addSetup(entry[0], entry[1]);
        }

        this._myBoosterGroupCountMap = new Map();
        this._myBoosterGroupDistanceCountMap = new Map();
        this._myWavesCountMap = new Map();

        this._myIsTesting = false;
    }

    start() {
        this._myIsTesting = false;
        this._myFSM.perform("start");
    }

    update(dt) {
        this._myFSM.update(dt);
    }

    _startVent() {
        this._myMrNOTClones = [];
        this._myPulseRadar.start();

        this._myVentCompleted = false;

        this._prepareVentRuntimeSetup();

        this._myCurrentWave = this._myVentSetup.myWavesMap.get(this._myVentSetup.myFirstWave).createWave(this._myCurrentVentRuntimeSetup, Global.myVentDuration);
        this._myCurrentWaveID = this._myVentSetup.myFirstWave;

        this._myPreviousWave = null;
        this._myPreviousWaveID = null;

        let breakDelayMultiplier = this._myCurrentVentRuntimeSetup.myVentMultipliers.myBreakDelayTimeMultiplier.get(Global.myVentDuration);
        this._myBreakDelayTimer = new PP.Timer(this._myVentSetup.myBreakSetup.myBreakTimeCooldown.get(Global.myVentDuration) * breakDelayMultiplier);
        this._myBreakCloneCooldown = this._myVentSetup.myBreakSetup.myBreakCloneCooldown.get(Global.myVentDuration);

        let smallBreakDelayMultiplier = this._myCurrentVentRuntimeSetup.myVentMultipliers.mySmallBreakDelayTimeMultiplier.get(Global.myVentDuration);
        this._mySmallBreakDelayTimer = new PP.Timer(this._myVentSetup.mySmallBreakSetup.myBreakTimeCooldown.get(Global.myVentDuration) * smallBreakDelayMultiplier, false);
        this._mySmallBreakCloneCooldown = this._myVentSetup.mySmallBreakSetup.myBreakCloneCooldown.get(Global.myVentDuration);

        this._myVentTimer = new PP.Timer(this._myVentSetup.myVentDuration - Global.myVentDuration);
        this._myClonesLeft = this._myVentSetup.myClonesToDismiss;

        this._myCloneDismissed = 0;

        this._myMrNOT = null;
        this._myMrNOTTimer = new PP.Timer(this._myVentSetup.myMrNOTSetup.myMrNOTTimeCooldown.get(Global.myVentDuration) - Global.myVentDuration, this._myVentSetup.myMrNOTSetup.myMrNOTAppearenceEnabled);

        this._myNextWaveChanceBooster.reset();

        this._myBoosterGroupCountMap = new Map();
        this._myBoosterGroupDistanceCountMap = new Map();
        this._myWavesCountMap = new Map();

        this._myMrNOTBreak = false;

        Global.myDebugCurrentVentObject = this;

        this._debugNextWave();
    }

    _updateWave(dt) {
        this._myOncePerFrame = true;

        this._myVentTimer.update(dt);
        this._myBreakDelayTimer.update(dt);
        this._mySmallBreakDelayTimer.update(dt);
        this._myMrNOTTimer.update(dt);
        this._myNextWaveChanceBooster.update(dt, Global.myVentDuration);

        if (this._myCurrentWave != null) {
            let cloneSetups = this._myCurrentWave.update(dt);
            for (let cloneSetup of cloneSetups) {
                this.addClone(cloneSetup);
            }
        }

        this._myPulseRadar.update(dt);
        this._updateClones(dt);
        if (this._myMrNOT) {
            this._myMrNOT.update(dt);
            if (this._myMrNOT && this._myMrNOT.isDone()) {
                this._mrNOTDismissedDone();
            }
        }

        if (this._myFSM.isInState("wave")) {
            if (this._isVentCompleted()) {
                if (!this._myIsTesting && this._myOnVentCompletedCallback) {
                    this.ventCompletedDebug();

                    this._myOnVentCompletedCallback();
                }
            } else if (this._myCurrentWave != null && this._myCurrentWave.isDone()) {
                this._getNextWave();
                if (this._myCurrentWave != null) {
                    this._checkBreak();
                }
            } else if (this._myVentSetup.myMrNOTSetup.myMrNOTAppearenceEnabled && !this._myVentCompleted) {
                if (this._myMrNOTTimer.isDone()) {
                    this._myMrNOTTimer.reset();
                    this._mrNOTAppear();
                }
            }
        }
    }

    _getNextWave() {
        if (!this._myVentSetup.myIsEndless && this._myVentTimer.isDone() && this._myClonesLeft <= 0) {
            this._myVentCompleted = true;
            this._myCurrentWave = null;
        } else {
            this._myPreviousWave = this._myCurrentWave;
            this._myPreviousWaveID = this._myCurrentWaveID;

            this._myCurrentWaveID = this._myVentSetup.myNextWavesMap.get(this._myCurrentWaveID).getNextWave(Global.myVentDuration, this._myNextWaveChanceBooster);
            this._myNextWaveChanceBooster.nextWaveSelected(this._myCurrentWaveID, Global.myVentDuration);

            if (this._myDebugActive && this._myDebugActiveBoosterGroup) {
                let name = this._myNextWaveChanceBooster.getBoostGroupName(this._myCurrentWaveID);
                let value = this._myBoosterGroupCountMap.get(name);
                if (value == null) {
                    value = 0;
                }
                this._myBoosterGroupCountMap.set(name, value + 1);

                if (!this._myBoosterGroupDistanceCountMap.has(name)) {
                    this._myBoosterGroupDistanceCountMap.set(name, []);
                }

                let currentDistance = this._myBoosterGroupDistanceCountMap.get(name);
                currentDistance.push(0);

                for (let entry of this._myBoosterGroupDistanceCountMap.entries()) {
                    if (entry[0] != name) {
                        entry[1][entry[1].length - 1] = entry[1][entry[1].length - 1] + 1;
                    }
                }

                let waveCount = this._myWavesCountMap.get(this._myCurrentWaveID);
                if (waveCount == null) {
                    waveCount = 0;
                }
                this._myWavesCountMap.set(this._myCurrentWaveID, waveCount + 1);
            }

            let refDirection = Global.myPlayerForward;
            if (this._myVentSetup.myRefDirection != null) {
                refDirection = this._myVentSetup.myRefDirection.pp_clone();
            }

            this._myCurrentWave = this._myVentSetup.myWavesMap.get(this._myCurrentWaveID).createWave(this._myCurrentVentRuntimeSetup, Global.myVentDuration, refDirection);
        }
    }

    _checkBreak() {
        let skipBreak = !this._myVentSetup.myIsEndless && this._myVentTimer.getTimer() <= this._myVentSetup.mySkipBreakWhenTimerBelow.get(Global.myVentDuration);
        let skipSmallBreak = !this._myVentSetup.myIsEndless && this._myVentTimer.getTimer() <= this._myVentSetup.mySkipSmallBreakWhenTimerBelow.get(Global.myVentDuration);
        skipSmallBreak = skipSmallBreak || (!skipBreak && this._myBreakDelayTimer.getTimer() < this._myVentSetup.mySkipSmallBreakWhenBreakTimerBelow.get(Global.myVentDuration));
        if (!skipBreak && this._myBreakDelayTimer.isDone() && this._myBreakCloneCooldown <= 0) {
            this._myFSM.perform("startBreak");
        } else if (!skipSmallBreak && this._mySmallBreakDelayTimer.isDone() && this._mySmallBreakCloneCooldown <= 0) {
            this._myFSM.perform("startSmallBreak");
        } else {
            this._debugNextWave();
        }
    }

    _startBreak() {
        let multiplier = this._myCurrentVentRuntimeSetup.myVentMultipliers.myBreakTimeMultiplier.get(Global.myVentDuration);
        if (!this._myMrNOTBreak) {
            this._myBreakTimer = new PP.Timer(this._myVentSetup.myBreakSetup.myBreakDuration.get(Global.myVentDuration) * multiplier);
        } else {
            this._myBreakTimer = new PP.Timer(this._myVentSetup.myMrNOTSetup.myBreakDuration.get(Global.myVentDuration));
            this._myMrNOTBreak = false;
        }
        this._myIsSmallBreak = false;

        if (this._myDebugActive && this._myDebugActiveNextWave) {
            console.log("Break -", this._myBreakTimer.getDuration().toFixed(3));
        }
    }

    _startSmallBreak() {
        let multiplier = this._myCurrentVentRuntimeSetup.myVentMultipliers.mySmallBreakTimeMultiplier.get(Global.myVentDuration);
        this._myBreakTimer = new PP.Timer(this._myVentSetup.mySmallBreakSetup.myBreakDuration.get(Global.myVentDuration) * multiplier);
        this._myIsSmallBreak = true;

        if (this._myDebugActive && this._myDebugActiveNextWave) {
            console.log("Small Break -", this._myBreakTimer.getDuration().toFixed(3));
        }
    }

    _break(dt) {
        this._myVentTimer.update(dt);
        this._myBreakTimer.update(dt);
        this._myBreakDelayTimer.update(dt);
        this._myMrNOTTimer.update(dt);
        this._myNextWaveChanceBooster.update(dt, Global.myVentDuration);

        this._myPulseRadar.update(dt);
        this._updateClones(dt);
        if (this._myMrNOT) {
            this._myMrNOT.update(dt);
        }

        if (this._myFSM.isInState("break") || this._myFSM.isInState("smallBreak")) {
            if (this._isVentCompleted()) {
                if (!this._myIsTesting && this._myOnVentCompletedCallback) {
                    this.ventCompletedDebug();

                    this._myOnVentCompletedCallback();
                }
            } else if (this._myBreakTimer.isDone()) {
                let skipBreak = !this._myVentSetup.myIsEndless && this._myVentTimer.getTimer() <= this._myVentSetup.mySkipBreakWhenTimerBelow.get(Global.myVentDuration);
                if (!skipBreak && this._myIsSmallBreak && this._myBreakDelayTimer.isDone() && this._myBreakCloneCooldown <= 0) {
                    this._myFSM.perform("startBreak");
                } else {
                    this._myFSM.perform("end");
                }
            }
        }
    }

    _endBreak() {
        let breakDelayMultiplier = this._myCurrentVentRuntimeSetup.myVentMultipliers.myBreakDelayTimeMultiplier.get(Global.myVentDuration);
        this._myBreakDelayTimer = new PP.Timer(this._myVentSetup.myBreakSetup.myBreakTimeCooldown.get(Global.myVentDuration) * breakDelayMultiplier);
        this._myBreakCloneCooldown = this._myVentSetup.myBreakSetup.myBreakCloneCooldown.get(Global.myVentDuration);

        let smallBreakDelayMultiplier = this._myCurrentVentRuntimeSetup.myVentMultipliers.mySmallBreakDelayTimeMultiplier.get(Global.myVentDuration);
        this._mySmallBreakDelayTimer = new PP.Timer(this._myVentSetup.mySmallBreakSetup.myBreakTimeCooldown.get(Global.myVentDuration) * smallBreakDelayMultiplier);
        this._mySmallBreakCloneCooldown = this._myVentSetup.mySmallBreakSetup.myBreakCloneCooldown.get(Global.myVentDuration);

        if (this._myVentSetup.myMrNOTSetup.myMrNOTAppearenceEnabled && this._myMrNOTTimer.isStarted() &&
            this._myMrNOTTimer.getTimer() <= this._myVentSetup.myMrNOTSetup.myResetMrNOTTimerWhenBelowBreak.get(Global.myVentDuration)) {
            this._myMrNOTTimer = new PP.Timer(this._myVentSetup.myMrNOTSetup.myResetTimerAmountBreak.get(Global.myVentDuration));

            this._mySmallBreakDelayTimer = new PP.Timer(0, false);
            this._mySmallBreakCloneCooldown = 0;

            this._myBreakDelayTimer = new PP.Timer(0, false);
            this._mySmallBreakCloneCooldown = 0;
        }

        this._debugNextWave();
    }

    _endSmallBreak() {
        let smallBreakDelayMultiplier = this._myCurrentVentRuntimeSetup.myVentMultipliers.mySmallBreakDelayTimeMultiplier.get(Global.myVentDuration);
        this._mySmallBreakDelayTimer = new PP.Timer(this._myVentSetup.mySmallBreakSetup.myBreakTimeCooldown.get(Global.myVentDuration) * smallBreakDelayMultiplier);
        this._mySmallBreakCloneCooldown = this._myVentSetup.mySmallBreakSetup.myBreakCloneCooldown.get(Global.myVentDuration);

        if (this._myBreakDelayTimer.getTimer() < this._myVentSetup.myResetBreakWhenBreakTimerBelow.get(Global.myVentDuration)) {
            this._myBreakDelayTimer = new PP.Timer(this._myVentSetup.myResetBreakAmount.get(Global.myVentDuration));

            this._mySmallBreakDelayTimer = new PP.Timer(0, false);
            this._mySmallBreakCloneCooldown = 0;
        }

        if (this._myVentSetup.myMrNOTSetup.myMrNOTAppearenceEnabled && this._myMrNOTTimer.isStarted() &&
            this._myMrNOTTimer.getTimer() <= this._myVentSetup.myMrNOTSetup.myResetMrNOTTimerWhenBelowSmallBreak.get(Global.myVentDuration)) {
            this._myMrNOTTimer = new PP.Timer(this._myVentSetup.myMrNOTSetup.myResetTimerAmountSmallBreak.get(Global.myVentDuration));

            this._mySmallBreakDelayTimer = new PP.Timer(0, false);
            this._mySmallBreakCloneCooldown = 0;

            this._myBreakDelayTimer = new PP.Timer(0, false);
            this._mySmallBreakCloneCooldown = 0;
        }

        this._debugNextWave();
    }

    isDone() {
        return this._myFSM.isInState("done");
    }

    stop() {
        this._myFSM.perform("stop");
    }

    _stop() {
        for (let clone of this._myMrNOTClones) {
            clone.hide();
        }

        if (this._myMrNOT) {
            this._myMrNOT.hide();
            this._myMrNOT = null;
        }

        this._myMrNOTClones = [];
    }

    clean(cleanDelay = 0) {
        this._myFSM.perform("startClean", cleanDelay);
    }

    _startClean(fsm, transition, cleanDelay) {
        this._myMrNOTCleanDelay = new PP.Timer(cleanDelay);
        if (this._myMrNOT) {
            this._myMrNOT.stop();
        }

        this._myUnspawnList = [];

        let indexList = [];
        for (let i = 0; i < this._myMrNOTClones.length; i++) {
            if (this._myMrNOTClones[i].canUnspawn()) {
                indexList.push(i);
                this._myMrNOTClones[i].stop();
            }
        }

        while (indexList.length > 0) {
            let randomIndex = Math.pp_randomInt(0, indexList.length - 1);
            let index = indexList.pp_removeIndex(randomIndex);

            let randomTimer = Math.pp_random(0.20, 0.25);
            if (this._myUnspawnList.length == 0) {
                randomTimer += 0.3 + cleanDelay;
            }
            this._myUnspawnList.push([this._myMrNOTClones[index], new PP.Timer(randomTimer)]);
        }
    }

    _clean(dt) {
        if (this._myMrNOTCleanDelay.isRunning()) {
            this._myMrNOTCleanDelay.update(dt);
            if (this._myMrNOTCleanDelay.isDone()) {
                if (this._myMrNOT) {
                    this._myMrNOT.disappear();
                }
            }
        }

        if (this._myUnspawnList.length > 0) {
            let first = this._myUnspawnList[0];
            first[1].update(dt);
            if (first[1].isDone()) {
                first[0].unspawn();
                this._myUnspawnList.shift();
            }
        }

        this._updateClones(dt);
        if (this._myMrNOT) {
            this._myMrNOT.update(dt);
            if (this._myMrNOT && this._myMrNOT.isDone()) {
                this._myMrNOT = null;
            }
        }

        if (this._myMrNOTClones.length <= 0 && this._myMrNOT == null) {
            this._myFSM.perform("end");
        }
    }

    onVentLost(callback) {
        this._myOnVentLostCallback = callback;
    }

    onVentCompleted(callback) {
        this._myOnVentCompletedCallback = callback;
    }

    addClone(cloneSetup) {
        let startPosition = cloneSetup.myDirection.pp_clone();
        startPosition.vec3_normalize(startPosition);
        startPosition.vec3_scale(cloneSetup.myStartDistance, startPosition);
        startPosition[1] += cloneSetup.myStartHeight;

        let endPosition = [0, cloneSetup.myEndHeight, 0];

        this._myPulseRadar.addSignal(startPosition);

        if (!this._myIsTesting) {
            let mrNOTClone = new MrNOTClone(startPosition, endPosition, cloneSetup.myTimeToReachTarget, this._myVentSetup.myCloneRotationSetup, this._mrNOTCloneDismissed.bind(this), this._mrNOTCloneReachYou.bind(this));
            this._myMrNOTClones.push(mrNOTClone);
        } else {
            this._mrNOTCloneDismissed();
        }
    }

    _mrNOTCloneDismissed() {
        this._myClonesLeft = Math.max(0, this._myClonesLeft - 1);
        this._myBreakCloneCooldown = Math.max(0, this._myBreakCloneCooldown - 1);
        this._mySmallBreakCloneCooldown = Math.max(0, this._mySmallBreakCloneCooldown - 1);

        this._myCloneDismissed++;
    }

    _mrNOTCloneReachYou() {
        if (!this._myIsTesting && this._myOnVentLostCallback && this._myOncePerFrame &&
            (this._myFSM.isInState("wave") || this._myFSM.isInState("break") || this._myFSM.isInState("smallBreak"))) {
            this.ventLostDebug();

            this._myOnVentLostCallback();
            this._myOncePerFrame = false;
        }
    }

    ventCompletedDebug() {
        if (this._myDebugActive) {
            console.log("\nVent Completed - Duration -", Global.myVentDuration.toFixed(3), "- Dismissed -", this._myCloneDismissed);

            this._boosterGroupDebug();
        }
    }

    ventLostDebug() {
        if (this._myDebugActive) {
            console.log("\nVent Lost - Duration -", Global.myVentDuration.toFixed(3), "- Dismissed -", this._myCloneDismissed);

            this._boosterGroupDebug();
        }
    }

    _boosterGroupDebug() {
        if (this._myDebugActiveBoosterGroup) {
            console.log("\nBooster Group Stats");
            let total = 0;
            for (let entry of this._myBoosterGroupCountMap.entries()) {
                total += entry[1];
            }
            for (let entry of this._myBoosterGroupCountMap.entries()) {
                let distance = this._myBoosterGroupDistanceCountMap.get(entry[0]);
                let distanceSum = 0;
                for (let value of distance) {
                    distanceSum += value;
                }

                let averageDistance = distanceSum / distance.length;

                console.log("   ", entry[0], "-", entry[1].toFixed(2), "-", (entry[1] / total).toFixed(3), "-", averageDistance.toFixed(3));
            }

            console.log("\nWaves Stats");

            total = 0;
            for (let entry of this._myWavesCountMap.entries()) {
                total += entry[1];
            }

            let longestName = 0;
            for (let entry of this._myWavesCountMap.entries()) {
                if (entry[0].length > longestName) {
                    longestName = entry[0].length;
                }
            }

            for (let entry of this._myWavesCountMap.entries()) {
                let name = entry[0];
                while (name.length < longestName) {
                    name = name.concat(" ");
                }
                console.log("   ", name, "-", entry[1].toFixed(2), "-", (entry[1] * 100 / total).toFixed(1));
            }

            console.log("");

            //console.log("   ", Global.myVentDuration.toFixed(3));
        }
    }

    _mrNOTReachYou() {
        if (PP.myEasyTuneVariables.get("Prevent Vent Lost")) {
            this._mrNOTDismissed();
            //this._mrNOTCloneReachYou();
        } else {
            this._mrNOTCloneReachYou();
        }
    }

    _updateClones(dt) {
        for (let clone of this._myMrNOTClones) {
            clone.update(dt);
        }

        this._myMrNOTClones.pp_removeAll(element => element.isDone());
    }

    _isVentCompleted() {
        return this._myVentCompleted && this._myMrNOTClones.length <= 0 && this._myMrNOT == null;
    }

    _debugNextWave() {
        if (this._myDebugActive) {
            if (this._myDebugActiveNextWave) {
                console.log("Next Wave -", this._myCurrentWaveID);
            }

            if (this._myDebugActivePreviousWaveStats && this._myPreviousWave) {
                try {
                    console.log("   Prev Wave ID -", this._myPreviousWaveID);
                    console.log("   Prev Wave Clones -", this._myPreviousWave.getActualClonesCount());
                    console.log("   Prev Wave Duration -", this._myPreviousWave.getDuration().toFixed(3));
                } catch (error) {
                    console.error("OMG", this._myPreviousWaveID, this._myPreviousWave);
                }
            }

            if (this._myDebugActiveWaveStats) {
                console.log("   Wave Average Clones -", this._myCurrentWave.getAverageClonesCount());
            }

            if (this._myDebugActiveVentStats) {
                console.log("   Vent Duration -", Global.myVentDuration.toFixed(3));
                console.log("   Dismissed -", this._myCloneDismissed);
            }

            if (this._myDebugActiveBreak) {
                console.log("   Break -", this._myBreakDelayTimer.getTimer().toFixed(3), " -", this._myBreakCloneCooldown);
                console.log("   Small Break -", this._mySmallBreakDelayTimer.getTimer().toFixed(3), " -", this._mySmallBreakCloneCooldown);
            }

            if (this._myDebugActiveMrNOT) {
                console.log("   mr NOT -", this._myMrNOTTimer.getTimer().toFixed(3));
            }
        }
    }

    _prepareVentRuntimeSetup() {
        this._myCurrentVentRuntimeSetup = new VentRuntimeSetup();
        this._myCurrentVentRuntimeSetup.myValidAngleRanges = this._myVentSetup.myValidAngleRanges;
        this._myCurrentVentRuntimeSetup.myVentMultipliers = this._myVentSetup.myVentMultipliers;
    }

    _mrNOTAppear() {
        let direction = Global.myPlayerForward.pp_clone();
        let startAngle = this._myVentSetup.myMrNOTSetup.myStartAngle.get(Global.myVentDuration) * Math.pp_randomSign();
        direction.vec3_rotateAxis(startAngle, [0, 1, 0], direction);

        let oldVentSetup = this._myCurrentVentRuntimeSetup;

        this._myCurrentVentRuntimeSetup = new VentRuntimeSetup();
        this._myCurrentVentRuntimeSetup.myValidAngleRanges = [];
        let timeToReachTarget = this._myVentSetup.myMrNOTSetup.myTimeToReachTarget.get(Global.myVentDuration);
        this._myCurrentVentRuntimeSetup.myValidAngleRanges.push([new RangeValueOverTime([30, 180], [90, 180], (timeToReachTarget / 5) + Global.myVentDuration, timeToReachTarget + Global.myVentDuration), direction.pp_clone()]);
        this._myCurrentVentRuntimeSetup.myValidAngleRanges.push([new RangeValueOverTime([-180, -30], [-180, -90], (timeToReachTarget / 5) + Global.myVentDuration, timeToReachTarget + Global.myVentDuration), direction.pp_clone()]);

        oldVentSetup.myValidAngleRanges = this._myCurrentVentRuntimeSetup.myValidAngleRanges;

        this._myCurrentVentRuntimeSetup.myVentMultipliers = this._myVentSetup.myMrNOTSetup.myVentMultipliers;

        let mrNOTSetup = new MrNOTVentSetup();
        mrNOTSetup.myDirection = direction;
        mrNOTSetup.myTimeToReachTarget = timeToReachTarget;
        mrNOTSetup.myMaxPatience = this._myVentSetup.myMrNOTSetup.myMaxPatience.get(timeToReachTarget);

        this._myMrNOT = new MrNOTVent(mrNOTSetup, this._myCurrentVentRuntimeSetup, this._mrNOTDismissed.bind(this), this._mrNOTReachYou.bind(this));

        this._myBreakDelayTimer.start(0);
        this._myBreakDelayTimer.update(0);
        this._myBreakCloneCooldown = 0;
        this._myMrNOTBreak = true;

        if (this._myDebugActive && this._myDebugActiveMrNOT) {
            console.log("mr NOT - Duration -", mrNOTSetup.myTimeToReachTarget.toFixed(3), " - Patience -", mrNOTSetup.myMaxPatience);
        }

        //this._boosterGroupDebug();

        if (!Global.mySaveManager.loadBool("mr_NOT_encountered", false)) {
            Global.mySaveManager.save("mr_NOT_encountered", true);

            if (Global.myGoogleAnalytics) {
                gtag("event", "mr_NOT_encountered_before_trial", {
                    "value": 1
                });
            }
        }
    }

    _mrNOTDismissed() {
        let oldVentSetup = this._myCurrentVentRuntimeSetup;
        this._prepareVentRuntimeSetup();
        oldVentSetup.myValidAngleRanges = this._myCurrentVentRuntimeSetup.myValidAngleRanges;

        this._myMrNOT.disappear();

        this._myBreakDelayTimer.start(0);
        this._myBreakDelayTimer.update(0);
        this._myBreakCloneCooldown = 0;
        this._myMrNOTBreak = true;

        if (this._myFSM.isInState("break") || this._myFSM.isInState("smallBreak")) {
            this._myFSM.perform("forceEnd");
            this._myCurrentWave = new ZeroWave();
        }
    }

    _mrNOTDismissedDone() {
        this._myMrNOT = null;
        this._myMrNOTTimer = new PP.Timer(this._myVentSetup.myMrNOTSetup.myMrNOTTimeCooldown.get(Global.myVentDuration));
    }

    _test(duration = 550, startDuration = 0, isBoost = true, isWave = false, numberOfTest = 100) {
        this._myIsTesting = true;
        let dt = 1 / 72;

        let boosterGroupCountMaps = [];
        let boosterGroupDistanceCountMaps = [];
        let wavesCountMaps = [];

        //console.clear();

        while (numberOfTest > 0) {
            //console.log("Test Count -", numberOfTest);
            numberOfTest--;
            this._myFSM.perform("start");
            Global.myVentDuration = startDuration;
            while (Global.myVentDuration < duration) {
                this.update(dt);
                Global.myVentDuration += dt;
                //console.log(Global.myVentDuration.toFixed(3));
            }

            boosterGroupCountMaps.push(this._myBoosterGroupCountMap);
            boosterGroupDistanceCountMaps.push(this._myBoosterGroupDistanceCountMap);
            wavesCountMaps.push(this._myWavesCountMap);

            this.stop();
        }

        //console.clear();

        let resultMapGroupCount = new Map();
        let resultMapGroupCountPercentage = new Map();
        let resultMapGroupCountDistance = new Map();
        if (isBoost) {
            let groups = ["1", "2", "3", "4", "5"];
            for (let key of groups) {
                resultMapGroupCount.set(key, -1);
                resultMapGroupCountPercentage.set(key, -1);
                resultMapGroupCountDistance.set(key, -1);
            }

            for (let i = 0; i < boosterGroupCountMaps.length; i++) {
                let groupCountMap = boosterGroupCountMaps[i];
                let groupCountDistanceMap = boosterGroupDistanceCountMaps[i];

                let total = 0;
                for (let entry of groupCountMap.entries()) {
                    total += entry[1];
                }
                for (let entry of groupCountMap.entries()) {
                    let distance = groupCountDistanceMap.get(entry[0]);
                    let distanceSum = 0;
                    for (let value of distance) {
                        distanceSum += value;
                    }

                    let averageDistance = distanceSum / distance.length;

                    if (resultMapGroupCount.get(entry[0]) == -1) {
                        resultMapGroupCount.set(entry[0], 0);
                        resultMapGroupCountPercentage.set(entry[0], 0);
                        resultMapGroupCountDistance.set(entry[0], 0);
                    }

                    if (!resultMapGroupCount.has(entry[0])) {
                        resultMapGroupCount.set(entry[0], 0);
                        resultMapGroupCountPercentage.set(entry[0], 0);
                        resultMapGroupCountDistance.set(entry[0], 0);
                    }

                    resultMapGroupCount.set(entry[0], resultMapGroupCount.get(entry[0]) + entry[1]);
                    resultMapGroupCountPercentage.set(entry[0], resultMapGroupCountPercentage.get(entry[0]) + entry[1] / total);
                    resultMapGroupCountDistance.set(entry[0], resultMapGroupCountDistance.get(entry[0]) + averageDistance);
                }
            }

            for (let entry of resultMapGroupCount.entries()) {
                let key = entry[0];
                resultMapGroupCount.set(key, resultMapGroupCount.get(key) / boosterGroupCountMaps.length);
                resultMapGroupCountPercentage.set(key, resultMapGroupCountPercentage.get(key) / boosterGroupCountMaps.length);
                resultMapGroupCountDistance.set(key, resultMapGroupCountDistance.get(key) / boosterGroupCountMaps.length);
            }
        }

        let resultMapWaveCount = new Map();
        let resultMapWaveCountPercentage = new Map();

        let boosterGroup1 = ["I_Am_Here", "I_Am_Here_2", "Queue_For_You", "Queue_For_You_2", "Merry_Go_Round", "Merry_Go_Round_Waves"];
        let boosterGroup2 = ["I_Am_Everywhere", "I_Am_Everywhere_2", "Give_Us_A_Hug_2", "Give_Us_A_Hug_3", "Man_In_The_Middle", "Merry_Go_Round_MITM"];
        let boosterGroup3 = ["I_Am_Everywhere_Waves", "I_Am_Here_Rain", "Queue_For_You_Rain", "Man_In_The_Middle_Waves", "Merry_Go_Round_Rain"];
        let boosterGroup4 = ["Man_In_The_Middle_Everywhere", "I_Am_Everywhere_GUAH2", "Merry_Go_Round_GUAH2", "Man_In_The_Middle_Everywhere_Waves", "I_Am_Everywhere_GUAH3", "Merry_Go_Round_GUAH3"];
        let boosterGroup5 = ["Give_Us_A_Hug_4", "Man_In_The_Middle_GUAH2", "Man_In_The_Middle_Everywhere_GUAH2", "Man_In_The_Middle_GUAH3", "Man_In_The_Middle_Everywhere_GUAH3", "Give_Us_A_Hug_Cross"];

        if (isWave) {
            for (let key of boosterGroup1) {
                resultMapWaveCount.set(key, -1);
                resultMapWaveCountPercentage.set(key, -1);
            }
            for (let key of boosterGroup2) {
                resultMapWaveCount.set(key, -1);
                resultMapWaveCountPercentage.set(key, -1);
            }
            for (let key of boosterGroup3) {
                resultMapWaveCount.set(key, -1);
                resultMapWaveCountPercentage.set(key, -1);
            }
            for (let key of boosterGroup4) {
                resultMapWaveCount.set(key, -1);
                resultMapWaveCountPercentage.set(key, -1);
            }
            for (let key of boosterGroup5) {
                resultMapWaveCount.set(key, -1);
                resultMapWaveCountPercentage.set(key, -1);
            }

            for (let i = 0; i < wavesCountMaps.length; i++) {
                let waveCountMap = wavesCountMaps[i];

                let total = 0;
                for (let entry of waveCountMap.entries()) {
                    if (entry[1] >= 0) {
                        total += entry[1];
                    }
                }

                for (let entry of waveCountMap.entries()) {
                    if (resultMapWaveCount.get(entry[0]) == -1) {
                        resultMapWaveCount.set(entry[0], 0);
                        resultMapWaveCountPercentage.set(entry[0], 0);
                    }

                    if (!resultMapWaveCount.has(entry[0])) {
                        resultMapWaveCount.set(entry[0], 0);
                        resultMapWaveCountPercentage.set(entry[0], 0);
                    }

                    resultMapWaveCount.set(entry[0], resultMapWaveCount.get(entry[0]) + entry[1]);
                    resultMapWaveCountPercentage.set(entry[0], resultMapWaveCountPercentage.get(entry[0]) + entry[1] / total);
                }
            }

            for (let entry of resultMapWaveCount.entries()) {
                let key = entry[0];
                if (entry[1] >= 0) {
                    resultMapWaveCount.set(key, resultMapWaveCount.get(key) / wavesCountMaps.length);
                    resultMapWaveCountPercentage.set(key, resultMapWaveCountPercentage.get(key) / wavesCountMaps.length);
                }
            }
        }

        console.log("\nTEST");

        if (isBoost) {
            console.log("Booster Group Stats");
            for (let entry of resultMapGroupCount.entries()) {
                if (entry[1] >= 0) {
                    console.log("   ", entry[0], "-", entry[1].toFixed(2), "-", resultMapGroupCountPercentage.get(entry[0]).toFixed(3), "-", resultMapGroupCountDistance.get(entry[0]).toFixed(3));
                }
            }
        }

        if (isBoost && isWave) {
            console.log("");
        }

        if (isWave) {
            console.log("Waves Stats");

            let longestName = 0;
            for (let entry of resultMapWaveCount.entries()) {
                if (entry[0].length > longestName && entry[1] != -1) {
                    longestName = entry[0].length;
                }
            }

            let everyBoostGroup = true;

            for (let key of boosterGroup1) {
                if (!resultMapWaveCount.has(key) || resultMapWaveCount.get(key) == -1) {
                    everyBoostGroup = false;
                }
            }
            for (let key of boosterGroup2) {
                if (!resultMapWaveCount.has(key) || resultMapWaveCount.get(key) == -1) {
                    everyBoostGroup = false;
                }
            }
            for (let key of boosterGroup3) {
                if (!resultMapWaveCount.has(key) || resultMapWaveCount.get(key) == -1) {
                    everyBoostGroup = false;
                }
            }
            for (let key of boosterGroup4) {
                if (!resultMapWaveCount.has(key) || resultMapWaveCount.get(key) == -1) {
                    everyBoostGroup = false;
                }
            }
            for (let key of boosterGroup5) {
                if (!resultMapWaveCount.has(key) || resultMapWaveCount.get(key) == -1) {
                    everyBoostGroup = false;
                }
            }

            everyBoostGroup = everyBoostGroup && (resultMapWaveCount.size == (boosterGroup1.length + boosterGroup2.length + boosterGroup3.length + boosterGroup4.length + boosterGroup5.length));

            let newLineCounters = [boosterGroup1.length, boosterGroup2.length, boosterGroup3.length, boosterGroup4.length];
            let newLineIndex = 0;
            let newLineCount = newLineCounters[newLineIndex];

            for (let entry of resultMapWaveCount.entries()) {
                if (entry[1] >= 0) {
                    let name = entry[0];
                    while (name.length < longestName) {
                        name = name.concat(" ");
                    }
                    console.log("   ", name, "-", entry[1].toFixed(2), "-", (resultMapWaveCountPercentage.get(entry[0]) * 100).toFixed(1));

                    newLineCount--;
                    if (newLineCount == 0 && everyBoostGroup) {
                        console.log("");
                        newLineIndex++;
                        if (newLineIndex < newLineCounters.length) {
                            newLineCount = newLineCounters[newLineIndex];
                        }
                    }
                }
            }
        }

        console.log("\n   ", Global.myVentDuration.toFixed(3));
    }

    _testOfTest() {
        this._test(1700, 700, true, true);
        this._test(1700, 700, true, true);
        this._test(1700, 700, true, true);
        this._test(1700, 700, true, true);

        this._test(700, 150, true, true);
        this._test(700, 150, true, true);
    }

    _testOfTestBoost() {
        this._test(1700, 700);
        this._test(1700, 700);
        this._test(1700, 700);
        this._test(1700, 700);

        this._test(700, 150);
        this._test(700, 150);
    }

    _testOfTestWaves() {
        this._test(1700, 700, false, true);
        this._test(1700, 700, false, true);
        this._test(1700, 700, false, true);
        this._test(1700, 700, false, true);

        this._test(700, 150, false, true);
        this._test(700, 150, false, true);
    }
}
class VentState extends PP.State {
    constructor(ventSetup, evidenceSetupList) {
        super();

        this._myFSM = new PP.FSM();
        //this._myFSM.setDebugLogActive(true, "        Vent State");
        this._myFSM.addState("init");
        this._myFSM.addState("first_wait", new PP.TimerState(1.5, "end"));
        this._myFSM.addState("vent", this._updateVent.bind(this));
        this._myFSM.addState("clean", this._updateClean.bind(this));
        this._myFSM.addState("defeat", this._updateDefeat.bind(this));
        this._myFSM.addState("second_wait_clean", new PP.TimerState(0, "end"));
        this._myFSM.addState("second_wait_defeat", new PP.TimerState(0, "end"));
        this._myFSM.addState("done");

        this._myFSM.addTransition("init", "first_wait", "start", this._prepareState.bind(this));
        this._myFSM.addTransition("first_wait", "vent", "end", this._prepareVent.bind(this));
        this._myFSM.addTransition("vent", "clean", "completed", this._prepareClean.bind(this));
        this._myFSM.addTransition("vent", "defeat", "lost", this._prepareDefeat.bind(this));
        this._myFSM.addTransition("clean", "second_wait_clean", "end");
        this._myFSM.addTransition("defeat", "second_wait_defeat", "end");
        this._myFSM.addTransition("second_wait_clean", "done", "end", this._ventCompleted.bind(this));
        this._myFSM.addTransition("second_wait_defeat", "done", "end", this._ventLost.bind(this));
        this._myFSM.addTransition("done", "first_wait", "start", this._prepareState.bind(this));

        this._myFSM.addTransition("init", "done", "skip");
        this._myFSM.addTransition("first_wait", "done", "skip");
        this._myFSM.addTransition("second_wait_clean", "done", "skip");
        this._myFSM.addTransition("second_wait_defeat", "done", "skip");
        this._myFSM.addTransition("vent", "done", "skip", this._hideVent.bind(this));
        this._myFSM.addTransition("clean", "done", "skip", this._hideVent.bind(this));
        this._myFSM.addTransition("defeat", "done", "skip", this._hideVent.bind(this));

        this._myFSM.init("init");

        this._myParentFSM = null;

        this._myEvidenceManager = new EvidenceManager(evidenceSetupList);

        this._myVent = new Vent(ventSetup);
        this._myVent.onVentLost(this._onVentLost.bind(this));
        this._myVent.onVentCompleted(this._onVentCompleted.bind(this));

        this._myNotEnough = new NotEnough();
    }

    update(dt, fsm) {
        Global.myVentDuration += dt;

        this._myFSM.update(dt);
        this._myEvidenceManager.update(dt);
        this._myVent.update(dt);

        if (Global.myDebugShortcutsEnabled) {
            //TEMP REMOVE THIS
            if (PP.myRightGamepad.getButtonInfo(PP.ButtonType.SELECT).isPressEnd(Global.myDebugShortcutsPress)) {
                this._myFSM.perform("skip");
                this._myVent.ventCompletedDebug();
                this._ventCompleted();
            }

            //TEMP REMOVE THIS
            if (PP.myLeftGamepad.getButtonInfo(PP.ButtonType.SQUEEZE).isPressEnd(Global.myDebugShortcutsPress)) {
                Global.myStopMusic = true;
                this._myFSM.perform("skip");
                this._myVent.ventLostDebug();
                this._ventLost();
            }
        }
    }

    _prepareState(fsm, transition) {
        Global.myVentDuration = 0;
    }

    _prepareVent() {
        this._myEvidenceManager.start();
        this._myVent.start();
    }

    _updateVent(dt, fsm) {
    }

    _prepareClean() {
        this._myEvidenceManager.clean();
        this._myVent.clean();
    }

    _updateClean(dt, fsm) {
        if (this._myEvidenceManager.isDone() && this._myVent.isDone()) {
            this._myFSM.perform("end");
        }
    }

    _prepareDefeat() {
        let zestyObject = Global.myGameObjects.get(GameObjectType.ZESTY_MARKET);
        let grabbable = zestyObject.pp_getComponentHierarchy("pp-grabbable");
        if (grabbable.isGrabbed()) {
            let zestyComponent = zestyObject.pp_getComponentHierarchy("zesty-banner");
            if (zestyComponent) {
                //Global.myZestyToClick = zestyComponent;
            }
        }

        this._myEvidenceManager.explode();
        this._myVent.stop();
        this._myNotEnough.start();
        Global.myParticlesManager.mrNOTParticles(Global.myPlayerPosition);

        Global.myStopMusic = true;
    }

    _updateDefeat(dt, fsm) {
        this._myNotEnough.update(dt);

        if (this._myEvidenceManager.isDone() && !this._myNotEnough.isNotEnoughing()) {
            this._myFSM.perform("end");
        }
    }

    _ventCompleted() {
        this._myParentFSM.perform("completed");
    }

    _ventLost(dt, fsm) {
        this._myParentFSM.perform("lost");
    }

    _hideVent() {
        this._hideEvidences();
        this._myVent.stop();
    }

    _hideEvidences() {
        this._myEvidenceManager.hide();
    }

    start(fsm, transition) {
        this._myParentFSM = fsm;
        this._myFSM.perform("start");
    }

    end(fsm, transitionID) {
        if (!this._myFSM.isInState("done")) {
            this._myFSM.perform("skip");
        }
    }

    _onVentLost() {
        this._myFSM.perform("lost");
    }

    _onVentCompleted() {
        this._myFSM.perform("completed");
    }
}
(()=>{var tr=Object.create,X=Object.defineProperty;var rr=Object.getOwnPropertyDescriptor;var nr=Object.getOwnPropertyNames;var sr=Object.getPrototypeOf,ir=Object.prototype.hasOwnProperty;var ar=t=>X(t,"__esModule",{value:!0});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var or=(t,e,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of nr(e))!ir.call(t,n)&&n!=="default"&&X(t,n,{get:()=>e[n],enumerable:!(r=rr(e,n))||r.enumerable});return t},Te=t=>or(ar(X(t!=null?tr(sr(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var Q=c((yn,Ce)=>{"use strict";Ce.exports=function(e,r){return function(){for(var s=new Array(arguments.length),i=0;i<s.length;i++)s[i]=arguments[i];return e.apply(r,s)}}});var d=c((vn,Se)=>{"use strict";var ur=Q(),G=Object.prototype.toString,Z=function(t){return function(e){var r=G.call(e);return t[r]||(t[r]=r.slice(8,-1).toLowerCase())}}(Object.create(null));function T(t){return t=t.toLowerCase(),function(r){return Z(r)===t}}function Y(t){return Array.isArray(t)}function U(t){return typeof t=="undefined"}function lr(t){return t!==null&&!U(t)&&t.constructor!==null&&!U(t.constructor)&&typeof t.constructor.isBuffer=="function"&&t.constructor.isBuffer(t)}var Oe=T("ArrayBuffer");function cr(t){var e;return typeof ArrayBuffer!="undefined"&&ArrayBuffer.isView?e=ArrayBuffer.isView(t):e=t&&t.buffer&&Oe(t.buffer),e}function fr(t){return typeof t=="string"}function dr(t){return typeof t=="number"}function qe(t){return t!==null&&typeof t=="object"}function F(t){if(Z(t)!=="object")return!1;var e=Object.getPrototypeOf(t);return e===null||e===Object.prototype}var pr=T("Date"),hr=T("File"),mr=T("Blob"),yr=T("FileList");function ee(t){return G.call(t)==="[object Function]"}function vr(t){return qe(t)&&ee(t.pipe)}function br(t){var e="[object FormData]";return t&&(typeof FormData=="function"&&t instanceof FormData||G.call(t)===e||ee(t.toString)&&t.toString()===e)}var wr=T("URLSearchParams");function gr(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}function Er(){return typeof navigator!="undefined"&&(navigator.product==="ReactNative"||navigator.product==="NativeScript"||navigator.product==="NS")?!1:typeof window!="undefined"&&typeof document!="undefined"}function te(t,e){if(!(t===null||typeof t=="undefined"))if(typeof t!="object"&&(t=[t]),Y(t))for(var r=0,n=t.length;r<n;r++)e.call(null,t[r],r,t);else for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.call(null,t[s],s,t)}function re(){var t={};function e(s,i){F(t[i])&&F(s)?t[i]=re(t[i],s):F(s)?t[i]=re({},s):Y(s)?t[i]=s.slice():t[i]=s}for(var r=0,n=arguments.length;r<n;r++)te(arguments[r],e);return t}function xr(t,e,r){return te(e,function(s,i){r&&typeof s=="function"?t[i]=ur(s,r):t[i]=s}),t}function Rr(t){return t.charCodeAt(0)===65279&&(t=t.slice(1)),t}function Ar(t,e,r,n){t.prototype=Object.create(e.prototype,n),t.prototype.constructor=t,r&&Object.assign(t.prototype,r)}function Tr(t,e,r){var n,s,i,a={};e=e||{};do{for(n=Object.getOwnPropertyNames(t),s=n.length;s-- >0;)i=n[s],a[i]||(e[i]=t[i],a[i]=!0);t=Object.getPrototypeOf(t)}while(t&&(!r||r(t,e))&&t!==Object.prototype);return e}function Cr(t,e,r){t=String(t),(r===void 0||r>t.length)&&(r=t.length),r-=e.length;var n=t.indexOf(e,r);return n!==-1&&n===r}function Or(t){if(!t)return null;var e=t.length;if(U(e))return null;for(var r=new Array(e);e-- >0;)r[e]=t[e];return r}var qr=function(t){return function(e){return t&&e instanceof t}}(typeof Uint8Array!="undefined"&&Object.getPrototypeOf(Uint8Array));Se.exports={isArray:Y,isArrayBuffer:Oe,isBuffer:lr,isFormData:br,isArrayBufferView:cr,isString:fr,isNumber:dr,isObject:qe,isPlainObject:F,isUndefined:U,isDate:pr,isFile:hr,isBlob:mr,isFunction:ee,isStream:vr,isURLSearchParams:wr,isStandardBrowserEnv:Er,forEach:te,merge:re,extend:xr,trim:gr,stripBOM:Rr,inherits:Ar,toFlatObject:Tr,kindOf:Z,kindOfTest:T,endsWith:Cr,toArray:Or,isTypedArray:qr,isFileList:yr}});var ne=c((bn,Pe)=>{"use strict";var S=d();function ke(t){return encodeURIComponent(t).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}Pe.exports=function(e,r,n){if(!r)return e;var s;if(n)s=n(r);else if(S.isURLSearchParams(r))s=r.toString();else{var i=[];S.forEach(r,function(l,h){l===null||typeof l=="undefined"||(S.isArray(l)?h=h+"[]":l=[l],S.forEach(l,function(f){S.isDate(f)?f=f.toISOString():S.isObject(f)&&(f=JSON.stringify(f)),i.push(ke(h)+"="+ke(f))}))}),s=i.join("&")}if(s){var a=e.indexOf("#");a!==-1&&(e=e.slice(0,a)),e+=(e.indexOf("?")===-1?"?":"&")+s}return e}});var Le=c((wn,Ne)=>{"use strict";var Sr=d();function j(){this.handlers=[]}j.prototype.use=function(e,r,n){return this.handlers.push({fulfilled:e,rejected:r,synchronous:n?n.synchronous:!1,runWhen:n?n.runWhen:null}),this.handlers.length-1};j.prototype.eject=function(e){this.handlers[e]&&(this.handlers[e]=null)};j.prototype.forEach=function(e){Sr.forEach(this.handlers,function(n){n!==null&&e(n)})};Ne.exports=j});var _e=c((gn,De)=>{"use strict";var kr=d();De.exports=function(e,r){kr.forEach(e,function(s,i){i!==r&&i.toUpperCase()===r.toUpperCase()&&(e[r]=s,delete e[i])})}});var C=c((En,je)=>{"use strict";var Be=d();function k(t,e,r,n,s){Error.call(this),this.message=t,this.name="AxiosError",e&&(this.code=e),r&&(this.config=r),n&&(this.request=n),s&&(this.response=s)}Be.inherits(k,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code,status:this.response&&this.response.status?this.response.status:null}}});var Ue=k.prototype,Fe={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED"].forEach(function(t){Fe[t]={value:t}});Object.defineProperties(k,Fe);Object.defineProperty(Ue,"isAxiosError",{value:!0});k.from=function(t,e,r,n,s,i){var a=Object.create(Ue);return Be.toFlatObject(t,a,function(l){return l!==Error.prototype}),k.call(a,t.message,e,r,n,s),a.name=t.name,i&&Object.assign(a,i),a};je.exports=k});var se=c((xn,ze)=>{"use strict";ze.exports={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1}});var ie=c((Rn,Me)=>{"use strict";var g=d();function Pr(t,e){e=e||new FormData;var r=[];function n(i){return i===null?"":g.isDate(i)?i.toISOString():g.isArrayBuffer(i)||g.isTypedArray(i)?typeof Blob=="function"?new Blob([i]):Buffer.from(i):i}function s(i,a){if(g.isPlainObject(i)||g.isArray(i)){if(r.indexOf(i)!==-1)throw Error("Circular reference detected in "+a);r.push(i),g.forEach(i,function(l,h){if(!g.isUndefined(l)){var o=a?a+"."+h:h,f;if(l&&!a&&typeof l=="object"){if(g.endsWith(h,"{}"))l=JSON.stringify(l);else if(g.endsWith(h,"[]")&&(f=g.toArray(l))){f.forEach(function(v){!g.isUndefined(v)&&e.append(o,n(v))});return}}s(l,o)}}),r.pop()}else e.append(a,n(i))}return s(t),e}Me.exports=Pr});var We=c((An,Ie)=>{"use strict";var ae=C();Ie.exports=function(e,r,n){var s=n.config.validateStatus;!n.status||!s||s(n.status)?e(n):r(new ae("Request failed with status code "+n.status,[ae.ERR_BAD_REQUEST,ae.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n))}});var He=c((Tn,$e)=>{"use strict";var z=d();$e.exports=z.isStandardBrowserEnv()?function(){return{write:function(r,n,s,i,a,u){var l=[];l.push(r+"="+encodeURIComponent(n)),z.isNumber(s)&&l.push("expires="+new Date(s).toGMTString()),z.isString(i)&&l.push("path="+i),z.isString(a)&&l.push("domain="+a),u===!0&&l.push("secure"),document.cookie=l.join("; ")},read:function(r){var n=document.cookie.match(new RegExp("(^|;\\s*)("+r+")=([^;]*)"));return n?decodeURIComponent(n[3]):null},remove:function(r){this.write(r,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}()});var Ve=c((Cn,Je)=>{"use strict";Je.exports=function(e){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)}});var Xe=c((On,Ke)=>{"use strict";Ke.exports=function(e,r){return r?e.replace(/\/+$/,"")+"/"+r.replace(/^\/+/,""):e}});var oe=c((qn,Qe)=>{"use strict";var Nr=Ve(),Lr=Xe();Qe.exports=function(e,r){return e&&!Nr(r)?Lr(e,r):r}});var Ze=c((Sn,Ge)=>{"use strict";var ue=d(),Dr=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];Ge.exports=function(e){var r={},n,s,i;return e&&ue.forEach(e.split(`
`),function(u){if(i=u.indexOf(":"),n=ue.trim(u.substr(0,i)).toLowerCase(),s=ue.trim(u.substr(i+1)),n){if(r[n]&&Dr.indexOf(n)>=0)return;n==="set-cookie"?r[n]=(r[n]?r[n]:[]).concat([s]):r[n]=r[n]?r[n]+", "+s:s}}),r}});var tt=c((kn,et)=>{"use strict";var Ye=d();et.exports=Ye.isStandardBrowserEnv()?function(){var e=/(msie|trident)/i.test(navigator.userAgent),r=document.createElement("a"),n;function s(i){var a=i;return e&&(r.setAttribute("href",a),a=r.href),r.setAttribute("href",a),{href:r.href,protocol:r.protocol?r.protocol.replace(/:$/,""):"",host:r.host,search:r.search?r.search.replace(/^\?/,""):"",hash:r.hash?r.hash.replace(/^#/,""):"",hostname:r.hostname,port:r.port,pathname:r.pathname.charAt(0)==="/"?r.pathname:"/"+r.pathname}}return n=s(window.location.href),function(a){var u=Ye.isString(a)?s(a):a;return u.protocol===n.protocol&&u.host===n.host}}():function(){return function(){return!0}}()});var _=c((Pn,nt)=>{"use strict";var le=C(),_r=d();function rt(t){le.call(this,t??"canceled",le.ERR_CANCELED),this.name="CanceledError"}_r.inherits(rt,le,{__CANCEL__:!0});nt.exports=rt});var it=c((Nn,st)=>{"use strict";st.exports=function(e){var r=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return r&&r[1]||""}});var ce=c((Ln,at)=>{"use strict";var B=d(),Br=We(),Ur=He(),Fr=ne(),jr=oe(),zr=Ze(),Mr=tt(),Ir=se(),x=C(),Wr=_(),$r=it();at.exports=function(e){return new Promise(function(n,s){var i=e.data,a=e.headers,u=e.responseType,l;function h(){e.cancelToken&&e.cancelToken.unsubscribe(l),e.signal&&e.signal.removeEventListener("abort",l)}B.isFormData(i)&&B.isStandardBrowserEnv()&&delete a["Content-Type"];var o=new XMLHttpRequest;if(e.auth){var f=e.auth.username||"",v=e.auth.password?unescape(encodeURIComponent(e.auth.password)):"";a.Authorization="Basic "+btoa(f+":"+v)}var m=jr(e.baseURL,e.url);o.open(e.method.toUpperCase(),Fr(m,e.params,e.paramsSerializer),!0),o.timeout=e.timeout;function Re(){if(!!o){var w="getAllResponseHeaders"in o?zr(o.getAllResponseHeaders()):null,q=!u||u==="text"||u==="json"?o.responseText:o.response,A={data:q,status:o.status,statusText:o.statusText,headers:w,config:e,request:o};Br(function(K){n(K),h()},function(K){s(K),h()},A),o=null}}if("onloadend"in o?o.onloadend=Re:o.onreadystatechange=function(){!o||o.readyState!==4||o.status===0&&!(o.responseURL&&o.responseURL.indexOf("file:")===0)||setTimeout(Re)},o.onabort=function(){!o||(s(new x("Request aborted",x.ECONNABORTED,e,o)),o=null)},o.onerror=function(){s(new x("Network Error",x.ERR_NETWORK,e,o,o)),o=null},o.ontimeout=function(){var q=e.timeout?"timeout of "+e.timeout+"ms exceeded":"timeout exceeded",A=e.transitional||Ir;e.timeoutErrorMessage&&(q=e.timeoutErrorMessage),s(new x(q,A.clarifyTimeoutError?x.ETIMEDOUT:x.ECONNABORTED,e,o)),o=null},B.isStandardBrowserEnv()){var Ae=(e.withCredentials||Mr(m))&&e.xsrfCookieName?Ur.read(e.xsrfCookieName):void 0;Ae&&(a[e.xsrfHeaderName]=Ae)}"setRequestHeader"in o&&B.forEach(a,function(q,A){typeof i=="undefined"&&A.toLowerCase()==="content-type"?delete a[A]:o.setRequestHeader(A,q)}),B.isUndefined(e.withCredentials)||(o.withCredentials=!!e.withCredentials),u&&u!=="json"&&(o.responseType=e.responseType),typeof e.onDownloadProgress=="function"&&o.addEventListener("progress",e.onDownloadProgress),typeof e.onUploadProgress=="function"&&o.upload&&o.upload.addEventListener("progress",e.onUploadProgress),(e.cancelToken||e.signal)&&(l=function(w){!o||(s(!w||w&&w.type?new Wr:w),o.abort(),o=null)},e.cancelToken&&e.cancelToken.subscribe(l),e.signal&&(e.signal.aborted?l():e.signal.addEventListener("abort",l))),i||(i=null);var V=$r(m);if(V&&["http","https","file"].indexOf(V)===-1){s(new x("Unsupported protocol "+V+":",x.ERR_BAD_REQUEST,e));return}o.send(i)})}});var ut=c((Dn,ot)=>{ot.exports=null});var I=c((_n,dt)=>{"use strict";var p=d(),lt=_e(),ct=C(),Hr=se(),Jr=ie(),Vr={"Content-Type":"application/x-www-form-urlencoded"};function ft(t,e){!p.isUndefined(t)&&p.isUndefined(t["Content-Type"])&&(t["Content-Type"]=e)}function Kr(){var t;return typeof XMLHttpRequest!="undefined"?t=ce():typeof process!="undefined"&&Object.prototype.toString.call(process)==="[object process]"&&(t=ce()),t}function Xr(t,e,r){if(p.isString(t))try{return(e||JSON.parse)(t),p.trim(t)}catch(n){if(n.name!=="SyntaxError")throw n}return(r||JSON.stringify)(t)}var M={transitional:Hr,adapter:Kr(),transformRequest:[function(e,r){if(lt(r,"Accept"),lt(r,"Content-Type"),p.isFormData(e)||p.isArrayBuffer(e)||p.isBuffer(e)||p.isStream(e)||p.isFile(e)||p.isBlob(e))return e;if(p.isArrayBufferView(e))return e.buffer;if(p.isURLSearchParams(e))return ft(r,"application/x-www-form-urlencoded;charset=utf-8"),e.toString();var n=p.isObject(e),s=r&&r["Content-Type"],i;if((i=p.isFileList(e))||n&&s==="multipart/form-data"){var a=this.env&&this.env.FormData;return Jr(i?{"files[]":e}:e,a&&new a)}else if(n||s==="application/json")return ft(r,"application/json"),Xr(e);return e}],transformResponse:[function(e){var r=this.transitional||M.transitional,n=r&&r.silentJSONParsing,s=r&&r.forcedJSONParsing,i=!n&&this.responseType==="json";if(i||s&&p.isString(e)&&e.length)try{return JSON.parse(e)}catch(a){if(i)throw a.name==="SyntaxError"?ct.from(a,ct.ERR_BAD_RESPONSE,this,null,this.response):a}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:ut()},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};p.forEach(["delete","get","head"],function(e){M.headers[e]={}});p.forEach(["post","put","patch"],function(e){M.headers[e]=p.merge(Vr)});dt.exports=M});var ht=c((Bn,pt)=>{"use strict";var Qr=d(),Gr=I();pt.exports=function(e,r,n){var s=this||Gr;return Qr.forEach(n,function(a){e=a.call(s,e,r)}),e}});var fe=c((Un,mt)=>{"use strict";mt.exports=function(e){return!!(e&&e.__CANCEL__)}});var bt=c((Fn,vt)=>{"use strict";var yt=d(),de=ht(),Zr=fe(),Yr=I(),en=_();function pe(t){if(t.cancelToken&&t.cancelToken.throwIfRequested(),t.signal&&t.signal.aborted)throw new en}vt.exports=function(e){pe(e),e.headers=e.headers||{},e.data=de.call(e,e.data,e.headers,e.transformRequest),e.headers=yt.merge(e.headers.common||{},e.headers[e.method]||{},e.headers),yt.forEach(["delete","get","head","post","put","patch","common"],function(s){delete e.headers[s]});var r=e.adapter||Yr.adapter;return r(e).then(function(s){return pe(e),s.data=de.call(e,s.data,s.headers,e.transformResponse),s},function(s){return Zr(s)||(pe(e),s&&s.response&&(s.response.data=de.call(e,s.response.data,s.response.headers,e.transformResponse))),Promise.reject(s)})}});var he=c((jn,wt)=>{"use strict";var b=d();wt.exports=function(e,r){r=r||{};var n={};function s(o,f){return b.isPlainObject(o)&&b.isPlainObject(f)?b.merge(o,f):b.isPlainObject(f)?b.merge({},f):b.isArray(f)?f.slice():f}function i(o){if(b.isUndefined(r[o])){if(!b.isUndefined(e[o]))return s(void 0,e[o])}else return s(e[o],r[o])}function a(o){if(!b.isUndefined(r[o]))return s(void 0,r[o])}function u(o){if(b.isUndefined(r[o])){if(!b.isUndefined(e[o]))return s(void 0,e[o])}else return s(void 0,r[o])}function l(o){if(o in r)return s(e[o],r[o]);if(o in e)return s(void 0,e[o])}var h={url:a,method:a,data:a,baseURL:u,transformRequest:u,transformResponse:u,paramsSerializer:u,timeout:u,timeoutMessage:u,withCredentials:u,adapter:u,responseType:u,xsrfCookieName:u,xsrfHeaderName:u,onUploadProgress:u,onDownloadProgress:u,decompress:u,maxContentLength:u,maxBodyLength:u,beforeRedirect:u,transport:u,httpAgent:u,httpsAgent:u,cancelToken:u,socketPath:u,responseEncoding:u,validateStatus:l};return b.forEach(Object.keys(e).concat(Object.keys(r)),function(f){var v=h[f]||i,m=v(f);b.isUndefined(m)&&v!==l||(n[f]=m)}),n}});var me=c((zn,gt)=>{gt.exports={version:"0.27.2"}});var Rt=c((Mn,xt)=>{"use strict";var tn=me().version,R=C(),ye={};["object","boolean","number","function","string","symbol"].forEach(function(t,e){ye[t]=function(n){return typeof n===t||"a"+(e<1?"n ":" ")+t}});var Et={};ye.transitional=function(e,r,n){function s(i,a){return"[Axios v"+tn+"] Transitional option '"+i+"'"+a+(n?". "+n:"")}return function(i,a,u){if(e===!1)throw new R(s(a," has been removed"+(r?" in "+r:"")),R.ERR_DEPRECATED);return r&&!Et[a]&&(Et[a]=!0,console.warn(s(a," has been deprecated since v"+r+" and will be removed in the near future"))),e?e(i,a,u):!0}};function rn(t,e,r){if(typeof t!="object")throw new R("options must be an object",R.ERR_BAD_OPTION_VALUE);for(var n=Object.keys(t),s=n.length;s-- >0;){var i=n[s],a=e[i];if(a){var u=t[i],l=u===void 0||a(u,i,t);if(l!==!0)throw new R("option "+i+" must be "+l,R.ERR_BAD_OPTION_VALUE);continue}if(r!==!0)throw new R("Unknown option "+i,R.ERR_BAD_OPTION)}}xt.exports={assertOptions:rn,validators:ye}});var St=c((In,qt)=>{"use strict";var At=d(),nn=ne(),Tt=Le(),Ct=bt(),W=he(),sn=oe(),Ot=Rt(),P=Ot.validators;function N(t){this.defaults=t,this.interceptors={request:new Tt,response:new Tt}}N.prototype.request=function(e,r){typeof e=="string"?(r=r||{},r.url=e):r=e||{},r=W(this.defaults,r),r.method?r.method=r.method.toLowerCase():this.defaults.method?r.method=this.defaults.method.toLowerCase():r.method="get";var n=r.transitional;n!==void 0&&Ot.assertOptions(n,{silentJSONParsing:P.transitional(P.boolean),forcedJSONParsing:P.transitional(P.boolean),clarifyTimeoutError:P.transitional(P.boolean)},!1);var s=[],i=!0;this.interceptors.request.forEach(function(m){typeof m.runWhen=="function"&&m.runWhen(r)===!1||(i=i&&m.synchronous,s.unshift(m.fulfilled,m.rejected))});var a=[];this.interceptors.response.forEach(function(m){a.push(m.fulfilled,m.rejected)});var u;if(!i){var l=[Ct,void 0];for(Array.prototype.unshift.apply(l,s),l=l.concat(a),u=Promise.resolve(r);l.length;)u=u.then(l.shift(),l.shift());return u}for(var h=r;s.length;){var o=s.shift(),f=s.shift();try{h=o(h)}catch(v){f(v);break}}try{u=Ct(h)}catch(v){return Promise.reject(v)}for(;a.length;)u=u.then(a.shift(),a.shift());return u};N.prototype.getUri=function(e){e=W(this.defaults,e);var r=sn(e.baseURL,e.url);return nn(r,e.params,e.paramsSerializer)};At.forEach(["delete","get","head","options"],function(e){N.prototype[e]=function(r,n){return this.request(W(n||{},{method:e,url:r,data:(n||{}).data}))}});At.forEach(["post","put","patch"],function(e){function r(n){return function(i,a,u){return this.request(W(u||{},{method:e,headers:n?{"Content-Type":"multipart/form-data"}:{},url:i,data:a}))}}N.prototype[e]=r(),N.prototype[e+"Form"]=r(!0)});qt.exports=N});var Pt=c((Wn,kt)=>{"use strict";var an=_();function L(t){if(typeof t!="function")throw new TypeError("executor must be a function.");var e;this.promise=new Promise(function(s){e=s});var r=this;this.promise.then(function(n){if(!!r._listeners){var s,i=r._listeners.length;for(s=0;s<i;s++)r._listeners[s](n);r._listeners=null}}),this.promise.then=function(n){var s,i=new Promise(function(a){r.subscribe(a),s=a}).then(n);return i.cancel=function(){r.unsubscribe(s)},i},t(function(s){r.reason||(r.reason=new an(s),e(r.reason))})}L.prototype.throwIfRequested=function(){if(this.reason)throw this.reason};L.prototype.subscribe=function(e){if(this.reason){e(this.reason);return}this._listeners?this._listeners.push(e):this._listeners=[e]};L.prototype.unsubscribe=function(e){if(!!this._listeners){var r=this._listeners.indexOf(e);r!==-1&&this._listeners.splice(r,1)}};L.source=function(){var e,r=new L(function(s){e=s});return{token:r,cancel:e}};kt.exports=L});var Lt=c(($n,Nt)=>{"use strict";Nt.exports=function(e){return function(n){return e.apply(null,n)}}});var _t=c((Hn,Dt)=>{"use strict";var on=d();Dt.exports=function(e){return on.isObject(e)&&e.isAxiosError===!0}});var Ft=c((Jn,ve)=>{"use strict";var Bt=d(),un=Q(),$=St(),ln=he(),cn=I();function Ut(t){var e=new $(t),r=un($.prototype.request,e);return Bt.extend(r,$.prototype,e),Bt.extend(r,e),r.create=function(s){return Ut(ln(t,s))},r}var y=Ut(cn);y.Axios=$;y.CanceledError=_();y.CancelToken=Pt();y.isCancel=fe();y.VERSION=me().version;y.toFormData=ie();y.AxiosError=C();y.Cancel=y.CanceledError;y.all=function(e){return Promise.all(e)};y.spread=Lt();y.isAxiosError=_t();ve.exports=y;ve.exports.default=y});var be=c((Vn,jt)=>{jt.exports=Ft()});var O=Te(be());var zt=Te(be()),H=t=>{if(t.substring(0,4)==="ipfs")return`https://ipfs.zesty.market/ipfs/${t.substring(7)}`;if(t.substring(0,4)==="http")return t;if(t.substring(0,5)==="https")return t;if(t.substring(0,2)==="ar")zt.default.get(`https://arweave.net/${t.substring(5)}`).then(e=>e.url).catch(e=>{console.error(e)});else return`https://ipfs.zesty.market/ipfs/${t}`},E=()=>{let t=[{gateway:"https://cloudflare-ipfs.com",weight:35},{gateway:"https://gateway.pinata.cloud",weight:35},{gateway:"https://dweb.link",weight:30}],e=[],r;for(r=0;r<t.length;r++)e[r]=t[r].weight+(e[r-1]||0);let n=Math.random()*e[e.length-1];for(r=0;r<e.length&&!(e[r]>n);r++);return t[r].gateway},we=()=>{let t=window.XRHand!=null&&window.XRMediaBinding!=null,e=navigator.userAgent.includes("OculusBrowser"),r=t&&e?"Full":t||e?"Partial":"None";return{match:r!=="None",confidence:r}},ge=()=>{let t=window.mozInnerScreenX!=null&&window.speechSynthesis==null,e=navigator.userAgent.includes("Mobile VR")&&!navigator.userAgent.includes("OculusBrowser"),r=t&&e?"Full":t||e?"Partial":"None";return{match:r!=="None",confidence:r}},Mt=async()=>{let t=await navigator.xr.isSessionSupported("immersive-vr")&&await navigator.xr.isSessionSupported("immersive-ar"),e=navigator.userAgent.includes("Pico Neo 3 Link"),r=t&&e?"Full":t||e?"Partial":"None";return{match:r!=="None",confidence:r}},It=()=>{let t=navigator.maxTouchPoints===0||navigator.msMaxTouchPoints===0,e=!navigator.userAgent.includes("Android")&&!navigator.userAgent.includes("Mobile"),r=t&&e?"Full":t||e?"Partial":"None";return{match:r!=="None",confidence:r}},Ee=async()=>{let t={platform:"",confidence:""};return we().match?t={platform:"Oculus",confidence:we().confidence}:ge().match?t={platform:"Wolvic",confidence:ge().confidence}:await Mt().match?t={platform:"Pico",confidence:await Mt().confidence}:It().match?t={platform:"Desktop",confidence:It().confidence}:t={platform:"Unknown",confidence:"None"},t},Wt=t=>{if(!!t){if(we().match){if(t.includes("https://www.oculus.com/experiences/quest/")){setTimeout(()=>{window.open(t,"_blank")},1e3);return}}else if(ge().match){let e=document.createElement("div"),r=document.createElement("div"),n=document.createElement("p"),s=document.createElement("button"),i=document.createElement("button");e.style.backgroundColor="rgb(0, 0, 0, 0.75)",e.style.color="white",e.style.textAlign="center",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.padding="5%",e.style.borderRadius="5%",e.style.transform="translate(-50%, -50%)",n.innerHTML=`<b>This billboard leads to ${t}. Continue?</b>`,s.innerText="Move cursor back into window.",s.style.width="100vw",s.style.height="100vh",s.onmouseenter=()=>{s.style.width="auto",s.style.height="auto",s.innerText="Yes"},s.onclick=()=>{window.open(t,"_blank"),e.remove()},i.innerText="No",i.onclick=()=>{e.remove()},e.append(r),r.append(n),r.append(s),r.append(i),document.body.append(e);return}window.open(t,"_blank")}},$t=t=>t.indexOf("utm_source=")!==-1||t.indexOf("utm_campaign=")!==-1||t.indexOf("utm_channel=")!==-1,Ht=(t,e)=>{let r=new URL(t);return r.searchParams.set("utm_source","ZestyMarket"),r.searchParams.set("utm_campaign","ZestyCampaign"),r.searchParams.set("utm_channel",`SpaceId_${e}`),r.href};var D={tall:{width:.75,height:1,style:{standard:`${E()}/ipns/lib.zesty.market/assets/zesty-banner-tall.png`,minimal:`${E()}/ipns/lib.zesty.market/assets/zesty-banner-tall-minimal.png`,transparent:`${E()}/ipns/lib.zesty.market/assets/zesty-banner-tall-transparent.png`}},wide:{width:4,height:1,style:{standard:`${E()}/ipns/lib.zesty.market/assets/zesty-banner-wide.png`,minimal:`${E()}/ipns/lib.zesty.market/assets/zesty-banner-wide-minimal.png`,transparent:`${E()}/ipns/lib.zesty.market/assets/zesty-banner-wide-transparent.png`}},square:{width:1,height:1,style:{standard:`${E()}/ipns/lib.zesty.market/assets/zesty-banner-square.png`,minimal:`${E()}/ipns/lib.zesty.market/assets/zesty-banner-square-minimal.png`,transparent:`${E()}/ipns/lib.zesty.market/assets/zesty-banner-square-transparent.png`}}},J="square",Jt="standard";var Vt="https://beacon.zesty.market",Kt="https://beacon2.zesty.market/zgraphql",fn={matic:"https://api.thegraph.com/subgraphs/name/zestymarket/zesty-market-graph-matic",polygon:"https://api.thegraph.com/subgraphs/name/zestymarket/zesty-market-graph-matic",rinkeby:"https://api.thegraph.com/subgraphs/name/zestymarket/zesty-market-graph-rinkeby"},xe={uri:void 0},dn={name:"Default banner",description:"This is the default banner that would be displayed ipsum",image:"https://ipfs.zesty.market/ipfs/QmWBNfP8roDrwz3XQo4qpu9fMxvUSTn8LB7d4JK7ybrfZ2/assets/zesty-ad-square.png",url:"https://www.zesty.market"},Xt=async(t,e="polygon")=>{let r=Math.floor(Date.now()/1e3);return O.default.post(fn[e],{query:`
      query {
        tokenDatas (
          where: {
            id: "${t}"
          }
        )
        { 
          sellerNFTSetting {
            sellerAuctions (
              first: 5
              where: {
                contractTimeStart_lte: ${r}
                contractTimeEnd_gte: ${r}
                cancelled: false
              }
            ) {
              id
              buyerCampaigns {
                id
                uri
              }
              buyerCampaignsApproved
              buyerCampaignsIdList
            }
          }
          id
        }
      }
    `}).then(n=>pn(n)).catch(n=>(console.log(n),xe))},pn=t=>{if(t.status!=200)return xe;let e=t.data.data.tokenDatas[0]?.sellerNFTSetting?.sellerAuctions,r=null;return e?.[0]?.buyerCampaignsApproved?.find((n,s)=>{if(n){let i=e[0].buyerCampaignsIdList[s];r=e[0].buyerCampaigns.find(a=>a.id===i)}}),r??xe},Qt=async(t,e,r,n,s)=>{if(!t){let i={uri:"DEFAULT_URI",data:dn},a=e||J,u=r||Jt,l=s||D;return i.data.image=l[a].style[u],i}return O.default.get(H(t)).then(i=>($t(i.data.url)||(i.data.url=Ht(i.data.url,n)),i.status==200?{uri:t,data:i.data}:null))},Gt=async t=>{let{platform:e,confidence:r}=await Ee();try{let n=Vt+`/api/v1/space/${t}`;await O.default.put(n),await O.default.post(Kt,{query:`mutation { increment(eventType: visits, spaceId: "${t}", platform: { name: ${e}, confidence: ${r} }) { message } }`},{headers:{"Content-Type":"application/json"}})}catch(n){console.log("Failed to emit onload event",n.message)}},Zt=async t=>{let{platform:e,confidence:r}=await Ee();try{let n=Vt+`/api/v1/space/click/${t}`;await O.default.put(n),await O.default.post(Kt,{query:`mutation { increment(eventType: clicks, spaceId: "${t}", platform: { name: ${e}, confidence: ${r} }) { message } }`},{headers:{"Content-Type":"application/json"}})}catch(n){console.log("Failed to emit onclick event",n.message)}};var Yt="1.6.0";console.log("Zesty SDK Version: ",Yt);WL.registerComponent("zesty-banner",{space:{type:WL.Type.Int},network:{type:WL.Type.Enum,values:["rinkeby","polygon"],default:"polygon"},format:{type:WL.Type.Enum,values:Object.keys(D),default:J},style:{type:WL.Type.Enum,values:["standard","minimal","transparent"],default:"transparent"},scaleToRatio:{type:WL.Type.Bool,default:!0},textureProperty:{type:WL.Type.String,default:"auto"},beacon:{type:WL.Type.Bool,default:!0},dynamicFormats:{type:WL.Type.Bool,default:!0},createAutomaticCollision:{type:WL.Type.Bool,default:!0}},{init:function(){this.formats=Object.values(D),this.formatKeys=Object.keys(D),this.styleKeys=["standard","minimal","transparent"]},start:function(){if(this.mesh=this.object.getComponent("mesh"),!this.mesh)throw new Error("'zesty-banner ' missing mesh component");if(this.createAutomaticCollision&&(this.collision=this.object.getComponent("collision")||this.object.addComponent("collision",{collider:WL.Collider.Box,group:2}),this.cursorTarget=this.object.getComponent("cursor-target")||this.object.addComponent("cursor-target"),this.cursorTarget.addClickFunction(this.onClick.bind(this))),this.dynamicFormats){let t=document.createElement("script");t.onload=()=>{this.formatsOverride=zestyFormats.formats,this.startLoading()},t.setAttribute("src","https://ipfs.io/ipns/lib.zesty.market/zesty-formats.js"),t.setAttribute("crossorigin","anonymous"),document.body.appendChild(t)}else this.startLoading()},startLoading:function(){this.loadBanner(this.space,this.network,this.formatKeys[this.format],this.styleKeys[this.style]).then(t=>{this.banner=t,this.scaleToRatio&&(this.height=this.object.scalingLocal[1],this.object.resetScaling(),this.createAutomaticCollision&&(this.collision.extents=[this.formats[this.format].width*this.height,this.height,.1]),this.object.scale([this.formats[this.format].width*this.height,this.height,1]));let e=this.mesh.material.clone();if(this.textureProperty==="auto"){let r=e.pipeline||e.shader;if(r==="Phong Opaque Textured")e.diffuseTexture=t.texture,e.alphaMaskThreshold=.3;else if(r==="Flat Opaque Textured")e.flatTexture=t.texture,e.alphaMaskThreshold=.8;else throw Error("'zesty-banner ' unable to apply banner texture: unsupported pipeline "+e.shader);this.mesh.material=e}else this.mesh.material[this.textureProperty]=t.texture;this.beacon&&Gt(this.space)})},onClick:function(){this.banner?.url&&(WL.xrSession?WL.xrSession.end().then(this.executeClick.bind(this)):this.executeClick())},executeClick:function(){Wt(this.banner.url),this.beacon&&Zt(this.space)},loadBanner:async function(t,e,r,n){e=e?"polygon":"rinkeby";let s=await Xt(t,e),i=await Qt(s.uri,r,n,t,this.formatsOverride),a=i.data.url;a=a.match(/^http[s]?:\/\//)?a:"https://"+a,a==="https://www.zesty.market"&&(a=`https://app.zesty.market/space/${t}`);let u=i.data.image;return u=u.match(/^.+\.(png|jpe?g)/i)?u:H(u),WL.textures.load(u,"").then(l=>(i.texture=l,i.imageSrc=u,i.url=a,i))}});})();
//# sourceMappingURL=zesty-wonderland-sdk.js.map

WL.registerComponent("pp-easy-light-attenuation", {
    _myVariableName: { type: WL.Type.String, default: "" },
    _mySetAsDefault: { type: WL.Type.Bool, default: false },
    _myUseTuneTarget: { type: WL.Type.Bool, default: false }

}, {
    init: function () {
        this._myEasyObjectTuner = new PP.EasyLightAttenuation(this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    },
    start: function () {
        this._myEasyObjectTuner.start();
    },
    update: function (dt) {
        this._myEasyObjectTuner.update(dt);
    }
});

PP.EasyLightAttenuation = class EasyLightAttenuation extends PP.EasyObjectTuner {
    constructor(object, variableName, setAsDefault, useTuneTarget) {
        super(object, variableName, setAsDefault, useTuneTarget);
    }

    _getVariableNamePrefix() {
        let nameFirstPart = "Light Attenuation ";
        return nameFirstPart;
    }

    _createEasyTuneVariable(variableName) {
        return new PP.EasyTuneNumber(variableName, this._getDefaultValue(), 0.01, 3, 0, 1);
    }

    _getObjectValue(object) {
        let attenuation = this._getLightAttenuation(object);
        return attenuation;
    }

    _getDefaultValue() {
        return 0;
    }

    _updateObjectValue(object, value) {
        let attenuation = value;

        let light = object.pp_getComponent("light");
        if (light) {
            light.color[3] = attenuation;
        }
    }

    _getLightAttenuation(object) {
        let attenuation = this._getDefaultValue();

        let light = object.pp_getComponent("light");
        if (light) {
            attenuation = light.color[3];
        }

        return attenuation;
    }
};
WL.registerComponent("pp-easy-light-color", {
    _myVariableName: { type: WL.Type.String, default: "" },
    _mySetAsDefault: { type: WL.Type.Bool, default: false },
    _myUseTuneTarget: { type: WL.Type.Bool, default: false },
    _myColorModel: { type: WL.Type.Enum, values: ['rgb', 'hsv'] }

}, {
    init: function () {
        this._myEasyObjectTuner = new PP.EasyLightColor(this._myColorModel, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    },
    start: function () {
        this._myEasyObjectTuner.start();
    },
    update: function (dt) {
        this._myEasyObjectTuner.update(dt);
    }
});

PP.EasyLightColor = class EasyLightColor extends PP.EasyObjectTuner {
    constructor(colorModel, object, variableName, setAsDefault, useTuneTarget) {
        super(object, variableName, setAsDefault, useTuneTarget);
        this._myColorModel = colorModel;
    }

    _getVariableNamePrefix() {
        let nameFirstPart = null;

        if (this._myColorModel == 0) {
            nameFirstPart = "Light RGB ";
        } else {
            nameFirstPart = "Light HSV ";
        }

        return nameFirstPart;
    }

    _createEasyTuneVariable(variableName) {
        return new PP.EasyTuneIntArray(variableName, this._getDefaultValue(), 100, 0, 255);
    }

    _getObjectValue(object) {
        let color = null;

        let lightColor = this._getLightColor(object);
        if (lightColor) {
            if (this._myColorModel == 0) {
                color = PP.ColorUtils.rgbCodeToHuman(lightColor);
            } else {
                color = PP.ColorUtils.hsvCodeToHuman(PP.ColorUtils.rgbToHsv(lightColor));
            }
        } else {
            color = this._getDefaultValue();
        }

        return color;
    }

    _getDefaultValue() {
        return vec3_create();
    }

    _updateObjectValue(object, value) {
        let color = value;

        if (this._myColorModel == 0) {
            color = PP.ColorUtils.rgbHumanToCode(color);
        } else {
            color = PP.ColorUtils.hsvToRgb(PP.ColorUtils.hsvHumanToCode(color));
        }

        let light = object.pp_getComponent("light");
        if (light) {
            light.color[0] = color[0];
            light.color[1] = color[1];
            light.color[2] = color[2];
            light.color[3] = light.color[3];
        }

        if ((PP.myRightGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).isPressStart() && PP.myLeftGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).myIsPressed) ||
            (PP.myLeftGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).isPressStart() && PP.myRightGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).myIsPressed)) {

            let hsvColor = PP.ColorUtils.color1To255(PP.ColorUtils.rgbToHsv(color));
            let rgbColor = PP.ColorUtils.color1To255(color);

            console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
        }
    }

    _getLightColor(object) {
        let color = null;
        let light = object.pp_getComponent("light");
        if (light) {
            color = light.color.slice(0, 3);
        }

        return color;
    }
};
WL.registerComponent("pp-easy-mesh-color", {
    _myVariableName: { type: WL.Type.String, default: "" },
    _myUseTuneTarget: { type: WL.Type.Bool, default: false },
    _mySetAsDefault: { type: WL.Type.Bool, default: false },
    _myColorModel: { type: WL.Type.Enum, values: ['rgb', 'hsv'], default: 'hsv' },
    _myColorType: { type: WL.Type.Enum, values: ['color', 'diffuse color', 'ambient color', 'specular color', 'emissive color', 'fog color', 'ambient factor'], default: 'color' },

}, {
    init: function () {
        this._myEasyObjectTuner = new PP.EasyMeshColor(this._myColorModel, this._myColorType, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    },
    start: function () {
        this._myEasyObjectTuner.start();
    },
    update: function (dt) {
        this._myEasyObjectTuner.update(dt);
    }
});

PP.EasyMeshColor = class EasyMeshColor extends PP.EasyObjectTuner {
    constructor(colorModel, colorType, object, variableName, setAsDefault, useTuneTarget) {
        super(object, variableName, setAsDefault, useTuneTarget);
        this._myColorModel = colorModel;
        this._myColorType = colorType;
        this._myColorVariableNames = ['color', 'diffuseColor', 'ambientColor', 'specularColor', 'emissiveColor', 'fogColor', 'ambientFactor',];
    }

    _getVariableNamePrefix() {
        let nameFirstPart = null;

        if (this._myColorModel == 0) {
            nameFirstPart = "Mesh RGB ";
        } else {
            nameFirstPart = "Mesh HSV ";
        }

        return nameFirstPart;
    }

    _createEasyTuneVariable(variableName) {
        if (this._myColorType == 6) {
            return new PP.EasyTuneNumberArray(variableName, this._getDefaultValue(), 0.1, 3, 0, 1);
        }
        return new PP.EasyTuneIntArray(variableName, this._getDefaultValue(), 100, 0, 255);
    }

    _getObjectValue(object) {
        let color = null;

        let meshMaterial = this._getMeshMaterial(object);
        if (meshMaterial) {
            if (this._myColorType != 6) {
                color = meshMaterial[this._myColorVariableNames[this._myColorType]].pp_clone();

                if (this._myColorModel == 0) {
                    color = PP.ColorUtils.rgbCodeToHuman(color);
                } else {
                    color = PP.ColorUtils.hsvCodeToHuman(PP.ColorUtils.rgbToHsv(color));
                }
            } else {
                color = [meshMaterial[this._myColorVariableNames[this._myColorType]]];
            }
        } else {
            color = this._getDefaultValue();
        }

        return color;
    }

    _getDefaultValue() {
        if (this._myColorType == 6) {
            return [0];
        }

        return vec4_create();
    }

    _updateObjectValue(object, value) {
        let color = value;

        if (this._myColorType != 6) {
            if (this._myColorModel == 0) {
                color = PP.ColorUtils.rgbHumanToCode(color);
            } else {
                color = PP.ColorUtils.hsvToRgb(PP.ColorUtils.hsvHumanToCode(color));
            }
        }

        let meshMaterial = this._getMeshMaterial(object);
        if (meshMaterial) {
            meshMaterial[this._myColorVariableNames[this._myColorType]] = color;
        }

        if (this._myColorType != 6) {
            if ((PP.myRightGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).isPressStart() && PP.myLeftGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).myIsPressed) ||
                (PP.myLeftGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).isPressStart() && PP.myRightGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).myIsPressed)) {

                let hsvColor = PP.ColorUtils.color1To255(PP.ColorUtils.rgbToHsv(color));
                let rgbColor = PP.ColorUtils.color1To255(color);

                console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
            }
        }
    }

    _getMeshMaterial(object) {
        let material = null;
        let mesh = object.pp_getComponentHierarchy("mesh");
        if (mesh) {
            material = mesh.material;
        }

        return material;
    }
};
WL.registerComponent("pp-easy-scale", {
    _myVariableName: { type: WL.Type.String, default: "" },
    _mySetAsDefault: { type: WL.Type.Bool, default: false },
    _myUseTuneTarget: { type: WL.Type.Bool, default: false },
    _myIsLocal: { type: WL.Type.Bool, default: false },
    _myScaleAsOne: { type: WL.Type.Bool, default: true }, // Edit all scale values together
}, {
    init: function () {
        this._myEasyObjectTuner = new PP.EasyScale(this._myIsLocal, this._myScaleAsOne, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    },
    start: function () {
        this._myEasyObjectTuner.start();
    },
    update: function (dt) {
        this._myEasyObjectTuner.update(dt);
    }
});

PP.EasyScale = class EasyScale extends PP.EasyObjectTuner {
    constructor(isLocal, scaleAsOne, object, variableName, setAsDefault, useTuneTarget) {
        super(object, variableName, setAsDefault, useTuneTarget);
        this._myIsLocal = isLocal;
        this._myScaleAsOne = scaleAsOne;
    }

    _getVariableNamePrefix() {
        return "Scale ";
    }

    _createEasyTuneVariable(variableName) {
        return new PP.EasyTuneNumberArray(variableName, this._getDefaultValue(), 1, 3, 0.001, null, this._myScaleAsOne);
    }

    _getObjectValue(object) {
        return this._myIsLocal ? object.pp_getScaleLocal() : object.pp_getScaleWorld();
    }

    _getDefaultValue() {
        return vec3_create(1, 1, 1);
    }

    _updateObjectValue(object, value) {
        if (this._myIsLocal) {
            object.pp_setScaleLocal(value);
        } else {
            object.pp_setScaleWorld(value);
        }
    }
};
WL.registerComponent("pp-easy-set-tune-target-child-number", {
    _myVariableName: { type: WL.Type.String, default: "" },
    _mySetAsDefault: { type: WL.Type.Bool, default: false },
}, {
    init: function () {
    },
    start: function () {
        this._myEasyTuneVariableName = "Target Child ";

        if (this._myVariableName == "") {
            this._myEasyTuneVariableName = this._myEasyTuneVariableName.concat(this.object.objectId);
        } else {
            this._myEasyTuneVariableName = this._myEasyTuneVariableName.concat(this._myVariableName);
        }

        let childrenCount = this.object.pp_getChildren().length;
        let min = 1;
        let max = childrenCount;
        if (childrenCount == 0) {
            min = 0;
            max = 0;
        }

        PP.myEasyTuneVariables.add(new PP.EasyTuneInt(this._myEasyTuneVariableName, 0, 10, min, max));
        if (this._mySetAsDefault) {
            PP.setEasyTuneWidgetActiveVariable(this._myEasyTuneVariableName);
        }

        this._myCurrentChildIndex = -1;
        this._myCurrentChildrenCount = childrenCount;
    },
    update: function () {
        if (PP.myEasyTuneVariables.isActive(this._myEasyTuneVariableName)) {
            let childrenCount = this.object.pp_getChildren().length;
            if (childrenCount != this._myCurrentChildrenCount) {
                this._myCurrentChildrenCount = childrenCount;

                let min = 1;
                let max = childrenCount;
                if (childrenCount == 0) {
                    min = 0;
                    max = 0;
                }

                let easyTuneVariable = PP.myEasyTuneVariables.getEasyTuneVariable(this._myEasyTuneVariableName);
                easyTuneVariable.setMin(min);
                easyTuneVariable.setMax(max);
            }

            let childIndex = PP.myEasyTuneVariables.get(this._myEasyTuneVariableName);
            if (childIndex != this._myCurrentChildIndex) {
                this._myCurrentChildIndex = childIndex;
                if (this._myCurrentChildIndex == 0) {
                    PP.myEasyTuneTarget = null;
                } else {
                    PP.myEasyTuneTarget = this.object.pp_getChildren()[this._myCurrentChildIndex - 1];
                }
            }
        }
    }
});
WL.registerComponent("pp-easy-set-tune-target-grab", {
}, {
    init: function () {
    },
    start: function () {
        this._myGrabber = this.object.pp_getComponent("pp-grabber-hand");
    },
    update: function () {
    },
    _onRelease: function (grabber, grabbable) {
        PP.myEasyTuneTarget = grabbable.object;
    },
    _onGrab: function (grabber, grabbable) {
        PP.myEasyTuneTarget = null;
    },
    onActivate() {
        this._myGrabber.registerGrabEventListener(this, this._onGrab.bind(this));
        this._myGrabber.registerThrowEventListener(this, this._onRelease.bind(this));
    },
    onDeactivate() {
        this._myGrabber.unregisterGrabEventListener(this);
        this._myGrabber.unregisterThrowEventListener(this);
    }
});
WL.registerComponent("pp-easy-text-color", {
    _myVariableName: { type: WL.Type.String, default: "" },
    _mySetAsDefault: { type: WL.Type.Bool, default: false },
    _myUseTuneTarget: { type: WL.Type.Bool, default: false },
    _myColorModel: { type: WL.Type.Enum, values: ['rgb', 'hsv'], default: 'hsv' },
    _myColorType: { type: WL.Type.Enum, values: ['color', 'outline color'], default: 'color' }

}, {
    init: function () {
        this._myEasyObjectTuner = new PP.EasyTextColor(this._myColorModel, this._myColorType, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    },
    start: function () {
        this._myEasyObjectTuner.start();
    },
    update: function (dt) {
        this._myEasyObjectTuner.update(dt);
    }
});

PP.EasyTextColor = class EasyTextColor extends PP.EasyObjectTuner {
    constructor(colorModel, colorType, object, variableName, setAsDefault, useTuneTarget) {
        super(object, variableName, setAsDefault, useTuneTarget);
        this._myColorModel = colorModel;
        this._myColorType = colorType;
        this._myColorVariableNames = ['color', 'outlineColor'];
    }

    _getVariableNamePrefix() {
        let nameFirstPart = null;

        if (this._myColorModel == 0) {
            nameFirstPart = "Text RGB ";
        } else {
            nameFirstPart = "Text HSV ";
        }

        return nameFirstPart;
    }

    _createEasyTuneVariable(variableName) {
        return new PP.EasyTuneIntArray(variableName, this._getDefaultValue(), 100, 0, 255);
    }

    _getObjectValue(object) {
        let color = null;

        let textMaterial = this._getTextMaterial(object);
        if (textMaterial) {
            console.error(this._myColorType, this._myColorVariableNames[this._myColorType]);
            console.error(textMaterial[this._myColorVariableNames[this._myColorType]]);
            color = textMaterial[this._myColorVariableNames[this._myColorType]].pp_clone();

            if (this._myColorModel == 0) {
                color = PP.ColorUtils.rgbCodeToHuman(color);
            } else {
                color = PP.ColorUtils.hsvCodeToHuman(PP.ColorUtils.rgbToHsv(color));
            }
        } else {
            color = this._getDefaultValue();
        }

        return color;
    }

    _getDefaultValue() {
        return vec4_create();
    }

    _updateObjectValue(object, value) {
        let color = value;

        if (this._myColorModel == 0) {
            color = PP.ColorUtils.rgbHumanToCode(color);
        } else {
            color = PP.ColorUtils.hsvToRgb(PP.ColorUtils.hsvHumanToCode(color));
        }

        let textMaterial = this._getTextMaterial(object);
        if (textMaterial) {
            textMaterial[this._myColorVariableNames[this._myColorType]] = color;
        }

        if ((PP.myRightGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).isPressStart() && PP.myLeftGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).myIsPressed) ||
            (PP.myLeftGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).isPressStart() && PP.myRightGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).myIsPressed)) {

            let hsvColor = PP.ColorUtils.color1To255(PP.ColorUtils.rgbToHsv(color));
            let rgbColor = PP.ColorUtils.color1To255(color);

            console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
        }
    }

    _getTextMaterial(object) {
        let material = null;
        let text = object.pp_getComponentHierarchy("text");
        if (text) {
            material = text.material;
        }

        return material;
    }
};
WL.registerComponent("pp-easy-transform", {
    _myVariableName: { type: WL.Type.String, default: "" },
    _mySetAsDefault: { type: WL.Type.Bool, default: false },
    _myUseTuneTarget: { type: WL.Type.Bool, default: false },
    _myIsLocal: { type: WL.Type.Bool, default: false },
    _myScaleAsOne: { type: WL.Type.Bool, default: true }, // Edit all scale values together
}, {
    init: function () {
        this._myEasyObjectTuner = new PP.EasyTransform(this._myIsLocal, this._myScaleAsOne, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    },
    start: function () {
        this._myEasyObjectTuner.start();
    },
    update: function (dt) {
        this._myEasyObjectTuner.update(dt);
    }
});

PP.EasyTransform = class EasyTransform extends PP.EasyObjectTuner {
    constructor(isLocal, scaleAsOne, object, variableName, setAsDefault, useTuneTarget) {
        super(object, variableName, setAsDefault, useTuneTarget);
        this._myIsLocal = isLocal;
        this._myScaleAsOne = scaleAsOne;
    }

    _getVariableNamePrefix() {
        return "Transform ";
    }

    _createEasyTuneVariable(variableName) {
        return new PP.EasyTuneSimpleTransform(variableName, this._getDefaultValue(), this._myScaleAsOne);
    }

    _getObjectValue(object) {
        return this._myIsLocal ? object.pp_getTransformLocal() : object.pp_getTransformWorld();
    }

    _getDefaultValue() {
        return mat4_create();
    }

    _updateObjectValue(object, value) {
        if (this._myIsLocal) {
            object.pp_setTransformLocal(value);
        } else {
            object.pp_setTransformWorld(value);
        }
    }
};

PP.EasyTuneBoolArrayWidget = class EasyTuneBoolArrayWidget {

    constructor(arraySize, gamepad) {
        this._myGamepad = gamepad;

        this._mySetup = new PP.EasyTuneBoolArrayWidgetSetup(arraySize);
        this._myUI = new PP.EasyTuneBoolArrayWidgetUI();

        this._myVariable = null;

        this._myIsVisible = true;

        this._myScrollVariableRequestCallbacks = new Map();     // Signature: callback(scrollAmount)

        this._myAppendToVariableName = "";

        this._myValueEditIndex = 0;
        this._myValueButtonEditIntensity = 0;
        this._myValueButtonEditIntensityTimer = 0;
        this._myValueEditActive = false;
    }

    setEasyTuneVariable(variable, appendToVariableName) {
        this._myVariable = variable;

        if ((typeof appendToVariableName) !== 'undefined') {
            this._myAppendToVariableName = appendToVariableName;
        } else {
            this._myAppendToVariableName = "";
        }

        this._refreshUI();
    }

    _refreshUI() {
        if (this._myVariable) {
            this._myUI.myVariableLabelTextComponent.text = this._myVariable.myName.concat(this._myAppendToVariableName);

            for (let i = 0; i < this._mySetup.myArraySize; i++) {
                this._myUI.myValueTextComponents[i].text = (this._myVariable.myValue[i]) ? "true" : "false";
            }
        }
    }

    setVisible(visible) {
        if (visible) {
            this._refreshUI();
        }
        this._myUI.setVisible(visible);

        this._myIsVisible = visible;
    }

    registerScrollVariableRequestEventListener(id, callback) {
        this._myScrollVariableRequestCallbacks.set(id, callback);
    }

    unregisterScrollVariableRequestEventListener(id) {
        this._myScrollVariableRequestCallbacks.delete(id);
    }

    start(parentObject, additionalSetup) {
        this._myUI.build(parentObject, this._mySetup, additionalSetup);
        this._myUI.setAdditionalButtonsActive(additionalSetup.myEnableAdditionalButtons);

        this._addListeners();
    }

    update(dt) {
        if (this._isActive()) {
            this._updateValue(dt);
        }
    }

    _updateValue(dt) {
        let stickVariableIntensity = 0;

        if (this._myGamepad) {
            stickVariableIntensity = this._myGamepad.getAxesInfo().myAxes[1];
        }

        let valueIntensity = 0;
        if (this._myValueEditActive) {
            valueIntensity = stickVariableIntensity;
        } else if (this._myValueButtonEditIntensity != 0) {
            if (this._myValueButtonEditIntensityTimer <= 0) {
                valueIntensity = this._myValueButtonEditIntensity;
            } else {
                this._myValueButtonEditIntensityTimer -= dt;
            }
        }

        if (Math.abs(valueIntensity) > this._mySetup.myThumbstickToggleThreshold) {
            this._myVariable.myValue[this._myValueEditIndex] = valueIntensity > 0;
            this._refreshUI();
        }
    }

    _isActive() {
        return this._myIsVisible && this._myVariable;
    }

    _addListeners() {
        let ui = this._myUI;

        ui.myVariableLabelCursorTargetComponent.addClickFunction(this._resetAllValues.bind(this));
        ui.myVariableLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myVariableLabelText));
        ui.myVariableLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myVariableLabelText, this._mySetup.myVariableLabelTextScale));

        ui.myNextButtonCursorTargetComponent.addClickFunction(this._scrollVariableRequest.bind(this, 1));
        ui.myNextButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myNextButtonBackgroundComponent.material));
        ui.myNextButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myNextButtonBackgroundComponent.material));

        ui.myPreviousButtonCursorTargetComponent.addClickFunction(this._scrollVariableRequest.bind(this, -1));
        ui.myPreviousButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
        ui.myPreviousButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));

        for (let i = 0; i < this._mySetup.myArraySize; i++) {
            for (let i = 0; i < this._mySetup.myArraySize; i++) {
                ui.myValueIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, i, 1));
                ui.myValueIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, i, 0));
                ui.myValueDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, i, -1));
                ui.myValueDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, i, 0));

                ui.myValueIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
                ui.myValueIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
                ui.myValueDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
                ui.myValueDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));

                ui.myValueCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, i));
                ui.myValueCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, i, ui.myValueTexts[i], true));
                ui.myValueCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, i, ui.myValueTexts[i], false));
            }
        }
    }

    _setValueEditIntensity(index, value) {
        if (this._isActive() || value == 0) {
            if (value != 0) {
                this._myValueButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
                this._myValueEditIndex = index;
            }

            this._myValueButtonEditIntensity = value;
        }
    }

    _setValueEditActive(index, text, active) {
        if (this._isActive() || !active) {
            if (active) {
                this._myValueEditIndex = index;
                text.scale(this._mySetup.myTextHoverScaleMultiplier);
            } else {
                text.scalingWorld = this._mySetup.myValueTextScale;
            }

            this._myValueEditActive = active;
        }
    }

    _scrollVariableRequest(amount) {
        if (this._isActive()) {
            for (let callback of this._myScrollVariableRequestCallbacks.values()) {
                callback(amount);
            }
        }
    }

    _resetValue(index) {
        if (this._isActive()) {
            this._myVariable.myValue[index] = this._myVariable.myInitialValue[index];
            this._myUI.myValueTextComponents[index].text = (this._myVariable.myValue[index]) ? "true" : "false";
        }
    }

    _resetAllValues() {
        for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this._resetValue(i);
        }
    }

    _genericHover(material) {
        material.color = this._mySetup.myButtonHoverColor;
    }

    _genericUnHover(material) {
        material.color = this._mySetup.myBackgroundColor;
    }

    _genericTextHover(text) {
        text.scale(this._mySetup.myTextHoverScaleMultiplier);
    }

    _genericTextUnHover(text, originalScale) {
        text.scalingWorld = originalScale;
    }
};
PP.EasyTuneBoolArrayWidgetSetup = class EasyTuneBoolArrayWidgetSetup {

    constructor(arraySize) {
        this.myArraySize = arraySize;
        this._initializeBuildSetup();
        this._initializeRuntimeSetup();
    }

    _initializeBuildSetup() {
        //General
        this.myBackgroundColor = [46 / 255, 46 / 255, 46 / 255, 1];

        this.myCursorTargetCollisionCollider = 2; // box
        this.myCursorTargetCollisionGroup = 7;
        this.myCursorTargetCollisionThickness = 0.001;

        this.myDefaultTextColor = [255 / 255, 255 / 255, 255 / 255, 1];

        this.myTextAlignment = 2; // center
        this.myTextJustification = 2; // middle
        this.myTextOutlineRange = [0.45, 0.45];
        this.myTextColor = this.myDefaultTextColor;
        this.myTextOutlineColor = this.myDefaultTextColor;

        //Pivot
        this.myPivotObjectPositions = [];
        this.myPivotObjectPositions[PP.ToolHandedness.NONE] = [0, 0, 0];
        this.myPivotObjectPositions[PP.ToolHandedness.LEFT] = [-0.04, 0.02, 0.00003013]; //little "random" z offset to avoid glitching with other widgets
        this.myPivotObjectPositions[PP.ToolHandedness.RIGHT] = [-0.08, 0.02, 0.00003013];

        let panelZ = 0.01;
        let distanceFromBorder = 0.0125;
        let distanceFromValue = 0.055;
        let colliderZPosition = 0.017;
        let backgroundHalfWidth = 0.2;

        this.mySideButtonBackgroundScale = [0.015, 0.015, 1];
        this.mySideButtonTextScale = [0.18, 0.18, 0.18];
        this.mySideButtonTextPosition = [0, 0, 0.007];

        this.mySideButtonCursorTargetPosition = [0, 0, 0];
        this.mySideButtonCursorTargetPosition[2] = colliderZPosition - panelZ;
        this.mySideButtonCollisionExtents = this.mySideButtonBackgroundScale.slice(0);
        this.mySideButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myLeftSideButtonPosition = [0, 0, -0.00001];
        this.myLeftSideButtonPosition[0] = -backgroundHalfWidth + this.mySideButtonBackgroundScale[0] + distanceFromBorder;

        this.myRightSideButtonPosition = [0, 0, -0.00001];
        this.myRightSideButtonPosition[0] = backgroundHalfWidth - this.mySideButtonBackgroundScale[0] - distanceFromBorder;

        this.myIncreaseButtonText = "+";
        this.myDecreaseButtonText = "-";

        //Display
        this.myDisplayPanelPosition = [0, 0.1, 0];

        this.myVariableLabelPanelPosition = [0, 0.025, panelZ];
        this.myVariableLabelTextScale = [0.19, 0.19, 0.19];

        this.myVariableLabelCursorTargetPosition = [0, 0, 0];
        this.myVariableLabelCursorTargetPosition[2] = colliderZPosition - panelZ;
        this.myVariableLabelCollisionExtents = [0.065, 0.0175, 1];
        this.myVariableLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myNextButtonText = ">";
        this.myPreviousButtonText = "<";

        this.myValuesPanelPosition = [0, this.myVariableLabelPanelPosition[1] - distanceFromValue, panelZ];

        this.myValueTextScale = [0.4, 0.4, 0.4];

        this.myValueCursorTargetPosition = [0, 0, 0];
        this.myValueCursorTargetPosition[2] = colliderZPosition - panelZ;
        this.myValueCollisionExtents = [0.065, 0.02, 1];
        this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;

        this.myValuePanelsPositions = [];
        this.myValuePanelsPositions[0] = [0, 0, 0];
        for (let i = 1; i < this.myArraySize; i++) {
            this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].slice(0);
            this.myValuePanelsPositions[i][1] -= this.myDistanceBetweenValues;
        }

        //Background
        {
            let valuePanelLastPosition = (this.myValuePanelsPositions[this.myArraySize - 1]) ? this.myValuePanelsPositions[this.myArraySize - 1][1] : 0;
            let maxY = this.myDisplayPanelPosition[1] + this.myVariableLabelPanelPosition[1] + this.mySideButtonBackgroundScale[1] + distanceFromBorder * 1.25;
            let minY = this.myDisplayPanelPosition[1] + this.myValuesPanelPosition[1] + valuePanelLastPosition - distanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
            this.myBackPanelPosition = [0, (maxY + minY) / 2, 0];
            this.myBackBackgroundScale = [backgroundHalfWidth, (maxY - minY) / 2, 1];
            this.myBackBackgroundColor = [70 / 255, 70 / 255, 70 / 255, 1];
        }

        //Pointer
        this.myPointerCollisionExtents = this.myBackBackgroundScale.slice(0);
        this.myPointerCollisionExtents[2] = this.myCursorTargetCollisionThickness;
        this.myPointerCursorTargetPosition = this.myBackPanelPosition.slice(0);
        this.myPointerCursorTargetPosition[2] = colliderZPosition - 0.0001; // a little behind the button target to avoid hiding it
    }

    _initializeRuntimeSetup() {
        this.myButtonHoverColor = [150 / 255, 150 / 255, 150 / 255, 1];
        this.myTextHoverScaleMultiplier = [1.25, 1.25, 1.25];

        this.myThumbstickToggleThreshold = 0.6;
        this.myButtonEditDelay = 0;
    }
};

PP.EasyTuneBoolArrayWidgetUI = class EasyTuneBoolArrayWidgetUI {

    build(parentObject, setup, additionalSetup) {
        this._myParentObject = parentObject;
        this._mySetup = setup;
        this._myAdditionalSetup = additionalSetup;

        this._myAdditionalButtonsActive = true;

        this._myPlaneMesh = PP.MeshUtils.createPlaneMesh();

        this._createSkeleton();
        this._setTransforms();
        this._addComponents();
    }

    setVisible(visible) {
        this.myPivotObject.pp_setActiveHierarchy(visible);
        if (visible) {
            this.setAdditionalButtonsActive(this._myAdditionalButtonsActive);
        }
    }

    setAdditionalButtonsActive(active) {
        this._myAdditionalButtonsActive = active;

        for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValueIncreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
            this.myValueDecreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
        }
    }

    //Skeleton
    _createSkeleton() {
        this.myPivotObject = WL.scene.addObject(this._myParentObject);

        this.myBackPanel = WL.scene.addObject(this.myPivotObject);
        this.myBackBackground = WL.scene.addObject(this.myBackPanel);

        this._createDisplaySkeleton();
        this._createPointerSkeleton();
    }

    _createDisplaySkeleton() {
        this.myDisplayPanel = WL.scene.addObject(this.myPivotObject);

        this.myVariableLabelPanel = WL.scene.addObject(this.myDisplayPanel);
        this.myVariableLabelText = WL.scene.addObject(this.myVariableLabelPanel);
        this.myVariableLabelCursorTarget = WL.scene.addObject(this.myVariableLabelPanel);

        //Next/Previous
        this.myNextButtonPanel = WL.scene.addObject(this.myVariableLabelPanel);
        this.myNextButtonBackground = WL.scene.addObject(this.myNextButtonPanel);
        this.myNextButtonText = WL.scene.addObject(this.myNextButtonPanel);
        this.myNextButtonCursorTarget = WL.scene.addObject(this.myNextButtonPanel);

        this.myPreviousButtonPanel = WL.scene.addObject(this.myVariableLabelPanel);
        this.myPreviousButtonBackground = WL.scene.addObject(this.myPreviousButtonPanel);
        this.myPreviousButtonText = WL.scene.addObject(this.myPreviousButtonPanel);
        this.myPreviousButtonCursorTarget = WL.scene.addObject(this.myPreviousButtonPanel);

        this.myValuesPanel = WL.scene.addObject(this.myDisplayPanel);

        this.myValuePanels = [];
        this.myValueTexts = [];
        this.myValueCursorTargets = [];

        this.myValueIncreaseButtonPanels = [];
        this.myValueIncreaseButtonBackgrounds = [];
        this.myValueIncreaseButtonTexts = [];
        this.myValueIncreaseButtonCursorTargets = [];

        this.myValueDecreaseButtonPanels = [];
        this.myValueDecreaseButtonBackgrounds = [];
        this.myValueDecreaseButtonTexts = [];
        this.myValueDecreaseButtonCursorTargets = [];

        for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValuePanels[i] = WL.scene.addObject(this.myValuesPanel);
            this.myValueTexts[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueCursorTargets[i] = WL.scene.addObject(this.myValuePanels[i]);

            //Increase/Decrease
            this.myValueIncreaseButtonPanels[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueIncreaseButtonBackgrounds[i] = WL.scene.addObject(this.myValueIncreaseButtonPanels[i]);
            this.myValueIncreaseButtonTexts[i] = WL.scene.addObject(this.myValueIncreaseButtonPanels[i]);
            this.myValueIncreaseButtonCursorTargets[i] = WL.scene.addObject(this.myValueIncreaseButtonPanels[i]);

            this.myValueDecreaseButtonPanels[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueDecreaseButtonBackgrounds[i] = WL.scene.addObject(this.myValueDecreaseButtonPanels[i]);
            this.myValueDecreaseButtonTexts[i] = WL.scene.addObject(this.myValueDecreaseButtonPanels[i]);
            this.myValueDecreaseButtonCursorTargets[i] = WL.scene.addObject(this.myValueDecreaseButtonPanels[i]);
        }
    }

    _createPointerSkeleton() {
        this.myPointerCursorTarget = WL.scene.addObject(this.myPivotObject);
    }

    //Transforms
    _setTransforms() {
        this.myPivotObject.setTranslationLocal(this._mySetup.myPivotObjectPositions[this._myAdditionalSetup.myHandedness]);

        this.myBackPanel.setTranslationLocal(this._mySetup.myBackPanelPosition);
        this.myBackBackground.scale(this._mySetup.myBackBackgroundScale);

        this._setDisplayTransforms();
        this._setPointerTransform();
    }

    _setDisplayTransforms() {
        this.myDisplayPanel.setTranslationLocal(this._mySetup.myDisplayPanelPosition);

        this.myVariableLabelPanel.setTranslationLocal(this._mySetup.myVariableLabelPanelPosition);
        this.myVariableLabelText.scale(this._mySetup.myVariableLabelTextScale);
        this.myVariableLabelCursorTarget.setTranslationLocal(this._mySetup.myVariableLabelCursorTargetPosition);

        //Next/Previous
        this.myNextButtonPanel.setTranslationLocal(this._mySetup.myRightSideButtonPosition);
        this.myNextButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myNextButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myNextButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myNextButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        this.myPreviousButtonPanel.setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
        this.myPreviousButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myPreviousButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myPreviousButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myPreviousButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        this.myValuesPanel.setTranslationLocal(this._mySetup.myValuesPanelPosition);

        for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValuePanels[i].setTranslationLocal(this._mySetup.myValuePanelsPositions[i]);
            this.myValueTexts[i].scale(this._mySetup.myValueTextScale);
            this.myValueCursorTargets[i].setTranslationLocal(this._mySetup.myValueCursorTargetPosition);

            this.myValueIncreaseButtonPanels[i].setTranslationLocal(this._mySetup.myRightSideButtonPosition);
            this.myValueIncreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myValueIncreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myValueIncreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myValueIncreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

            this.myValueDecreaseButtonPanels[i].setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
            this.myValueDecreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myValueDecreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myValueDecreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myValueDecreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
        }
    }

    _setPointerTransform() {
        this.myPointerCursorTarget.setTranslationLocal(this._mySetup.myPointerCursorTargetPosition);
    }

    //Components
    _addComponents() {
        this.myBackBackgroundComponent = this.myBackBackground.addComponent('mesh');
        this.myBackBackgroundComponent.mesh = this._myPlaneMesh;
        this.myBackBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myBackBackgroundComponent.material.color = this._mySetup.myBackBackgroundColor;

        this._addDisplayComponents();
        this._addPointerComponents();
    }

    _addDisplayComponents() {
        this.myVariableLabelTextComponent = this.myVariableLabelText.addComponent('text');
        this._setupTextComponent(this.myVariableLabelTextComponent);
        this.myVariableLabelTextComponent.text = " ";

        this.myVariableLabelCursorTargetComponent = this.myVariableLabelCursorTarget.addComponent('cursor-target');
        this.myVariableLabelCollisionComponent = this.myVariableLabelCursorTarget.addComponent('collision');
        this.myVariableLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myVariableLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myVariableLabelCollisionComponent.extents = this._mySetup.myVariableLabelCollisionExtents;

        //Next/Previous
        this.myNextButtonBackgroundComponent = this.myNextButtonBackground.addComponent('mesh');
        this.myNextButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myNextButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myNextButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myNextButtonTextComponent = this.myNextButtonText.addComponent('text');
        this._setupTextComponent(this.myNextButtonTextComponent);
        this.myNextButtonTextComponent.text = this._mySetup.myNextButtonText;

        this.myNextButtonCursorTargetComponent = this.myNextButtonCursorTarget.addComponent('cursor-target');
        this.myNextButtonCollisionComponent = this.myNextButtonCursorTarget.addComponent('collision');
        this.myNextButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myNextButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myNextButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        this.myPreviousButtonBackgroundComponent = this.myPreviousButtonBackground.addComponent('mesh');
        this.myPreviousButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myPreviousButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myPreviousButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myPreviousButtonTextComponent = this.myPreviousButtonText.addComponent('text');
        this._setupTextComponent(this.myPreviousButtonTextComponent);
        this.myPreviousButtonTextComponent.text = this._mySetup.myPreviousButtonText;

        this.myPreviousButtonCursorTargetComponent = this.myPreviousButtonCursorTarget.addComponent('cursor-target');
        this.myPreviousButtonCollisionComponent = this.myPreviousButtonCursorTarget.addComponent('collision');
        this.myPreviousButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPreviousButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPreviousButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        this.myValueTextComponents = [];
        this.myValueCursorTargetComponents = [];
        this.myValueCollisionComponents = [];

        this.myValueIncreaseButtonBackgroundComponents = [];
        this.myValueIncreaseButtonTextComponents = [];
        this.myValueIncreaseButtonCursorTargetComponents = [];
        this.myValueIncreaseButtonCollisionComponents = [];

        this.myValueDecreaseButtonBackgroundComponents = [];
        this.myValueDecreaseButtonTextComponents = [];
        this.myValueDecreaseButtonCursorTargetComponents = [];
        this.myValueDecreaseButtonCollisionComponents = [];


        for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValueTextComponents[i] = this.myValueTexts[i].addComponent('text');
            this._setupTextComponent(this.myValueTextComponents[i]);
            this.myValueTextComponents[i].text = " ";

            this.myValueCursorTargetComponents[i] = this.myValueCursorTargets[i].addComponent('cursor-target');
            this.myValueCollisionComponents[i] = this.myValueCursorTargets[i].addComponent('collision');
            this.myValueCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myValueCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myValueCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;

            //Increase/Decrease
            this.myValueIncreaseButtonBackgroundComponents[i] = this.myValueIncreaseButtonBackgrounds[i].addComponent('mesh');
            this.myValueIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myValueIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myValueIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;

            this.myValueIncreaseButtonTextComponents[i] = this.myValueIncreaseButtonTexts[i].addComponent('text');
            this._setupTextComponent(this.myValueIncreaseButtonTextComponents[i]);
            this.myValueIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;

            this.myValueIncreaseButtonCursorTargetComponents[i] = this.myValueIncreaseButtonCursorTargets[i].addComponent('cursor-target');
            this.myValueIncreaseButtonCollisionComponents[i] = this.myValueIncreaseButtonCursorTargets[i].addComponent('collision');
            this.myValueIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myValueIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myValueIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;

            this.myValueDecreaseButtonBackgroundComponents[i] = this.myValueDecreaseButtonBackgrounds[i].addComponent('mesh');
            this.myValueDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myValueDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myValueDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;

            this.myValueDecreaseButtonTextComponents[i] = this.myValueDecreaseButtonTexts[i].addComponent('text');
            this._setupTextComponent(this.myValueDecreaseButtonTextComponents[i]);
            this.myValueDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;

            this.myValueDecreaseButtonCursorTargetComponents[i] = this.myValueDecreaseButtonCursorTargets[i].addComponent('cursor-target');
            this.myValueDecreaseButtonCollisionComponents[i] = this.myValueDecreaseButtonCursorTargets[i].addComponent('collision');
            this.myValueDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myValueDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myValueDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
        }
    }

    _addPointerComponents() {
        this.myPointerCollisionComponent = this.myPointerCursorTarget.addComponent('collision');
        this.myPointerCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPointerCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPointerCollisionComponent.extents = this._mySetup.myPointerCollisionExtents;
    }

    _setupTextComponent(textComponent) {
        textComponent.alignment = this._mySetup.myTextAlignment;
        textComponent.justification = this._mySetup.myTextJustification;
        textComponent.material = this._myAdditionalSetup.myTextMaterial.clone();
        textComponent.material.outlineRange = this._mySetup.myTextOutlineRange;
        textComponent.material.color = this._mySetup.myTextColor;
        textComponent.material.outlineColor = this._mySetup.myTextOutlineColor;
        textComponent.text = "";
    }
};

PP.EasyTuneBoolWidget = class EasyTuneBoolWidget {

    constructor(gamepad) {
        this._myGamepad = gamepad;

        this._myParentObject = null;
        this._myAdditionalSetup = null;

        this._myWidgets = new Map();

        this._myVariable = null;
        this._myIsVisible = true;

        this._myAppendToVariableName = null;

        this._myScrollVariableRequestCallbacks = new Map();     // Signature: callback(scrollAmount)

        this._myCurrentArraySize = 0;
    }

    setEasyTuneVariable(variable, appendToVariableName) {
        this._myVariable = variable;
        this._myCurrentArraySize = this._myVariable.myValue.length;
        this._myAppendToVariableName = appendToVariableName;

        if (!this._myWidgets.has(this._myCurrentArraySize)) {
            this._createWidget(this._myCurrentArraySize);
        }

        this._myWidgets.get(this._myCurrentArraySize).setEasyTuneVariable(variable, appendToVariableName);

        this.setVisible(this._myIsVisible);
    }

    setVisible(visible) {
        if (this._myVariable) {
            this._sizeChangedCheck();

            for (let widget of this._myWidgets.values()) {
                widget.setVisible(false);
            }

            this._myWidgets.get(this._myCurrentArraySize).setVisible(visible);
        }

        this._myIsVisible = visible;
    }

    registerScrollVariableRequestEventListener(id, callback) {
        this._myScrollVariableRequestCallbacks.set(id, callback);
    }

    unregisterScrollVariableRequestEventListener(id) {
        this._myScrollVariableRequestCallbacks.delete(id);
    }

    start(parentObject, additionalSetup) {
        this._myParentObject = parentObject;
        this._myAdditionalSetup = additionalSetup;

        this._createWidget(1);

        if (this._myVariable) {
            this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
        }
    }

    update(dt) {
        if (this._isActive()) {
            this._sizeChangedCheck();

            this._myWidgets.get(this._myCurrentArraySize).update(dt);
        }
    }

    _isActive() {
        return this._myIsVisible && this._myVariable;
    }

    _scrollVariable(amount) {
        for (let callback of this._myScrollVariableRequestCallbacks.values()) {
            callback(amount);
        }
    }

    _createWidget(arraySize) {
        this._myWidgets.set(arraySize, new PP.EasyTuneBoolArrayWidget(arraySize, this._myGamepad));
        this._myWidgets.get(arraySize).start(this._myParentObject, this._myAdditionalSetup);
        this._myWidgets.get(arraySize).setVisible(false);
        this._myWidgets.get(arraySize).registerScrollVariableRequestEventListener(this, this._scrollVariable.bind(this));
    }

    _sizeChangedCheck() {
        if (this._myVariable.myValue.length != this._myCurrentArraySize) {
            this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
        }
    }
};

PP.EasyTuneNoneWidget = class EasyTuneNoneWidget {

    constructor() {
        this._mySetup = new PP.EasyTuneNoneWidgetSetup();
        this._myUI = new PP.EasyTuneNoneWidgetUI();

        this._myVariable = null;

        this._myIsVisible = true;

        this._myScrollVariableRequestCallbacks = new Map();     // Signature: callback(scrollAmount)

        this._myAppendToVariableName = "";
    }

    setEasyTuneVariable(variable, appendToVariableName) {
        this._myVariable = variable;

        if ((typeof appendToVariableName) !== 'undefined') {
            this._myAppendToVariableName = appendToVariableName;
        } else {
            this._myAppendToVariableName = "";
        }

        this._refreshUI();
    }

    _refreshUI() {
        if (this._myVariable) {
            this._myUI.myVariableLabelTextComponent.text = this._myVariable.myName.concat(this._myAppendToVariableName);
        }
    }

    setVisible(visible) {
        if (visible) {
            this._refreshUI();
        }
        this._myUI.setVisible(visible);

        this._myIsVisible = visible;
    }

    registerScrollVariableRequestEventListener(id, callback) {
        this._myScrollVariableRequestCallbacks.set(id, callback);
    }

    unregisterScrollVariableRequestEventListener(id) {
        this._myScrollVariableRequestCallbacks.delete(id);
    }

    start(parentObject, additionalSetup) {
        this._myUI.build(parentObject, this._mySetup, additionalSetup);

        this._addListeners();
    }

    update(dt) {
    }

    _isActive() {
        return this._myIsVisible && this._myVariable;
    }

    _addListeners() {
        let ui = this._myUI;

        ui.myNextButtonCursorTargetComponent.addClickFunction(this._scrollVariableRequest.bind(this, 1));
        ui.myNextButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myNextButtonBackgroundComponent.material));
        ui.myNextButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myNextButtonBackgroundComponent.material));

        ui.myPreviousButtonCursorTargetComponent.addClickFunction(this._scrollVariableRequest.bind(this, -1));
        ui.myPreviousButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
        ui.myPreviousButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
    }

    _scrollVariableRequest(amount) {
        if (this._isActive()) {
            for (let callback of this._myScrollVariableRequestCallbacks.values()) {
                callback(amount);
            }
        }
    }

    _genericHover(material) {
        material.color = this._mySetup.myButtonHoverColor;
    }

    _genericUnHover(material) {
        material.color = this._mySetup.myBackgroundColor;
    }
};
PP.EasyTuneNoneWidgetSetup = class EasyTuneNoneWidgetSetup {

    constructor() {
        this._initializeBuildSetup();
        this._initializeRuntimeSetup();
    }

    _initializeBuildSetup() {
        //General
        this.myBackgroundColor = [46 / 255, 46 / 255, 46 / 255, 1];

        this.myCursorTargetCollisionCollider = 2; // box
        this.myCursorTargetCollisionGroup = 7;
        this.myCursorTargetCollisionThickness = 0.001;

        this.myDefaultTextColor = [255 / 255, 255 / 255, 255 / 255, 1];

        this.myTextAlignment = 2; // center
        this.myTextJustification = 2; // middle
        this.myTextOutlineRange = [0.45, 0.45];
        this.myTextColor = this.myDefaultTextColor;
        this.myTextOutlineColor = this.myDefaultTextColor;

        //Pivot
        this.myPivotObjectPositions = [];
        this.myPivotObjectPositions[PP.ToolHandedness.NONE] = [0, 0, 0];
        this.myPivotObjectPositions[PP.ToolHandedness.LEFT] = [-0.04, 0.02, 0.00004213]; //little "random" z offset to avoid glitching with other widgets
        this.myPivotObjectPositions[PP.ToolHandedness.RIGHT] = [-0.08, 0.02, 0.00004213];

        let panelZ = 0.01;
        let distanceFromBorder = 0.0125;
        let colliderZPosition = 0.017;
        let backgroundHalfWidth = 0.2;

        this.mySideButtonBackgroundScale = [0.015, 0.015, 1];
        this.mySideButtonTextScale = [0.18, 0.18, 0.18];
        this.mySideButtonTextPosition = [0, 0, 0.007];

        this.mySideButtonCursorTargetPosition = [0, 0, 0];
        this.mySideButtonCursorTargetPosition[2] = colliderZPosition - panelZ;
        this.mySideButtonCollisionExtents = this.mySideButtonBackgroundScale.slice(0);
        this.mySideButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myLeftSideButtonPosition = [0, 0, -0.00001];
        this.myLeftSideButtonPosition[0] = -backgroundHalfWidth + this.mySideButtonBackgroundScale[0] + distanceFromBorder;

        this.myRightSideButtonPosition = [0, 0, -0.00001];
        this.myRightSideButtonPosition[0] = backgroundHalfWidth - this.mySideButtonBackgroundScale[0] - distanceFromBorder;

        //Display
        this.myDisplayPanelPosition = [0, 0.1, 0];

        this.myVariableLabelPanelPosition = [0, 0.025, panelZ];
        this.myVariableLabelTextScale = [0.19, 0.19, 0.19];

        this.myTypeNotSupportedPanelPosition = [0, -0.03, panelZ];
        this.myTypeNotSupportedTextScale = [0.275, 0.275, 0.275];
        this.myTypeNotSupportedText = "Type Not Supported";

        this.myValueCursorTargetPosition = [0, 0, 0];
        this.myValueCursorTargetPosition[2] = colliderZPosition - panelZ;
        this.myValueCollisionExtents = [0.065, 0.02, 1];
        this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myNextButtonText = ">";
        this.myPreviousButtonText = "<";

        //Background
        {
            let maxY = this.myDisplayPanelPosition[1] + this.myVariableLabelPanelPosition[1] + this.mySideButtonBackgroundScale[1] + distanceFromBorder * 1.25;
            let minY = this.myDisplayPanelPosition[1] + this.myTypeNotSupportedPanelPosition[1] - distanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
            this.myBackPanelPosition = [0, (maxY + minY) / 2, 0];
            this.myBackBackgroundScale = [backgroundHalfWidth, (maxY - minY) / 2, 1];
            this.myBackBackgroundColor = [70 / 255, 70 / 255, 70 / 255, 1];
        }

        //Pointer
        this.myPointerCollisionExtents = this.myBackBackgroundScale.slice(0);
        this.myPointerCollisionExtents[2] = this.myCursorTargetCollisionThickness;
        this.myPointerCursorTargetPosition = this.myBackPanelPosition.slice(0);
        this.myPointerCursorTargetPosition[2] = colliderZPosition - 0.0001; // a little behind the button target to avoid hiding it
    }

    _initializeRuntimeSetup() {
        this.myButtonHoverColor = [150 / 255, 150 / 255, 150 / 255, 1];
    }
};

PP.EasyTuneNoneWidgetUI = class EasyTuneNoneWidgetUI {

    build(parentObject, setup, additionalSetup) {
        this._myParentObject = parentObject;
        this._mySetup = setup;
        this._myAdditionalSetup = additionalSetup;
        this._myPlaneMesh = PP.MeshUtils.createPlaneMesh();

        this._createSkeleton();
        this._setTransforms();
        this._addComponents();
    }

    setVisible(visible) {
        this.myPivotObject.pp_setActiveHierarchy(visible);
    }

    //Skeleton
    _createSkeleton() {
        this.myPivotObject = WL.scene.addObject(this._myParentObject);

        this.myBackPanel = WL.scene.addObject(this.myPivotObject);
        this.myBackBackground = WL.scene.addObject(this.myBackPanel);

        this._createDisplaySkeleton();
        this._createPointerSkeleton();
    }

    _createDisplaySkeleton() {
        this.myDisplayPanel = WL.scene.addObject(this.myPivotObject);

        this.myVariableLabelPanel = WL.scene.addObject(this.myDisplayPanel);
        this.myVariableLabelText = WL.scene.addObject(this.myVariableLabelPanel);

        this.myTypeNotSupportedPanel = WL.scene.addObject(this.myDisplayPanel);
        this.myTypeNotSupportedText = WL.scene.addObject(this.myTypeNotSupportedPanel);
        this.myTypeNotSupportedCursorTarget = WL.scene.addObject(this.myTypeNotSupportedPanel);

        //Next/Previous
        this.myNextButtonPanel = WL.scene.addObject(this.myVariableLabelPanel);
        this.myNextButtonBackground = WL.scene.addObject(this.myNextButtonPanel);
        this.myNextButtonText = WL.scene.addObject(this.myNextButtonPanel);
        this.myNextButtonCursorTarget = WL.scene.addObject(this.myNextButtonPanel);

        this.myPreviousButtonPanel = WL.scene.addObject(this.myVariableLabelPanel);
        this.myPreviousButtonBackground = WL.scene.addObject(this.myPreviousButtonPanel);
        this.myPreviousButtonText = WL.scene.addObject(this.myPreviousButtonPanel);
        this.myPreviousButtonCursorTarget = WL.scene.addObject(this.myPreviousButtonPanel);
    }

    _createPointerSkeleton() {
        this.myPointerCursorTarget = WL.scene.addObject(this.myPivotObject);
    }

    //Transforms
    _setTransforms() {
        this.myPivotObject.setTranslationLocal(this._mySetup.myPivotObjectPositions[this._myAdditionalSetup.myHandedness]);

        this.myBackPanel.setTranslationLocal(this._mySetup.myBackPanelPosition);
        this.myBackBackground.scale(this._mySetup.myBackBackgroundScale);

        this._setDisplayTransforms();
        this._setPointerTransform();
    }

    _setDisplayTransforms() {
        this.myDisplayPanel.setTranslationLocal(this._mySetup.myDisplayPanelPosition);

        this.myVariableLabelPanel.setTranslationLocal(this._mySetup.myVariableLabelPanelPosition);
        this.myVariableLabelText.scale(this._mySetup.myVariableLabelTextScale);

        this.myTypeNotSupportedPanel.setTranslationLocal(this._mySetup.myTypeNotSupportedPanelPosition);
        this.myTypeNotSupportedText.scale(this._mySetup.myTypeNotSupportedTextScale);

        //Next/Previous
        this.myNextButtonPanel.setTranslationLocal(this._mySetup.myRightSideButtonPosition);
        this.myNextButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myNextButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myNextButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myNextButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        this.myPreviousButtonPanel.setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
        this.myPreviousButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myPreviousButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myPreviousButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myPreviousButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
    }

    _setPointerTransform() {
        this.myPointerCursorTarget.setTranslationLocal(this._mySetup.myPointerCursorTargetPosition);
    }

    //Components
    _addComponents() {
        this.myBackBackgroundComponent = this.myBackBackground.addComponent('mesh');
        this.myBackBackgroundComponent.mesh = this._myPlaneMesh;
        this.myBackBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myBackBackgroundComponent.material.color = this._mySetup.myBackBackgroundColor;

        this._addDisplayComponents();
        this._addPointerComponents();
    }

    _addDisplayComponents() {
        this.myVariableLabelTextComponent = this.myVariableLabelText.addComponent('text');
        this._setupTextComponent(this.myVariableLabelTextComponent);
        this.myVariableLabelTextComponent.text = " ";

        this.myTypeNotSupportedTextComponent = this.myTypeNotSupportedText.addComponent('text');
        this._setupTextComponent(this.myTypeNotSupportedTextComponent);
        this.myTypeNotSupportedTextComponent.text = this._mySetup.myTypeNotSupportedText;

        //Next/Previous
        this.myNextButtonBackgroundComponent = this.myNextButtonBackground.addComponent('mesh');
        this.myNextButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myNextButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myNextButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myNextButtonTextComponent = this.myNextButtonText.addComponent('text');
        this._setupTextComponent(this.myNextButtonTextComponent);
        this.myNextButtonTextComponent.text = this._mySetup.myNextButtonText;

        this.myNextButtonCursorTargetComponent = this.myNextButtonCursorTarget.addComponent('cursor-target');
        this.myNextButtonCollisionComponent = this.myNextButtonCursorTarget.addComponent('collision');
        this.myNextButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myNextButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myNextButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        this.myPreviousButtonBackgroundComponent = this.myPreviousButtonBackground.addComponent('mesh');
        this.myPreviousButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myPreviousButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myPreviousButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myPreviousButtonTextComponent = this.myPreviousButtonText.addComponent('text');
        this._setupTextComponent(this.myPreviousButtonTextComponent);
        this.myPreviousButtonTextComponent.text = this._mySetup.myPreviousButtonText;

        this.myPreviousButtonCursorTargetComponent = this.myPreviousButtonCursorTarget.addComponent('cursor-target');
        this.myPreviousButtonCollisionComponent = this.myPreviousButtonCursorTarget.addComponent('collision');
        this.myPreviousButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPreviousButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPreviousButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    }

    _addPointerComponents() {
        this.myPointerCollisionComponent = this.myPointerCursorTarget.addComponent('collision');
        this.myPointerCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPointerCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPointerCollisionComponent.extents = this._mySetup.myPointerCollisionExtents;
    }

    _setupTextComponent(textComponent) {
        textComponent.alignment = this._mySetup.myTextAlignment;
        textComponent.justification = this._mySetup.myTextJustification;
        textComponent.material = this._myAdditionalSetup.myTextMaterial.clone();
        textComponent.material.outlineRange = this._mySetup.myTextOutlineRange;
        textComponent.material.color = this._mySetup.myTextColor;
        textComponent.material.outlineColor = this._mySetup.myTextOutlineColor;
        textComponent.text = "";
    }
};

PP.EasyTuneNumberArrayWidget = class EasyTuneNumberArrayWidget {

    constructor(arraySize, gamepad) {
        this._myGamepad = gamepad;

        this._mySetup = new PP.EasyTuneNumberArrayWidgetSetup(arraySize);
        this._myUI = new PP.EasyTuneNumberArrayWidgetUI();

        this._myVariable = null;

        this._myIsVisible = true;

        this._myScrollVariableRequestCallbacks = new Map();     // Signature: callback(scrollAmount)

        this._myAppendToVariableName = "";

        this._myValueEditIndex = -1;

        this._myValueButtonEditIntensity = 0;
        this._myValueButtonEditIntensityTimer = 0;
        this._myStepButtonEditIntensity = 0;
        this._myStepButtonEditIntensityTimer = 0;

        this._myValueEditActive = false;
        this._myStepEditActive = false;

        this._myValueRealValue = null;
        this._myStepMultiplierValue = null;
        this._myStepFastEdit = false;
    }

    setEasyTuneVariable(variable, appendToVariableName) {
        this._myVariable = variable;

        if ((typeof appendToVariableName) !== 'undefined') {
            this._myAppendToVariableName = appendToVariableName;
        } else {
            this._myAppendToVariableName = "";
        }

        if (this._myValueEditIndex >= 0) {
            this._myValueRealValue = this._myVariable.myValue[this._myValueEditIndex];
        }

        this._refreshUI();
    }

    _refreshUI() {
        if (this._myVariable) {
            this._myUI.myVariableLabelTextComponent.text = this._myVariable.myName.concat(this._myAppendToVariableName);

            for (let i = 0; i < this._mySetup.myArraySize; i++) {
                this._myUI.myValueTextComponents[i].text = this._myVariable.myValue[i].toFixed(this._myVariable.myDecimalPlaces);
            }

            this._myUI.myStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myStepPerSecond);
        }
    }

    setVisible(visible) {
        if (visible) {
            this._refreshUI();
        }
        this._myUI.setVisible(visible);

        this._myIsVisible = visible;
    }

    registerScrollVariableRequestEventListener(id, callback) {
        this._myScrollVariableRequestCallbacks.set(id, callback);
    }

    unregisterScrollVariableRequestEventListener(id) {
        this._myScrollVariableRequestCallbacks.delete(id);
    }

    start(parentObject, additionalSetup) {
        this._myUI.build(parentObject, this._mySetup, additionalSetup);
        this._myUI.setAdditionalButtonsActive(additionalSetup.myEnableAdditionalButtons);

        this._addListeners();
    }

    update(dt) {
        if (this._isActive()) {
            this._updateValue(dt);
        }
    }

    _updateValue(dt) {
        let stickVariableIntensity = 0;

        if (this._myGamepad) {
            let y = this._myGamepad.getAxesInfo().myAxes[1];

            if (Math.abs(y) > this._mySetup.myEditThumbstickMinThreshold) {
                let normalizedEditAmount = (Math.abs(y) - this._mySetup.myEditThumbstickMinThreshold) / (1 - this._mySetup.myEditThumbstickMinThreshold);
                stickVariableIntensity = Math.sign(y) * normalizedEditAmount;
            }
        }

        let valueIntensity = 0;
        if (this._myValueEditActive) {
            valueIntensity = stickVariableIntensity;
        } else if (this._myValueButtonEditIntensity != 0) {
            if (this._myValueButtonEditIntensityTimer <= 0) {
                valueIntensity = this._myValueButtonEditIntensity;
            } else {
                this._myValueButtonEditIntensityTimer -= dt;
            }
        }

        if (valueIntensity != 0) {
            let amountToAdd = valueIntensity * this._myVariable.myStepPerSecond * dt;

            this._myValueRealValue += amountToAdd;

            if (this._myVariable.myMin != null && this._myVariable.myMax != null) {
                this._myValueRealValue = Math.pp_clamp(this._myValueRealValue, this._myVariable.myMin, this._myVariable.myMax);
            } else if (this._myVariable.myMin != null) {
                this._myValueRealValue = Math.max(this._myValueRealValue, this._myVariable.myMin);
            } else if (this._myVariable.myMax != null) {
                this._myValueRealValue = Math.min(this._myValueRealValue, this._myVariable.myMax);
            }

            let decimalPlacesMultiplier = Math.pow(10, this._myVariable.myDecimalPlaces);

            if (this._myVariable.myEditAllValuesTogether) {
                let newValue = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                let difference = newValue - this._myVariable.myValue[this._myValueEditIndex];

                for (let i = 0; i < this._mySetup.myArraySize; i++) {
                    this._myVariable.myValue[i] = Math.round((this._myVariable.myValue[i] + difference) * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;

                    if (this._myVariable.myMin != null && this._myVariable.myMax != null) {
                        this._myVariable.myValue[i] = Math.pp_clamp(this._myVariable.myValue[i], this._myVariable.myMin, this._myVariable.myMax);
                    } else if (this._myVariable.myMin != null) {
                        this._myVariable.myValue[i] = Math.max(this._myVariable.myValue[i], this._myVariable.myMin);
                    } else if (this._myVariable.myMax != null) {
                        this._myVariable.myValue[i] = Math.min(this._myVariable.myValue[i], this._myVariable.myMax);
                    }

                    this._myUI.myValueTextComponents[i].text = this._myVariable.myValue[i].toFixed(this._myVariable.myDecimalPlaces);
                }

            } else {
                this._myVariable.myValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;

                if (this._myVariable.myMin != null && this._myVariable.myMax != null) {
                    this._myVariable.myValue[this._myValueEditIndex] = Math.pp_clamp(this._myVariable.myValue[this._myValueEditIndex], this._myVariable.myMin, this._myVariable.myMax);
                } else if (this._myVariable.myMin != null) {
                    this._myVariable.myValue[this._myValueEditIndex] = Math.max(this._myVariable.myValue[this._myValueEditIndex], this._myVariable.myMin);
                } else if (this._myVariable.myMax != null) {
                    this._myVariable.myValue[this._myValueEditIndex] = Math.min(this._myVariable.myValue[this._myValueEditIndex], this._myVariable.myMax);
                }

                this._myUI.myValueTextComponents[this._myValueEditIndex].text = this._myVariable.myValue[this._myValueEditIndex].toFixed(this._myVariable.myDecimalPlaces);
            }
        } else {
            this._myValueRealValue = this._myVariable.myValue[this._myValueEditIndex];
        }

        let stepIntensity = 0;
        if (this._myStepEditActive) {
            stepIntensity = stickVariableIntensity;
        } else if (this._myStepButtonEditIntensity != 0) {
            if (this._myStepButtonEditIntensityTimer <= 0) {
                stepIntensity = this._myStepButtonEditIntensity;
            } else {
                this._myStepButtonEditIntensityTimer -= dt;
            }
        }

        if (stepIntensity != 0) {
            let amountToAdd = 0;
            if (this._myStepFastEdit) {
                amountToAdd = Math.sign(stepIntensity) * 1;
                this._myStepFastEdit = false;
            } else {
                amountToAdd = stepIntensity * this._mySetup.myStepMultiplierStepPerSecond * dt;
            }

            this._myStepMultiplierValue += amountToAdd;
            if (Math.abs(this._myStepMultiplierValue) >= 1) {
                if (Math.sign(this._myStepMultiplierValue) > 0) {
                    this._myStepMultiplierValue -= 1;
                    this._changeStep(this._myVariable.myStepPerSecond * 10);
                } else {
                    this._myStepMultiplierValue += 1;
                    this._changeStep(this._myVariable.myStepPerSecond * 0.1);
                }
            }
        } else {
            this._myStepMultiplierValue = 0;
            this._myStepFastEdit = true;
        }
    }

    _isActive() {
        return this._myIsVisible && this._myVariable;
    }

    _addListeners() {
        let ui = this._myUI;

        ui.myVariableLabelCursorTargetComponent.addClickFunction(this._resetAllValues.bind(this));
        ui.myVariableLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myVariableLabelText));
        ui.myVariableLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myVariableLabelText, this._mySetup.myVariableLabelTextScale));

        ui.myNextButtonCursorTargetComponent.addClickFunction(this._scrollVariableRequest.bind(this, 1));
        ui.myNextButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myNextButtonBackgroundComponent.material));
        ui.myNextButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myNextButtonBackgroundComponent.material));

        ui.myPreviousButtonCursorTargetComponent.addClickFunction(this._scrollVariableRequest.bind(this, -1));
        ui.myPreviousButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
        ui.myPreviousButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));

        for (let i = 0; i < this._mySetup.myArraySize; i++) {
            ui.myValueIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, i, 1));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, i, -1));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, i, 0));

            ui.myValueIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));

            ui.myValueCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, i));
            ui.myValueCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, i, ui.myValueTexts[i], true));
            ui.myValueCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, i, ui.myValueTexts[i], false));
        }

        ui.myStepCursorTargetComponent.addClickFunction(this._resetStep.bind(this));
        ui.myStepCursorTargetComponent.addHoverFunction(this._setStepEditActive.bind(this, ui.myStepText, true));
        ui.myStepCursorTargetComponent.addUnHoverFunction(this._setStepEditActive.bind(this, ui.myStepText, false));

        ui.myStepIncreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 1));
        ui.myStepIncreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 0));
        ui.myStepDecreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, -1));
        ui.myStepDecreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 0));

        ui.myStepIncreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
        ui.myStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
        ui.myStepDecreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
        ui.myStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
    }

    _setValueEditIntensity(index, value) {
        if (this._isActive() || value == 0) {
            if (value != 0) {
                this._myValueButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
                this._myValueRealValue = this._myVariable.myValue[index];
                this._myValueEditIndex = index;
            }

            this._myValueButtonEditIntensity = value;
        }
    }

    _setStepEditIntensity(value) {
        if (this._isActive() || value == 0) {
            if (value != 0) {
                this._myStepButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
            }

            this._myStepButtonEditIntensity = value;
        }
    }

    _setValueEditActive(index, text, active) {
        if (this._isActive() || !active) {
            if (active) {
                this._myValueRealValue = this._myVariable.myValue[index];
                this._myValueEditIndex = index;
                text.scale(this._mySetup.myTextHoverScaleMultiplier);
            } else {
                text.scalingWorld = this._mySetup.myValueTextScale;
            }

            this._myValueEditActive = active;
        }
    }

    _setStepEditActive(text, active) {
        if (this._isActive() || !active) {
            if (active) {
                text.scale(this._mySetup.myTextHoverScaleMultiplier);
            } else {
                text.scalingWorld = this._mySetup.myStepTextScale;
            }

            this._myStepEditActive = active;
        }
    }

    _scrollVariableRequest(amount) {
        if (this._isActive()) {
            for (let callback of this._myScrollVariableRequestCallbacks.values()) {
                callback(amount);
            }
        }
    }

    _resetValue(index) {
        if (this._isActive()) {
            this._myVariable.myValue[index] = this._myVariable.myInitialValue[index];
            this._myUI.myValueTextComponents[index].text = this._myVariable.myValue[index].toFixed(this._myVariable.myDecimalPlaces);
        }
    }

    _resetAllValues() {
        for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this._resetValue(i);
        }
    }

    _resetStep() {
        if (this._isActive()) {
            this._changeStep(this._myVariable.myInitialStepPerSecond);
        }
    }

    _changeStep(step) {
        step = Math.pp_roundDecimal(step, 10);
        this._myVariable.myStepPerSecond = step;
        this._myUI.myStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myStepPerSecond);
    }

    _genericHover(material) {
        material.color = this._mySetup.myButtonHoverColor;
    }

    _genericUnHover(material) {
        material.color = this._mySetup.myBackgroundColor;
    }

    _genericTextHover(text) {
        text.scale(this._mySetup.myTextHoverScaleMultiplier);
    }

    _genericTextUnHover(text, originalScale) {
        text.scalingWorld = originalScale;
    }
};
PP.EasyTuneNumberArrayWidgetSetup = class EasyTuneNumberArrayWidgetSetup {

    constructor(arraySize) {
        this.myArraySize = arraySize;
        this._initializeBuildSetup();
        this._initializeRuntimeSetup();
    }

    _initializeBuildSetup() {
        //General
        this.myBackgroundColor = [46 / 255, 46 / 255, 46 / 255, 1];

        this.myCursorTargetCollisionCollider = 2; // box
        this.myCursorTargetCollisionGroup = 7;
        this.myCursorTargetCollisionThickness = 0.001;

        this.myDefaultTextColor = [255 / 255, 255 / 255, 255 / 255, 1];

        this.myTextAlignment = 2; // center
        this.myTextJustification = 2; // middle
        this.myTextOutlineRange = [0.45, 0.45];
        this.myTextColor = this.myDefaultTextColor;
        this.myTextOutlineColor = this.myDefaultTextColor;

        //Pivot
        this.myPivotObjectPositions = [];
        this.myPivotObjectPositions[PP.ToolHandedness.NONE] = [0, 0, 0];
        this.myPivotObjectPositions[PP.ToolHandedness.LEFT] = [-0.04, 0.02, 0.00003713]; //little "random" z offset to avoid glitching with other widgets
        this.myPivotObjectPositions[PP.ToolHandedness.RIGHT] = [-0.08, 0.02, 0.00003713];

        let panelZ = 0.01;
        let distanceFromBorder = 0.0125;
        let distanceFromValue = 0.055;
        let colliderZPosition = 0.017;
        let backgroundHalfWidth = 0.2;

        this.mySideButtonBackgroundScale = [0.015, 0.015, 1];
        this.mySideButtonTextScale = [0.18, 0.18, 0.18];
        this.mySideButtonTextPosition = [0, 0, 0.007];

        this.mySideButtonCursorTargetPosition = [0, 0, 0];
        this.mySideButtonCursorTargetPosition[2] = colliderZPosition - panelZ;
        this.mySideButtonCollisionExtents = this.mySideButtonBackgroundScale.slice(0);
        this.mySideButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myLeftSideButtonPosition = [0, 0, -0.00001];
        this.myLeftSideButtonPosition[0] = -backgroundHalfWidth + this.mySideButtonBackgroundScale[0] + distanceFromBorder;

        this.myRightSideButtonPosition = [0, 0, -0.00001];
        this.myRightSideButtonPosition[0] = backgroundHalfWidth - this.mySideButtonBackgroundScale[0] - distanceFromBorder;

        this.myIncreaseButtonText = "+";
        this.myDecreaseButtonText = "-";

        //Display
        this.myDisplayPanelPosition = [0, 0.1, 0];

        this.myVariableLabelPanelPosition = [0, 0.025, panelZ];
        this.myVariableLabelTextScale = [0.19, 0.19, 0.19];

        this.myVariableLabelCursorTargetPosition = [0, 0, 0];
        this.myVariableLabelCursorTargetPosition[2] = colliderZPosition - panelZ;
        this.myVariableLabelCollisionExtents = [0.065, 0.0175, 1];
        this.myVariableLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myNextButtonText = ">";
        this.myPreviousButtonText = "<";

        this.myValuesPanelPosition = [0, this.myVariableLabelPanelPosition[1] - distanceFromValue, panelZ];

        this.myValueTextScale = [0.4, 0.4, 0.4];

        this.myValueCursorTargetPosition = [0, 0, 0];
        this.myValueCursorTargetPosition[2] = colliderZPosition - panelZ;
        this.myValueCollisionExtents = [0.065, 0.02, 1];
        this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;

        this.myValuePanelsPositions = [];
        this.myValuePanelsPositions[0] = [0, 0, 0];
        for (let i = 1; i < this.myArraySize; i++) {
            this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].slice(0);
            this.myValuePanelsPositions[i][1] -= this.myDistanceBetweenValues;
        }

        //Step
        let valuePanelLastPosition = (this.myValuePanelsPositions[this.myArraySize - 1]) ? this.myValuePanelsPositions[this.myArraySize - 1][1] : 0;
        this.myStepPanelPosition = [0, this.myDisplayPanelPosition[1] + this.myValuesPanelPosition[1] + valuePanelLastPosition - distanceFromValue, panelZ];
        this.myStepTextScale = [0.19, 0.19, 0.19];
        this.myStepStartString = "Step: ";

        this.myStepCursorTargetPosition = [0, 0, 0];
        this.myStepCursorTargetPosition[2] = colliderZPosition - this.myStepPanelPosition[2];
        this.myStepCollisionExtents = [0.065, 0.0175, 1];
        this.myStepCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        //Background
        {
            let maxY = this.myDisplayPanelPosition[1] + this.myVariableLabelPanelPosition[1] + this.mySideButtonBackgroundScale[1] + distanceFromBorder * 1.25;
            let minY = this.myStepPanelPosition[1] - distanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
            this.myBackPanelPosition = [0, (maxY + minY) / 2, 0];
            this.myBackBackgroundScale = [backgroundHalfWidth, (maxY - minY) / 2, 1];
            this.myBackBackgroundColor = [70 / 255, 70 / 255, 70 / 255, 1];
        }

        //Pointer
        this.myPointerCollisionExtents = this.myBackBackgroundScale.slice(0);
        this.myPointerCollisionExtents[2] = this.myCursorTargetCollisionThickness;
        this.myPointerCursorTargetPosition = this.myBackPanelPosition.slice(0);
        this.myPointerCursorTargetPosition[2] = colliderZPosition - 0.0001; // a little behind the button target to avoid hiding it
    }

    _initializeRuntimeSetup() {
        this.myButtonHoverColor = [150 / 255, 150 / 255, 150 / 255, 1];
        this.myTextHoverScaleMultiplier = [1.25, 1.25, 1.25];

        this.myEditThumbstickMinThreshold = 0.35;
        this.myStepMultiplierStepPerSecond = 2.25;
        this.myButtonEditDelay = 0;
    }
};

PP.EasyTuneNumberArrayWidgetUI = class EasyTuneNumberArrayWidgetUI {

    build(parentObject, setup, additionalSetup) {
        this._myParentObject = parentObject;
        this._mySetup = setup;
        this._myAdditionalSetup = additionalSetup;

        this._myAdditionalButtonsActive = true;

        this._myPlaneMesh = PP.MeshUtils.createPlaneMesh();

        this._createSkeleton();
        this._setTransforms();
        this._addComponents();
    }

    setVisible(visible) {
        this.myPivotObject.pp_setActiveHierarchy(visible);
        if (visible) {
            this.setAdditionalButtonsActive(this._myAdditionalButtonsActive);
        }
    }

    setAdditionalButtonsActive(active) {
        this._myAdditionalButtonsActive = active;

        for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValueIncreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
            this.myValueDecreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
        }
        this.myStepIncreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
        this.myStepDecreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
    }

    //Skeleton
    _createSkeleton() {
        this.myPivotObject = WL.scene.addObject(this._myParentObject);

        this.myBackPanel = WL.scene.addObject(this.myPivotObject);
        this.myBackBackground = WL.scene.addObject(this.myBackPanel);

        this._createDisplaySkeleton();
        this._createStepSkeleton();
        this._createPointerSkeleton();
    }

    _createDisplaySkeleton() {
        this.myDisplayPanel = WL.scene.addObject(this.myPivotObject);

        this.myVariableLabelPanel = WL.scene.addObject(this.myDisplayPanel);
        this.myVariableLabelText = WL.scene.addObject(this.myVariableLabelPanel);
        this.myVariableLabelCursorTarget = WL.scene.addObject(this.myVariableLabelPanel);

        //Next/Previous
        this.myNextButtonPanel = WL.scene.addObject(this.myVariableLabelPanel);
        this.myNextButtonBackground = WL.scene.addObject(this.myNextButtonPanel);
        this.myNextButtonText = WL.scene.addObject(this.myNextButtonPanel);
        this.myNextButtonCursorTarget = WL.scene.addObject(this.myNextButtonPanel);

        this.myPreviousButtonPanel = WL.scene.addObject(this.myVariableLabelPanel);
        this.myPreviousButtonBackground = WL.scene.addObject(this.myPreviousButtonPanel);
        this.myPreviousButtonText = WL.scene.addObject(this.myPreviousButtonPanel);
        this.myPreviousButtonCursorTarget = WL.scene.addObject(this.myPreviousButtonPanel);

        this.myValuesPanel = WL.scene.addObject(this.myDisplayPanel);

        this.myValuePanels = [];
        this.myValueTexts = [];
        this.myValueCursorTargets = [];

        this.myValueIncreaseButtonPanels = [];
        this.myValueIncreaseButtonBackgrounds = [];
        this.myValueIncreaseButtonTexts = [];
        this.myValueIncreaseButtonCursorTargets = [];

        this.myValueDecreaseButtonPanels = [];
        this.myValueDecreaseButtonBackgrounds = [];
        this.myValueDecreaseButtonTexts = [];
        this.myValueDecreaseButtonCursorTargets = [];

        for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValuePanels[i] = WL.scene.addObject(this.myValuesPanel);
            this.myValueTexts[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueCursorTargets[i] = WL.scene.addObject(this.myValuePanels[i]);

            //Increase/Decrease
            this.myValueIncreaseButtonPanels[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueIncreaseButtonBackgrounds[i] = WL.scene.addObject(this.myValueIncreaseButtonPanels[i]);
            this.myValueIncreaseButtonTexts[i] = WL.scene.addObject(this.myValueIncreaseButtonPanels[i]);
            this.myValueIncreaseButtonCursorTargets[i] = WL.scene.addObject(this.myValueIncreaseButtonPanels[i]);

            this.myValueDecreaseButtonPanels[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueDecreaseButtonBackgrounds[i] = WL.scene.addObject(this.myValueDecreaseButtonPanels[i]);
            this.myValueDecreaseButtonTexts[i] = WL.scene.addObject(this.myValueDecreaseButtonPanels[i]);
            this.myValueDecreaseButtonCursorTargets[i] = WL.scene.addObject(this.myValueDecreaseButtonPanels[i]);
        }
    }

    _createStepSkeleton() {
        this.myStepPanel = WL.scene.addObject(this.myPivotObject);
        this.myStepText = WL.scene.addObject(this.myStepPanel);
        this.myStepCursorTarget = WL.scene.addObject(this.myStepPanel);

        //Increase/Decrease
        this.myStepIncreaseButtonPanel = WL.scene.addObject(this.myStepPanel);
        this.myStepIncreaseButtonBackground = WL.scene.addObject(this.myStepIncreaseButtonPanel);
        this.myStepIncreaseButtonText = WL.scene.addObject(this.myStepIncreaseButtonPanel);
        this.myStepIncreaseButtonCursorTarget = WL.scene.addObject(this.myStepIncreaseButtonPanel);

        this.myStepDecreaseButtonPanel = WL.scene.addObject(this.myStepPanel);
        this.myStepDecreaseButtonBackground = WL.scene.addObject(this.myStepDecreaseButtonPanel);
        this.myStepDecreaseButtonText = WL.scene.addObject(this.myStepDecreaseButtonPanel);
        this.myStepDecreaseButtonCursorTarget = WL.scene.addObject(this.myStepDecreaseButtonPanel);
    }

    _createPointerSkeleton() {
        this.myPointerCursorTarget = WL.scene.addObject(this.myPivotObject);
    }

    //Transforms
    _setTransforms() {
        this.myPivotObject.setTranslationLocal(this._mySetup.myPivotObjectPositions[this._myAdditionalSetup.myHandedness]);

        this.myBackPanel.setTranslationLocal(this._mySetup.myBackPanelPosition);
        this.myBackBackground.scale(this._mySetup.myBackBackgroundScale);

        this._setDisplayTransforms();
        this._setStepTransforms();
        this._setPointerTransform();
    }

    _setDisplayTransforms() {
        this.myDisplayPanel.setTranslationLocal(this._mySetup.myDisplayPanelPosition);

        this.myVariableLabelPanel.setTranslationLocal(this._mySetup.myVariableLabelPanelPosition);
        this.myVariableLabelText.scale(this._mySetup.myVariableLabelTextScale);
        this.myVariableLabelCursorTarget.setTranslationLocal(this._mySetup.myVariableLabelCursorTargetPosition);

        //Next/Previous
        this.myNextButtonPanel.setTranslationLocal(this._mySetup.myRightSideButtonPosition);
        this.myNextButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myNextButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myNextButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myNextButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        this.myPreviousButtonPanel.setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
        this.myPreviousButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myPreviousButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myPreviousButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myPreviousButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        this.myValuesPanel.setTranslationLocal(this._mySetup.myValuesPanelPosition);

        for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValuePanels[i].setTranslationLocal(this._mySetup.myValuePanelsPositions[i]);
            this.myValueTexts[i].scale(this._mySetup.myValueTextScale);
            this.myValueCursorTargets[i].setTranslationLocal(this._mySetup.myValueCursorTargetPosition);

            this.myValueIncreaseButtonPanels[i].setTranslationLocal(this._mySetup.myRightSideButtonPosition);
            this.myValueIncreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myValueIncreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myValueIncreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myValueIncreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

            this.myValueDecreaseButtonPanels[i].setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
            this.myValueDecreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myValueDecreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myValueDecreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myValueDecreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
        }
    }

    _setStepTransforms() {
        this.myStepPanel.setTranslationLocal(this._mySetup.myStepPanelPosition);
        this.myStepText.scale(this._mySetup.myStepTextScale);
        this.myStepCursorTarget.setTranslationLocal(this._mySetup.myStepCursorTargetPosition);

        //Increase/Decrease
        this.myStepIncreaseButtonPanel.setTranslationLocal(this._mySetup.myRightSideButtonPosition);
        this.myStepIncreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myStepIncreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myStepIncreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myStepIncreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        this.myStepDecreaseButtonPanel.setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
        this.myStepDecreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myStepDecreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myStepDecreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myStepDecreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

    }

    _setPointerTransform() {
        this.myPointerCursorTarget.setTranslationLocal(this._mySetup.myPointerCursorTargetPosition);
    }

    //Components
    _addComponents() {
        this.myBackBackgroundComponent = this.myBackBackground.addComponent('mesh');
        this.myBackBackgroundComponent.mesh = this._myPlaneMesh;
        this.myBackBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myBackBackgroundComponent.material.color = this._mySetup.myBackBackgroundColor;

        this._addDisplayComponents();
        this._addStepComponents();
        this._addPointerComponents();
    }

    _addDisplayComponents() {
        this.myVariableLabelTextComponent = this.myVariableLabelText.addComponent('text');
        this._setupTextComponent(this.myVariableLabelTextComponent);
        this.myVariableLabelTextComponent.text = " ";

        this.myVariableLabelCursorTargetComponent = this.myVariableLabelCursorTarget.addComponent('cursor-target');
        this.myVariableLabelCollisionComponent = this.myVariableLabelCursorTarget.addComponent('collision');
        this.myVariableLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myVariableLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myVariableLabelCollisionComponent.extents = this._mySetup.myVariableLabelCollisionExtents;

        //Next/Previous
        this.myNextButtonBackgroundComponent = this.myNextButtonBackground.addComponent('mesh');
        this.myNextButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myNextButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myNextButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myNextButtonTextComponent = this.myNextButtonText.addComponent('text');
        this._setupTextComponent(this.myNextButtonTextComponent);
        this.myNextButtonTextComponent.text = this._mySetup.myNextButtonText;

        this.myNextButtonCursorTargetComponent = this.myNextButtonCursorTarget.addComponent('cursor-target');
        this.myNextButtonCollisionComponent = this.myNextButtonCursorTarget.addComponent('collision');
        this.myNextButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myNextButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myNextButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        this.myPreviousButtonBackgroundComponent = this.myPreviousButtonBackground.addComponent('mesh');
        this.myPreviousButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myPreviousButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myPreviousButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myPreviousButtonTextComponent = this.myPreviousButtonText.addComponent('text');
        this._setupTextComponent(this.myPreviousButtonTextComponent);
        this.myPreviousButtonTextComponent.text = this._mySetup.myPreviousButtonText;

        this.myPreviousButtonCursorTargetComponent = this.myPreviousButtonCursorTarget.addComponent('cursor-target');
        this.myPreviousButtonCollisionComponent = this.myPreviousButtonCursorTarget.addComponent('collision');
        this.myPreviousButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPreviousButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPreviousButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        this.myValueTextComponents = [];
        this.myValueCursorTargetComponents = [];
        this.myValueCollisionComponents = [];

        this.myValueIncreaseButtonBackgroundComponents = [];
        this.myValueIncreaseButtonTextComponents = [];
        this.myValueIncreaseButtonCursorTargetComponents = [];
        this.myValueIncreaseButtonCollisionComponents = [];

        this.myValueDecreaseButtonBackgroundComponents = [];
        this.myValueDecreaseButtonTextComponents = [];
        this.myValueDecreaseButtonCursorTargetComponents = [];
        this.myValueDecreaseButtonCollisionComponents = [];


        for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValueTextComponents[i] = this.myValueTexts[i].addComponent('text');
            this._setupTextComponent(this.myValueTextComponents[i]);
            this.myValueTextComponents[i].text = " ";

            this.myValueCursorTargetComponents[i] = this.myValueCursorTargets[i].addComponent('cursor-target');
            this.myValueCollisionComponents[i] = this.myValueCursorTargets[i].addComponent('collision');
            this.myValueCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myValueCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myValueCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;

            //Increase/Decrease
            this.myValueIncreaseButtonBackgroundComponents[i] = this.myValueIncreaseButtonBackgrounds[i].addComponent('mesh');
            this.myValueIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myValueIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myValueIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;

            this.myValueIncreaseButtonTextComponents[i] = this.myValueIncreaseButtonTexts[i].addComponent('text');
            this._setupTextComponent(this.myValueIncreaseButtonTextComponents[i]);
            this.myValueIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;

            this.myValueIncreaseButtonCursorTargetComponents[i] = this.myValueIncreaseButtonCursorTargets[i].addComponent('cursor-target');
            this.myValueIncreaseButtonCollisionComponents[i] = this.myValueIncreaseButtonCursorTargets[i].addComponent('collision');
            this.myValueIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myValueIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myValueIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;

            this.myValueDecreaseButtonBackgroundComponents[i] = this.myValueDecreaseButtonBackgrounds[i].addComponent('mesh');
            this.myValueDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myValueDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myValueDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;

            this.myValueDecreaseButtonTextComponents[i] = this.myValueDecreaseButtonTexts[i].addComponent('text');
            this._setupTextComponent(this.myValueDecreaseButtonTextComponents[i]);
            this.myValueDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;

            this.myValueDecreaseButtonCursorTargetComponents[i] = this.myValueDecreaseButtonCursorTargets[i].addComponent('cursor-target');
            this.myValueDecreaseButtonCollisionComponents[i] = this.myValueDecreaseButtonCursorTargets[i].addComponent('collision');
            this.myValueDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myValueDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myValueDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
        }
    }

    _addStepComponents() {
        this.myStepTextComponent = this.myStepText.addComponent('text');
        this._setupTextComponent(this.myStepTextComponent);
        this.myStepTextComponent.text = " ";

        this.myStepCursorTargetComponent = this.myStepCursorTarget.addComponent('cursor-target');
        this.myStepCollisionComponent = this.myStepCursorTarget.addComponent('collision');
        this.myStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;

        //Increase/Decrease
        this.myStepIncreaseButtonBackgroundComponent = this.myStepIncreaseButtonBackground.addComponent('mesh');
        this.myStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myStepIncreaseButtonTextComponent = this.myStepIncreaseButtonText.addComponent('text');
        this._setupTextComponent(this.myStepIncreaseButtonTextComponent);
        this.myStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;

        this.myStepIncreaseButtonCursorTargetComponent = this.myStepIncreaseButtonCursorTarget.addComponent('cursor-target');
        this.myStepIncreaseButtonCollisionComponent = this.myStepIncreaseButtonCursorTarget.addComponent('collision');
        this.myStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        this.myStepDecreaseButtonBackgroundComponent = this.myStepDecreaseButtonBackground.addComponent('mesh');
        this.myStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myStepDecreaseButtonTextComponent = this.myStepDecreaseButtonText.addComponent('text');
        this._setupTextComponent(this.myStepDecreaseButtonTextComponent);
        this.myStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;

        this.myStepDecreaseButtonCursorTargetComponent = this.myStepDecreaseButtonCursorTarget.addComponent('cursor-target');
        this.myStepDecreaseButtonCollisionComponent = this.myStepDecreaseButtonCursorTarget.addComponent('collision');
        this.myStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    }

    _addPointerComponents() {
        this.myPointerCollisionComponent = this.myPointerCursorTarget.addComponent('collision');
        this.myPointerCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPointerCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPointerCollisionComponent.extents = this._mySetup.myPointerCollisionExtents;
    }

    _setupTextComponent(textComponent) {
        textComponent.alignment = this._mySetup.myTextAlignment;
        textComponent.justification = this._mySetup.myTextJustification;
        textComponent.material = this._myAdditionalSetup.myTextMaterial.clone();
        textComponent.material.outlineRange = this._mySetup.myTextOutlineRange;
        textComponent.material.color = this._mySetup.myTextColor;
        textComponent.material.outlineColor = this._mySetup.myTextOutlineColor;
        textComponent.text = "";
    }
};

PP.EasyTuneNumberWidget = class EasyTuneNumberWidget {

    constructor(gamepad) {
        this._myGamepad = gamepad;

        this._myParentObject = null;
        this._myAdditionalSetup = null;

        this._myWidgets = new Map();

        this._myVariable = null;
        this._myIsVisible = true;

        this._myAppendToVariableName = null;

        this._myScrollVariableRequestCallbacks = new Map();     // Signature: callback(scrollAmount)

        this._myCurrentArraySize = 0;
    }

    setEasyTuneVariable(variable, appendToVariableName) {
        this._myVariable = variable;
        this._myCurrentArraySize = this._myVariable.myValue.length;
        this._myAppendToVariableName = appendToVariableName;

        if (!this._myWidgets.has(this._myCurrentArraySize)) {
            this._createWidget(this._myCurrentArraySize);
        }

        this._myWidgets.get(this._myCurrentArraySize).setEasyTuneVariable(variable, appendToVariableName);

        this.setVisible(this._myIsVisible);
    }

    setVisible(visible) {
        if (this._myVariable) {
            this._sizeChangedCheck();

            for (let widget of this._myWidgets.values()) {
                widget.setVisible(false);
            }

            this._myWidgets.get(this._myCurrentArraySize).setVisible(visible);
        }

        this._myIsVisible = visible;
    }

    registerScrollVariableRequestEventListener(id, callback) {
        this._myScrollVariableRequestCallbacks.set(id, callback);
    }

    unregisterScrollVariableRequestEventListener(id) {
        this._myScrollVariableRequestCallbacks.delete(id);
    }

    start(parentObject, additionalSetup) {
        this._myParentObject = parentObject;
        this._myAdditionalSetup = additionalSetup;

        this._createWidget(1);

        if (this._myVariable) {
            this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
        }
    }

    update(dt) {
        if (this._isActive()) {
            this._sizeChangedCheck();

            this._myWidgets.get(this._myCurrentArraySize).update(dt);
        }
    }

    _isActive() {
        return this._myIsVisible && this._myVariable;
    }

    _scrollVariable(amount) {
        for (let callback of this._myScrollVariableRequestCallbacks.values()) {
            callback(amount);
        }
    }

    _createWidget(arraySize) {
        this._myWidgets.set(arraySize, new PP.EasyTuneNumberArrayWidget(arraySize, this._myGamepad));
        this._myWidgets.get(arraySize).start(this._myParentObject, this._myAdditionalSetup);
        this._myWidgets.get(arraySize).setVisible(false);
        this._myWidgets.get(arraySize).registerScrollVariableRequestEventListener(this, this._scrollVariable.bind(this));
    }

    _sizeChangedCheck() {
        if (this._myVariable.myValue.length != this._myCurrentArraySize) {
            this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
        }
    }
};
PP.EasyTuneSimpleTransformWidget = class EasyTuneSimpleTransformWidget {

    constructor(gamepad) {
        this._myGamepad = gamepad;

        this._mySetup = new PP.EasyTuneSimpleTransformWidgetSetup();
        this._myUI = new PP.EasyTuneSimpleTransformWidgetUI();

        this._myVariable = null;

        this._myIsVisible = true;

        this._myScrollVariableRequestCallbacks = new Map();     // Signature: callback(scrollAmount)

        this._myAppendToVariableName = "";

        this._myValueButtonEditIntensity = 0;
        this._myValueButtonEditIntensityTimer = 0;
        this._myStepButtonEditIntensity = 0;
        this._myStepButtonEditIntensityTimer = 0;

        this._myValueEditActive = false;
        this._myStepEditActive = false;

        this._myValueRealValue = null;
        this._myComponentStepValue = null;
        this._myStepMultiplierValue = null;
        this._myStepFastEdit = false;

        this._myValueEditIndex = -1;
        this._myComponentIndex = 0;
        this._myStepIndex = 0;
    }

    setEasyTuneVariable(variable, appendToVariableName) {
        this._myVariable = variable;

        if ((typeof appendToVariableName) !== 'undefined') {
            this._myAppendToVariableName = appendToVariableName;
        } else {
            this._myAppendToVariableName = "";
        }

        this._refreshUI();
    }

    _refreshUI() {
        if (this._myVariable) {
            this._myUI.myVariableLabelTextComponent.text = this._myVariable.myName.concat(this._myAppendToVariableName);

            for (let i = 0; i < 3; i++) {
                this._myUI.myPositionTextComponents[i].text = this._myVariable.myPosition[i].toFixed(this._myVariable.myDecimalPlaces);
            }
            this._myUI.myPositionStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myPositionStepPerSecond);

            for (let i = 0; i < 3; i++) {
                this._myUI.myRotationTextComponents[i].text = this._myVariable.myRotation[i].toFixed(this._myVariable.myDecimalPlaces);
            }
            this._myUI.myRotationStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myRotationStepPerSecond);

            for (let i = 0; i < 3; i++) {
                this._myUI.myScaleTextComponents[i].text = this._myVariable.myScale[i].toFixed(this._myVariable.myDecimalPlaces);
            }
            this._myUI.myScaleStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myScaleStepPerSecond);
        }
    }

    setVisible(visible) {
        if (visible) {
            this._refreshUI();
        }
        this._myUI.setVisible(visible);

        this._myIsVisible = visible;
    }

    registerScrollVariableRequestEventListener(id, callback) {
        this._myScrollVariableRequestCallbacks.set(id, callback);
    }

    unregisterScrollVariableRequestEventListener(id) {
        this._myScrollVariableRequestCallbacks.delete(id);
    }

    start(parentObject, additionalSetup) {
        this._myUI.build(parentObject, this._mySetup, additionalSetup);
        this._myUI.setAdditionalButtonsActive(additionalSetup.myEnableAdditionalButtons);

        this._addListeners();
    }

    update(dt) {
        if (this._isActive()) {
            this._updateValue(dt);
        }
    }

    _updateValue(dt) {
        let stickVariableIntensity = 0;

        if (this._myGamepad) {
            let y = this._myGamepad.getAxesInfo().myAxes[1];

            if (Math.abs(y) > this._mySetup.myEditThumbstickMinThreshold) {
                let normalizedEditAmount = (Math.abs(y) - this._mySetup.myEditThumbstickMinThreshold) / (1 - this._mySetup.myEditThumbstickMinThreshold);
                stickVariableIntensity = Math.sign(y) * normalizedEditAmount;
            }
        }

        let valueIntensity = 0;
        if (this._myValueEditActive) {
            valueIntensity = stickVariableIntensity;
        } else if (this._myValueButtonEditIntensity != 0) {
            if (this._myValueButtonEditIntensityTimer <= 0) {
                valueIntensity = this._myValueButtonEditIntensity;
            } else {
                this._myValueButtonEditIntensityTimer -= dt;
            }
        }

        if (valueIntensity != 0) {
            let amountToAdd = valueIntensity * this._myComponentStepValue * dt;

            this._myValueRealValue += amountToAdd;

            let decimalPlacesMultiplier = Math.pow(10, this._myVariable.myDecimalPlaces);

            switch (this._myComponentIndex) {
                case 0:
                    this._myVariable.myPosition[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                    this._myUI.myPositionTextComponents[this._myValueEditIndex].text = this._myVariable.myPosition[this._myValueEditIndex].toFixed(this._myVariable.myDecimalPlaces);
                    break;
                case 1:
                    if (this._myValueRealValue > 180) {
                        while (this._myValueRealValue > 180) {
                            this._myValueRealValue -= 180;
                        }
                        this._myValueRealValue = -180 + this._myValueRealValue;
                    }

                    if (this._myValueRealValue < -180) {
                        while (this._myValueRealValue < - 180) {
                            this._myValueRealValue += 180;
                        }
                        this._myValueRealValue = 180 - this._myValueRealValue;
                    }

                    this._myVariable.myRotation[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                    this._myUI.myRotationTextComponents[this._myValueEditIndex].text = this._myVariable.myRotation[this._myValueEditIndex].toFixed(this._myVariable.myDecimalPlaces);
                    break;
                case 2:
                    if (this._myValueRealValue <= 0) {
                        this._myValueRealValue = 1 / decimalPlacesMultiplier;
                    }

                    if (this._myVariable.myScaleAsOne) {
                        let newValue = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                        let difference = newValue - this._myVariable.myScale[this._myValueEditIndex];

                        for (let i = 0; i < 3; i++) {
                            this._myVariable.myScale[i] = Math.round((this._myVariable.myScale[i] + difference) * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                            this._myVariable.myScale[i] = Math.max(this._myVariable.myScale[i], 1 / decimalPlacesMultiplier);
                            this._myUI.myScaleTextComponents[i].text = this._myVariable.myScale[i].toFixed(this._myVariable.myDecimalPlaces);
                        }
                    } else {
                        this._myVariable.myScale[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                        this._myVariable.myScale[this._myValueEditIndex] = Math.max(this._myVariable.myScale[this._myValueEditIndex], 1 / decimalPlacesMultiplier);
                        this._myUI.myScaleTextComponents[this._myValueEditIndex].text = this._myVariable.myScale[this._myValueEditIndex].toFixed(this._myVariable.myDecimalPlaces);
                    }
                    break;
            }
        } else {
            switch (this._myComponentIndex) {
                case 0:
                    this._myValueRealValue = this._myVariable.myPosition[this._myValueEditIndex];
                    break;
                case 1:
                    this._myValueRealValue = this._myVariable.myRotation[this._myValueEditIndex];
                    break;
                case 2:
                    this._myValueRealValue = this._myVariable.myScale[this._myValueEditIndex];
                    break;
            }
        }

        let stepIntensity = 0;
        if (this._myStepEditActive) {
            stepIntensity = stickVariableIntensity;
        } else if (this._myStepButtonEditIntensity != 0) {
            if (this._myStepButtonEditIntensityTimer <= 0) {
                stepIntensity = this._myStepButtonEditIntensity;
            } else {
                this._myStepButtonEditIntensityTimer -= dt;
            }
        }

        if (stepIntensity != 0) {
            let amountToAdd = 0;
            if (this._myStepFastEdit) {
                amountToAdd = Math.sign(stepIntensity) * 1;
                this._myStepFastEdit = false;
            } else {
                amountToAdd = stepIntensity * this._mySetup.myStepMultiplierStepPerSecond * dt;
            }

            this._myStepMultiplierValue += amountToAdd;
            if (Math.abs(this._myStepMultiplierValue) >= 1) {
                let stepValue = 0;
                switch (this._myStepIndex) {
                    case 0:
                        stepValue = this._myVariable.myPositionStepPerSecond;
                        break;
                    case 1:
                        stepValue = this._myVariable.myRotationStepPerSecond;
                        break;
                    case 2:
                        stepValue = this._myVariable.myScaleStepPerSecond;
                        break;
                    default:
                        stepValue = 0;
                }
                if (Math.sign(this._myStepMultiplierValue) > 0) {
                    this._myStepMultiplierValue -= 1;
                    this._changeStep(this._myStepIndex, stepValue * 10);
                } else {
                    this._myStepMultiplierValue += 1;
                    this._changeStep(this._myStepIndex, stepValue * 0.1);
                }
            }
        } else {
            this._myStepMultiplierValue = 0;
            this._myStepFastEdit = true;
        }
    }

    _isActive() {
        return this._myIsVisible && this._myVariable;
    }

    _addListeners() {
        let ui = this._myUI;

        ui.myVariableLabelCursorTargetComponent.addClickFunction(this._resetAllValues.bind(this));
        ui.myVariableLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myVariableLabelText));
        ui.myVariableLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myVariableLabelText, this._mySetup.myVariableLabelTextScale));

        ui.myNextButtonCursorTargetComponent.addClickFunction(this._scrollVariableRequest.bind(this, 1));
        ui.myNextButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myNextButtonBackgroundComponent.material));
        ui.myNextButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myNextButtonBackgroundComponent.material));

        ui.myPreviousButtonCursorTargetComponent.addClickFunction(this._scrollVariableRequest.bind(this, -1));
        ui.myPreviousButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
        ui.myPreviousButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));

        ui.myPositionLabelCursorTargetComponent.addClickFunction(this._resetComponentValues.bind(this, 0));
        ui.myPositionLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myPositionLabelText));
        ui.myPositionLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myPositionLabelText, this._mySetup.myComponentLabelTextScale));
        for (let i = 0; i < 3; i++) {
            ui.myPositionIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 0, i, 1));
            ui.myPositionIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
            ui.myPositionDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 0, i, -1));
            ui.myPositionDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 0, i, 0));

            ui.myPositionIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
            ui.myPositionIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
            ui.myPositionDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));
            ui.myPositionDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));

            ui.myPositionCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, 0, i));
            ui.myPositionCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, 0, i, ui.myPositionTexts[i], true));
            ui.myPositionCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, 0, i, ui.myPositionTexts[i], false));
        }

        ui.myRotationLabelCursorTargetComponent.addClickFunction(this._resetComponentValues.bind(this, 1));
        ui.myRotationLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myRotationLabelText));
        ui.myRotationLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myRotationLabelText, this._mySetup.myComponentLabelTextScale));
        for (let i = 0; i < 3; i++) {
            ui.myRotationIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 1, i, 1));
            ui.myRotationIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
            ui.myRotationDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 1, i, -1));
            ui.myRotationDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 1, i, 0));

            ui.myRotationIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
            ui.myRotationIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
            ui.myRotationDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));
            ui.myRotationDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));

            ui.myRotationCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, 1, i));
            ui.myRotationCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, 1, i, ui.myRotationTexts[i], true));
            ui.myRotationCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, 1, i, ui.myRotationTexts[i], false));
        }

        ui.myScaleLabelCursorTargetComponent.addClickFunction(this._resetComponentValues.bind(this, 2));
        ui.myScaleLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myScaleLabelText));
        ui.myScaleLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myScaleLabelText, this._mySetup.myComponentLabelTextScale));
        for (let i = 0; i < 3; i++) {
            ui.myScaleIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 2, i, 1));
            ui.myScaleIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
            ui.myScaleDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 2, i, -1));
            ui.myScaleDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 2, i, 0));

            ui.myScaleIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
            ui.myScaleIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
            ui.myScaleDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));
            ui.myScaleDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));

            ui.myScaleCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, 2, i));
            ui.myScaleCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, 2, i, ui.myScaleTexts[i], true));
            ui.myScaleCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, 2, i, ui.myScaleTexts[i], false));
        }

        ui.myPositionStepCursorTargetComponent.addClickFunction(this._resetStep.bind(this, 0));
        ui.myPositionStepCursorTargetComponent.addHoverFunction(this._setStepEditActive.bind(this, 0, ui.myPositionStepText, true));
        ui.myPositionStepCursorTargetComponent.addUnHoverFunction(this._setStepEditActive.bind(this, 0, ui.myPositionStepText, false));

        ui.myPositionStepIncreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 0, 1));
        ui.myPositionStepIncreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 0, 0));
        ui.myPositionStepDecreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 0, -1));
        ui.myPositionStepDecreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 0, 0));

        ui.myPositionStepIncreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
        ui.myPositionStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
        ui.myPositionStepDecreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));
        ui.myPositionStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));

        ui.myRotationStepCursorTargetComponent.addClickFunction(this._resetStep.bind(this, 1));
        ui.myRotationStepCursorTargetComponent.addHoverFunction(this._setStepEditActive.bind(this, 1, ui.myRotationStepText, true));
        ui.myRotationStepCursorTargetComponent.addUnHoverFunction(this._setStepEditActive.bind(this, 1, ui.myRotationStepText, false));

        ui.myRotationStepIncreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 1, 1));
        ui.myRotationStepIncreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 1, 0));
        ui.myRotationStepDecreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 1, -1));
        ui.myRotationStepDecreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 1, 0));

        ui.myRotationStepIncreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
        ui.myRotationStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
        ui.myRotationStepDecreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));
        ui.myRotationStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));

        ui.myScaleStepCursorTargetComponent.addClickFunction(this._resetStep.bind(this, 2));
        ui.myScaleStepCursorTargetComponent.addHoverFunction(this._setStepEditActive.bind(this, 2, ui.myScaleStepText, true));
        ui.myScaleStepCursorTargetComponent.addUnHoverFunction(this._setStepEditActive.bind(this, 2, ui.myScaleStepText, false));

        ui.myScaleStepIncreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 2, 1));
        ui.myScaleStepIncreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 2, 0));
        ui.myScaleStepDecreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 2, -1));
        ui.myScaleStepDecreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 2, 0));

        ui.myScaleStepIncreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
        ui.myScaleStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
        ui.myScaleStepDecreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));
        ui.myScaleStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));

    }

    _setValueEditIntensity(componentIndex, index, value) {
        if (this._isActive() || value == 0) {
            if (value != 0) {
                switch (componentIndex) {
                    case 0:
                        this._myValueRealValue = this._myVariable.myPosition[index];
                        this._myComponentStepValue = this._myVariable.myPositionStepPerSecond;
                        break;
                    case 1:
                        this._myValueRealValue = this._myVariable.myRotation[index];
                        this._myComponentStepValue = this._myVariable.myRotationStepPerSecond;
                        break;
                    case 2:
                        this._myValueRealValue = this._myVariable.myScale[index];
                        this._myComponentStepValue = this._myVariable.myScaleStepPerSecond;
                        break;
                }

                this._myValueButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
                this._myValueEditIndex = index;
                this._myComponentIndex = componentIndex;
            }

            this._myValueButtonEditIntensity = value;
        }
    }

    _setStepEditIntensity(index, value) {
        if (this._isActive() || value == 0) {
            if (value != 0) {
                this._myStepButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
            }

            this._myStepButtonEditIntensity = value;

            this._myStepIndex = index;
        }
    }

    _setValueEditActive(componentIndex, index, text, active) {
        if (this._isActive() || !active) {
            if (active) {
                switch (componentIndex) {
                    case 0:
                        this._myValueRealValue = this._myVariable.myPosition[index];
                        this._myComponentStepValue = this._myVariable.myPositionStepPerSecond;
                        break;
                    case 1:
                        this._myValueRealValue = this._myVariable.myRotation[index];
                        this._myComponentStepValue = this._myVariable.myRotationStepPerSecond;
                        break;
                    case 2:
                        this._myValueRealValue = this._myVariable.myScale[index];
                        this._myComponentStepValue = this._myVariable.myScaleStepPerSecond;
                        break;
                }

                this._myValueEditIndex = index;
                this._myComponentIndex = componentIndex;
                text.scale(this._mySetup.myTextHoverScaleMultiplier);
            } else {
                text.scalingWorld = this._mySetup.myValueTextScale;
            }

            this._myValueEditActive = active;
        }
    }

    _setStepEditActive(index, text, active) {
        if (this._isActive() || !active) {
            if (active) {
                text.scale(this._mySetup.myTextHoverScaleMultiplier);
            } else {
                text.scalingWorld = this._mySetup.myStepTextScale;
            }

            this._myStepEditActive = active;
            this._myStepIndex = index;
        }
    }

    _scrollVariableRequest(amount) {
        if (this._isActive()) {
            for (let callback of this._myScrollVariableRequestCallbacks.values()) {
                callback(amount);
            }
        }
    }

    _resetValue(componentIndex, index) {
        if (this._isActive()) {
            switch (componentIndex) {
                case 0:
                    this._myVariable.myPosition[index] = this._myVariable.myInitialPosition[index];
                    this._myUI.myPositionTextComponents[index].text = this._myVariable.myPosition[index].toFixed(this._myVariable.myDecimalPlaces);
                    break;
                case 1:
                    this._myVariable.myRotation[index] = this._myVariable.myInitialRotation[index];
                    this._myUI.myRotationTextComponents[index].text = this._myVariable.myRotation[index].toFixed(this._myVariable.myDecimalPlaces);
                    break;
                case 2:
                    this._myVariable.myScale[index] = this._myVariable.myInitialScale[index];
                    this._myUI.myScaleTextComponents[index].text = this._myVariable.myScale[index].toFixed(this._myVariable.myDecimalPlaces);
                    break;
                default:
                    initialValue = 0;
            }
        }
    }

    _resetAllValues() {
        for (let i = 0; i < 3; i++) {
            this._resetComponentValues(i);
        }
    }

    _resetComponentValues(index) {
        for (let i = 0; i < 3; i++) {
            this._resetValue(index, i);
        }
    }

    _resetStep(index) {
        if (this._isActive()) {
            let initialValue = 0;
            switch (index) {
                case 0:
                    initialValue = this._myVariable.myInitialPositionStepPerSecond;
                    break;
                case 1:
                    initialValue = this._myVariable.myInitialRotationStepPerSecond;
                    break;
                case 2:
                    initialValue = this._myVariable.myInitialScaleStepPerSecond;
                    break;
                default:
                    initialValue = 0;
            }

            this._changeStep(index, initialValue);
        }
    }

    _changeStep(index, step) {
        step = Math.pp_roundDecimal(step, 10);

        switch (index) {
            case 0:
                this._myVariable.myPositionStepPerSecond = step;
                this._myUI.myPositionStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myPositionStepPerSecond);
                break;
            case 1:
                this._myVariable.myRotationStepPerSecond = step;
                this._myUI.myRotationStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myRotationStepPerSecond);
                break;
            case 2:
                this._myVariable.myScaleStepPerSecond = step;
                this._myUI.myScaleStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myScaleStepPerSecond);
                break;
        }
    }

    _genericHover(material) {
        material.color = this._mySetup.myButtonHoverColor;
    }

    _genericUnHover(material) {
        material.color = this._mySetup.myBackgroundColor;
    }

    _genericTextHover(text) {
        text.scale(this._mySetup.myTextHoverScaleMultiplier);
    }

    _genericTextUnHover(text, originalScale) {
        text.scalingWorld = originalScale;
    }
};
PP.EasyTuneSimpleTransformWidgetSetup = class EasyTuneSimpleTransformWidgetSetup {

    constructor() {
        this._initializeBuildSetup();
        this._initializeRuntimeSetup();
    }

    _initializeBuildSetup() {
        //General
        this.myBackgroundColor = [46 / 255, 46 / 255, 46 / 255, 1];

        this.myCursorTargetCollisionCollider = 2; // box
        this.myCursorTargetCollisionGroup = 7;
        this.myCursorTargetCollisionThickness = 0.001;

        this.myDefaultTextColor = [255 / 255, 255 / 255, 255 / 255, 1];

        this.myTextAlignment = 2; // center
        this.myTextJustification = 2; // middle
        this.myTextOutlineRange = [0.45, 0.45];
        this.myTextColor = this.myDefaultTextColor;
        this.myTextOutlineColor = this.myDefaultTextColor;

        //Pivot
        this.myPivotObjectPositions = [];
        this.myPivotObjectPositions[PP.ToolHandedness.NONE] = [0, 0, 0];
        this.myPivotObjectPositions[PP.ToolHandedness.LEFT] = [-0.04, 0.02, 0.00003713]; //little "random" z offset to avoid glitching with other widgets
        this.myPivotObjectPositions[PP.ToolHandedness.RIGHT] = [-0.08, 0.02, 0.00003713];

        let panelZ = 0.01;
        let distanceFromBorder = 0.0125;
        let distanceFromValue = 0.055;
        let colliderZPosition = 0.017;
        let backgroundHalfWidth = 0.2;

        this.mySideButtonBackgroundScale = [0.015, 0.015, 1];
        this.mySideButtonTextScale = [0.18, 0.18, 0.18];
        this.mySideButtonTextPosition = [0, 0, 0.007];

        this.mySideButtonCursorTargetPosition = [0, 0, 0];
        this.mySideButtonCursorTargetPosition[2] = colliderZPosition - panelZ;
        this.mySideButtonCollisionExtents = this.mySideButtonBackgroundScale.slice(0);
        this.mySideButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myLeftSideButtonPosition = [-0.13, 0, 0];
        this.myRightSideButtonPosition = [-this.myLeftSideButtonPosition[0], 0, 0];

        this.myPreviousButtonPosition = [0, 0, -0.00001];
        this.myPreviousButtonPosition[0] = -backgroundHalfWidth + this.mySideButtonBackgroundScale[0] + distanceFromBorder;

        this.myNextButtonPosition = [0, 0, -0.00001];
        this.myNextButtonPosition[0] = backgroundHalfWidth - this.mySideButtonBackgroundScale[0] - distanceFromBorder;

        this.myIncreaseButtonText = "+";
        this.myDecreaseButtonText = "-";

        //Display
        this.myDisplayPanelPosition = [0, 0.1, 0];

        this.myVariableLabelPanelPosition = [0, 0.025, panelZ];
        this.myVariableLabelTextScale = [0.19, 0.19, 0.19];

        this.myVariableLabelCursorTargetPosition = [0, 0, 0];
        this.myVariableLabelCursorTargetPosition[2] = colliderZPosition - panelZ;
        this.myVariableLabelCollisionExtents = [0.065, 0.0175, 1];
        this.myVariableLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myNextButtonText = ">";
        this.myPreviousButtonText = "<";

        let distanceBetweenComponents = Math.abs(this.myNextButtonPosition[0]) + Math.abs(this.myRightSideButtonPosition[0]);
        let distanceFromVariableLabel = 0.045;
        this.myPositionPanelPosition = [0, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, panelZ];
        this.myRotationPanelPosition = [this.myPositionPanelPosition[0] + distanceBetweenComponents, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, panelZ];
        this.myScalePanelPosition = [this.myPositionPanelPosition[0] - distanceBetweenComponents, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, panelZ];

        this.myPositionText = "Position";
        this.myRotationText = "Rotation";
        this.myScaleText = "Scale";

        this.myComponentLabelTextScale = [0.19, 0.19, 0.19];
        this.myComponentLabelCursorTargetPosition = [0, 0, 0];
        this.myComponentLabelCursorTargetPosition[2] = colliderZPosition - panelZ;
        this.myComponentLabelCollisionExtents = [0.065, 0.0175, 1];
        this.myComponentLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        this.myValueTextScale = [0.4, 0.4, 0.4];

        this.myValueCursorTargetPosition = [0, 0.0, 0];
        this.myValueCursorTargetPosition[2] = colliderZPosition - panelZ;
        this.myValueCollisionExtents = [0.065, 0.02, 1];
        this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        let distanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;

        this.myValuePanelsPositions = [];
        this.myValuePanelsPositions[0] = [0, -distanceFromValue, 0];
        for (let i = 1; i < 3; i++) {
            this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].slice(0);
            this.myValuePanelsPositions[i][1] -= distanceBetweenValues;
        }

        //Step
        let valuePanelLastPosition = this.myValuePanelsPositions[2][1];
        this.myStepPanelPosition = [0, valuePanelLastPosition - distanceFromValue, 0];
        this.myStepTextScale = [0.19, 0.19, 0.19];
        this.myStepStartString = "Step: ";

        this.myStepCursorTargetPosition = [0, 0, 0];
        this.myStepCursorTargetPosition[2] = colliderZPosition - this.myStepPanelPosition[2];
        this.myStepCollisionExtents = [0.065, 0.0175, 1];
        this.myStepCollisionExtents[2] = this.myCursorTargetCollisionThickness;

        //Background
        {
            let maxY = this.myDisplayPanelPosition[1] + this.myVariableLabelPanelPosition[1] + this.mySideButtonBackgroundScale[1] + distanceFromBorder * 1.25;
            let minY = this.myDisplayPanelPosition[1] + this.myPositionPanelPosition[1] + this.myStepPanelPosition[1] - distanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];

            let maxX = this.myDisplayPanelPosition[0] + this.myRotationPanelPosition[0] + this.myRightSideButtonPosition[0] + this.mySideButtonBackgroundScale[0] + distanceFromBorder;
            let minX = this.myDisplayPanelPosition[0] + this.myScalePanelPosition[0] + this.myLeftSideButtonPosition[0] - this.mySideButtonBackgroundScale[0] - distanceFromBorder;

            this.myBackPanelPosition = [(maxX + minX) / 2, (maxY + minY) / 2, 0];
            this.myBackBackgroundScale = [(maxX - minX) / 2, (maxY - minY) / 2, 1];
            this.myBackBackgroundColor = [70 / 255, 70 / 255, 70 / 255, 1];
        }

        //Pointer
        this.myPointerCollisionExtents = this.myBackBackgroundScale.slice(0);
        this.myPointerCollisionExtents[2] = this.myCursorTargetCollisionThickness;
        this.myPointerCursorTargetPosition = this.myBackPanelPosition.slice(0);
        this.myPointerCursorTargetPosition[2] = colliderZPosition - 0.0001; // a little behind the button target to avoid hiding it
    }

    _initializeRuntimeSetup() {
        this.myButtonHoverColor = [150 / 255, 150 / 255, 150 / 255, 1];
        this.myTextHoverScaleMultiplier = [1.25, 1.25, 1.25];

        this.myEditThumbstickMinThreshold = 0.35;
        this.myStepMultiplierStepPerSecond = 2.25;
        this.myButtonEditDelay = 0;
    }
};

PP.EasyTuneSimpleTransformWidgetUI = class EasyTuneSimpleTransformWidgetUI {

    build(parentObject, setup, additionalSetup) {
        this._myParentObject = parentObject;
        this._mySetup = setup;
        this._myAdditionalSetup = additionalSetup;

        this._myAdditionalButtonsActive = true;

        this._myPlaneMesh = PP.MeshUtils.createPlaneMesh();

        this._createSkeleton();
        this._setTransforms();
        this._addComponents();
    }

    setVisible(visible) {
        this.myPivotObject.pp_setActiveHierarchy(visible);
        if (visible) {
            this.setAdditionalButtonsActive(this._myAdditionalButtonsActive);
        }
    }

    setAdditionalButtonsActive(active) {
        this._myAdditionalButtonsActive = active;

        for (let i = 0; i < 3; i++) {
            this.myPositionIncreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
            this.myPositionDecreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
        }
        this.myPositionStepIncreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
        this.myPositionStepDecreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);

        for (let i = 0; i < 3; i++) {
            this.myRotationIncreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
            this.myRotationDecreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
        }
        this.myRotationStepIncreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
        this.myRotationStepDecreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);

        for (let i = 0; i < 3; i++) {
            this.myScaleIncreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
            this.myScaleDecreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
        }
        this.myScaleStepIncreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
        this.myScaleStepDecreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
    }

    //Skeleton
    _createSkeleton() {
        this.myPivotObject = WL.scene.addObject(this._myParentObject);

        this.myBackPanel = WL.scene.addObject(this.myPivotObject);
        this.myBackBackground = WL.scene.addObject(this.myBackPanel);

        this._createDisplaySkeleton();
        this._createStepSkeleton();
        this._createPointerSkeleton();
    }

    _createDisplaySkeleton() {
        this.myDisplayPanel = WL.scene.addObject(this.myPivotObject);

        this.myVariableLabelPanel = WL.scene.addObject(this.myDisplayPanel);
        this.myVariableLabelText = WL.scene.addObject(this.myVariableLabelPanel);
        this.myVariableLabelCursorTarget = WL.scene.addObject(this.myVariableLabelPanel);

        //Next/Previous
        this.myNextButtonPanel = WL.scene.addObject(this.myVariableLabelPanel);
        this.myNextButtonBackground = WL.scene.addObject(this.myNextButtonPanel);
        this.myNextButtonText = WL.scene.addObject(this.myNextButtonPanel);
        this.myNextButtonCursorTarget = WL.scene.addObject(this.myNextButtonPanel);

        this.myPreviousButtonPanel = WL.scene.addObject(this.myVariableLabelPanel);
        this.myPreviousButtonBackground = WL.scene.addObject(this.myPreviousButtonPanel);
        this.myPreviousButtonText = WL.scene.addObject(this.myPreviousButtonPanel);
        this.myPreviousButtonCursorTarget = WL.scene.addObject(this.myPreviousButtonPanel);

        //Position
        this.myPositionPanel = WL.scene.addObject(this.myDisplayPanel);
        this.myPositionLabelText = WL.scene.addObject(this.myPositionPanel);
        this.myPositionLabelCursorTarget = WL.scene.addObject(this.myPositionPanel);

        this.myPositionPanels = [];
        this.myPositionTexts = [];
        this.myPositionCursorTargets = [];

        this.myPositionIncreaseButtonPanels = [];
        this.myPositionIncreaseButtonBackgrounds = [];
        this.myPositionIncreaseButtonTexts = [];
        this.myPositionIncreaseButtonCursorTargets = [];

        this.myPositionDecreaseButtonPanels = [];
        this.myPositionDecreaseButtonBackgrounds = [];
        this.myPositionDecreaseButtonTexts = [];
        this.myPositionDecreaseButtonCursorTargets = [];

        for (let i = 0; i < 3; i++) {
            this.myPositionPanels[i] = WL.scene.addObject(this.myPositionPanel);
            this.myPositionTexts[i] = WL.scene.addObject(this.myPositionPanels[i]);
            this.myPositionCursorTargets[i] = WL.scene.addObject(this.myPositionPanels[i]);

            //Increase/Decrease
            this.myPositionIncreaseButtonPanels[i] = WL.scene.addObject(this.myPositionPanels[i]);
            this.myPositionIncreaseButtonBackgrounds[i] = WL.scene.addObject(this.myPositionIncreaseButtonPanels[i]);
            this.myPositionIncreaseButtonTexts[i] = WL.scene.addObject(this.myPositionIncreaseButtonPanels[i]);
            this.myPositionIncreaseButtonCursorTargets[i] = WL.scene.addObject(this.myPositionIncreaseButtonPanels[i]);

            this.myPositionDecreaseButtonPanels[i] = WL.scene.addObject(this.myPositionPanels[i]);
            this.myPositionDecreaseButtonBackgrounds[i] = WL.scene.addObject(this.myPositionDecreaseButtonPanels[i]);
            this.myPositionDecreaseButtonTexts[i] = WL.scene.addObject(this.myPositionDecreaseButtonPanels[i]);
            this.myPositionDecreaseButtonCursorTargets[i] = WL.scene.addObject(this.myPositionDecreaseButtonPanels[i]);
        }

        //Rotation
        this.myRotationPanel = WL.scene.addObject(this.myDisplayPanel);
        this.myRotationLabelText = WL.scene.addObject(this.myRotationPanel);
        this.myRotationLabelCursorTarget = WL.scene.addObject(this.myRotationPanel);

        this.myRotationPanels = [];
        this.myRotationTexts = [];
        this.myRotationCursorTargets = [];

        this.myRotationIncreaseButtonPanels = [];
        this.myRotationIncreaseButtonBackgrounds = [];
        this.myRotationIncreaseButtonTexts = [];
        this.myRotationIncreaseButtonCursorTargets = [];

        this.myRotationDecreaseButtonPanels = [];
        this.myRotationDecreaseButtonBackgrounds = [];
        this.myRotationDecreaseButtonTexts = [];
        this.myRotationDecreaseButtonCursorTargets = [];

        for (let i = 0; i < 3; i++) {
            this.myRotationPanels[i] = WL.scene.addObject(this.myRotationPanel);
            this.myRotationTexts[i] = WL.scene.addObject(this.myRotationPanels[i]);
            this.myRotationCursorTargets[i] = WL.scene.addObject(this.myRotationPanels[i]);

            //Increase/Decrease
            this.myRotationIncreaseButtonPanels[i] = WL.scene.addObject(this.myRotationPanels[i]);
            this.myRotationIncreaseButtonBackgrounds[i] = WL.scene.addObject(this.myRotationIncreaseButtonPanels[i]);
            this.myRotationIncreaseButtonTexts[i] = WL.scene.addObject(this.myRotationIncreaseButtonPanels[i]);
            this.myRotationIncreaseButtonCursorTargets[i] = WL.scene.addObject(this.myRotationIncreaseButtonPanels[i]);

            this.myRotationDecreaseButtonPanels[i] = WL.scene.addObject(this.myRotationPanels[i]);
            this.myRotationDecreaseButtonBackgrounds[i] = WL.scene.addObject(this.myRotationDecreaseButtonPanels[i]);
            this.myRotationDecreaseButtonTexts[i] = WL.scene.addObject(this.myRotationDecreaseButtonPanels[i]);
            this.myRotationDecreaseButtonCursorTargets[i] = WL.scene.addObject(this.myRotationDecreaseButtonPanels[i]);
        }

        //Scale
        this.myScalePanel = WL.scene.addObject(this.myDisplayPanel);
        this.myScaleLabelText = WL.scene.addObject(this.myScalePanel);
        this.myScaleLabelCursorTarget = WL.scene.addObject(this.myScalePanel);

        this.myScalePanels = [];
        this.myScaleTexts = [];
        this.myScaleCursorTargets = [];

        this.myScaleIncreaseButtonPanels = [];
        this.myScaleIncreaseButtonBackgrounds = [];
        this.myScaleIncreaseButtonTexts = [];
        this.myScaleIncreaseButtonCursorTargets = [];

        this.myScaleDecreaseButtonPanels = [];
        this.myScaleDecreaseButtonBackgrounds = [];
        this.myScaleDecreaseButtonTexts = [];
        this.myScaleDecreaseButtonCursorTargets = [];

        for (let i = 0; i < 3; i++) {
            this.myScalePanels[i] = WL.scene.addObject(this.myScalePanel);
            this.myScaleTexts[i] = WL.scene.addObject(this.myScalePanels[i]);
            this.myScaleCursorTargets[i] = WL.scene.addObject(this.myScalePanels[i]);

            //Increase/Decrease
            this.myScaleIncreaseButtonPanels[i] = WL.scene.addObject(this.myScalePanels[i]);
            this.myScaleIncreaseButtonBackgrounds[i] = WL.scene.addObject(this.myScaleIncreaseButtonPanels[i]);
            this.myScaleIncreaseButtonTexts[i] = WL.scene.addObject(this.myScaleIncreaseButtonPanels[i]);
            this.myScaleIncreaseButtonCursorTargets[i] = WL.scene.addObject(this.myScaleIncreaseButtonPanels[i]);

            this.myScaleDecreaseButtonPanels[i] = WL.scene.addObject(this.myScalePanels[i]);
            this.myScaleDecreaseButtonBackgrounds[i] = WL.scene.addObject(this.myScaleDecreaseButtonPanels[i]);
            this.myScaleDecreaseButtonTexts[i] = WL.scene.addObject(this.myScaleDecreaseButtonPanels[i]);
            this.myScaleDecreaseButtonCursorTargets[i] = WL.scene.addObject(this.myScaleDecreaseButtonPanels[i]);
        }
    }

    _createStepSkeleton() {
        //Position
        this.myPositionStepPanel = WL.scene.addObject(this.myPositionPanel);
        this.myPositionStepText = WL.scene.addObject(this.myPositionStepPanel);
        this.myPositionStepCursorTarget = WL.scene.addObject(this.myPositionStepPanel);

        //Increase/Decrease
        this.myPositionStepIncreaseButtonPanel = WL.scene.addObject(this.myPositionStepPanel);
        this.myPositionStepIncreaseButtonBackground = WL.scene.addObject(this.myPositionStepIncreaseButtonPanel);
        this.myPositionStepIncreaseButtonText = WL.scene.addObject(this.myPositionStepIncreaseButtonPanel);
        this.myPositionStepIncreaseButtonCursorTarget = WL.scene.addObject(this.myPositionStepIncreaseButtonPanel);

        this.myPositionStepDecreaseButtonPanel = WL.scene.addObject(this.myPositionStepPanel);
        this.myPositionStepDecreaseButtonBackground = WL.scene.addObject(this.myPositionStepDecreaseButtonPanel);
        this.myPositionStepDecreaseButtonText = WL.scene.addObject(this.myPositionStepDecreaseButtonPanel);
        this.myPositionStepDecreaseButtonCursorTarget = WL.scene.addObject(this.myPositionStepDecreaseButtonPanel);

        //Rotation
        this.myRotationStepPanel = WL.scene.addObject(this.myRotationPanel);
        this.myRotationStepText = WL.scene.addObject(this.myRotationStepPanel);
        this.myRotationStepCursorTarget = WL.scene.addObject(this.myRotationStepPanel);

        //Increase/Decrease
        this.myRotationStepIncreaseButtonPanel = WL.scene.addObject(this.myRotationStepPanel);
        this.myRotationStepIncreaseButtonBackground = WL.scene.addObject(this.myRotationStepIncreaseButtonPanel);
        this.myRotationStepIncreaseButtonText = WL.scene.addObject(this.myRotationStepIncreaseButtonPanel);
        this.myRotationStepIncreaseButtonCursorTarget = WL.scene.addObject(this.myRotationStepIncreaseButtonPanel);

        this.myRotationStepDecreaseButtonPanel = WL.scene.addObject(this.myRotationStepPanel);
        this.myRotationStepDecreaseButtonBackground = WL.scene.addObject(this.myRotationStepDecreaseButtonPanel);
        this.myRotationStepDecreaseButtonText = WL.scene.addObject(this.myRotationStepDecreaseButtonPanel);
        this.myRotationStepDecreaseButtonCursorTarget = WL.scene.addObject(this.myRotationStepDecreaseButtonPanel);

        //Scale
        this.myScaleStepPanel = WL.scene.addObject(this.myScalePanel);
        this.myScaleStepText = WL.scene.addObject(this.myScaleStepPanel);
        this.myScaleStepCursorTarget = WL.scene.addObject(this.myScaleStepPanel);

        //Increase/Decrease
        this.myScaleStepIncreaseButtonPanel = WL.scene.addObject(this.myScaleStepPanel);
        this.myScaleStepIncreaseButtonBackground = WL.scene.addObject(this.myScaleStepIncreaseButtonPanel);
        this.myScaleStepIncreaseButtonText = WL.scene.addObject(this.myScaleStepIncreaseButtonPanel);
        this.myScaleStepIncreaseButtonCursorTarget = WL.scene.addObject(this.myScaleStepIncreaseButtonPanel);

        this.myScaleStepDecreaseButtonPanel = WL.scene.addObject(this.myScaleStepPanel);
        this.myScaleStepDecreaseButtonBackground = WL.scene.addObject(this.myScaleStepDecreaseButtonPanel);
        this.myScaleStepDecreaseButtonText = WL.scene.addObject(this.myScaleStepDecreaseButtonPanel);
        this.myScaleStepDecreaseButtonCursorTarget = WL.scene.addObject(this.myScaleStepDecreaseButtonPanel);
    }

    _createPointerSkeleton() {
        this.myPointerCursorTarget = WL.scene.addObject(this.myPivotObject);
    }

    //Transforms
    _setTransforms() {
        this.myPivotObject.setTranslationLocal(this._mySetup.myPivotObjectPositions[this._myAdditionalSetup.myHandedness]);

        this.myBackPanel.setTranslationLocal(this._mySetup.myBackPanelPosition);
        this.myBackBackground.scale(this._mySetup.myBackBackgroundScale);

        this._setDisplayTransforms();
        this._setStepTransforms();
        this._setPointerTransform();
    }

    _setDisplayTransforms() {
        this.myDisplayPanel.setTranslationLocal(this._mySetup.myDisplayPanelPosition);

        this.myVariableLabelPanel.setTranslationLocal(this._mySetup.myVariableLabelPanelPosition);
        this.myVariableLabelText.scale(this._mySetup.myVariableLabelTextScale);
        this.myVariableLabelCursorTarget.setTranslationLocal(this._mySetup.myVariableLabelCursorTargetPosition);

        //Next/Previous
        this.myNextButtonPanel.setTranslationLocal(this._mySetup.myNextButtonPosition);
        this.myNextButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myNextButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myNextButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myNextButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        this.myPreviousButtonPanel.setTranslationLocal(this._mySetup.myPreviousButtonPosition);
        this.myPreviousButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myPreviousButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myPreviousButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myPreviousButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        //Position
        this.myPositionPanel.setTranslationLocal(this._mySetup.myPositionPanelPosition);
        this.myPositionLabelText.scale(this._mySetup.myComponentLabelTextScale);
        this.myPositionLabelCursorTarget.setTranslationLocal(this._mySetup.myComponentLabelCursorTargetPosition);

        for (let i = 0; i < 3; i++) {
            this.myPositionPanels[i].setTranslationLocal(this._mySetup.myValuePanelsPositions[i]);
            this.myPositionTexts[i].scale(this._mySetup.myValueTextScale);
            this.myPositionCursorTargets[i].setTranslationLocal(this._mySetup.myValueCursorTargetPosition);

            this.myPositionIncreaseButtonPanels[i].setTranslationLocal(this._mySetup.myRightSideButtonPosition);
            this.myPositionIncreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myPositionIncreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myPositionIncreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myPositionIncreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

            this.myPositionDecreaseButtonPanels[i].setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
            this.myPositionDecreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myPositionDecreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myPositionDecreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myPositionDecreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
        }

        //Rotation
        this.myRotationPanel.setTranslationLocal(this._mySetup.myRotationPanelPosition);
        this.myRotationLabelText.scale(this._mySetup.myComponentLabelTextScale);
        this.myRotationLabelCursorTarget.setTranslationLocal(this._mySetup.myComponentLabelCursorTargetPosition);

        for (let i = 0; i < 3; i++) {
            this.myRotationPanels[i].setTranslationLocal(this._mySetup.myValuePanelsPositions[i]);
            this.myRotationTexts[i].scale(this._mySetup.myValueTextScale);
            this.myRotationCursorTargets[i].setTranslationLocal(this._mySetup.myValueCursorTargetPosition);

            this.myRotationIncreaseButtonPanels[i].setTranslationLocal(this._mySetup.myRightSideButtonPosition);
            this.myRotationIncreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myRotationIncreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myRotationIncreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myRotationIncreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

            this.myRotationDecreaseButtonPanels[i].setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
            this.myRotationDecreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myRotationDecreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myRotationDecreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myRotationDecreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
        }

        //Scale
        this.myScalePanel.setTranslationLocal(this._mySetup.myScalePanelPosition);
        this.myScaleLabelText.scale(this._mySetup.myComponentLabelTextScale);
        this.myScaleLabelCursorTarget.setTranslationLocal(this._mySetup.myComponentLabelCursorTargetPosition);

        for (let i = 0; i < 3; i++) {
            this.myScalePanels[i].setTranslationLocal(this._mySetup.myValuePanelsPositions[i]);
            this.myScaleTexts[i].scale(this._mySetup.myValueTextScale);
            this.myScaleCursorTargets[i].setTranslationLocal(this._mySetup.myValueCursorTargetPosition);

            this.myScaleIncreaseButtonPanels[i].setTranslationLocal(this._mySetup.myRightSideButtonPosition);
            this.myScaleIncreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myScaleIncreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myScaleIncreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myScaleIncreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

            this.myScaleDecreaseButtonPanels[i].setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
            this.myScaleDecreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myScaleDecreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myScaleDecreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myScaleDecreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
        }
    }

    _setStepTransforms() {
        //Position
        this.myPositionStepPanel.setTranslationLocal(this._mySetup.myStepPanelPosition);
        this.myPositionStepText.scale(this._mySetup.myStepTextScale);
        this.myPositionStepCursorTarget.setTranslationLocal(this._mySetup.myStepCursorTargetPosition);

        //Increase/Decrease
        this.myPositionStepIncreaseButtonPanel.setTranslationLocal(this._mySetup.myRightSideButtonPosition);
        this.myPositionStepIncreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myPositionStepIncreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myPositionStepIncreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myPositionStepIncreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        this.myPositionStepDecreaseButtonPanel.setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
        this.myPositionStepDecreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myPositionStepDecreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myPositionStepDecreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myPositionStepDecreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        //Rotation
        this.myRotationStepPanel.setTranslationLocal(this._mySetup.myStepPanelPosition);
        this.myRotationStepText.scale(this._mySetup.myStepTextScale);
        this.myRotationStepCursorTarget.setTranslationLocal(this._mySetup.myStepCursorTargetPosition);

        //Increase/Decrease
        this.myRotationStepIncreaseButtonPanel.setTranslationLocal(this._mySetup.myRightSideButtonPosition);
        this.myRotationStepIncreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myRotationStepIncreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myRotationStepIncreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myRotationStepIncreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        this.myRotationStepDecreaseButtonPanel.setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
        this.myRotationStepDecreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myRotationStepDecreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myRotationStepDecreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myRotationStepDecreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        //Scale
        this.myScaleStepPanel.setTranslationLocal(this._mySetup.myStepPanelPosition);
        this.myScaleStepText.scale(this._mySetup.myStepTextScale);
        this.myScaleStepCursorTarget.setTranslationLocal(this._mySetup.myStepCursorTargetPosition);

        //Increase/Decrease
        this.myScaleStepIncreaseButtonPanel.setTranslationLocal(this._mySetup.myRightSideButtonPosition);
        this.myScaleStepIncreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myScaleStepIncreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myScaleStepIncreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myScaleStepIncreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

        this.myScaleStepDecreaseButtonPanel.setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
        this.myScaleStepDecreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
        this.myScaleStepDecreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
        this.myScaleStepDecreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
        this.myScaleStepDecreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);

    }

    _setPointerTransform() {
        this.myPointerCursorTarget.setTranslationLocal(this._mySetup.myPointerCursorTargetPosition);
    }

    //Components
    _addComponents() {
        this.myBackBackgroundComponent = this.myBackBackground.addComponent('mesh');
        this.myBackBackgroundComponent.mesh = this._myPlaneMesh;
        this.myBackBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myBackBackgroundComponent.material.color = this._mySetup.myBackBackgroundColor;

        this._addDisplayComponents();
        this._addStepComponents();
        this._addPointerComponents();
    }

    _addDisplayComponents() {
        this.myVariableLabelTextComponent = this.myVariableLabelText.addComponent('text');
        this._setupTextComponent(this.myVariableLabelTextComponent);
        this.myVariableLabelTextComponent.text = " ";

        this.myVariableLabelCursorTargetComponent = this.myVariableLabelCursorTarget.addComponent('cursor-target');
        this.myVariableLabelCollisionComponent = this.myVariableLabelCursorTarget.addComponent('collision');
        this.myVariableLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myVariableLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myVariableLabelCollisionComponent.extents = this._mySetup.myVariableLabelCollisionExtents;

        //Next/Previous
        this.myNextButtonBackgroundComponent = this.myNextButtonBackground.addComponent('mesh');
        this.myNextButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myNextButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myNextButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myNextButtonTextComponent = this.myNextButtonText.addComponent('text');
        this._setupTextComponent(this.myNextButtonTextComponent);
        this.myNextButtonTextComponent.text = this._mySetup.myNextButtonText;

        this.myNextButtonCursorTargetComponent = this.myNextButtonCursorTarget.addComponent('cursor-target');
        this.myNextButtonCollisionComponent = this.myNextButtonCursorTarget.addComponent('collision');
        this.myNextButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myNextButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myNextButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        this.myPreviousButtonBackgroundComponent = this.myPreviousButtonBackground.addComponent('mesh');
        this.myPreviousButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myPreviousButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myPreviousButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myPreviousButtonTextComponent = this.myPreviousButtonText.addComponent('text');
        this._setupTextComponent(this.myPreviousButtonTextComponent);
        this.myPreviousButtonTextComponent.text = this._mySetup.myPreviousButtonText;

        this.myPreviousButtonCursorTargetComponent = this.myPreviousButtonCursorTarget.addComponent('cursor-target');
        this.myPreviousButtonCollisionComponent = this.myPreviousButtonCursorTarget.addComponent('collision');
        this.myPreviousButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPreviousButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPreviousButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        //Position
        this.myPositionLabelTextComponent = this.myPositionLabelText.addComponent('text');
        this._setupTextComponent(this.myPositionLabelTextComponent);
        this.myPositionLabelTextComponent.text = this._mySetup.myPositionText;

        this.myPositionLabelCursorTargetComponent = this.myPositionLabelCursorTarget.addComponent('cursor-target');
        this.myPositionLabelCollisionComponent = this.myPositionLabelCursorTarget.addComponent('collision');
        this.myPositionLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPositionLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPositionLabelCollisionComponent.extents = this._mySetup.myComponentLabelCollisionExtents;

        this.myPositionTextComponents = [];
        this.myPositionCursorTargetComponents = [];
        this.myPositionCollisionComponents = [];

        this.myPositionIncreaseButtonBackgroundComponents = [];
        this.myPositionIncreaseButtonTextComponents = [];
        this.myPositionIncreaseButtonCursorTargetComponents = [];
        this.myPositionIncreaseButtonCollisionComponents = [];

        this.myPositionDecreaseButtonBackgroundComponents = [];
        this.myPositionDecreaseButtonTextComponents = [];
        this.myPositionDecreaseButtonCursorTargetComponents = [];
        this.myPositionDecreaseButtonCollisionComponents = [];

        for (let i = 0; i < 3; i++) {
            this.myPositionTextComponents[i] = this.myPositionTexts[i].addComponent('text');
            this._setupTextComponent(this.myPositionTextComponents[i]);
            this.myPositionTextComponents[i].text = " ";

            this.myPositionCursorTargetComponents[i] = this.myPositionCursorTargets[i].addComponent('cursor-target');
            this.myPositionCollisionComponents[i] = this.myPositionCursorTargets[i].addComponent('collision');
            this.myPositionCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myPositionCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myPositionCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;

            //Increase/Decrease
            this.myPositionIncreaseButtonBackgroundComponents[i] = this.myPositionIncreaseButtonBackgrounds[i].addComponent('mesh');
            this.myPositionIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myPositionIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myPositionIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;

            this.myPositionIncreaseButtonTextComponents[i] = this.myPositionIncreaseButtonTexts[i].addComponent('text');
            this._setupTextComponent(this.myPositionIncreaseButtonTextComponents[i]);
            this.myPositionIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;

            this.myPositionIncreaseButtonCursorTargetComponents[i] = this.myPositionIncreaseButtonCursorTargets[i].addComponent('cursor-target');
            this.myPositionIncreaseButtonCollisionComponents[i] = this.myPositionIncreaseButtonCursorTargets[i].addComponent('collision');
            this.myPositionIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myPositionIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myPositionIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;

            this.myPositionDecreaseButtonBackgroundComponents[i] = this.myPositionDecreaseButtonBackgrounds[i].addComponent('mesh');
            this.myPositionDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myPositionDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myPositionDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;

            this.myPositionDecreaseButtonTextComponents[i] = this.myPositionDecreaseButtonTexts[i].addComponent('text');
            this._setupTextComponent(this.myPositionDecreaseButtonTextComponents[i]);
            this.myPositionDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;

            this.myPositionDecreaseButtonCursorTargetComponents[i] = this.myPositionDecreaseButtonCursorTargets[i].addComponent('cursor-target');
            this.myPositionDecreaseButtonCollisionComponents[i] = this.myPositionDecreaseButtonCursorTargets[i].addComponent('collision');
            this.myPositionDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myPositionDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myPositionDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
        }

        //Rotation
        this.myRotationLabelTextComponent = this.myRotationLabelText.addComponent('text');
        this._setupTextComponent(this.myRotationLabelTextComponent);
        this.myRotationLabelTextComponent.text = this._mySetup.myRotationText;

        this.myRotationLabelCursorTargetComponent = this.myRotationLabelCursorTarget.addComponent('cursor-target');
        this.myRotationLabelCollisionComponent = this.myRotationLabelCursorTarget.addComponent('collision');
        this.myRotationLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myRotationLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myRotationLabelCollisionComponent.extents = this._mySetup.myComponentLabelCollisionExtents;

        this.myRotationTextComponents = [];
        this.myRotationCursorTargetComponents = [];
        this.myRotationCollisionComponents = [];

        this.myRotationIncreaseButtonBackgroundComponents = [];
        this.myRotationIncreaseButtonTextComponents = [];
        this.myRotationIncreaseButtonCursorTargetComponents = [];
        this.myRotationIncreaseButtonCollisionComponents = [];

        this.myRotationDecreaseButtonBackgroundComponents = [];
        this.myRotationDecreaseButtonTextComponents = [];
        this.myRotationDecreaseButtonCursorTargetComponents = [];
        this.myRotationDecreaseButtonCollisionComponents = [];

        for (let i = 0; i < 3; i++) {
            this.myRotationTextComponents[i] = this.myRotationTexts[i].addComponent('text');
            this._setupTextComponent(this.myRotationTextComponents[i]);
            this.myRotationTextComponents[i].text = " ";

            this.myRotationCursorTargetComponents[i] = this.myRotationCursorTargets[i].addComponent('cursor-target');
            this.myRotationCollisionComponents[i] = this.myRotationCursorTargets[i].addComponent('collision');
            this.myRotationCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myRotationCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myRotationCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;

            //Increase/Decrease
            this.myRotationIncreaseButtonBackgroundComponents[i] = this.myRotationIncreaseButtonBackgrounds[i].addComponent('mesh');
            this.myRotationIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myRotationIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myRotationIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;

            this.myRotationIncreaseButtonTextComponents[i] = this.myRotationIncreaseButtonTexts[i].addComponent('text');
            this._setupTextComponent(this.myRotationIncreaseButtonTextComponents[i]);
            this.myRotationIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;

            this.myRotationIncreaseButtonCursorTargetComponents[i] = this.myRotationIncreaseButtonCursorTargets[i].addComponent('cursor-target');
            this.myRotationIncreaseButtonCollisionComponents[i] = this.myRotationIncreaseButtonCursorTargets[i].addComponent('collision');
            this.myRotationIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myRotationIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myRotationIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;

            this.myRotationDecreaseButtonBackgroundComponents[i] = this.myRotationDecreaseButtonBackgrounds[i].addComponent('mesh');
            this.myRotationDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myRotationDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myRotationDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;

            this.myRotationDecreaseButtonTextComponents[i] = this.myRotationDecreaseButtonTexts[i].addComponent('text');
            this._setupTextComponent(this.myRotationDecreaseButtonTextComponents[i]);
            this.myRotationDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;

            this.myRotationDecreaseButtonCursorTargetComponents[i] = this.myRotationDecreaseButtonCursorTargets[i].addComponent('cursor-target');
            this.myRotationDecreaseButtonCollisionComponents[i] = this.myRotationDecreaseButtonCursorTargets[i].addComponent('collision');
            this.myRotationDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myRotationDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myRotationDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
        }

        //Scale
        this.myScaleLabelTextComponent = this.myScaleLabelText.addComponent('text');
        this._setupTextComponent(this.myScaleLabelTextComponent);
        this.myScaleLabelTextComponent.text = this._mySetup.myScaleText;

        this.myScaleLabelCursorTargetComponent = this.myScaleLabelCursorTarget.addComponent('cursor-target');
        this.myScaleLabelCollisionComponent = this.myScaleLabelCursorTarget.addComponent('collision');
        this.myScaleLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myScaleLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myScaleLabelCollisionComponent.extents = this._mySetup.myComponentLabelCollisionExtents;

        this.myScaleTextComponents = [];
        this.myScaleCursorTargetComponents = [];
        this.myScaleCollisionComponents = [];

        this.myScaleIncreaseButtonBackgroundComponents = [];
        this.myScaleIncreaseButtonTextComponents = [];
        this.myScaleIncreaseButtonCursorTargetComponents = [];
        this.myScaleIncreaseButtonCollisionComponents = [];

        this.myScaleDecreaseButtonBackgroundComponents = [];
        this.myScaleDecreaseButtonTextComponents = [];
        this.myScaleDecreaseButtonCursorTargetComponents = [];
        this.myScaleDecreaseButtonCollisionComponents = [];

        for (let i = 0; i < 3; i++) {
            this.myScaleTextComponents[i] = this.myScaleTexts[i].addComponent('text');
            this._setupTextComponent(this.myScaleTextComponents[i]);
            this.myScaleTextComponents[i].text = " ";

            this.myScaleCursorTargetComponents[i] = this.myScaleCursorTargets[i].addComponent('cursor-target');
            this.myScaleCollisionComponents[i] = this.myScaleCursorTargets[i].addComponent('collision');
            this.myScaleCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myScaleCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myScaleCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;

            //Increase/Decrease
            this.myScaleIncreaseButtonBackgroundComponents[i] = this.myScaleIncreaseButtonBackgrounds[i].addComponent('mesh');
            this.myScaleIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myScaleIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myScaleIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;

            this.myScaleIncreaseButtonTextComponents[i] = this.myScaleIncreaseButtonTexts[i].addComponent('text');
            this._setupTextComponent(this.myScaleIncreaseButtonTextComponents[i]);
            this.myScaleIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;

            this.myScaleIncreaseButtonCursorTargetComponents[i] = this.myScaleIncreaseButtonCursorTargets[i].addComponent('cursor-target');
            this.myScaleIncreaseButtonCollisionComponents[i] = this.myScaleIncreaseButtonCursorTargets[i].addComponent('collision');
            this.myScaleIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myScaleIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myScaleIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;

            this.myScaleDecreaseButtonBackgroundComponents[i] = this.myScaleDecreaseButtonBackgrounds[i].addComponent('mesh');
            this.myScaleDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myScaleDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myScaleDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;

            this.myScaleDecreaseButtonTextComponents[i] = this.myScaleDecreaseButtonTexts[i].addComponent('text');
            this._setupTextComponent(this.myScaleDecreaseButtonTextComponents[i]);
            this.myScaleDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;

            this.myScaleDecreaseButtonCursorTargetComponents[i] = this.myScaleDecreaseButtonCursorTargets[i].addComponent('cursor-target');
            this.myScaleDecreaseButtonCollisionComponents[i] = this.myScaleDecreaseButtonCursorTargets[i].addComponent('collision');
            this.myScaleDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myScaleDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myScaleDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
        }
    }

    _addStepComponents() {
        //Position
        this.myPositionStepTextComponent = this.myPositionStepText.addComponent('text');
        this._setupTextComponent(this.myPositionStepTextComponent);
        this.myPositionStepTextComponent.text = " ";

        this.myPositionStepCursorTargetComponent = this.myPositionStepCursorTarget.addComponent('cursor-target');
        this.myPositionStepCollisionComponent = this.myPositionStepCursorTarget.addComponent('collision');
        this.myPositionStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPositionStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPositionStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;

        //Increase/Decrease
        this.myPositionStepIncreaseButtonBackgroundComponent = this.myPositionStepIncreaseButtonBackground.addComponent('mesh');
        this.myPositionStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myPositionStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myPositionStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myPositionStepIncreaseButtonTextComponent = this.myPositionStepIncreaseButtonText.addComponent('text');
        this._setupTextComponent(this.myPositionStepIncreaseButtonTextComponent);
        this.myPositionStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;

        this.myPositionStepIncreaseButtonCursorTargetComponent = this.myPositionStepIncreaseButtonCursorTarget.addComponent('cursor-target');
        this.myPositionStepIncreaseButtonCollisionComponent = this.myPositionStepIncreaseButtonCursorTarget.addComponent('collision');
        this.myPositionStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPositionStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPositionStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        this.myPositionStepDecreaseButtonBackgroundComponent = this.myPositionStepDecreaseButtonBackground.addComponent('mesh');
        this.myPositionStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myPositionStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myPositionStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myPositionStepDecreaseButtonTextComponent = this.myPositionStepDecreaseButtonText.addComponent('text');
        this._setupTextComponent(this.myPositionStepDecreaseButtonTextComponent);
        this.myPositionStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;

        this.myPositionStepDecreaseButtonCursorTargetComponent = this.myPositionStepDecreaseButtonCursorTarget.addComponent('cursor-target');
        this.myPositionStepDecreaseButtonCollisionComponent = this.myPositionStepDecreaseButtonCursorTarget.addComponent('collision');
        this.myPositionStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPositionStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPositionStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        //Rotation
        this.myRotationStepTextComponent = this.myRotationStepText.addComponent('text');
        this._setupTextComponent(this.myRotationStepTextComponent);
        this.myRotationStepTextComponent.text = " ";

        this.myRotationStepCursorTargetComponent = this.myRotationStepCursorTarget.addComponent('cursor-target');
        this.myRotationStepCollisionComponent = this.myRotationStepCursorTarget.addComponent('collision');
        this.myRotationStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myRotationStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myRotationStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;

        //Increase/Decrease
        this.myRotationStepIncreaseButtonBackgroundComponent = this.myRotationStepIncreaseButtonBackground.addComponent('mesh');
        this.myRotationStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myRotationStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myRotationStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myRotationStepIncreaseButtonTextComponent = this.myRotationStepIncreaseButtonText.addComponent('text');
        this._setupTextComponent(this.myRotationStepIncreaseButtonTextComponent);
        this.myRotationStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;

        this.myRotationStepIncreaseButtonCursorTargetComponent = this.myRotationStepIncreaseButtonCursorTarget.addComponent('cursor-target');
        this.myRotationStepIncreaseButtonCollisionComponent = this.myRotationStepIncreaseButtonCursorTarget.addComponent('collision');
        this.myRotationStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myRotationStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myRotationStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        this.myRotationStepDecreaseButtonBackgroundComponent = this.myRotationStepDecreaseButtonBackground.addComponent('mesh');
        this.myRotationStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myRotationStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myRotationStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myRotationStepDecreaseButtonTextComponent = this.myRotationStepDecreaseButtonText.addComponent('text');
        this._setupTextComponent(this.myRotationStepDecreaseButtonTextComponent);
        this.myRotationStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;

        this.myRotationStepDecreaseButtonCursorTargetComponent = this.myRotationStepDecreaseButtonCursorTarget.addComponent('cursor-target');
        this.myRotationStepDecreaseButtonCollisionComponent = this.myRotationStepDecreaseButtonCursorTarget.addComponent('collision');
        this.myRotationStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myRotationStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myRotationStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        //Scale
        this.myScaleStepTextComponent = this.myScaleStepText.addComponent('text');
        this._setupTextComponent(this.myScaleStepTextComponent);
        this.myScaleStepTextComponent.text = " ";

        this.myScaleStepCursorTargetComponent = this.myScaleStepCursorTarget.addComponent('cursor-target');
        this.myScaleStepCollisionComponent = this.myScaleStepCursorTarget.addComponent('collision');
        this.myScaleStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myScaleStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myScaleStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;

        //Increase/Decrease
        this.myScaleStepIncreaseButtonBackgroundComponent = this.myScaleStepIncreaseButtonBackground.addComponent('mesh');
        this.myScaleStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myScaleStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myScaleStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myScaleStepIncreaseButtonTextComponent = this.myScaleStepIncreaseButtonText.addComponent('text');
        this._setupTextComponent(this.myScaleStepIncreaseButtonTextComponent);
        this.myScaleStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;

        this.myScaleStepIncreaseButtonCursorTargetComponent = this.myScaleStepIncreaseButtonCursorTarget.addComponent('cursor-target');
        this.myScaleStepIncreaseButtonCollisionComponent = this.myScaleStepIncreaseButtonCursorTarget.addComponent('collision');
        this.myScaleStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myScaleStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myScaleStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;

        this.myScaleStepDecreaseButtonBackgroundComponent = this.myScaleStepDecreaseButtonBackground.addComponent('mesh');
        this.myScaleStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
        this.myScaleStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
        this.myScaleStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;

        this.myScaleStepDecreaseButtonTextComponent = this.myScaleStepDecreaseButtonText.addComponent('text');
        this._setupTextComponent(this.myScaleStepDecreaseButtonTextComponent);
        this.myScaleStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;

        this.myScaleStepDecreaseButtonCursorTargetComponent = this.myScaleStepDecreaseButtonCursorTarget.addComponent('cursor-target');
        this.myScaleStepDecreaseButtonCollisionComponent = this.myScaleStepDecreaseButtonCursorTarget.addComponent('collision');
        this.myScaleStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myScaleStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myScaleStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    }

    _addPointerComponents() {
        this.myPointerCollisionComponent = this.myPointerCursorTarget.addComponent('collision');
        this.myPointerCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
        this.myPointerCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
        this.myPointerCollisionComponent.extents = this._mySetup.myPointerCollisionExtents;
    }

    _setupTextComponent(textComponent) {
        textComponent.alignment = this._mySetup.myTextAlignment;
        textComponent.justification = this._mySetup.myTextJustification;
        textComponent.material = this._myAdditionalSetup.myTextMaterial.clone();
        textComponent.material.outlineRange = this._mySetup.myTextOutlineRange;
        textComponent.material.color = this._mySetup.myTextColor;
        textComponent.material.outlineColor = this._mySetup.myTextOutlineColor;
        textComponent.text = "";
    }
};
PP.EasyTuneWidget = class EasyTuneWidget {

    constructor() {
        this._myIsStarted = false;
        this._myStartVariable = null;

        this._myWidgetFrame = new PP.WidgetFrame("E", 1);
        this._myWidgetFrame.registerWidgetVisibleChangedEventListener(this, this._widgetVisibleChanged.bind(this));

        this._mySetup = new PP.EasyTuneWidgetSetup();
        this._myAdditionalSetup = null;

        this._myWidgets = [];

        this._myEasyTuneVariables = null;
        this._myEasyTuneLastSize = 0;
        this._myVariableNames = null;

        this._myCurrentWidget = null;
        this._myCurrentVariable = null;

        this._myScrollVariableTimer = 0;

        this._myGamepad = null;

        this._myRefreshVariablesTimer = 0;

        this._myDirty = false;
    }

    setActiveVariable(variableName) {
        if (!this._myIsStarted) {
            this._myStartVariable = variableName;
        } else if (this._myEasyTuneVariables.has(variableName)) {
            this._myCurrentVariable = this._myEasyTuneVariables.get(variableName);
            this._selectCurrentWidget();
        } else {
            console.log("Can't set easy tune active variable");
        }
    }

    refresh() {
        if (this._myWidgetFrame.myIsWidgetVisible) {
            this._myDirty = true;
        }
    }

    start(parentObject, additionalSetup, easyTuneVariables) {
        this._myRightGamepad = PP.myRightGamepad; //@EDIT get right gamepad here based on how you store it in your game
        this._myLeftGamepad = PP.myLeftGamepad; //@EDIT get left gamepad here based on how you store it in your game
        if (this._mySetup.myGamepadHandedness == PP.ToolHandedness.RIGHT) {
            this._myGamepad = this._myRightGamepad;
        } else if (this._mySetup.myGamepadHandedness == PP.ToolHandedness.LEFT) {
            this._myGamepad = this._myLeftGamepad;
        }

        this._myIsStarted = true;

        this._myAdditionalSetup = additionalSetup;

        this._myWidgetFrame.start(parentObject, additionalSetup);

        this._myEasyTuneVariables = easyTuneVariables;
        this._myEasyTuneLastSize = this._myEasyTuneVariables.size;
        this._myVariableNames = Array.from(this._myEasyTuneVariables.keys());

        if (this._myEasyTuneVariables.size > 0) {
            this._myCurrentVariable = this._myEasyTuneVariables.get(this._myVariableNames[0]);
        }

        if (this._myStartVariable) {
            if (this._myEasyTuneVariables.has(this._myStartVariable)) {
                this._myCurrentVariable = this._myEasyTuneVariables.get(this._myStartVariable);
            } else {
                console.log("Can't set easy tune active variable");
            }
        }

        this._initializeWidgets();
    }

    update(dt) {
        this._myWidgetFrame.update(dt);

        if (this._myEasyTuneVariables.size != this._myEasyTuneLastSize || this._myDirty) {
            this._refreshEasyTuneVariables();
        }

        if (this._myWidgetFrame.myIsWidgetVisible && this._myEasyTuneVariables.size > 0) {
            if (this._mySetup.myRefreshVariablesDelay != null) {
                this._myRefreshVariablesTimer += dt;
                if (this._myRefreshVariablesTimer > this._mySetup.myRefreshVariablesDelay) {
                    this._myRefreshVariablesTimer = 0;
                    this._refreshEasyTuneVariables();
                }
            }

            if (this._myCurrentWidget) {
                this._myCurrentWidget.update(dt);
            }

            if (this._myAdditionalSetup.myEnableChangeVariableShortcut) {
                this._updateGamepadScrollVariable(dt);
            }
        }

        this._updateGamepadWidgetVisibility();

        this._updateActiveVariable();
    }

    _initializeWidgets() {
        this._myWidgets[PP.EasyTuneVariableType.NONE] = new PP.EasyTuneNoneWidget();
        this._myWidgets[PP.EasyTuneVariableType.NUMBER] = new PP.EasyTuneNumberWidget(this._myGamepad);
        this._myWidgets[PP.EasyTuneVariableType.BOOL] = new PP.EasyTuneBoolWidget(this._myGamepad);
        this._myWidgets[PP.EasyTuneVariableType.EASY_TRANSFORM] = new PP.EasyTuneSimpleTransformWidget(this._myGamepad);

        for (let item of this._myWidgets) {
            item.start(this._myWidgetFrame.getWidgetObject(), this._myAdditionalSetup);
            item.setVisible(false);
            item.registerScrollVariableRequestEventListener(this, this._scrollVariable.bind(this));
        }

        this._selectCurrentWidget();
    }

    _selectCurrentWidget() {
        if (this._myEasyTuneVariables.size <= 0) {
            return;
        }

        if (this._myCurrentWidget) {
            this._myCurrentWidget.setVisible(false);
        }

        if (this._myCurrentVariable.myType in this._myWidgets) {
            this._myCurrentWidget = this._myWidgets[this._myCurrentVariable.myType];
            this._myCurrentWidget.setEasyTuneVariable(this._myCurrentVariable, this._createIndexString());
            this._myCurrentWidget.setVisible(this._myWidgetFrame.myIsWidgetVisible);
        } else {
            this._myCurrentWidget = this._myWidgets[PP.EasyTuneVariableType.NONE];
            this._myCurrentWidget.setEasyTuneVariable(this._myCurrentVariable, this._createIndexString());
            this._myCurrentWidget.setVisible(this._myWidgetFrame.myIsWidgetVisible);
        }
    }

    _refreshEasyTuneVariables() {
        this._myVariableNames = Array.from(this._myEasyTuneVariables.keys());
        this._myEasyTuneLastSize = this._myEasyTuneVariables.size;

        if (this._myEasyTuneVariables.size > 0) {
            if (this._myCurrentVariable && this._myEasyTuneVariables.has(this._myCurrentVariable.myName)) {
                this._myCurrentVariable = this._myEasyTuneVariables.get(this._myCurrentVariable.myName);
            } else {
                this._myCurrentVariable = this._myEasyTuneVariables.get(this._myVariableNames[0]);
            }

            this._selectCurrentWidget();
        } else {
            this._myCurrentVariable = null;
            if (this._myCurrentWidget) {
                this._myCurrentWidget.setVisible(false);
                this._myCurrentWidget = null;
            }
        }

        this._myDirty = false;
    }

    _updateGamepadWidgetVisibility() {
        if (this._myGamepad) {
            if ((this._myGamepad.getButtonInfo(PP.ButtonType.BOTTOM_BUTTON).isPressStart() && this._myGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).myIsPressed) ||
                (this._myGamepad.getButtonInfo(PP.ButtonType.TOP_BUTTON).isPressStart() && this._myGamepad.getButtonInfo(PP.ButtonType.BOTTOM_BUTTON).myIsPressed)) {
                this._toggleVisibility();
            }
        }
    }

    _toggleVisibility() {
        this._myWidgetFrame.toggleVisibility();
    }

    _widgetVisibleChanged(visible) {
        if (this._myCurrentWidget) {
            if (this._myEasyTuneVariables.size > 0) {
                this._myCurrentWidget.setVisible(visible);
            } else {
                this._myCurrentWidget.setVisible(false);
            }
        }

        if (visible) {
            this._refreshEasyTuneVariables();
        }
    }

    _updateGamepadScrollVariable(dt) {
        if (this._myGamepad && (!this._mySetup.myScrollVariableButtonType || this._myGamepad.getButtonInfo(this._mySetup.myScrollVariableButtonType).myIsPressed)) {
            let x = this._myGamepad.getAxesInfo().myAxes[0];
            let y = this._myGamepad.getAxesInfo().myAxes[1];
            if (Math.abs(x) > this._mySetup.myScrollVariableMinXThreshold && Math.abs(y) < this._mySetup.myScrollVariableMaxYThreshold) {
                this._myScrollVariableTimer += dt;
                while (this._myScrollVariableTimer > this._mySetup.myScrollVariableDelay) {
                    this._myScrollVariableTimer -= this._mySetup.myScrollVariableDelay;
                    this._scrollVariable(Math.sign(x));
                }
            } else {
                this._myScrollVariableTimer = this._mySetup.myScrollVariableDelay;
            }
        } else {
            this._myScrollVariableTimer = this._mySetup.myScrollVariableDelay;
        }
    }

    _scrollVariable(amount) {
        if (this._myEasyTuneVariables.size <= 0) {
            return;
        }

        let variableIndex = this._getVariableIndex(this._myCurrentVariable);
        if (variableIndex >= 0) {
            let newIndex = (((variableIndex + amount) % this._myVariableNames.length) + this._myVariableNames.length) % this._myVariableNames.length; //manage negative numbers
            if (this._myEasyTuneVariables.has(this._myVariableNames[newIndex])) {
                this._myCurrentVariable = this._myEasyTuneVariables.get(this._myVariableNames[newIndex]);
                this._selectCurrentWidget();
            } else {
                this._refreshEasyTuneVariables();
            }
        } else {
            this._refreshEasyTuneVariables();
        }
    }

    _createIndexString() {
        let indexString = " (";
        let index = (this._getVariableIndex(this._myCurrentVariable) + 1).toString();
        let length = (this._myEasyTuneVariables.size).toString();
        while (index.length < length.length) {
            index = "0".concat(index);
        }

        indexString = indexString.concat(index).concat(" - ").concat(length).concat(")");

        return indexString;
    }

    _getVariableIndex(variable) {
        let variableIndex = this._myVariableNames.indexOf(variable.myName);
        return variableIndex;
    }

    _updateActiveVariable() {
        this._myEasyTuneVariables.forEach(function (value) {
            value.myIsActive = false;
        });

        if (this._myWidgetFrame.myIsWidgetVisible && this._myCurrentVariable) {
            this._myCurrentVariable.myIsActive = true;
        }
    }
};
PP.EasyTuneWidgetSetup = class EasyTuneWidgetSetup {

    constructor() {
        this._initializeRuntimeSetup();
    }

    _initializeRuntimeSetup() {
        this.myGamepadHandedness = PP.ToolHandedness.RIGHT;

        this.myScrollVariableDelay = 0.5;
        this.myScrollVariableMinXThreshold = 0.6;
        this.myScrollVariableMaxYThreshold = 0.25;
        this.myScrollVariableButtonType = null;

        this.myRefreshVariablesDelay = null;
    }
};
WL.registerComponent("pp-debug-axes", {
}, {
    init: function () {
    },
    start: function () {
        this._myDebugAxes = new PP.DebugAxes();
    },
    update: function (dt) {
        this._myDebugAxes.setTransform(this.object.transformWorld);
    }
});
class IAmHereWaveSetup {
    constructor() {
        this.myClonesCount = new RangeValueOverTime([1, 1], [1, 1], 0, 0, true);
        this.mySpawnConeAngle = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.myMinAngleBetweenClones = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.myWaveStartAngle = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.myTimeBetweenClones = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.mySameTimeBetweenClones = new RangeValueOverTime([-1, -1], [-1, -1], 0, 0, false); // >= 0 means true
        this.myFirstCloneInTheMiddle = true;
        this.myDoneDelay = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.myTimeBeforeStart = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);

        this.myDiscardOutsideValidAngle = new RangeValueOverTime([1, 1], [1, 1], 0, 0, false); // >= 0 means true

        this.myRefDirection = null;
    }

    createWave(ventRuntimeSetup, timeElapsed, refDirection = null) {
        return new IAmHereWave(ventRuntimeSetup, this, timeElapsed, refDirection);
    }

    getAverageClonesCount(timeElapsed) {
        return this.myClonesCount.getAverage(timeElapsed);
    }

    getPrecomputed(timeElapsed) {
        let setup = new IAmHereWaveSetup();

        setup.myClonesCount = this.myClonesCount.get(timeElapsed);
        setup.mySpawnConeAngle = this.mySpawnConeAngle.get(timeElapsed);
        setup.myMinAngleBetweenClones = this.myMinAngleBetweenClones.get(timeElapsed);
        setup.myWaveStartAngle = this.myWaveStartAngle.get(timeElapsed);
        setup.mySameTimeBetweenClones = this.mySameTimeBetweenClones.get(timeElapsed);
        if (setup.mySameTimeBetweenClones >= 0) {
            setup.myTimeBetweenClones = this.myTimeBetweenClones.get(timeElapsed);
        } else {
            setup.myTimeBetweenClones = this.myTimeBetweenClones;
        }

        setup.myFirstCloneInTheMiddle = this.myFirstCloneInTheMiddle;
        setup.myDoneDelay = this.myDoneDelay.get(timeElapsed);
        setup.myTimeBeforeStart = this.myTimeBeforeStart.get(timeElapsed);

        setup.myDiscardOutsideValidAngle = this.myDiscardOutsideValidAngle.get(timeElapsed);

        setup.myRefDirection = this.myRefDirection;

        return setup;
    }
}

class IAmHereWave {
    constructor(ventRuntimeSetup, waveSetup, timeElapsed, refDirection) {
        this._myGameTimeElapsed = timeElapsed;
        this._myWaveSetup = waveSetup;
        this._myVentRuntimeSetup = ventRuntimeSetup;

        this._myTotalClonesCount = this._myWaveSetup.myClonesCount.get(timeElapsed);
        this._myClonesCount = this._myTotalClonesCount;
        this._mySpawnConeAngle = this._myWaveSetup.mySpawnConeAngle.get(timeElapsed);
        this._myMinAngleBetweenClones = this._myWaveSetup.myMinAngleBetweenClones.get(timeElapsed);
        this._myPreviousAngle = 0;

        this._mySameTimeBetweenClones = waveSetup.mySameTimeBetweenClones.get(timeElapsed) >= 0;

        this._myDiscardOutsideValidAngle = waveSetup.myDiscardOutsideValidAngle.get(timeElapsed) >= 0;

        if (refDirection == null) {
            this._myRefDirectionParams = Global.myPlayerForward.pp_clone();
        } else {
            this._myRefDirectionParams = refDirection.pp_clone();
        }

        let spawnTimeMultiplier = this._myVentRuntimeSetup.myVentMultipliers.mySpawnTimeMultiplier.get(this._myGameTimeElapsed);
        this._myTimeBetweenClones = this._myWaveSetup.myTimeBetweenClones.get(this._myGameTimeElapsed) * spawnTimeMultiplier;

        this._mySpawnTimer = new PP.Timer(this._myWaveSetup.myTimeBeforeStart.get(this._myGameTimeElapsed) * spawnTimeMultiplier);
        let doneTimeMultiplier = this._myVentRuntimeSetup.myVentMultipliers.myDoneTimeMultiplier.get(this._myGameTimeElapsed);
        this._myDoneDelayTimer = new PP.Timer(this._myWaveSetup.myDoneDelay.get(this._myGameTimeElapsed) * doneTimeMultiplier, false);

        this._myFirst = true;
        this._myLastSign = null;

        this._myOneCloneSetupValid = false;
        this._myLastValidSpawnTimer = this._mySpawnTimer.getDuration();

        this._myFirstUpdate = true;

        this._myDuration = 0;
        this._myActualClonesCount = 0;
    }

    update(dt) {
        if (this.isDone()) {
            return [];
        }

        this._myDuration += dt;

        if (this._myFirstUpdate) {
            this._myFirstUpdate = false;
            this._computeWaveStartDirection(this._myRefDirectionParams);
        }

        let cloneSetups = [];

        if (this._mySpawnTimer.isRunning()) {
            this._mySpawnTimer.update(dt);
            if (this._mySpawnTimer.isDone()) {

                if (this._myClonesCount > 0) {
                    cloneSetups = this._createCloneSetups();

                    if (cloneSetups.length > 0) {
                        this._myClonesCount -= 1;
                    }

                    cloneSetups.pp_removeAll(element => element == null);

                    if (cloneSetups.length > 0) {
                        this._myOneCloneSetupValid = true;
                    }
                }

                if (this._myClonesCount <= 0) {
                    if (this._myOneCloneSetupValid) {
                        if (cloneSetups.length > 0) {
                            this._myDoneDelayTimer.start();
                        } else {
                            this._myDoneDelayTimer.start(this._myDoneDelayTimer.getDuration() - this._myLastValidSpawnTimer);
                        }
                    } else {
                        this._myDoneDelayTimer.start(0);
                    }
                } else {
                    if (cloneSetups.length > 0) {
                        this._mySpawnTimer.start(this._myTimeBetweenClones);
                        if (!this._mySameTimeBetweenClones) {
                            let spawnTimeMultiplier = this._myVentRuntimeSetup.myVentMultipliers.mySpawnTimeMultiplier.get(this._myGameTimeElapsed);
                            this._myTimeBetweenClones = this._myWaveSetup.myTimeBetweenClones.get(this._myGameTimeElapsed) * spawnTimeMultiplier;
                        }
                        this._myLastValidSpawnTimer = this._mySpawnTimer.getDuration();
                    } else {
                        this._mySpawnTimer.start(0);
                    }
                }
            }
        }

        if (this._myDoneDelayTimer.isRunning()) {
            this._myDoneDelayTimer.update(dt);
        }

        this._myActualClonesCount += cloneSetups.length;

        return cloneSetups;
    }

    getDuration() {
        return this._myDuration;
    }

    getActualClonesCount() {
        return this._myActualClonesCount;
    }

    getAverageClonesCount() {
        return this._myTotalClonesCount;
    }

    isDone() {
        return this._myDoneDelayTimer.isDone();
    }

    _createCloneSetups() {
        let cloneSetups = [];

        let direction = null;

        if (this._myFirst && this._myWaveSetup.myFirstCloneInTheMiddle) {
            this._myFirst = false;
            direction = this._myWaveStartDirection.pp_clone();
            direction.vec3_normalize(direction);

            this._myPreviousAngle = 0;
        } else {

            let attempts = 100;
            let angle = 0;

            let angleValid = false;
            let startDirection = [];
            while (attempts > 0) {
                if (this._myLastSign != null) {
                    angle = Math.pp_random(0, this._mySpawnConeAngle) * -this._myLastSign;
                } else {
                    angle = Math.pp_random(0, this._mySpawnConeAngle) * Math.pp_randomSign();
                }
                if (Math.pp_angleDistance(angle, this._myPreviousAngle) >= this._myMinAngleBetweenClones || this._myFirst) {
                    this._myWaveStartDirection.vec3_rotateAxis(angle, [0, 1, 0], startDirection);
                    angleValid = this._checkDirectionValid(startDirection);

                    if (angleValid) {
                        attempts = 0;
                    }
                }
                attempts--;
            }

            if (this._myLastSign == null) {
                this._myLastSign = Math.pp_sign(angle);
            } else {
                this._myLastSign *= -1;
            }

            direction = this._myWaveStartDirection.pp_clone();
            direction.vec3_rotateAxis(angle, [0, 1, 0], direction);
            direction.vec3_normalize(direction);
            this._myPreviousAngle = angle;

            this._myFirst = false;
        }

        let tempCloneSetups = this._createCloneSetupsWithDirection(direction);

        for (let cloneSetup of tempCloneSetups) {
            if (cloneSetup != null && (!this._myDiscardOutsideValidAngle || this._checkVentAngleValid(cloneSetup.myDirection))) {
                cloneSetups.push(cloneSetup);
            } else {
                cloneSetups.push(null);
            }
        }

        return cloneSetups;
    }

    _createCloneSetupsWithDirection(direction) {
        let cloneSetups = [];

        let cloneSetup = new MrNOTCloneSetup();
        cloneSetup.myDirection = direction;

        cloneSetups.push(cloneSetup);

        return cloneSetups;
    }

    _checkVentAngleValid(direction) {
        let angleValid = false;
        for (let range of this._myVentRuntimeSetup.myValidAngleRanges) {
            let angle = direction.vec3_angleSigned(range[1], [0, 1, 0]);
            if (range[0].isInsideAngle(angle, Global.myVentDuration)) {
                angleValid = true;
                break;
            }
        }

        return angleValid;
    }

    _checkDirectionValid(direction) {
        return this._checkVentAngleValid(direction);
    }

    _computeWaveStartDirection(refDirection) {
        if (this._myWaveSetup.myRefDirection != null) {
            refDirection = this._myWaveSetup.myRefDirection;
        } else if (refDirection == null) {
            refDirection = Global.myPlayerForward;
        }

        let attempts = 100;
        let angleValid = false;

        let flatRefDirection = refDirection.vec3_removeComponentAlongAxis([0, 1, 0]);

        let startDirection = [];
        while (attempts > 0 && !angleValid) {
            this._myWaveStartAngle = this._myWaveSetup.myWaveStartAngle.get(this._myGameTimeElapsed) * Math.pp_randomSign();
            flatRefDirection.vec3_rotateAxis(this._myWaveStartAngle, [0, 1, 0], startDirection);
            angleValid = this._checkDirectionValid(startDirection);

            attempts--;
        }

        this._myWaveStartDirection = flatRefDirection.vec3_rotateAxis(this._myWaveStartAngle, [0, 1, 0]);
        this._myWaveStartDirection.vec3_normalize(this._myWaveStartDirection);
    }
}
class NextWaveChanceBooster {
    constructor() {
        this._myWavesDataMap = new Map();
    }

    addSetup(id, setup) {
        let data = new NextWaveChanceBoosterData(setup);
        this._myWavesDataMap.set(id, data);
    }

    nextWaveSelected(selectedID, timeElapsed) {
        let selectedData = this._myWavesDataMap.get(selectedID);
        if (selectedData) {

            let group = selectedData.getBoostGroup();
            let divider = selectedData.getDivider(timeElapsed);

            for (let currentID of group) {
                let data = this._myWavesDataMap.get(currentID);
                data.divide(divider);
            }

            selectedData.reset();
        }
    }

    getChanceBoost(id, timeElapsed) {
        let data = this._myWavesDataMap.get(id);
        if (data) {
            return data.getChanceBoost(timeElapsed);
        }

        return 0;
    }

    getTimeSinceLastPick(id) {
        let data = this._myWavesDataMap.get(id);
        if (data) {
            return data.getTimeSinceLastPick();
        }

        return 0;
    }

    getBoostGroupName(id) {
        let data = this._myWavesDataMap.get(id);
        if (data) {
            return data.getBoostGroupName();
        }

        return "0";
    }

    update(dt, timeElapsed) {
        this._myWavesDataMap.forEach(function (data) { data.update(dt, timeElapsed); });
    }

    reset() {
        this._myWavesDataMap.forEach(function (data) { data.reset(); });
    }
}

class NextWaveChanceBoosterData {
    constructor(setup) {
        this._mySetup = setup;

        this._myTimeSinceLastPick = 0;
        this._myChanceBoost = 0;
    }

    update(dt, timeElapsed) {
        if (timeElapsed >= this._mySetup.myStartTime) {
            this._myTimeSinceLastPick += dt;
            this._myChanceBoost += dt;
        }
    }

    reset() {
        this._myTimeSinceLastPick = 0;
        this._myChanceBoost = this._mySetup.myBoostValueOnReset;
    }

    getTimeSinceLastPick() {
        return this._myTimeSinceLastPick;
    }

    getChanceBoost(timeElapsed) {
        let damping = this._mySetup.myDampingOverLastPick.get(this._myTimeSinceLastPick);
        let chanceBoost = this._myChanceBoost + damping;

        if (chanceBoost >= 0) {
            chanceBoost = this._myChanceBoost * this._mySetup.myBoostMultiplier.get(timeElapsed);
        }

        return chanceBoost;
    }

    getBoostGroup() {
        return this._mySetup.myBoostGroup;
    }

    getBoostGroupName() {
        return this._mySetup.myBoostGroupName;
    }

    divide(divider) {
        if (this._myChanceBoost > 0) {
            this._myChanceBoost /= divider;
        }
    }

    getDivider(timeElapsed) {
        return this._mySetup.myBoostDivider.get(timeElapsed);
    }
}

class NextWaveChanceBoosterSetup {
    constructor(startTime, boostGroup, boostGroupName, dampingOverLastPick, boostMultiplier, boostDivider, boostValueOnReset) {
        this.myStartTime = startTime;
        this.myBoostGroup = boostGroup;
        this.myBoostGroupName = boostGroupName;
        this.myDampingOverLastPick = dampingOverLastPick;
        this.myBoostMultiplier = boostMultiplier;
        this.myBoostDivider = boostDivider;
        this.myBoostValueOnReset = boostValueOnReset;
    }
}
class NextWavesSetup {
    constructor() {
        this._myNextWaves = [];
    }

    addWave(waveID, chance, startTime = 0, endTime = null) {
        let wave = new NextWaveSetup(waveID, chance, startTime, endTime);
        this._myNextWaves.push(wave);
    }

    removeWave(waveID) {
        this._myNextWaves.pp_removeAll(element => element.myWaveID == waveID);
    }

    getNextWave(timeElapsed, booster) {
        let validWaves = [];
        let totalChance = 0;
        for (let i = 0; i < this._myNextWaves.length; i++) {
            let waveToCheck = this._myNextWaves[i];
            if (waveToCheck.myStartTime <= timeElapsed && (waveToCheck.myEndTime == null || waveToCheck.myEndTime > timeElapsed)) {
                if (waveToCheck.myChance.get(timeElapsed) >= 1) {
                    validWaves.push(waveToCheck);

                    let minChance = 10;
                    totalChance += Math.max(minChance, Math.floor(waveToCheck.myChance.get(timeElapsed) + booster.getChanceBoost(waveToCheck.myWaveID, timeElapsed)));
                }
            }
        }

        if (validWaves.length == 0) {
            validWaves.push(this._myNextWaves[0]);
            console.error("No valid next wave found, how?");
        }

        let nextWave = null;
        let randomChance = Math.pp_random(0, totalChance);
        let currentChance = 0;
        for (let i = 0; i < validWaves.length; i++) {
            let validWave = validWaves[i];

            let minChance = 10;
            currentChance += Math.max(minChance, Math.floor(validWave.myChance.get(timeElapsed) + booster.getChanceBoost(validWave.myWaveID, timeElapsed)));
            if (randomChance < currentChance) {
                nextWave = validWave;
                break;
            }
        }

        if (nextWave == null) {
            nextWave = validWaves[validWaves.length - 1];
            console.error("No random wave found, how?");
        }

        //validWavesGlobal = validWaves;

        //console.warn(booster.getBoostGroupName(nextWave.myWaveID), "-", booster.getChanceBoost(nextWave.myWaveID).toFixed(3), "-", booster.getTimeSinceLastPick(nextWave.myWaveID).toFixed(3), "-", nextWave.myWaveID);

        return nextWave.myWaveID;
    }
}

//var validWavesGlobal = null;

class NextWaveSetup {
    constructor(waveID, chance, startTime, endTime) {
        this.myWaveID = waveID;
        this.myChance = chance;
        this.myStartTime = startTime;
        this.myEndTime = endTime;
    }
}
class ValueOverTime {
    constructor(startValue, endValue, startTime, endTime, isInt = false) {
        this._myStartValue = startValue;
        this._myEndValue = endValue;
        this._myStartTime = startTime;
        this._myEndTime = endTime;
        this._myIsInt = isInt;

        this._myUseFloor = this._myStartValue <= this._myEndValue;
    }

    get(timeElapsed) {
        let interpolationValue = Math.pp_mapToRange(timeElapsed, this._myStartTime, this._myEndTime, 0, 1);
        let lerpValue = Math.pp_lerp(this._myStartValue, this._myEndValue, interpolationValue);

        if (this._myIsInt) {
            if (this._myUseFloor) {
                lerpValue = Math.floor(lerpValue);
            } else {
                lerpValue = Math.ceil(lerpValue);
            }
        }

        return lerpValue;
    }

    getAverage(timeElapsed) {
        return this.get(timeElapsed);
    }
}

class RangeValueOverTime {
    constructor(startRange, endRange, startTime, endTime, isInt = false) {
        this._myRangeStartValue = new ValueOverTime(startRange[0], endRange[0], startTime, endTime, isInt);
        this._myRangeEndValue = new ValueOverTime(startRange[1], endRange[1], startTime, endTime, isInt);
        this._myIsInt = isInt;
    }

    get(timeElapsed) {
        let startValue = this._myRangeStartValue.get(timeElapsed);
        let endValue = this._myRangeEndValue.get(timeElapsed);

        let randomValue = null;

        if (this._myIsInt) {
            randomValue = Math.pp_randomInt(startValue, endValue);
        } else {
            randomValue = Math.pp_random(startValue, endValue);
        }

        return randomValue;
    }

    isInside(value, timeElapsed) {
        let startValue = this._myRangeStartValue.get(timeElapsed);
        let endValue = this._myRangeEndValue.get(timeElapsed);

        let min = Math.min(startValue, endValue);
        let max = Math.max(startValue, endValue);

        return value >= min && value <= max;
    }

    isInsideAngle(value, timeElapsed) {
        let startValue = this._myRangeStartValue.get(timeElapsed);
        let endValue = this._myRangeEndValue.get(timeElapsed);

        return Math.pp_isInsideAngleRange(value, startValue, endValue);
    }

    getAverage(timeElapsed) {
        let startValue = this._myRangeStartValue.get(timeElapsed);
        let endValue = this._myRangeEndValue.get(timeElapsed);

        let average = (startValue + endValue) / 2;
        if (this._myIsInt) {
            average = Math.round(average);
        }

        return average;
    }
}

class RangeValue {
    constructor(range, isInt = false) {
        this._myRange = range;
        this._myIsInt = isInt;
    }

    get() {
        let randomValue = null;

        if (this._myIsInt) {
            randomValue = Math.pp_randomInt(this._myRange[0], this._myRange[1]);
        } else {
            randomValue = Math.pp_random(this._myRange[0], this._myRange[1]);
        }

        return randomValue;
    }

    isInside(value) {
        let min = Math.min(this._myRange[0], this._myRange[1]);
        let max = Math.max(this._myRange[0], this._myRange[1]);

        return value >= min && value <= max;
    }

    isInsideAngle(value) {
        return Math.pp_isInsideAngleRange(value, this._myRange[0], this._myRange[1]);
    }

    getAverage(timeElapsed) {
        let average = (this._myRange[0] + this._myRange[1]) / 2;
        if (this._myIsInt) {
            average = Math.round(average);
        }

        return average;
    }
}

Number.prototype.get = function () {
    return this.valueOf();
};

Number.prototype.getAverage = function () {
    return this.valueOf();
};
class WaveOfWavesSetup {
    constructor() {
        this.myWavesCount = new RangeValueOverTime([1, 1], [1, 1], 0, 0, true);
        this.myTimeBetweenWaves = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.mySameTimeBetweenWaves = new RangeValueOverTime([-1, -1], [-1, -1], 0, 0, false); // >= 0 means true
        this.myDoneDelay = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.myTimeBeforeStart = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);

        this.myWaveStartAngle = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);

        this.myWavesSetup = []; // every item is an array, 0 is a wave setup, 1 is the chance, 2 is the debug name
        this.myWavesSetupPickOne = new RangeValueOverTime([-1, -1], [-1, -1], 0, 0, false); // >= 0 means true
        this.myWavesSetupPrecompute = new RangeValueOverTime([-1, -1], [-1, -1], 0, 0, false); // >= 0 means true
    }

    getAverageClonesCount(timeElapsed) {
        let average = 0;
        for (let waveSetup of this.myWavesSetup) {
            average += waveSetup[0].getAverageClonesCount(timeElapsed);
        }
        average = average / this.myWavesSetup.length;

        return Math.round(this.myWavesCount.getAverage(timeElapsed) * average);
    }

    getPrecomputed(timeElapsed) {
        let setup = new WaveOfWavesSetup();

        setup.myWavesCount = this.myWavesCount.get(timeElapsed);
        setup.mySameTimeBetweenWaves = this.mySameTimeBetweenWaves.get(timeElapsed);
        if (setup.mySameTimeBetweenWaves >= 0) {
            setup.myTimeBetweenWaves = this.myTimeBetweenWaves.get(timeElapsed);
        } else {
            setup.myTimeBetweenWaves = this.myTimeBetweenWaves;
        }
        setup.myDoneDelay = this.myDoneDelay.get(timeElapsed);
        setup.myTimeBeforeStart = this.myTimeBeforeStart.get(timeElapsed);

        setup.myWaveStartAngle = this.myWaveStartAngle.get(timeElapsed);

        setup.myWavesSetup = this.myWavesSetup.pp_clone();
        setup.myWavesSetupPickOne = this.myWavesSetupPickOne.get(timeElapsed);
        setup.myWavesSetupPrecompute = this.myWavesSetupPrecompute.get(timeElapsed);

        if (setup.myWavesSetup.length == 0) {
            setup.myWavesSetup.push([new IAmHereWaveSetup(), 1, "I_Am_Here"]);
        }

        if (setup.myWavesSetupPickOne >= 0) {
            setup._pickOneWave(timeElapsed);
        }

        if (setup.myWavesSetupPrecompute >= 0) {
            let wavesSetup = setup.myWavesSetup;
            setup.myWavesSetup = [];
            for (let setup of wavesSetup) {
                setup.myWavesSetup.push([setup[0].getPrecomputed(timeElapsed), setup[1], setup[2]]);
            }
        }

        return setup;
    }

    _pickOneWave(timeElapsed) {
        let wave = this.myWavesSetup[0][0];
        let name = this.myWavesSetup[0][2];

        let totalChance = 0;
        for (let waveSetup of this.myWavesSetup) {
            totalChance += Math.floor(waveSetup[1].get(timeElapsed));
        }

        let randomChance = Math.pp_randomInt(1, totalChance);
        let currentChance = 0;
        for (let waveSetup of this.myWavesSetup) {
            currentChance += Math.floor(waveSetup[1].get(timeElapsed));
            if (randomChance <= currentChance) {
                wave = waveSetup[0];
                name = waveSetup[2];
                break;
            }
        }

        this.myWavesSetup = [];
        this.myWavesSetup.push([wave, 1, name]);
    }
}

class WaveOfWaves {
    constructor(ventRuntimeSetup, waveSetup, timeElapsed, refDirection) {
        this._myGameTimeElapsed = timeElapsed;
        this._myWaveSetup = waveSetup;
        this._myVentRuntimeSetup = ventRuntimeSetup;
        this._mySpawnWavesSetup = waveSetup.myWavesSetup.pp_clone();

        if (this._mySpawnWavesSetup.length == 0) {
            this._mySpawnWavesSetup.push([new IAmHereWaveSetup(), 1, "I_Am_Here"]);
        }

        if (waveSetup.myWavesSetupPickOne.get(timeElapsed) >= 0) {
            this._getWaveSetup(true);
        }

        if (waveSetup.myWavesSetupPrecompute.get(timeElapsed) >= 0) {
            let wavesSetup = this._mySpawnWavesSetup;
            this._mySpawnWavesSetup = [];
            for (let setup of wavesSetup) {
                this._mySpawnWavesSetup.push([setup[0].getPrecomputed(this._myGameTimeElapsed), setup[1], setup[2]]);
            }
        }

        this._myTotalWavesCount = this._myWaveSetup.myWavesCount.get(timeElapsed);
        this._myWavesCount = this._myTotalWavesCount;
        this._mySameTimeBetweenWaves = waveSetup.mySameTimeBetweenWaves.get(timeElapsed) >= 0;

        let spawnTimeMultiplier = this._myVentRuntimeSetup.myVentMultipliers.mySpawnTimeMultiplier.get(this._myGameTimeElapsed);
        this._myTimeBetweenWaves = this._myWaveSetup.myTimeBetweenWaves.get(this._myGameTimeElapsed) * spawnTimeMultiplier;
        this._mySpawnTimer = new PP.Timer(this._myWaveSetup.myTimeBeforeStart.get(this._myGameTimeElapsed) * spawnTimeMultiplier);
        let doneTimeMultiplier = this._myVentRuntimeSetup.myVentMultipliers.myDoneTimeMultiplier.get(this._myGameTimeElapsed);
        this._myDoneDelayTimer = new PP.Timer(this._myWaveSetup.myDoneDelay.get(this._myGameTimeElapsed) * doneTimeMultiplier, false);

        this._computeWaveStartDirection(refDirection);

        this._myCurrentWaves = [];

        this._myDebugActive = false;

        this._myOneCloneSetupValid = false;
        this._myOneCloneSetupValidCurrentWave = false;
        this._myLastValidSpawnTimer = this._mySpawnTimer.getDuration();

        this._myDuration = 0;
        this._myActualClonesCount = 0;
    }

    update(dt) {
        if (this.isDone()) {
            return [];
        }

        this._myDuration += dt;

        let cloneSetups = [];

        if (this._mySpawnTimer.isRunning()) {
            this._mySpawnTimer.update(dt);
            if (this._mySpawnTimer.isDone()) {
                if (this._myWavesCount > 0) {
                    this._myOneCloneSetupValidCurrentWave = false;
                    this._myCurrentWaves = this._createNextWaves();
                    this._myWavesCount -= this._myCurrentWaves.length;
                }
            }
        }

        for (let wave of this._myCurrentWaves) {
            if (wave != null) {
                let innerCloneSetups = wave.update(dt);
                cloneSetups.push(...innerCloneSetups);
            }
        }

        if (cloneSetups.length > 0) {
            this._myOneCloneSetupValid = true;
            this._myOneCloneSetupValidCurrentWave = true;
        }

        this._myCurrentWaves.pp_removeAll(element => element == null || element.isDone());

        if (this._myCurrentWaves.length == 0 && this._myWavesCount > 0 && !this._mySpawnTimer.isRunning()) {
            if (this._myOneCloneSetupValidCurrentWave) {
                this._mySpawnTimer.start(this._getSpawnTimer());
                this._myLastValidSpawnTimer = this._mySpawnTimer.getDuration();
            } else {
                this._mySpawnTimer.start(0);
            }
        } else if (!this._myDoneDelayTimer.isRunning() && this._myWavesCount <= 0 && this._myCurrentWaves.length == 0) {
            if (this._myOneCloneSetupValid) {
                if (this._myOneCloneSetupValidCurrentWave) {
                    this._myDoneDelayTimer.start();
                } else {
                    this._myDoneDelayTimer.start(this._myDoneDelayTimer.getDuration() - this._myLastValidSpawnTimer);
                }
            } else {
                this._myDoneDelayTimer.start(0);
            }
        }

        if (this._myDoneDelayTimer.isRunning()) {
            this._myDoneDelayTimer.update(dt);
        }

        this._myActualClonesCount += cloneSetups.length;

        return cloneSetups;
    }

    isDone() {
        return this._myDoneDelayTimer.isDone();
    }

    getActualClonesCount() {
        return this._myActualClonesCount;
    }

    getDuration() {
        return this._myDuration;
    }

    getAverageClonesCount() {
        let average = 0;
        for (let waveSetup of this._mySpawnWavesSetup) {
            average += waveSetup[0].getAverageClonesCount(this._myGameTimeElapsed);
        }
        average = average / this._mySpawnWavesSetup.length;

        return Math.round(this._myTotalWavesCount * average);
    }

    _createNextWaves() {
        let waves = [];

        return waves;
    }

    _getSpawnTimer() {
        if (!this._mySameTimeBetweenWaves) {
            let spawnTimeMultiplier = this._myVentRuntimeSetup.myVentMultipliers.mySpawnTimeMultiplier.get(this._myGameTimeElapsed);
            this._myTimeBetweenWaves = this._myWaveSetup.myTimeBetweenWaves.get(this._myGameTimeElapsed) * spawnTimeMultiplier;
        }

        return this._myTimeBetweenWaves;
    }

    _getWaveSetup(setWaveSetup = false) {
        let wave = this._mySpawnWavesSetup[0][0];
        let name = this._mySpawnWavesSetup[0][2];

        let totalChance = 0;
        for (let waveSetup of this._mySpawnWavesSetup) {
            totalChance += Math.floor(waveSetup[1].get(this._myGameTimeElapsed));
        }

        let randomChance = Math.pp_randomInt(1, totalChance);
        let currentChance = 0;
        for (let waveSetup of this._mySpawnWavesSetup) {
            currentChance += Math.floor(waveSetup[1].get(this._myGameTimeElapsed));
            if (randomChance <= currentChance) {
                wave = waveSetup[0];
                name = waveSetup[2];
                break;
            }
        }

        if (setWaveSetup) {
            this._mySpawnWavesSetup = [];
            this._mySpawnWavesSetup.push([wave, 1, name]);
        } else if (this._myDebugActive && this._mySpawnWavesSetup.length > 1) {
            console.log("   Wave -", name);
        }

        return wave;
    }

    _checkVentAngleValid(direction) {
        let angleValid = false;
        for (let range of this._myVentRuntimeSetup.myValidAngleRanges) {
            let angle = direction.vec3_angleSigned(range[1], [0, 1, 0]);
            if (range[0].isInsideAngle(angle, Global.myVentDuration)) {
                angleValid = true;
                break;
            }
        }

        return angleValid;
    }

    _computeWaveStartDirection(refDirection) {
        if (refDirection == null) {
            refDirection = Global.myPlayerForward;
        }

        let attempts = 100;
        let angleValid = false;

        let flatRefDirection = refDirection.vec3_removeComponentAlongAxis([0, 1, 0]);

        while (attempts > 0 && !angleValid) {
            this._myWaveStartAngle = this._myWaveSetup.myWaveStartAngle.get(this._myGameTimeElapsed) * Math.pp_randomSign();
            let startDirection = flatRefDirection.vec3_rotateAxis(this._myWaveStartAngle, [0, 1, 0]);
            angleValid = this._checkVentAngleValid(startDirection);

            attempts--;
        }

        this._myWaveStartDirection = flatRefDirection.vec3_rotateAxis(this._myWaveStartAngle, [0, 1, 0]);
        this._myWaveStartDirection.vec3_normalize(this._myWaveStartDirection);
    }
}

class ZeroWaveSetup {
    constructor() {
    }

    createWave(ventRuntimeSetup, timeElapsed, refDirection = null) {
        return new ZeroWave();
    }

    getAverageClonesCount(timeElapsed) {
        return 0;
    }
}

class ZeroWave {
    constructor() {
    }

    update(dt) {
        let cloneSetups = [];
        return cloneSetups;
    }

    getDuration() {
        return 0;
    }

    getActualClonesCount() {
        return 0;
    }

    getAverageClonesCount() {
        return 0;
    }

    isDone() {
        return true;
    }
}
class GiveUsAHugSetup extends IAmHereWaveSetup {
    constructor() {
        super();

        this.myHugSize = new RangeValueOverTime([2, 2], [2, 2], 0, 0, true);
        this.myHugAngle = new RangeValueOverTime([40, 40], [40, 40], 0, 0, false);
        this.mySameHugAngle = new RangeValueOverTime([-1, -1], [-1, -1], 0, 0, false); // >= 0 means true
        this.mySameHugSize = new RangeValueOverTime([1, 1], [1, 1], 0, 0, false); // >= 0 means true

        this.myHugClonesSameDistance = new RangeValueOverTime([1, 1], [1, 1], 0, 0, false); // >= 0 means true
        this.myMinAngleBetweenClonesHugging = new RangeValueOverTime([30, 30], [30, 30], 0, 0, false);
    }

    createWave(ventRuntimeSetup, timeElapsed, refDirection = null) {
        return new GiveUsAHug(ventRuntimeSetup, this, timeElapsed, refDirection);
    }

    getAverageClonesCount(timeElapsed) {
        return this.myClonesCount.getAverage(timeElapsed) * this.myHugSize.getAverage(timeElapsed);
    }

    getPrecomputed(timeElapsed) {
        let setup = new GiveUsAHugSetup();

        setup.myClonesCount = this.myClonesCount.get(timeElapsed);
        setup.mySpawnConeAngle = this.mySpawnConeAngle.get(timeElapsed);
        setup.myMinAngleBetweenClones = this.myMinAngleBetweenClones.get(timeElapsed);
        setup.myWaveStartAngle = this.myWaveStartAngle.get(timeElapsed);
        setup.mySameTimeBetweenClones = this.mySameTimeBetweenClones.get(timeElapsed);
        if (setup.mySameTimeBetweenClones >= 0) {
            setup.myTimeBetweenClones = this.myTimeBetweenClones.get(timeElapsed);
        } else {
            setup.myTimeBetweenClones = this.myTimeBetweenClones;
        }

        setup.myFirstCloneInTheMiddle = this.myFirstCloneInTheMiddle;
        setup.myDoneDelay = this.myDoneDelay.get(timeElapsed);
        setup.myTimeBeforeStart = this.myTimeBeforeStart.get(timeElapsed);

        setup.myDiscardOutsideValidAngle = this.myDiscardOutsideValidAngle.get(timeElapsed);

        setup.myRefDirection = this.myRefDirection;

        setup.mySameHugAngle = this.mySameHugAngle.get(timeElapsed);
        if (setup.mySameHugAngle >= 0) {
            setup.myHugAngle = this.myHugAngle.get(timeElapsed);
        } else {
            setup.myHugAngle = this.myHugAngle;
        }
        setup.mySameHugSize = this.mySameHugSize.get(timeElapsed);
        if (setup.mySameHugSize >= 0) {
            setup.myHugSize = this.myHugSize.get(timeElapsed);
        } else {
            setup.myHugSize = this.myHugSize;
        }

        setup.myHugClonesSameDistance = this.myHugClonesSameDistance.get(timeElapsed);
        setup.myMinAngleBetweenClonesHugging = this.myMinAngleBetweenClonesHugging.get(timeElapsed);

        return setup;
    }
}

class GiveUsAHug extends IAmHereWave {
    constructor(ventRuntimeSetup, waveSetup, timeElapsed, refDirection) {
        super(ventRuntimeSetup, waveSetup, timeElapsed, refDirection);

        this._myHugSize = waveSetup.myHugSize.get(timeElapsed);
        this._myHugAngle = waveSetup.myHugAngle.get(timeElapsed);
        this._mySameHugAngle = waveSetup.mySameHugAngle.get(timeElapsed) >= 0;
        this._mySameHugSize = waveSetup.mySameHugSize.get(timeElapsed) >= 0;
        this._myHugClonesSameDistance = waveSetup.myHugClonesSameDistance.get(timeElapsed) >= 0;
        this._myMinAngleBetweenClonesHugging = waveSetup.myMinAngleBetweenClonesHugging.get(timeElapsed);
    }

    getAverageClonesCount() {
        return this._myTotalClonesCount * this._myHugSize;
    }

    _createCloneSetupsWithDirection(direction) {
        let cloneSetups = [];

        if (this._myHugClonesSameDistance) {
            let totalAngle = this._myHugAngle * 2;
            let sliceAngle = totalAngle / (this._myHugSize - 1);

            let startAngle = -this._myHugAngle;

            for (let i = 0; i < this._myHugSize; i++) {
                let angle = startAngle + sliceAngle * i;

                let cloneSetup = new MrNOTCloneSetup();
                cloneSetup.myDirection = direction.pp_clone();
                cloneSetup.myDirection.vec3_rotateAxis(angle, [0, 1, 0], cloneSetup.myDirection);
                if (this._areFarEnough(cloneSetup, cloneSetups)) {
                    cloneSetups.push(cloneSetup);
                } else {
                    cloneSetups.push(null);
                }
            }
        } else {
            let previousAngles = [];
            for (let i = 0; i < this._myHugSize; i++) {
                let attempts = 100;
                let angle = 0;

                let startDirection = [];
                while (attempts > 0) {
                    angle = Math.pp_random(0, this._myHugAngle) * Math.pp_randomSign();
                    let angleValid = true;

                    for (let previousAngle of previousAngles) {
                        if (Math.pp_angleDistance(angle, previousAngle) < this._myMinAngleBetweenClonesHugging) {
                            angleValid = false;
                            break;
                        }
                    }

                    if (angleValid) {
                        direction.vec3_rotateAxis(angle, [0, 1, 0], startDirection);
                        angleValid = this._checkVentAngleValid(startDirection);

                        if (angleValid) {
                            attempts = 0;
                        }
                    }

                    attempts--;
                }

                previousAngles.push(angle);

                let cloneSetup = new MrNOTCloneSetup();
                cloneSetup.myDirection = direction.pp_clone();
                cloneSetup.myDirection.vec3_rotateAxis(angle, [0, 1, 0], cloneSetup.myDirection);
                if (this._areFarEnough(cloneSetup, cloneSetups)) {
                    cloneSetups.push(cloneSetup);
                } else {
                    cloneSetups.push(null);
                }
            }
        }

        if (!this._mySameHugAngle) {
            this._myHugAngle = this._myWaveSetup.myHugAngle.get(this._myGameTimeElapsed);
        }

        if (!this._mySameHugSize) {
            this._myHugSize = this._myWaveSetup.myHugSize.get(this._myGameTimeElapsed);
        }

        return cloneSetups;
    }

    _areFarEnough(cloneSetupToTest, cloneSetups) {
        let valid = true;
        for (let cloneSetup of cloneSetups) {
            if (cloneSetup != null && cloneSetup.myDirection.vec3_angle(cloneSetupToTest.myDirection) < this._myMinAngleBetweenClonesHugging) {
                valid = false;
                break;
            }
        }

        return valid;
    }

    _checkDirectionValid(direction) {
        let isValid = true;

        if (this._myHugClonesSameDistance) {
            let totalAngle = this._myHugAngle * 2;
            let sliceAngle = totalAngle / (this._myHugSize - 1);

            let startAngle = -this._myHugAngle;

            let cloneDirection = direction.pp_clone();
            for (let i = 0; i < this._myHugSize; i++) {
                let angle = startAngle + sliceAngle * i;

                cloneDirection.pp_copy(direction);
                cloneDirection.vec3_rotateAxis(angle, [0, 1, 0], cloneDirection);
                if (!this._checkVentAngleValid(cloneDirection)) {
                    isValid = false;
                    break;
                }
            }
        } else {
            isValid = super._checkDirectionValid(direction);
        }

        return isValid;
    }
}
class IAmEverywhereWaveSetup extends WaveOfWavesSetup {
    constructor() {
        super();

        this.myAngleBetweenWaves = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
    }

    createWave(ventRuntimeSetup, timeElapsed, refDirection = null) {
        return new IAmEverywhereWave(ventRuntimeSetup, this, timeElapsed, refDirection);
    }
}

class IAmEverywhereWave extends WaveOfWaves {
    constructor(ventRuntimeSetup, waveSetup, timeElapsed, refDirection) {
        super(ventRuntimeSetup, waveSetup, timeElapsed, refDirection);

        this._myCurrentDirection = this._myWaveStartDirection.pp_clone();
        this._myFirst = true;
    }

    _createNextWaves() {
        let waves = [];

        if (!this._myFirst) {
            let angle = 0;
            let attempts = 100;

            let startDirection = [];
            while (attempts > 0) {
                angle = this._myWaveSetup.myAngleBetweenWaves.get(this._myGameTimeElapsed) * Math.pp_randomSign();

                this._myCurrentDirection.vec3_rotateAxis(angle, [0, 1, 0], startDirection);
                let angleValid = this._checkVentAngleValid(startDirection);

                if (angleValid) {
                    attempts = 0;
                }

                attempts--;
            }

            this._myCurrentDirection.vec3_rotateAxis(angle, [0, 1, 0], this._myCurrentDirection);
        } else {
            this._myFirst = false;
        }

        let direction = this._myCurrentDirection.pp_clone();
        direction.vec3_normalize(direction);

        waves.push(this._getWaveSetup().createWave(this._myVentRuntimeSetup, this._myGameTimeElapsed, direction));

        return waves;
    }
}
class ManInTheMiddleSetup extends WaveOfWavesSetup {
    constructor() {
        super();

        this.myAngleBetweenWaves = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.myTimeBeforeOpposite = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.mySameOppositeTimeBetweenWaves = new RangeValueOverTime([1, 1], [1, 1], 0, 0, false); // >= 0 means true
        this.myOppositeTimeAsTimeBetweenWaves = new RangeValueOverTime([1, 1], [1, 1], 0, 0, false); // >= 0 means true

        this.myOppositeTimeLessThanTimeBetweenWaves = new RangeValueOverTime([1, 1], [1, 1], 0, 0, false); // >= 0 means true
        this.myAllSameTimes = null;

        this.mySameTimeBetweenWaves = new RangeValueOverTime([1, 1], [1, 1], 0, 0, false); // >= 0 means true
    }

    createWave(ventRuntimeSetup, timeElapsed, refDirection = null) {
        return new ManInTheMiddle(ventRuntimeSetup, this, timeElapsed, refDirection);
    }

    getPrecomputed(timeElapsed) {
        let setup = new ManInTheMiddleSetup();

        setup.myWavesCount = this.myWavesCount.get(timeElapsed);
        setup.mySameTimeBetweenWaves = this.mySameTimeBetweenWaves.get(timeElapsed);
        setup.myDoneDelay = this.myDoneDelay.get(timeElapsed);
        setup.myTimeBeforeStart = this.myTimeBeforeStart.get(timeElapsed);

        setup.myWaveStartAngle = this.myWaveStartAngle.get(timeElapsed);

        setup.myWavesSetup = this.myWavesSetup.pp_clone();
        setup.myWavesSetupPickOne = this.myWavesSetupPickOne.get(timeElapsed);
        setup.myWavesSetupPrecompute = this.myWavesSetupPrecompute.get(timeElapsed);

        setup.myAngleBetweenWaves = this.myAngleBetweenWaves.get(timeElapsed);
        setup.mySameOppositeTimeBetweenWaves = this.mySameOppositeTimeBetweenWaves.get(timeElapsed);
        setup.myOppositeTimeAsTimeBetweenWaves = this.myOppositeTimeAsTimeBetweenWaves.get(timeElapsed);

        setup.myOppositeTimeLessThanTimeBetweenWaves = this.myOppositeTimeLessThanTimeBetweenWaves.get(timeElapsed);

        setup.myAllSameTimes = this.myAllSameTimes;
        if (setup.myAllSameTimes != null) {
            setup.myAllSameTimes = setup.myAllSameTimes.get(timeElapsed);
            if (setup.myAllSameTimes >= 0) {
                setup.myOppositeTimeAsTimeBetweenWaves = 1;
                setup.mySameOppositeTimeBetweenWaves = 1;
                setup.mySameTimeBetweenWaves = 1;
            } else {
                setup.myOppositeTimeAsTimeBetweenWaves = -1;
                setup.mySameOppositeTimeBetweenWaves = -1;
                setup.mySameTimeBetweenWaves = -1;
            }
        }

        if (setup.mySameTimeBetweenWaves >= 0) {
            setup.myTimeBetweenWaves = this.myTimeBetweenWaves.get(timeElapsed);
        } else {
            setup.myTimeBetweenWaves = this.myTimeBetweenWaves;
        }

        if (setup.mySameOppositeTimeBetweenWaves >= 0) {
            setup.myTimeBeforeOpposite = this.myTimeBeforeOpposite.get(timeElapsed);
        } else {
            setup.myTimeBeforeOpposite = this.myTimeBeforeOpposite;
        }

        if (setup.myWavesSetup.length == 0) {
            setup.myWavesSetup.push([new IAmHereWaveSetup(), 1, "I_Am_Here"]);
        }

        if (setup.myWavesSetupPickOne >= 0) {
            setup._pickOneWave(timeElapsed);
        }

        if (setup.myWavesSetupPrecompute >= 0) {
            let wavesSetup = setup.myWavesSetup;
            setup.myWavesSetup = [];
            for (let setup of wavesSetup) {
                setup.myWavesSetup.push([setup[0].getPrecomputed(timeElapsed), setup[1], setup[2]]);
            }
        }

        return setup;
    }
}

class ManInTheMiddle extends WaveOfWaves {
    constructor(ventRuntimeSetup, waveSetup, timeElapsed, refDirection) {
        super(ventRuntimeSetup, waveSetup, timeElapsed, refDirection);

        this._myWavesCount *= 2;
        this._myOppositeTimeAsTimeBetweenWaves = waveSetup.myOppositeTimeAsTimeBetweenWaves.get(timeElapsed) >= 0;
        this._mySameOppositeTimeBetweenWaves = waveSetup.mySameOppositeTimeBetweenWaves.get(timeElapsed) >= 0;
        let spawnTimeMultiplier = this._myVentRuntimeSetup.myVentMultipliers.mySpawnTimeMultiplier.get(this._myGameTimeElapsed);
        this._myTimeBeforeOpposite = this._myWaveSetup.myTimeBeforeOpposite.get(this._myGameTimeElapsed) * spawnTimeMultiplier;
        this._myOppositeTimeLessThanTimeBetweenWaves = waveSetup.myOppositeTimeLessThanTimeBetweenWaves.get(timeElapsed) >= 0;

        this._myAllSameTimes = null;
        if (waveSetup.myAllSameTimes != null) {
            this._myAllSameTimes = waveSetup.myAllSameTimes.get(timeElapsed) >= 0;
            if (this._myAllSameTimes) {
                this._myOppositeTimeAsTimeBetweenWaves = true;
                this._mySameOppositeTimeBetweenWaves = true;
                this._mySameTimeBetweenWaves = true;
            } else {
                this._myOppositeTimeAsTimeBetweenWaves = false;
                this._mySameOppositeTimeBetweenWaves = false;
                this._mySameTimeBetweenWaves = false;
            }
        }

        if (this._myOppositeTimeAsTimeBetweenWaves) {
            this._myTimeBeforeOpposite = this._myTimeBetweenWaves;
        }

        this._myFirst = true;

        this._myCurrentDirection = this._myWaveStartDirection.pp_clone();
        this._myIsOpposite = false;
    }

    _getSpawnTimer() {
        if (!this._myIsOpposite) {
            return super._getSpawnTimer();
        }

        if (this._myOppositeTimeAsTimeBetweenWaves) {
            this._myTimeBeforeOpposite = this._myTimeBetweenWaves;
        } else if (!this._mySameOppositeTimeBetweenWaves) {
            let spawnTimeMultiplier = this._myVentRuntimeSetup.myVentMultipliers.mySpawnTimeMultiplier.get(this._myGameTimeElapsed);

            let attempts = 100;
            while (attempts > 0) {
                this._myTimeBeforeOpposite = this._myWaveSetup.myTimeBeforeOpposite.get(this._myGameTimeElapsed) * spawnTimeMultiplier;
                if (this._myTimeBeforeOpposite <= this._myTimeBetweenWaves || !this._myOppositeTimeLessThanTimeBetweenWaves) {
                    attempts = 0;
                }
                attempts--;
            }
        }

        if (this._myTimeBeforeOpposite > this._myTimeBetweenWaves && this._myOppositeTimeLessThanTimeBetweenWaves) {
            this._myTimeBeforeOpposite = this._myTimeBetweenWaves;
        }

        return this._myTimeBeforeOpposite;
    }

    _checkVentAngleValid(direction) {
        let angleValid = false;
        let oppositeAngleValid = false;
        for (let range of this._myVentRuntimeSetup.myValidAngleRanges) {
            let angle = direction.vec3_angleSigned(range[1], [0, 1, 0]);
            if (range[0].isInsideAngle(angle, Global.myVentDuration)) {
                angleValid = true;
                break;
            }
        }

        if (angleValid) {
            let negateDirection = direction.vec3_negate();
            for (let range of this._myVentRuntimeSetup.myValidAngleRanges) {
                let oppositeAngle = negateDirection.vec3_angleSigned(range[1], [0, 1, 0]);
                if (range[0].isInsideAngle(oppositeAngle, Global.myVentDuration)) {
                    oppositeAngleValid = true;
                    break;
                }
            }
        }

        return angleValid && oppositeAngleValid;
    }

    _createNextWaves() {
        let waves = [];

        if (!this._myFirst) {
            if (!this._myIsOpposite) {
                let angle = 0;
                let attempts = 100;

                let startDirection = [];
                while (attempts > 0) {
                    angle = this._myWaveSetup.myAngleBetweenWaves.get(this._myGameTimeElapsed) * Math.pp_randomSign();
                    this._myCurrentDirection.vec3_rotateAxis(angle, [0, 1, 0], startDirection);
                    if (this._checkVentAngleValid(startDirection)) {
                        attempts = 0;
                    }

                    attempts--;
                }

                this._myCurrentDirection.vec3_rotateAxis(angle, [0, 1, 0], this._myCurrentDirection);
                this._myCurrentDirection.vec3_normalize(this._myCurrentDirection);
            }
        } else {
            this._myFirst = false;
        }

        let direction = this._myCurrentDirection.pp_clone();
        if (this._myIsOpposite) {
            direction = direction.vec3_negate();
        }

        this._myIsOpposite = !this._myIsOpposite;

        waves.push(this._getWaveSetup().createWave(this._myVentRuntimeSetup, this._myGameTimeElapsed, direction));

        return waves;
    }
}
class MerryGoRoundSetup extends WaveOfWavesSetup {
    constructor() {
        super();

        this.myAngleBetweenWaves = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
        this.mySameAngleBetweenWaves = new RangeValueOverTime([1, 1], [1, 1], 0, 0, false); // >= 0 means true
        this.myWaveDirection = new RangeValueOverTime([-1, 1], [-1, 1], 0, 0, false); // >= 0 means right
        this.myPrecomputeWaveDirection = new RangeValueOverTime([1, 1], [1, 1], 0, 0, false); // >= 0 means true
    }

    createWave(ventRuntimeSetup, timeElapsed, refDirection = null) {
        return new MerryGoRound(ventRuntimeSetup, this, timeElapsed, refDirection);
    }

    getPrecomputed(timeElapsed) {
        let setup = new MerryGoRoundSetup();

        setup.myWavesCount = this.myWavesCount.get(timeElapsed);
        setup.mySameTimeBetweenWaves = this.mySameTimeBetweenWaves.get(timeElapsed);
        if (setup.mySameTimeBetweenWaves >= 0) {
            setup.myTimeBetweenWaves = this.myTimeBetweenWaves.get(timeElapsed);
        } else {
            setup.myTimeBetweenWaves = this.myTimeBetweenWaves;
        }
        setup.myDoneDelay = this.myDoneDelay.get(timeElapsed);
        setup.myTimeBeforeStart = this.myTimeBeforeStart.get(timeElapsed);

        setup.myWaveStartAngle = this.myWaveStartAngle.get(timeElapsed);

        setup.myWavesSetup = this.myWavesSetup.pp_clone();
        setup.myWavesSetupPickOne = this.myWavesSetupPickOne.get(timeElapsed);
        setup.myWavesSetupPrecompute = this.myWavesSetupPrecompute.get(timeElapsed);

        setup.mySameAngleBetweenWaves = this.mySameAngleBetweenWaves.get(timeElapsed);
        if (setup.mySameAngleBetweenWaves >= 0) {
            setup.myAngleBetweenWaves = this.myAngleBetweenWaves.get(timeElapsed);
        } else {
            setup.myAngleBetweenWaves = this.myAngleBetweenWaves;
        }

        setup.myPrecomputeWaveDirection = this.myPrecomputeWaveDirection.get(timeElapsed);
        if (setup.myPrecomputeWaveDirection >= 0) {
            setup.myWaveDirection = this.myWaveDirection.get(timeElapsed);
        } else {
            setup.myWaveDirection = this.myWaveDirection;
        }

        if (setup.myWavesSetup.length == 0) {
            setup.myWavesSetup.push([new IAmHereWaveSetup(), 1, "I_Am_Here"]);
        }

        if (setup.myWavesSetupPickOne >= 0) {
            setup._pickOneWave(timeElapsed);
        }

        if (setup.myWavesSetupPrecompute >= 0) {
            let wavesSetup = setup.myWavesSetup;
            setup.myWavesSetup = [];
            for (let setup of wavesSetup) {
                setup.myWavesSetup.push([setup[0].getPrecomputed(timeElapsed), setup[1], setup[2]]);
            }
        }

        return setup;
    }
}

class MerryGoRound extends WaveOfWaves {
    constructor(ventRuntimeSetup, waveSetup, timeElapsed, refDirection) {
        super(ventRuntimeSetup, waveSetup, timeElapsed, refDirection);

        this._myWaveDirection = (this._myWaveSetup.myWaveDirection.get(timeElapsed) >= 0) ? 1 : -1;

        this._myAngleBetweenWaves = waveSetup.myAngleBetweenWaves.get(timeElapsed);
        this._mySameAngleBetweenWaves = waveSetup.mySameAngleBetweenWaves.get(timeElapsed) >= 0;

        this._myCurrentDirection = this._myWaveStartDirection.pp_clone();
        this._myFirst = true;
    }

    _createNextWaves() {
        let waves = [];

        if (!this._myFirst) {
            if (!this._mySameAngleBetweenWaves) {
                this._myAngleBetweenWaves = this._myWaveSetup.myAngleBetweenWaves.get(this._myGameTimeElapsed);
            }
            let angle = this._myAngleBetweenWaves * this._myWaveDirection;

            let maxAttempts = 0;
            let attempts = maxAttempts;

            while (attempts > 0) {
                let startDirection = this._myCurrentDirection.vec3_rotateAxis(angle, [0, 1, 0]);
                let angleValid = this._checkVentAngleValid(startDirection);

                if (angleValid) {
                    attempts = 0;
                } else {
                    angle += (360 / maxAttempts) * this._myWaveDirection;
                }

                attempts--;
            }

            this._myCurrentDirection.vec3_rotateAxis(angle, [0, 1, 0], this._myCurrentDirection);
        } else {
            this._myFirst = false;
        }

        let direction = this._myCurrentDirection.pp_clone();
        direction.vec3_normalize(direction);

        waves.push(this._getWaveSetup().createWave(this._myVentRuntimeSetup, this._myGameTimeElapsed, direction));

        return waves;
    }
}
class QueueForYouWaveSetup extends IAmHereWaveSetup {
    constructor() {
        super();
    }

    createWave(ventRuntimeSetup, timeElapsed, refDirection = null) {
        return new QueueForYouWave(ventRuntimeSetup, this, timeElapsed, refDirection);
    }

    getPrecomputed(timeElapsed) {
        let setup = new QueueForYouWaveSetup();

        setup.myClonesCount = this.myClonesCount.get(timeElapsed);
        setup.mySpawnConeAngle = this.mySpawnConeAngle.get(timeElapsed);
        setup.myMinAngleBetweenClones = this.myMinAngleBetweenClones.get(timeElapsed);
        setup.myWaveStartAngle = this.myWaveStartAngle.get(timeElapsed);
        setup.mySameTimeBetweenClones = this.mySameTimeBetweenClones.get(timeElapsed);
        if (setup.mySameTimeBetweenClones >= 0) {
            setup.myTimeBetweenClones = this.myTimeBetweenClones.get(timeElapsed);
        } else {
            setup.myTimeBetweenClones = this.myTimeBetweenClones;
        }

        setup.myFirstCloneInTheMiddle = this.myFirstCloneInTheMiddle;
        setup.myDoneDelay = this.myDoneDelay.get(timeElapsed);
        setup.myTimeBeforeStart = this.myTimeBeforeStart.get(timeElapsed);

        setup.myDiscardOutsideValidAngle = this.myDiscardOutsideValidAngle.get(timeElapsed);

        setup.myRefDirection = this.myRefDirection;

        return setup;
    }
}

class QueueForYouWave extends IAmHereWave {
    constructor(ventRuntimeSetup, waveSetup, timeElapsed, refDirection) {
        super(ventRuntimeSetup, waveSetup, timeElapsed, refDirection);
        this._mySpawnConeAngle = 0;
    }
}
ArcadeState.prototype._chatVentSetup = function () {
    let ventSetup = this._disputeVentSetup(true);

    ventSetup.myVentMultipliers.mySpawnTimeMultiplier *= 1.5;
    ventSetup.myVentMultipliers.myDoneTimeMultiplier *= 1.5;
    ventSetup.myVentMultipliers.myBreakTimeMultiplier *= 1.25;
    ventSetup.myVentMultipliers.myBreakDelayTimeMultiplier *= 1;
    ventSetup.myVentMultipliers.mySmallBreakTimeMultiplier *= 1.25;
    ventSetup.myVentMultipliers.mySmallBreakDelayTimeMultiplier *= 1;

    ventSetup.myMrNOTSetup.myVentMultipliers.mySpawnTimeMultiplier *= 1.5;
    ventSetup.myMrNOTSetup.myVentMultipliers.myDoneTimeMultiplier *= 1.5;
    ventSetup.myMrNOTSetup.myVentMultipliers.myBreakTimeMultiplier *= 1.25;
    ventSetup.myMrNOTSetup.myVentMultipliers.myBreakDelayTimeMultiplier *= 1;
    ventSetup.myMrNOTSetup.myVentMultipliers.mySmallBreakTimeMultiplier *= 1.25;
    ventSetup.myMrNOTSetup.myVentMultipliers.mySmallBreakDelayTimeMultiplier *= 1;

    ventSetup.myMrNOTSetup.myMrNOTTimeCooldown = new RangeValueOverTime([130, 150], [80, 100], 10, 300, false);
    ventSetup.myMrNOTSetup.myBreakDuration = new RangeValueOverTime([4 * 1.25, 5 * 1.25], [2.5 * 1.25, 3.5 * 1.25], 10, 300, false);

    return ventSetup;
};
ArcadeState.prototype._disputeVentSetup = function (avoidHarderGroups = false) {
    let ventSetup = new VentSetup();

    ventSetup.myBreakSetup.myBreakDuration = new RangeValueOverTime([3, 4], [1.5, 2.5], 10, 200, false);
    ventSetup.myBreakSetup.myBreakTimeCooldown = new RangeValueOverTime([40, 60], [35, 45], 10, 150, false);
    ventSetup.myBreakSetup.myBreakCloneCooldown = 5;

    ventSetup.mySmallBreakSetup.myBreakDuration = new RangeValueOverTime([1.5, 2.5], [0.5, 1], 50, 200, false);
    ventSetup.mySmallBreakSetup.myBreakTimeCooldown = new RangeValueOverTime([18, 22], [12, 16], 50, 150, false);
    ventSetup.mySmallBreakSetup.myBreakCloneCooldown = 3;

    ventSetup.myCloneRotationSetup.mySpinSpeed = new RangeValue([4, 6], false);
    ventSetup.myCloneRotationSetup.mySpinChance = new RangeValueOverTime([1, 12], [1, 6], 135, 300, true);
    ventSetup.myCloneRotationSetup.mySpinStartTime = 135;

    ventSetup.myCloneRotationSetup.myTiltAngle = new RangeValueOverTime([0, 5], [0, 15], 65, 200, false);
    ventSetup.myCloneRotationSetup.myTiltChance = new RangeValueOverTime([1, 6], [1, 2], 65, 200, true);
    ventSetup.myCloneRotationSetup.myTiltStartTime = 65;

    ventSetup.myVentMultipliers = new VentRuntimeMultipliers();
    ventSetup.myVentMultipliers.mySpawnTimeMultiplier = 0.9;
    ventSetup.myVentMultipliers.myDoneTimeMultiplier = 0.9;
    ventSetup.myVentMultipliers.myBreakTimeMultiplier = 1;
    ventSetup.myVentMultipliers.myBreakDelayTimeMultiplier = 1;
    ventSetup.myVentMultipliers.mySmallBreakTimeMultiplier = 1;
    ventSetup.myVentMultipliers.mySmallBreakDelayTimeMultiplier = 1;

    ventSetup.myMrNOTSetup = new VentMrNOTSetup();

    ventSetup.myMrNOTSetup.myMrNOTAppearenceEnabled = true;
    ventSetup.myMrNOTSetup.myMrNOTTimeCooldown = new RangeValueOverTime([90, 100], [60, 80], 10, 300, false);
    //ventSetup.myMrNOTSetup.myMrNOTTimeCooldown = 255;
    ventSetup.myMrNOTSetup.myBreakDuration = new RangeValueOverTime([4, 5], [2.5, 3.5], 10, 300, false);

    ventSetup.myMrNOTSetup.myVentMultipliers = new VentRuntimeMultipliers();
    ventSetup.myMrNOTSetup.myVentMultipliers.mySpawnTimeMultiplier = ventSetup.myVentMultipliers.mySpawnTimeMultiplier * 1.5;
    ventSetup.myMrNOTSetup.myVentMultipliers.myDoneTimeMultiplier = ventSetup.myVentMultipliers.mySpawnTimeMultiplier * 1.5;
    ventSetup.myMrNOTSetup.myVentMultipliers.myBreakTimeMultiplier = 0;
    ventSetup.myMrNOTSetup.myVentMultipliers.myBreakDelayTimeMultiplier = 100;
    ventSetup.myMrNOTSetup.myVentMultipliers.mySmallBreakTimeMultiplier = 1.5;
    ventSetup.myMrNOTSetup.myVentMultipliers.mySmallBreakDelayTimeMultiplier = 0.75;

    ventSetup.myMrNOTSetup.myStartAngle = new RangeValueOverTime([0, 0], [0, 0], 0, 0, false);
    ventSetup.myMrNOTSetup.myTimeToReachTarget = new RangeValueOverTime([35, 45], [25, 40], 10, 300, false);
    ventSetup.myMrNOTSetup.myMaxPatience = new ValueOverTime(13, 26, 25, 45, true);

    //ventSetup.myMrNOTSetup.myTimeToReachTarget = 45;
    //ventSetup.myMrNOTSetup.myMaxPatience = 100;

    let nextWavesSetup = new NextWavesSetup();

    let firstWavesStartTime = 15;
    let secondWavesStartTime = 130;
    let thirdWavesStartTime = 245;
    let fourthWavesStartTime = 350;

    let firstWavesStartTimeGroup = firstWavesStartTime;
    let secondWavesStartTimeGroup = secondWavesStartTime - 40;
    let thirdWavesStartTimeGroup = thirdWavesStartTime - 40;
    let fourthWavesStartTimeGroup = fourthWavesStartTime - 40;

    let firstGroupChance = 350;
    let secondGroupChance = 215;
    let thirdGroupChance = 135;
    let fourthGroupChance = 70;
    let fifthGroupChance = 40;

    // FIRST
    nextWavesSetup.addWave("I_Am_Here", firstGroupChance, 0, secondWavesStartTime);
    nextWavesSetup.addWave("Queue_For_You", firstGroupChance, 10, secondWavesStartTime);
    nextWavesSetup.addWave("Merry_Go_Round", firstGroupChance, 10, secondWavesStartTime);

    nextWavesSetup.addWave("I_Am_Everywhere", secondGroupChance, 45, secondWavesStartTime);
    nextWavesSetup.addWave("Give_Us_A_Hug_2", Math.floor(secondGroupChance * 2 / 3), 45, secondWavesStartTime);
    nextWavesSetup.addWave("Give_Us_A_Hug_3", Math.floor(secondGroupChance * 1 / 3), 45, secondWavesStartTime);
    nextWavesSetup.addWave("Man_In_The_Middle", secondGroupChance, 45, secondWavesStartTime);

    //

    //

    //

    // SECOND
    nextWavesSetup.addWave("I_Am_Here", firstGroupChance, secondWavesStartTime);
    nextWavesSetup.addWave("I_Am_Here_2", firstGroupChance, secondWavesStartTime);
    nextWavesSetup.addWave("Queue_For_You", firstGroupChance, secondWavesStartTime);
    nextWavesSetup.addWave("Queue_For_You_2", firstGroupChance, secondWavesStartTime);
    nextWavesSetup.addWave("Merry_Go_Round", Math.floor(firstGroupChance * 2 * 2 / 3), secondWavesStartTime);
    nextWavesSetup.addWave("Merry_Go_Round_Waves", Math.floor(firstGroupChance * 2 * 1 / 3), secondWavesStartTime);

    let secondGroupSecondWaveChance = secondGroupChance * 2;
    nextWavesSetup.addWave("I_Am_Everywhere", Math.floor(secondGroupSecondWaveChance * 1 / 2), secondWavesStartTime, thirdWavesStartTime);
    nextWavesSetup.addWave("I_Am_Everywhere_2", Math.floor(secondGroupSecondWaveChance * 1 / 2), secondWavesStartTime, thirdWavesStartTime);
    nextWavesSetup.addWave("Give_Us_A_Hug_2", Math.floor(secondGroupSecondWaveChance * 2 / 3), secondWavesStartTime, thirdWavesStartTime);
    nextWavesSetup.addWave("Give_Us_A_Hug_3", Math.floor(secondGroupSecondWaveChance * 1 / 3), secondWavesStartTime, thirdWavesStartTime);
    nextWavesSetup.addWave("Man_In_The_Middle", secondGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);

    let thirdGroupSecondWaveChance = thirdGroupChance;
    nextWavesSetup.addWave("I_Am_Everywhere_Waves", thirdGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);
    nextWavesSetup.addWave("I_Am_Here_Rain", thirdGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);
    nextWavesSetup.addWave("Queue_For_You_Rain", thirdGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);
    nextWavesSetup.addWave("I_Am_Everywhere_Waves", thirdGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);
    nextWavesSetup.addWave("I_Am_Here_Rain", thirdGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);
    nextWavesSetup.addWave("Queue_For_You_Rain", thirdGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);

    if (!avoidHarderGroups) {
        let fourthGroupSecondWaveChance = fourthGroupChance;
        nextWavesSetup.addWave("Man_In_The_Middle_Everywhere", fourthGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);
        nextWavesSetup.addWave("I_Am_Everywhere_GUAH2", fourthGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);
        nextWavesSetup.addWave("Merry_Go_Round_GUAH2", fourthGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);
        nextWavesSetup.addWave("Man_In_The_Middle_Everywhere", fourthGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);
        nextWavesSetup.addWave("I_Am_Everywhere_GUAH2", fourthGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);
        nextWavesSetup.addWave("Merry_Go_Round_GUAH2", fourthGroupSecondWaveChance, secondWavesStartTime, thirdWavesStartTime);

    }

    //

    // THIRD

    //

    let secondGroupThirdWaveChance = secondGroupChance * 2;
    nextWavesSetup.addWave("I_Am_Everywhere", Math.floor(secondGroupThirdWaveChance * 1 / 2), thirdWavesStartTime);
    nextWavesSetup.addWave("I_Am_Everywhere_2", Math.floor(secondGroupThirdWaveChance * 1 / 2), thirdWavesStartTime);
    nextWavesSetup.addWave("Give_Us_A_Hug_2", Math.floor(secondGroupThirdWaveChance * 2 / 3), thirdWavesStartTime);
    nextWavesSetup.addWave("Give_Us_A_Hug_3", Math.floor(secondGroupThirdWaveChance * 1 / 3), thirdWavesStartTime);
    nextWavesSetup.addWave("Man_In_The_Middle", Math.floor(secondGroupThirdWaveChance * 2 / 3), thirdWavesStartTime);
    nextWavesSetup.addWave("Merry_Go_Round_MITM", Math.floor(secondGroupThirdWaveChance * 1 / 3), thirdWavesStartTime);

    let thirdGroupThirdWaveChance = thirdGroupChance * 6 / 5;
    nextWavesSetup.addWave("I_Am_Everywhere_Waves", thirdGroupThirdWaveChance, thirdWavesStartTime);
    nextWavesSetup.addWave("I_Am_Here_Rain", thirdGroupThirdWaveChance, thirdWavesStartTime);
    nextWavesSetup.addWave("Queue_For_You_Rain", thirdGroupThirdWaveChance, thirdWavesStartTime);
    nextWavesSetup.addWave("Merry_Go_Round_Rain", thirdGroupThirdWaveChance, thirdWavesStartTime);
    nextWavesSetup.addWave("Man_In_The_Middle_Waves", thirdGroupThirdWaveChance, thirdWavesStartTime);

    if (!avoidHarderGroups) {
        let fourthGroupThirdWaveChance = fourthGroupChance * 2;
        nextWavesSetup.addWave("Man_In_The_Middle_Everywhere", Math.floor(fourthGroupThirdWaveChance * 1 / 2), thirdWavesStartTime);
        nextWavesSetup.addWave("I_Am_Everywhere_GUAH2", Math.floor(fourthGroupThirdWaveChance * 2 / 3), thirdWavesStartTime);
        nextWavesSetup.addWave("Merry_Go_Round_GUAH2", Math.floor(fourthGroupThirdWaveChance * 2 / 3), thirdWavesStartTime);
        nextWavesSetup.addWave("Man_In_The_Middle_Everywhere_Waves", Math.floor(fourthGroupThirdWaveChance * 1 / 2), thirdWavesStartTime);
        nextWavesSetup.addWave("I_Am_Everywhere_GUAH3", Math.floor(fourthGroupThirdWaveChance * 1 / 3), thirdWavesStartTime);
        nextWavesSetup.addWave("Merry_Go_Round_GUAH3", Math.floor(fourthGroupThirdWaveChance * 1 / 3), thirdWavesStartTime);

        let fifthGroupThirdWaveChance = fifthGroupChance * 2;
        nextWavesSetup.addWave("Give_Us_A_Hug_4", Math.floor(fifthGroupThirdWaveChance * 1 / 2), thirdWavesStartTime, fourthWavesStartTime);
        nextWavesSetup.addWave("Man_In_The_Middle_GUAH2", Math.floor(fifthGroupThirdWaveChance * 1 / 2), thirdWavesStartTime, fourthWavesStartTime);
        nextWavesSetup.addWave("Man_In_The_Middle_Everywhere_GUAH2", Math.floor(fifthGroupThirdWaveChance * 1 / 2), thirdWavesStartTime, fourthWavesStartTime);
        nextWavesSetup.addWave("Give_Us_A_Hug_4", Math.floor(fifthGroupThirdWaveChance * 1 / 2), thirdWavesStartTime, fourthWavesStartTime);
        nextWavesSetup.addWave("Man_In_The_Middle_GUAH2", Math.floor(fifthGroupThirdWaveChance * 1 / 2), thirdWavesStartTime, fourthWavesStartTime);
        nextWavesSetup.addWave("Man_In_The_Middle_Everywhere_GUAH2", Math.floor(fifthGroupThirdWaveChance * 1 / 2), thirdWavesStartTime, fourthWavesStartTime);
    }

    //FOURTH

    //

    //

    //

    //

    if (!avoidHarderGroups) {
        let fifthGroupFourthWaveChance = fifthGroupChance * 2;
        nextWavesSetup.addWave("Give_Us_A_Hug_4", Math.floor(fifthGroupFourthWaveChance * 2 / 3), fourthWavesStartTime);
        nextWavesSetup.addWave("Man_In_The_Middle_GUAH2", Math.floor(fifthGroupFourthWaveChance * 2 / 3), fourthWavesStartTime);
        nextWavesSetup.addWave("Man_In_The_Middle_Everywhere_GUAH2", Math.floor(fifthGroupFourthWaveChance * 2 / 3), fourthWavesStartTime);
        nextWavesSetup.addWave("Man_In_The_Middle_GUAH3", Math.floor(fifthGroupFourthWaveChance * 1 / 3), fourthWavesStartTime);
        nextWavesSetup.addWave("Man_In_The_Middle_Everywhere_GUAH3", Math.floor(fifthGroupFourthWaveChance * 1 / 3), fourthWavesStartTime);
        nextWavesSetup.addWave("Give_Us_A_Hug_Cross", Math.floor(fifthGroupFourthWaveChance * 1 / 3), fourthWavesStartTime);
    }

    //nextWavesSetup.addWave("Give_Us_A_Hug_Distance", 0, 0);

    // Wave Data

    let waveStartAngle = new RangeValue([25, 175]);

    let timeBetweenClones = new RangeValueOverTime([2, 3], [1, 1.5], 10, 100, false);
    let doneDelay = new RangeValueOverTime([2, 4], [1.5, 2.5], 10, 100, false);

    let timeBetweenClonesHard = new RangeValueOverTime([2, 3], [1.5, 2], 50, 200, false);
    let doneDelayHard = new RangeValueOverTime([3, 4], [2, 3], 50, 200, false);

    let timeBetweenClonesVeryHard = new RangeValueOverTime([2.5, 3], [2, 2.5], secondWavesStartTime, secondWavesStartTime + 150, false);
    let doneDelayVeryHard = new RangeValueOverTime([3, 4], [2.5, 3.5], secondWavesStartTime, secondWavesStartTime + 150, false);

    let timeBetweenClonesMegaHard = new RangeValueOverTime([3, 3.5], [2.5, 3], fourthWavesStartTime, fourthWavesStartTime + 150, false);
    let doneDelayMegaHard = new RangeValueOverTime([4, 4.5], [3, 4], fourthWavesStartTime, fourthWavesStartTime + 150, false);

    let randomTrue = new RangeValueOverTime([1, 1], [-0.5, 1], secondWavesStartTime, secondWavesStartTime + 5, false); // >= 0 means true
    let randomVeryTrue = new RangeValueOverTime([1, 1], [-0.75, 1], secondWavesStartTime, secondWavesStartTime + 5, false); // >= 0 means true
    let randomFalse = new RangeValueOverTime([-1, -1], [-1, 0.5], secondWavesStartTime, secondWavesStartTime + 5, false); // >= 0 means true
    let randomRandom = new RangeValue([-1, 1]); // >= 0 means true

    // Booster Data   
    let boosterGroup1 = ["I_Am_Here", "I_Am_Here_2", "Queue_For_You", "Queue_For_You_2", "Merry_Go_Round", "Merry_Go_Round_Waves"];
    let boosterGroup2 = ["I_Am_Everywhere", "I_Am_Everywhere_2", "Give_Us_A_Hug_2", "Give_Us_A_Hug_3", "Man_In_The_Middle", "Merry_Go_Round_MITM"];
    let boosterGroup3 = ["I_Am_Everywhere_Waves", "I_Am_Here_Rain", "Queue_For_You_Rain", "Man_In_The_Middle_Waves", "Merry_Go_Round_Rain"];
    let boosterGroup4 = ["Man_In_The_Middle_Everywhere", "I_Am_Everywhere_GUAH2", "Merry_Go_Round_GUAH2", "Man_In_The_Middle_Everywhere_Waves", "I_Am_Everywhere_GUAH3", "Merry_Go_Round_GUAH3"];
    let boosterGroup5 = ["Give_Us_A_Hug_4", "Man_In_The_Middle_GUAH2", "Man_In_The_Middle_Everywhere_GUAH2", "Man_In_The_Middle_GUAH3", "Man_In_The_Middle_Everywhere_GUAH3", "Give_Us_A_Hug_Cross"];

    let boosterGroupName1 = "1";
    let boosterGroupName2 = "2";
    let boosterGroupName3 = "3";
    let boosterGroupName4 = "4";
    let boosterGroupName5 = "5";

    let dampingOverLastPick1 = new ValueOverTime(-90, 0, 0, 30);
    let dampingOverLastPick2 = new ValueOverTime(-80, 0, 0, 30);
    let dampingOverLastPick3 = new ValueOverTime(-70, 0, 0, 30);
    let dampingOverLastPick4 = new ValueOverTime(-60, 0, 0, 30);
    let dampingOverLastPick5 = new ValueOverTime(-50, 0, 0, 30);

    dampingOverLastPick1 = new ValueOverTime(-90, 0, 0, 30);
    dampingOverLastPick2 = new ValueOverTime(-90, 0, 0, 30);
    dampingOverLastPick3 = new ValueOverTime(-90, 0, 0, 30);
    dampingOverLastPick4 = new ValueOverTime(-90, 0, 0, 30);
    dampingOverLastPick5 = new ValueOverTime(-90, 0, 0, 30);

    let boostMultiplier1 = new ValueOverTime(1.5, 2, 400, 600);
    let boostMultiplier2 = new ValueOverTime(6, 2, 50, 450);
    let boostMultiplier3 = new ValueOverTime(10, 1.75, secondWavesStartTime, 550);
    let boostMultiplier4 = new ValueOverTime(6, 1.5, secondWavesStartTime, 600);
    let boostMultiplier5 = new ValueOverTime(8, 1.25, thirdWavesStartTime, 650);

    boostMultiplier1 = 2;
    boostMultiplier2 = 2;
    boostMultiplier3 = 1.75;
    boostMultiplier4 = 1.25;
    boostMultiplier5 = 1;

    let boostDivider1 = new ValueOverTime(3, 2, 400, 600);
    let boostDivider2 = new ValueOverTime(1.5, 2, 50, 200);
    let boostDivider3 = new ValueOverTime(1.5, 2, secondWavesStartTime, secondWavesStartTime + 150);
    let boostDivider4 = new ValueOverTime(1.5, 2, secondWavesStartTime, secondWavesStartTime + 150);
    let boostDivider5 = new ValueOverTime(1.5, 2, thirdWavesStartTime, thirdWavesStartTime + 150);

    boostDivider1 = 2;
    boostDivider2 = 2;
    boostDivider3 = 2;
    boostDivider4 = 2;
    boostDivider5 = 2;

    let boostValueOnReset1 = -30;
    let boostValueOnReset2 = -30;
    let boostValueOnReset3 = -30;
    let boostValueOnReset4 = -30;
    let boostValueOnReset5 = -30;

    // Waves

    {
        let wave = new ZeroWaveSetup();

        let testNextWavesSetup = new NextWavesSetup();
        testNextWavesSetup.addWave("Test_Wave_No_Clones", 1);

        ventSetup.myWavesMap.set("Zero", wave);
        //ventSetup.myNextWavesMap.set("Zero", testNextWavesSetup);
        ventSetup.myNextWavesMap.set("Zero", nextWavesSetup);
    }

    {
        let wave = new IAmHereWaveSetup();

        wave.myClonesCount = 1;
        wave.myTimeBeforeStart = 10000;

        let testNextWavesSetup = new NextWavesSetup();
        testNextWavesSetup.addWave("Test_Wave_No_Clones", 1);

        ventSetup.myWavesMap.set("Test_Wave_No_Clones", wave);
        ventSetup.myNextWavesMap.set("Test_Wave_No_Clones", testNextWavesSetup);
    }

    let subOneWave = new IAmHereWaveSetup();
    subOneWave.myClonesCount = 1;
    subOneWave.myWaveStartAngle = 0;
    subOneWave.myFirstCloneInTheMiddle = true;
    subOneWave.myDoneDelay = 0;

    let subHereWave = new IAmHereWaveSetup();
    subHereWave.myClonesCount = new RangeValueOverTime([2, 3], [2, 3], 10, 100, true);
    subHereWave.myWaveStartAngle = 0;
    subHereWave.mySpawnConeAngle = new RangeValue([20, 40]);
    subHereWave.mySameTimeBetweenClones = randomRandom;
    subHereWave.myMinAngleBetweenClones = 10;
    subHereWave.myFirstCloneInTheMiddle = true;
    subHereWave.myTimeBetweenClones = new RangeValueOverTime([1, 1.5], [0.75, 1.25], secondWavesStartTime, secondWavesStartTime + 100, false);
    subHereWave.myDoneDelay = 0;

    let subQueueWave = new QueueForYouWaveSetup();
    subQueueWave.myClonesCount = new RangeValueOverTime([2, 3], [2, 3], 10, 100, true);
    subQueueWave.myWaveStartAngle = 0;
    subQueueWave.mySameTimeBetweenClones = randomTrue;
    subQueueWave.myTimeBetweenClones = new RangeValueOverTime([1, 1.5], [0.75, 1.25], secondWavesStartTime, secondWavesStartTime + 100, false);
    subQueueWave.myDoneDelay = 0;

    let subGiveUsAHug2Wave = new GiveUsAHugSetup();
    subGiveUsAHug2Wave.myClonesCount = 1;
    subGiveUsAHug2Wave.myWaveStartAngle = 0;
    subGiveUsAHug2Wave.myFirstCloneInTheMiddle = true;
    subGiveUsAHug2Wave.myTimeBetweenClones = 0;
    subGiveUsAHug2Wave.myHugSize = 2;
    subGiveUsAHug2Wave.myHugAngle = new RangeValueOverTime([20, 30], [20, 35], 10, 100, false);
    subGiveUsAHug2Wave.mySameHugAngle = randomTrue;
    subGiveUsAHug2Wave.myDoneDelay = 0;

    let subGiveUsAHug3Wave = new GiveUsAHugSetup();
    subGiveUsAHug3Wave.myClonesCount = 1;
    subGiveUsAHug3Wave.myWaveStartAngle = 0;
    subGiveUsAHug3Wave.myFirstCloneInTheMiddle = true;
    subGiveUsAHug3Wave.myTimeBetweenClones = 0;
    subGiveUsAHug3Wave.myHugSize = 3;
    subGiveUsAHug3Wave.myHugAngle = new RangeValueOverTime([40, 50], [40, 60], 10, 100, false);
    subGiveUsAHug3Wave.mySameHugAngle = randomTrue;
    subGiveUsAHug3Wave.myDoneDelay = 0;

    let subMerryWave = new MerryGoRoundSetup();
    subMerryWave.myWavesCount = new RangeValueOverTime([3, 4], [3, 4], 10, 100, true);
    subMerryWave.myWaveStartAngle = 0;
    subMerryWave.myAngleBetweenWaves = new RangeValueOverTime([15, 25], [15, 35], 10, 100, false);
    subMerryWave.mySameTimeBetweenWaves = randomVeryTrue;
    subMerryWave.mySameAngleBetweenWaves = randomVeryTrue;
    subMerryWave.myTimeBetweenWaves = new RangeValueOverTime([2, 3], [0.75, 1.25], 10, 100, false);
    subMerryWave.myPrecomputeWaveDirection = randomFalse;
    subMerryWave.myDoneDelay = 0;

    let subMITMWave = new ManInTheMiddleSetup();
    subMITMWave.myWavesCount = 1;
    subMITMWave.myWaveStartAngle = 0;
    subMITMWave.myTimeBetweenWaves = new RangeValueOverTime([1.5, 2], [1, 1.5], 10, 100, false);
    subMITMWave.myTimeBeforeOpposite = new RangeValueOverTime([1.5, 2], [1, 1.5], 10, 100, false);
    subMITMWave.myOppositeTimeAsTimeBetweenWaves = -1;
    subMITMWave.mySameOppositeTimeBetweenWaves = 1;
    subMITMWave.mySameTimeBetweenWaves = -1;
    subMITMWave.myDoneDelay = 0;

    // I AM HERE

    {
        let wave = new IAmHereWaveSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 3], [1, 5], 10, 150, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.mySameTimeBetweenClones = randomRandom;
        wave.myMinAngleBetweenClones = 10;
        wave.myFirstCloneInTheMiddle = true;
        wave.myTimeBetweenClones = timeBetweenClones;
        wave.myDoneDelay = doneDelay;

        ventSetup.myWavesMap.set("I_Am_Here", wave);
        ventSetup.myNextWavesMap.set("I_Am_Here", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("I_Am_Here",
            new NextWaveChanceBoosterSetup(firstWavesStartTimeGroup, boosterGroup1, boosterGroupName1, dampingOverLastPick1, boostMultiplier1, boostDivider1, boostValueOnReset1));

        ventSetup.myWavesMap.set("I_Am_Here_2", wave);
        ventSetup.myNextWavesMap.set("I_Am_Here_2", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("I_Am_Here_2",
            new NextWaveChanceBoosterSetup(secondWavesStartTimeGroup, boosterGroup1, boosterGroupName1, dampingOverLastPick1, boostMultiplier1, boostDivider1, boostValueOnReset1));
    }

    {
        let wave = new IAmHereWaveSetup();

        wave.myClonesCount = new RangeValueOverTime([4, 6], [4, 8], secondWavesStartTime, secondWavesStartTime + 150, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.mySameTimeBetweenClones = randomRandom;
        wave.myMinAngleBetweenClones = 10;
        wave.myFirstCloneInTheMiddle = true;
        wave.myTimeBetweenClones = new RangeValueOverTime([0.75, 1.25], [0.6, 1], secondWavesStartTime, secondWavesStartTime + 150, false);
        wave.myDoneDelay = doneDelayHard;

        ventSetup.myWavesMap.set("I_Am_Here_Rain", wave);
        ventSetup.myNextWavesMap.set("I_Am_Here_Rain", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("I_Am_Here_Rain",
            new NextWaveChanceBoosterSetup(secondWavesStartTimeGroup, boosterGroup3, boosterGroupName3, dampingOverLastPick3, boostMultiplier3, boostDivider3, boostValueOnReset3));
    }

    // QUEUE FOR YOU

    {
        let wave = new QueueForYouWaveSetup();

        wave.myClonesCount = new RangeValueOverTime([2, 3], [2, 5], 10, 150, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.mySameTimeBetweenClones = randomTrue;
        wave.myTimeBetweenClones = timeBetweenClones;
        wave.myDoneDelay = doneDelay;

        ventSetup.myWavesMap.set("Queue_For_You", wave);
        ventSetup.myNextWavesMap.set("Queue_For_You", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Queue_For_You",
            new NextWaveChanceBoosterSetup(firstWavesStartTimeGroup, boosterGroup1, boosterGroupName1, dampingOverLastPick1, boostMultiplier1, boostDivider1, boostValueOnReset1));

        ventSetup.myWavesMap.set("Queue_For_You_2", wave);
        ventSetup.myNextWavesMap.set("Queue_For_You_2", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Queue_For_You_2",
            new NextWaveChanceBoosterSetup(secondWavesStartTimeGroup, boosterGroup1, boosterGroupName1, dampingOverLastPick1, boostMultiplier1, boostDivider1, boostValueOnReset1));
    }

    {
        let wave = new QueueForYouWaveSetup();

        wave.myClonesCount = new RangeValueOverTime([4, 6], [4, 8], secondWavesStartTime, secondWavesStartTime + 150, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.mySameTimeBetweenClones = randomTrue;
        wave.myTimeBetweenClones = new RangeValueOverTime([0.75, 1.25], [0.6, 1], secondWavesStartTime, secondWavesStartTime + 150, false);
        wave.myDoneDelay = doneDelayHard;

        ventSetup.myWavesMap.set("Queue_For_You_Rain", wave);
        ventSetup.myNextWavesMap.set("Queue_For_You_Rain", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Queue_For_You_Rain",
            new NextWaveChanceBoosterSetup(secondWavesStartTimeGroup, boosterGroup3, boosterGroupName3, dampingOverLastPick3, boostMultiplier3, boostDivider3, boostValueOnReset3));
    }

    // MERRY GO ROUND

    {
        let wave = new MerryGoRoundSetup();

        wave.myWavesCount = new RangeValueOverTime([3, 5], [3, 6], 10, 100, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myAngleBetweenWaves = new RangeValueOverTime([15, 25], [15, 35], 10, 100, false);
        wave.mySameTimeBetweenWaves = randomVeryTrue;
        wave.mySameAngleBetweenWaves = randomVeryTrue;
        wave.myTimeBetweenWaves = new RangeValueOverTime([2, 3], [0.75, 1.25], 10, 100, false);
        wave.myDoneDelay = doneDelay;

        ventSetup.myWavesMap.set("Merry_Go_Round", wave);
        ventSetup.myNextWavesMap.set("Merry_Go_Round", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Merry_Go_Round",
            new NextWaveChanceBoosterSetup(firstWavesStartTimeGroup, boosterGroup1, boosterGroupName1, dampingOverLastPick1, boostMultiplier1 * 2 * 20 / 30, boostDivider1, boostValueOnReset1));
    }

    {
        let wave = new MerryGoRoundSetup();

        wave.myWavesCount = new RangeValueOverTime([8, 10], [8, 12], secondWavesStartTime, secondWavesStartTime + 150, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myAngleBetweenWaves = new RangeValueOverTime([15, 25], [15, 35], 10, 100, false);
        wave.mySameTimeBetweenWaves = randomVeryTrue;
        wave.mySameAngleBetweenWaves = randomVeryTrue;
        wave.myTimeBetweenWaves = new RangeValueOverTime([0.5, 0.9], [0.4, 0.8], thirdWavesStartTime, thirdWavesStartTime + 150, false);
        wave.myDoneDelay = doneDelayHard;

        ventSetup.myWavesMap.set("Merry_Go_Round_Rain", wave);
        ventSetup.myNextWavesMap.set("Merry_Go_Round_Rain", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Merry_Go_Round_Rain",
            new NextWaveChanceBoosterSetup(thirdWavesStartTimeGroup, boosterGroup3, boosterGroupName3, dampingOverLastPick3, boostMultiplier3, boostDivider3, boostValueOnReset3));
    }

    {
        let wave = new MerryGoRoundSetup();

        wave.myWavesCount = new RangeValueOverTime([3, 3], [3, 4], secondWavesStartTime, secondWavesStartTime + 100, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myAngleBetweenWaves = new RangeValueOverTime([15, 25], [15, 35], 10, 100, false);
        wave.mySameTimeBetweenWaves = randomVeryTrue;
        wave.mySameAngleBetweenWaves = randomVeryTrue;
        wave.myTimeBetweenWaves = timeBetweenClones;
        wave.myDoneDelay = doneDelay;

        wave.myWavesSetup.push([subHereWave, 1, "I_Am_Here"]);
        wave.myWavesSetup.push([subQueueWave, 2, "Queue_For_You"]);
        wave.myWavesSetupPrecompute = randomTrue;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("Merry_Go_Round_Waves", wave);
        ventSetup.myNextWavesMap.set("Merry_Go_Round_Waves", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Merry_Go_Round_Waves",
            new NextWaveChanceBoosterSetup(secondWavesStartTimeGroup, boosterGroup1, boosterGroupName1, dampingOverLastPick1, boostMultiplier1 * 2 * 10 / 30, boostDivider1, boostValueOnReset1));
    }

    {
        let wave = new MerryGoRoundSetup();

        wave.myWavesCount = new RangeValueOverTime([3, 4], [3, 6], secondWavesStartTime, secondWavesStartTime + 150, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myAngleBetweenWaves = new RangeValue([25, 35]);
        wave.mySameTimeBetweenWaves = randomVeryTrue;
        wave.mySameAngleBetweenWaves = randomVeryTrue;
        wave.myTimeBetweenWaves = timeBetweenClones;
        wave.myDoneDelay = doneDelayHard;

        wave.myWavesSetup.push([subGiveUsAHug2Wave, 1, "Give Us A Hug 2"]);
        wave.myWavesSetupPrecompute = randomRandom;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("Merry_Go_Round_GUAH2", wave);
        ventSetup.myNextWavesMap.set("Merry_Go_Round_GUAH2", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Merry_Go_Round_GUAH2",
            new NextWaveChanceBoosterSetup(secondWavesStartTimeGroup, boosterGroup4, boosterGroupName4, dampingOverLastPick4, boostMultiplier4 * 2 * 20 / 30, boostDivider4, boostValueOnReset4));
    }

    {
        let wave = new MerryGoRoundSetup();

        wave.myWavesCount = new RangeValueOverTime([3, 3], [3, 4], thirdWavesStartTime, thirdWavesStartTime + 100, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myAngleBetweenWaves = new RangeValue([25, 35]);
        wave.mySameTimeBetweenWaves = randomVeryTrue;
        wave.mySameAngleBetweenWaves = randomVeryTrue;
        wave.myTimeBetweenWaves = timeBetweenClonesHard;
        wave.myDoneDelay = doneDelayVeryHard;

        wave.myWavesSetup.push([subGiveUsAHug3Wave, 1, "Give Us A Hug 3"]);
        wave.myWavesSetupPrecompute = randomRandom;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("Merry_Go_Round_GUAH3", wave);
        ventSetup.myNextWavesMap.set("Merry_Go_Round_GUAH3", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Merry_Go_Round_GUAH3",
            new NextWaveChanceBoosterSetup(thirdWavesStartTimeGroup, boosterGroup4, boosterGroupName4, dampingOverLastPick4, boostMultiplier4 * 2 * 10 / 30, boostDivider4, boostValueOnReset4));
    }

    {
        let wave = new MerryGoRoundSetup();

        wave.myWavesCount = new RangeValueOverTime([3, 5], [3, 6], thirdWavesStartTime, thirdWavesStartTime + 100, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myAngleBetweenWaves = new RangeValueOverTime([15, 25], [15, 35], 10, 100, false);
        wave.mySameTimeBetweenWaves = randomVeryTrue;
        wave.mySameAngleBetweenWaves = randomVeryTrue;
        wave.myTimeBetweenWaves = new RangeValueOverTime([1.5, 2], [1, 1.5], 10, 100, false);
        wave.myDoneDelay = doneDelayHard;

        wave.myWavesSetup.push([subMITMWave, 1, "Man_In_The_Middle"]);
        wave.myWavesSetupPrecompute = randomTrue;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("Merry_Go_Round_MITM", wave);
        ventSetup.myNextWavesMap.set("Merry_Go_Round_MITM", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Merry_Go_Round_MITM",
            new NextWaveChanceBoosterSetup(thirdWavesStartTimeGroup, boosterGroup2, boosterGroupName2, dampingOverLastPick2, boostMultiplier2 * 2 * 10 / 30, boostDivider2, boostValueOnReset2));
    }

    // I AM EVERYWHERE

    {
        let wave = new IAmEverywhereWaveSetup();

        wave.myWavesCount = new RangeValueOverTime([3, 4], [3, 6], 10, 150, true);
        wave.myAngleBetweenWaves = new RangeValue([55, 175]);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myTimeBetweenWaves = timeBetweenClonesHard;
        wave.myDoneDelay = doneDelayHard;

        ventSetup.myWavesMap.set("I_Am_Everywhere", wave);
        ventSetup.myNextWavesMap.set("I_Am_Everywhere", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("I_Am_Everywhere",
            new NextWaveChanceBoosterSetup(firstWavesStartTimeGroup, boosterGroup2, boosterGroupName2, dampingOverLastPick2, boostMultiplier2, boostDivider2, boostValueOnReset2));

        ventSetup.myWavesMap.set("I_Am_Everywhere_2", wave);
        ventSetup.myNextWavesMap.set("I_Am_Everywhere_2", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("I_Am_Everywhere_2",
            new NextWaveChanceBoosterSetup(secondWavesStartTimeGroup, boosterGroup2, boosterGroupName2, dampingOverLastPick2, boostMultiplier2, boostDivider2, boostValueOnReset2));
    }

    {
        let wave = new IAmEverywhereWaveSetup();

        wave.myWavesCount = new RangeValueOverTime([2, 3], [2, 5], secondWavesStartTime, secondWavesStartTime + 150, true);
        wave.myAngleBetweenWaves = new RangeValue([55, 175]);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myTimeBetweenWaves = timeBetweenClones;
        wave.myDoneDelay = doneDelayVeryHard;

        wave.myWavesSetup.push([subOneWave, 2, "I_Am_Here_One"]);
        wave.myWavesSetup.push([subHereWave, 2, "I_Am_Here"]);
        wave.myWavesSetup.push([subQueueWave, 4, "Queue_For_You"]);
        wave.myWavesSetup.push([subMerryWave, 4, "Merry_Go_Round"]);
        wave.myWavesSetupPrecompute = randomTrue;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("I_Am_Everywhere_Waves", wave);
        ventSetup.myNextWavesMap.set("I_Am_Everywhere_Waves", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("I_Am_Everywhere_Waves",
            new NextWaveChanceBoosterSetup(secondWavesStartTimeGroup, boosterGroup3, boosterGroupName3, dampingOverLastPick3, boostMultiplier3, boostDivider3, boostValueOnReset3));
    }

    {
        let wave = new IAmEverywhereWaveSetup();

        wave.myWavesCount = new RangeValueOverTime([2, 3], [2, 5], secondWavesStartTime, secondWavesStartTime + 150, true);
        wave.myAngleBetweenWaves = new RangeValue([55, 175]);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myTimeBetweenWaves = timeBetweenClonesHard;
        wave.myDoneDelay = doneDelayHard;

        wave.myWavesSetup.push([subGiveUsAHug2Wave, 1, "Give Us A Hug 2"]);
        wave.myWavesSetupPrecompute = randomRandom;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("I_Am_Everywhere_GUAH2", wave);
        ventSetup.myNextWavesMap.set("I_Am_Everywhere_GUAH2", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("I_Am_Everywhere_GUAH2",
            new NextWaveChanceBoosterSetup(secondWavesStartTimeGroup, boosterGroup4, boosterGroupName4, dampingOverLastPick4, boostMultiplier4 * 2 * 20 / 30, boostDivider4, boostValueOnReset4));
    }


    {
        let wave = new IAmEverywhereWaveSetup();

        wave.myWavesCount = new RangeValueOverTime([2, 3], [2, 4], secondWavesStartTime, secondWavesStartTime + 100, true);
        wave.myAngleBetweenWaves = new RangeValue([55, 175]);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myTimeBetweenWaves = timeBetweenClonesVeryHard;
        wave.myDoneDelay = doneDelayVeryHard;

        wave.myWavesSetup.push([subGiveUsAHug3Wave, 1, "Give Us A Hug 3"]);
        wave.myWavesSetupPrecompute = randomRandom;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("I_Am_Everywhere_GUAH3", wave);
        ventSetup.myNextWavesMap.set("I_Am_Everywhere_GUAH3", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("I_Am_Everywhere_GUAH3",
            new NextWaveChanceBoosterSetup(thirdWavesStartTimeGroup, boosterGroup4, boosterGroupName4, dampingOverLastPick4, boostMultiplier4 * 2 * 10 / 30, boostDivider4, boostValueOnReset4));
    }

    // GIVE US A HUG

    {
        let wave = new GiveUsAHugSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 1], [1, 5], 10, 150, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.myFirstCloneInTheMiddle = true;
        wave.myTimeBetweenClones = timeBetweenClonesHard;
        wave.myDoneDelay = doneDelayHard;

        wave.myHugSize = 2;
        wave.myHugAngle = new RangeValueOverTime([20, 30], [20, 35], 10, 100, false);
        wave.mySameHugAngle = randomTrue;
        wave.mySameHugSize = randomTrue;

        ventSetup.myWavesMap.set("Give_Us_A_Hug_2", wave);
        ventSetup.myNextWavesMap.set("Give_Us_A_Hug_2", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Give_Us_A_Hug_2",
            new NextWaveChanceBoosterSetup(firstWavesStartTimeGroup, boosterGroup2, boosterGroupName2, dampingOverLastPick2, boostMultiplier2 * 2 * 20 / 30, boostDivider2, boostValueOnReset2));
    }

    {
        let wave = new GiveUsAHugSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 1], [1, 3], 10, 150, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.myFirstCloneInTheMiddle = true;
        wave.myTimeBetweenClones = timeBetweenClonesVeryHard;
        wave.myDoneDelay = doneDelayVeryHard;

        wave.myHugSize = 3;
        wave.myHugAngle = new RangeValueOverTime([40, 50], [40, 60], 10, 100, false);
        wave.mySameHugAngle = randomTrue;
        wave.mySameHugSize = randomTrue;

        ventSetup.myWavesMap.set("Give_Us_A_Hug_3", wave);
        ventSetup.myNextWavesMap.set("Give_Us_A_Hug_3", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Give_Us_A_Hug_3",
            new NextWaveChanceBoosterSetup(firstWavesStartTimeGroup, boosterGroup2, boosterGroupName2, dampingOverLastPick2, boostMultiplier2 * 2 * 10 / 30, boostDivider2, boostValueOnReset2));
    }

    {
        let wave = new GiveUsAHugSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 1], [1, 4], thirdWavesStartTime, thirdWavesStartTime + 150, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.myFirstCloneInTheMiddle = true;
        wave.myTimeBetweenClones = timeBetweenClonesVeryHard;
        wave.myDoneDelay = doneDelayVeryHard;

        wave.myHugSize = 4;
        wave.myHugAngle = new RangeValueOverTime([60, 70], [60, 80], thirdWavesStartTime, thirdWavesStartTime + 100, false);
        wave.mySameHugAngle = randomTrue;
        wave.mySameHugSize = randomTrue;

        ventSetup.myWavesMap.set("Give_Us_A_Hug_4", wave);
        ventSetup.myNextWavesMap.set("Give_Us_A_Hug_4", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Give_Us_A_Hug_4",
            new NextWaveChanceBoosterSetup(thirdWavesStartTimeGroup, boosterGroup5, boosterGroupName5, dampingOverLastPick5, boostMultiplier5 * 2 * 20 / 30, boostDivider5, boostValueOnReset5));
    }

    /*
    {
        let wave = new GiveUsAHugSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 1], [1, 3], 10, 100, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.myFirstCloneInTheMiddle = true;
        wave.myTimeBetweenClones = timeBetweenClonesVeryHard;
        wave.myDoneDelay = doneDelayVeryHard;

        wave.myHugSize = new RangeValueOverTime([3, 3], [3, 3], 10, 100, true);
        wave.myHugAngle = new RangeValueOverTime([80, 100], [80, 100], 10, 100, false);
        wave.mySameHugAngle = randomTrue;
        wave.mySameHugSize = randomTrue;
        wave.myHugClonesSameDistance = -1;

        ventSetup.myWavesMap.set("Give_Us_A_Hug_Distance", wave);
        ventSetup.myNextWavesMap.set("Give_Us_A_Hug_Distance", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Give_Us_A_Hug_Distance",
            new NextWaveChanceBoosterSetup(thirdWavesStartTimeGroup, boosterGroup3, boosterGroupName3, dampingOverLastPick3, boostMultiplier3, boostDivider3, boostValueOnReset3));
    }
    */

    {
        let wave = new GiveUsAHugSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 1], [1, 4], fourthGroupChance, fourthGroupChance + 150, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myFirstCloneInTheMiddle = true;
        wave.myTimeBetweenClones = timeBetweenClonesMegaHard;
        wave.myDoneDelay = doneDelayMegaHard;

        wave.myHugSize = 5;
        wave.myHugAngle = 180;

        ventSetup.myWavesMap.set("Give_Us_A_Hug_Cross", wave);
        ventSetup.myNextWavesMap.set("Give_Us_A_Hug_Cross", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Give_Us_A_Hug_Cross",
            new NextWaveChanceBoosterSetup(fourthWavesStartTimeGroup, boosterGroup5, boosterGroupName5, dampingOverLastPick5, boostMultiplier5 * 2 * 10 / 30, boostDivider5, boostValueOnReset5));
    }

    // MAN IN THE MIDDLE

    {
        let wave = new ManInTheMiddleSetup();

        wave.myWavesCount = new RangeValueOverTime([2, 3], [2, 4], 10, 150, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myTimeBetweenWaves = new RangeValueOverTime([1.5, 2], [1, 1.5], 10, 150, false);
        wave.myTimeBeforeOpposite = new RangeValueOverTime([1.5, 2], [1, 1.5], 10, 150, false);
        wave.myAllSameTimes = randomVeryTrue;
        wave.myOppositeTimeLessThanTimeBetweenWaves = -1;
        wave.myDoneDelay = doneDelayHard;

        ventSetup.myWavesMap.set("Man_In_The_Middle", wave);
        ventSetup.myNextWavesMap.set("Man_In_The_Middle", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Man_In_The_Middle",
            new NextWaveChanceBoosterSetup(firstWavesStartTimeGroup, boosterGroup2, boosterGroupName2, dampingOverLastPick2, boostMultiplier2 * 2 * 20 / 30, boostDivider2, boostValueOnReset2));
    }

    {
        let wave = new ManInTheMiddleSetup();

        wave.myWavesCount = new RangeValueOverTime([2, 3], [2, 4], secondWavesStartTime, secondWavesStartTime + 100, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myTimeBeforeOpposite = new RangeValueOverTime([1, 1.5], [0.7, 1], secondWavesStartTime, secondWavesStartTime + 150, false);
        wave.myTimeBetweenWaves = new RangeValueOverTime([1.5, 2], [1, 1.5], 10, 150, false);
        wave.myOppositeTimeAsTimeBetweenWaves = -1;
        wave.mySameOppositeTimeBetweenWaves = -1;
        wave.mySameTimeBetweenWaves = -1;
        wave.myAngleBetweenWaves = new RangeValue([40, 140]);
        wave.myDoneDelay = doneDelayVeryHard;

        ventSetup.myWavesMap.set("Man_In_The_Middle_Everywhere", wave);
        ventSetup.myNextWavesMap.set("Man_In_The_Middle_Everywhere", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Man_In_The_Middle_Everywhere",
            new NextWaveChanceBoosterSetup(secondWavesStartTimeGroup, boosterGroup4, boosterGroupName4, dampingOverLastPick4, boostMultiplier4, boostDivider4, boostValueOnReset4));
    }

    {
        let wave = new ManInTheMiddleSetup();

        wave.myWavesCount = new RangeValueOverTime([2, 2], [2, 3], thirdWavesStartTime, thirdWavesStartTime + 100, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myTimeBetweenWaves = new RangeValueOverTime([1, 1.5], [0.7, 1], secondWavesStartTime, secondWavesStartTime + 150, false);
        wave.myTimeBeforeOpposite = new RangeValueOverTime([1, 1.5], [0.7, 1], secondWavesStartTime, secondWavesStartTime + 150, false);
        wave.myAllSameTimes = randomVeryTrue;
        wave.myOppositeTimeLessThanTimeBetweenWaves = -1;
        wave.myDoneDelay = doneDelayVeryHard;

        wave.myWavesSetup.push([subOneWave, 2, "I_Am_Here_One"]);
        wave.myWavesSetup.push([subHereWave, 2, "I_Am_Here"]);
        wave.myWavesSetup.push([subQueueWave, 8, "Queue_For_You"]);
        wave.myWavesSetupPrecompute = randomTrue;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("Man_In_The_Middle_Waves", wave);
        ventSetup.myNextWavesMap.set("Man_In_The_Middle_Waves", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Man_In_The_Middle_Waves",
            new NextWaveChanceBoosterSetup(thirdWavesStartTimeGroup, boosterGroup3, boosterGroupName3, dampingOverLastPick3, boostMultiplier3, boostDivider3, boostValueOnReset3));
    }

    {
        let wave = new ManInTheMiddleSetup();

        wave.myWavesCount = new RangeValueOverTime([2, 2], [2, 3], thirdWavesStartTime, thirdWavesStartTime + 100, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myTimeBeforeOpposite = new RangeValueOverTime([1, 1.5], [0.7, 1], secondWavesStartTime, secondWavesStartTime + 150, false);
        wave.myTimeBetweenWaves = new RangeValueOverTime([1.5, 2], [1, 1.5], 10, 150, false);
        wave.myOppositeTimeAsTimeBetweenWaves = -1;
        wave.mySameOppositeTimeBetweenWaves = -1;
        wave.mySameTimeBetweenWaves = -1;
        wave.myAngleBetweenWaves = new RangeValue([40, 140]);
        wave.myDoneDelay = doneDelayVeryHard;

        wave.myWavesSetup.push([subHereWave, 1, "I_Am_Here"]);
        wave.myWavesSetup.push([subQueueWave, 2, "Queue_For_You"]);
        wave.myWavesSetupPrecompute = randomTrue;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("Man_In_The_Middle_Everywhere_Waves", wave);
        ventSetup.myNextWavesMap.set("Man_In_The_Middle_Everywhere_Waves", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Man_In_The_Middle_Everywhere_Waves",
            new NextWaveChanceBoosterSetup(thirdWavesStartTimeGroup, boosterGroup4, boosterGroupName4, dampingOverLastPick4, boostMultiplier4, boostDivider4, boostValueOnReset4));
    }

    {
        let wave = new ManInTheMiddleSetup();

        wave.myWavesCount = new RangeValueOverTime([2, 3], [2, 4], thirdWavesStartTime, thirdWavesStartTime + 100, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myTimeBetweenWaves = timeBetweenClones;
        wave.myTimeBeforeOpposite = timeBetweenClones;
        wave.myAllSameTimes = randomVeryTrue;
        wave.myOppositeTimeLessThanTimeBetweenWaves = -1;
        wave.myDoneDelay = doneDelayHard;

        wave.myWavesSetup.push([subGiveUsAHug2Wave, 1, "Give Us A Hug 2"]);
        wave.myWavesSetupPrecompute = randomRandom;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("Man_In_The_Middle_GUAH2", wave);
        ventSetup.myNextWavesMap.set("Man_In_The_Middle_GUAH2", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Man_In_The_Middle_GUAH2",
            new NextWaveChanceBoosterSetup(thirdWavesStartTimeGroup, boosterGroup5, boosterGroupName5, dampingOverLastPick5, boostMultiplier5 * 2 * 20 / 30, boostDivider5, boostValueOnReset5));
    }

    {
        let wave = new ManInTheMiddleSetup();

        wave.myWavesCount = new RangeValueOverTime([2, 3], [2, 4], thirdWavesStartTime, thirdWavesStartTime + 100, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myTimeBeforeOpposite = timeBetweenClones;
        wave.myTimeBetweenWaves = timeBetweenClonesHard;
        wave.myOppositeTimeAsTimeBetweenWaves = -1;
        wave.mySameOppositeTimeBetweenWaves = -1;
        wave.mySameTimeBetweenWaves = -1;
        wave.myAngleBetweenWaves = new RangeValue([40, 140]);
        wave.myDoneDelay = doneDelayHard;

        wave.myWavesSetup.push([subGiveUsAHug2Wave, 1, "Give Us A Hug 2"]);
        wave.myWavesSetupPrecompute = randomRandom;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("Man_In_The_Middle_Everywhere_GUAH2", wave);
        ventSetup.myNextWavesMap.set("Man_In_The_Middle_Everywhere_GUAH2", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Man_In_The_Middle_Everywhere_GUAH2",
            new NextWaveChanceBoosterSetup(thirdWavesStartTimeGroup, boosterGroup5, boosterGroupName5, dampingOverLastPick5, boostMultiplier5 * 2 * 20 / 30, boostDivider5, boostValueOnReset5));
    }

    {
        let wave = new ManInTheMiddleSetup();

        wave.myWavesCount = new RangeValueOverTime([2, 2], [2, 3], fourthWavesStartTime, fourthWavesStartTime + 100, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myTimeBeforeOpposite = timeBetweenClonesHard;
        wave.myTimeBetweenWaves = timeBetweenClonesHard;
        wave.myAllSameTimes = randomVeryTrue;
        wave.myOppositeTimeLessThanTimeBetweenWaves = -1;
        wave.myDoneDelay = doneDelayHard;

        wave.myWavesSetup.push([subGiveUsAHug3Wave, 1, "Give Us A Hug 3"]);
        wave.myWavesSetupPrecompute = randomRandom;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("Man_In_The_Middle_GUAH3", wave);
        ventSetup.myNextWavesMap.set("Man_In_The_Middle_GUAH3", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Man_In_The_Middle_GUAH3",
            new NextWaveChanceBoosterSetup(fourthWavesStartTimeGroup, boosterGroup5, boosterGroupName5, dampingOverLastPick5, boostMultiplier5 * 2 * 10 / 30, boostDivider5, boostValueOnReset5));
    }

    {
        let wave = new ManInTheMiddleSetup();

        wave.myWavesCount = new RangeValueOverTime([2, 2], [2, 3], fourthWavesStartTime, fourthWavesStartTime + 100, true);
        wave.myWaveStartAngle = waveStartAngle;
        wave.myTimeBeforeOpposite = timeBetweenClonesHard;
        wave.myTimeBetweenWaves = timeBetweenClonesVeryHard;
        wave.myOppositeTimeAsTimeBetweenWaves = -1;
        wave.mySameOppositeTimeBetweenWaves = -1;
        wave.mySameTimeBetweenWaves = -1;
        wave.myAngleBetweenWaves = new RangeValue([40, 140]);
        wave.myDoneDelay = doneDelayVeryHard;

        wave.myWavesSetup.push([subGiveUsAHug3Wave, 1, "Give Us A Hug 3"]);
        wave.myWavesSetupPrecompute = randomRandom;
        wave.myWavesSetupPickOne = randomVeryTrue;

        ventSetup.myWavesMap.set("Man_In_The_Middle_Everywhere_GUAH3", wave);
        ventSetup.myNextWavesMap.set("Man_In_The_Middle_Everywhere_GUAH3", nextWavesSetup);
        ventSetup.myNextWaveChanceBoosterSetupMap.set("Man_In_The_Middle_Everywhere_GUAH3",
            new NextWaveChanceBoosterSetup(fourthWavesStartTimeGroup, boosterGroup5, boosterGroupName5, dampingOverLastPick5, boostMultiplier5 * 2 * 10 / 30, boostDivider5, boostValueOnReset5));
    }

    ventSetup.myFirstWave = "Zero";

    return ventSetup;
};
TrialState.prototype._firstVentSetup = function () {
    let ventSetup = new VentSetup();

    ventSetup.myIsEndless = false;
    ventSetup.myClonesToDismiss = 0;
    ventSetup.myVentDuration = 80;

    ventSetup.myBreakSetup.myBreakDuration = new RangeValue([4, 5]);
    ventSetup.myBreakSetup.myBreakTimeCooldown = new RangeValueOverTime([30, 40], [20, 30], 10, 30, false);
    ventSetup.myBreakSetup.myBreakCloneCooldown = 5;

    ventSetup.mySmallBreakSetup.myBreakDuration = new RangeValueOverTime([2, 3], [1.5, 2.5], 30, 60, false);
    ventSetup.mySmallBreakSetup.myBreakTimeCooldown = new RangeValueOverTime([40, 50], [7, 12], 10, 45, false);
    ventSetup.mySmallBreakSetup.myBreakCloneCooldown = new ValueOverTime(5, 3, 45, 50, true);

    {
        let wave = new IAmHereWaveSetup();

        wave.myClonesCount = 1;
        wave.myWaveStartAngle = 0;
        wave.myDoneDelay = new RangeValue([5, 6], false);
        wave.myFirstCloneInTheMiddle = true;
        wave.myRefDirection = [0, 0, -1];

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("I_Am_Here_Warm_Up", 100);

        ventSetup.myWavesMap.set("I_Am_Here_Start", wave);
        ventSetup.myNextWavesMap.set("I_Am_Here_Start", nextWavesSetup);
    }

    {
        let wave = new IAmHereWaveSetup();

        wave.myClonesCount = 1;
        wave.myWaveStartAngle = new RangeValueOverTime([10, 20], [20, 40], 10, 30, false);
        wave.myDoneDelay = new RangeValueOverTime([5, 6], [2.5, 4], 10, 30, false);
        wave.myFirstCloneInTheMiddle = true;
        wave.myRefDirection = [0, 0, -1];

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("I_Am_Here_Warm_Up", 100, 0, 30);
        nextWavesSetup.addWave("I_Am_Here_Side", 100, 30, null);

        ventSetup.myWavesMap.set("I_Am_Here_Warm_Up", wave);
        ventSetup.myNextWavesMap.set("I_Am_Here_Warm_Up", nextWavesSetup);
    }

    {
        let wave = new IAmHereWaveSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 1], [1, 3], 30, 65, true);
        wave.myWaveStartAngle = new RangeValueOverTime([10, 30], [10, 50], 30, 70, false);
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.myMinAngleBetweenClones = 10;
        wave.myTimeBetweenClones = new RangeValueOverTime([2, 3], [1, 2], 30, 70, false);
        wave.myDoneDelay = new RangeValueOverTime([2.5, 4], [2.5, 3], 30, 70, false);
        wave.myFirstCloneInTheMiddle = true;

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", new ValueOverTime(1000000, 150, 60, 70), 60);

        ventSetup.myWavesMap.set("I_Am_Here_Front", wave);
        ventSetup.myNextWavesMap.set("I_Am_Here_Front", nextWavesSetup);
    }

    {
        let wave = new IAmHereWaveSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 1], [1, 3], 30, 65, true);
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.myMinAngleBetweenClones = 10;
        wave.myWaveStartAngle = new RangeValueOverTime([70, 110], [60, 150], 30, 70, false);
        wave.myTimeBetweenClones = new RangeValueOverTime([2, 3], [1, 2], 30, 70, false);
        wave.myDoneDelay = new RangeValueOverTime([2.5, 4], [2.5, 3], 30, 70, false);
        wave.myFirstCloneInTheMiddle = true;

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("I_Am_Here_Front", 75);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", new ValueOverTime(1000000, 150, 60, 70), 60);

        ventSetup.myWavesMap.set("I_Am_Here_Side", wave);
        ventSetup.myNextWavesMap.set("I_Am_Here_Side", nextWavesSetup);
    }

    {
        let wave = new IAmEverywhereWaveSetup();

        wave.myWavesCount = new RangeValueOverTime([3, 3], [3, 4], 65, 70, true);
        wave.myAngleBetweenWaves = new RangeValueOverTime([60, 110], [60, 110], 65, 75, false);
        wave.myTimeBetweenWaves = new RangeValueOverTime([2, 3], [1.5, 2.5], 65, 75, false);
        wave.myDoneDelay = new RangeValueOverTime([3, 4], [2.5, 4], 65, 75, false);
        wave.myWaveStartAngle = new RangeValueOverTime([60, 110], [60, 110], 65, 75, false);

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("I_Am_Here_Front", 75);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);

        ventSetup.myWavesMap.set("I_Am_Everywhere", wave);
        ventSetup.myNextWavesMap.set("I_Am_Everywhere", nextWavesSetup);
    }

    ventSetup.myFirstWave = "I_Am_Here_Start";

    return ventSetup;
};
TrialState.prototype._secondVentSetup = function () {
    let ventSetup = new VentSetup();

    ventSetup.myIsEndless = false;
    ventSetup.myClonesToDismiss = 0;
    ventSetup.myVentDuration = 95;

    ventSetup.myBreakSetup.myBreakDuration = new RangeValue([4, 5]);
    ventSetup.myBreakSetup.myBreakTimeCooldown = new RangeValueOverTime([30, 35], [30, 35], 10, 30, false);
    ventSetup.myBreakSetup.myBreakCloneCooldown = 5;

    ventSetup.mySmallBreakSetup.myBreakDuration = new RangeValueOverTime([2, 3], [1.5, 2.5], 30, 75, false);
    ventSetup.mySmallBreakSetup.myBreakTimeCooldown = new RangeValueOverTime([40, 50], [8, 12], 10, 45, false);
    ventSetup.mySmallBreakSetup.myBreakCloneCooldown = 3;

    ventSetup.myCloneRotationSetup.myTiltAngle = new RangeValueOverTime([0, 10], [0, 15], 40, 75, false);
    ventSetup.myCloneRotationSetup.myTiltChance = new RangeValueOverTime([1, 6], [1, 3], 40, 75, true);
    ventSetup.myCloneRotationSetup.myTiltStartTime = 40;

    {
        let wave = new IAmHereWaveSetup();

        wave.myClonesCount = 1;
        wave.myWaveStartAngle = new RangeValueOverTime([10, 30], [10, 50], 10, 70, false);
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.myMinAngleBetweenClones = 10;
        wave.myTimeBetweenClones = new RangeValueOverTime([2, 3], [1, 2], 0, 70, false);
        wave.myDoneDelay = new RangeValueOverTime([2, 4], [2, 2.5], 10, 70, false);
        wave.myFirstCloneInTheMiddle = true;
        wave.myRefDirection = [0, 0, -1];

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("I_Am_Here_Warm_Up", 100, 0, 20);
        nextWavesSetup.addWave("Merry_Go_Round_Left", 100, 20);
        nextWavesSetup.addWave("Merry_Go_Round_Right", 100, 20);

        ventSetup.myWavesMap.set("I_Am_Here_Warm_Up", wave);
        ventSetup.myNextWavesMap.set("I_Am_Here_Warm_Up", nextWavesSetup);
    }

    {
        let wave = new IAmHereWaveSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 1], [1, 3], 0, 30, true);
        wave.myWaveStartAngle = new RangeValueOverTime([10, 30], [10, 50], 10, 70, false);
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.myMinAngleBetweenClones = 10;
        wave.myTimeBetweenClones = new RangeValueOverTime([2, 3], [1, 2], 0, 70, false);
        wave.myDoneDelay = new RangeValueOverTime([2, 4], [2, 2.5], 10, 70, false);
        wave.myFirstCloneInTheMiddle = true;

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 125);
        nextWavesSetup.addWave("Merry_Go_Round_Left", 125);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 125, 50);
        nextWavesSetup.addWave("Queue_For_You", new ValueOverTime(1000000, 150, 50, 60), 50);

        ventSetup.myWavesMap.set("I_Am_Here_Front", wave);
        ventSetup.myNextWavesMap.set("I_Am_Here_Front", nextWavesSetup);
    }

    {
        let wave = new IAmHereWaveSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 1], [1, 3], 0, 30, true);
        wave.myWaveStartAngle = new RangeValueOverTime([70, 110], [60, 150], 10, 70, false);
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.myMinAngleBetweenClones = 10;
        wave.myTimeBetweenClones = new RangeValueOverTime([2, 3], [1, 2], 0, 70, false);
        wave.myDoneDelay = new RangeValueOverTime([2, 4], [2, 2.5], 10, 70, false);
        wave.myFirstCloneInTheMiddle = true;

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 125);
        nextWavesSetup.addWave("Merry_Go_Round_Left", 125);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 125, 50);
        nextWavesSetup.addWave("Queue_For_You", new ValueOverTime(1000000, 150, 50, 60), 50);

        ventSetup.myWavesMap.set("I_Am_Here_Side", wave);
        ventSetup.myNextWavesMap.set("I_Am_Here_Side", nextWavesSetup);
    }

    {
        let wave = new IAmEverywhereWaveSetup();

        wave.myWavesCount = new RangeValue([3, 4]);
        wave.myAngleBetweenWaves = new RangeValueOverTime([60, 110], [60, 130], 20, 60, false);
        wave.myTimeBetweenWaves = new RangeValueOverTime([2, 3], [1.5, 2.25], 0, 70, false);
        wave.myDoneDelay = new RangeValueOverTime([3, 4], [2.5, 4], 10, 70, false);
        wave.myWaveStartAngle = new RangeValueOverTime([60, 110], [60, 130], 20, 60, false);

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 125);
        nextWavesSetup.addWave("Merry_Go_Round_Left", 125);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("Queue_For_You", new ValueOverTime(1000000, 150, 50, 60), 50);

        ventSetup.myWavesMap.set("I_Am_Everywhere", wave);
        ventSetup.myNextWavesMap.set("I_Am_Everywhere", nextWavesSetup);
    }

    {
        let wave = new MerryGoRoundSetup();

        wave.myWavesCount = new RangeValueOverTime([4, 5], [4, 6], 30, 60, true);
        wave.myAngleBetweenWaves = new RangeValue([15, 25]);
        wave.myTimeBetweenWaves = new RangeValueOverTime([2, 3], [0.75, 1.25], 0, 70, false);
        wave.myWaveStartAngle = new RangeValueOverTime([10, 30], [10, 120], 20, 70, false);
        wave.mySameTimeBetweenWaves = 1;
        wave.myDoneDelay = new RangeValueOverTime([2, 4], [2, 2.5], 10, 70, false);
        wave.myWaveDirection = 1;

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 125, 50);
        nextWavesSetup.addWave("Queue_For_You", new ValueOverTime(1000000, 150, 50, 60), 50);

        ventSetup.myWavesMap.set("Merry_Go_Round_Left", wave);
        ventSetup.myNextWavesMap.set("Merry_Go_Round_Left", nextWavesSetup);
    }

    {
        let wave = new MerryGoRoundSetup();

        wave.myWavesCount = new RangeValueOverTime([4, 5], [4, 6], 30, 60, true);
        wave.myAngleBetweenWaves = new RangeValue([15, 25]);
        wave.myTimeBetweenWaves = new RangeValueOverTime([2, 3], [0.75, 1.25], 0, 70, false);
        wave.myWaveStartAngle = new RangeValueOverTime([10, 30], [10, 120], 20, 70, false);
        wave.mySameTimeBetweenWaves = 1;
        wave.myDoneDelay = new RangeValueOverTime([2, 4], [2, 2.5], 10, 70, false);
        wave.myWaveDirection = -1;

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 125, 50);
        nextWavesSetup.addWave("Queue_For_You", new ValueOverTime(1000000, 150, 50, 60), 50);

        ventSetup.myWavesMap.set("Merry_Go_Round_Right", wave);
        ventSetup.myNextWavesMap.set("Merry_Go_Round_Right", nextWavesSetup);
    }

    {
        let wave = new QueueForYouWaveSetup();

        wave.myClonesCount = new RangeValueOverTime([3, 3], [2, 4], 55, 60, true);
        wave.myWaveStartAngle = new RangeValue([25, 120]);
        wave.myTimeBetweenClones = new RangeValueOverTime([2, 3], [1, 2], 0, 70, false);
        wave.myDoneDelay = new RangeValueOverTime([2, 4], [2, 2.5], 10, 70, false);
        wave.mySameTimeBetweenClones = 1;

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 125);
        nextWavesSetup.addWave("Merry_Go_Round_Left", 125);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 125, 50);
        nextWavesSetup.addWave("Queue_For_You", 100);

        ventSetup.myWavesMap.set("Queue_For_You", wave);
        ventSetup.myNextWavesMap.set("Queue_For_You", nextWavesSetup);
    }

    ventSetup.myFirstWave = "I_Am_Here_Warm_Up";

    return ventSetup;
};
TrialState.prototype._thirdVentSetup = function () {
    let ventSetup = new VentSetup();

    ventSetup.myIsEndless = false;
    ventSetup.myClonesToDismiss = 0;
    ventSetup.myVentDuration = 110;

    ventSetup.myBreakSetup.myBreakDuration = new RangeValue([3, 4]);
    ventSetup.myBreakSetup.myBreakTimeCooldown = new RangeValueOverTime([40, 45], [30, 35], 10, 30, false);
    ventSetup.myBreakSetup.myBreakCloneCooldown = 5;

    ventSetup.mySmallBreakSetup.myBreakDuration = new RangeValueOverTime([2, 3], [1.5, 2.5], 30, 75, false);
    ventSetup.mySmallBreakSetup.myBreakTimeCooldown = new RangeValueOverTime([40, 50], [8, 12], 10, 45, false);
    ventSetup.mySmallBreakSetup.myBreakCloneCooldown = 3;

    ventSetup.myCloneRotationSetup.mySpinSpeed = new RangeValue([4, 6], false);
    ventSetup.myCloneRotationSetup.mySpinChance = new RangeValueOverTime([1, 12], [1, 4], 50, 95, true);
    ventSetup.myCloneRotationSetup.mySpinStartTime = 50;

    ventSetup.myCloneRotationSetup.myTiltAngle = new RangeValueOverTime([0, 10], [0, 15], 30, 60, false);
    ventSetup.myCloneRotationSetup.myTiltChance = new RangeValueOverTime([1, 5], [1, 2], 30, 70, true);
    ventSetup.myCloneRotationSetup.myTiltStartTime = 30;

    {
        let wave = new ZeroWaveSetup();

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
        nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 100);
        nextWavesSetup.addWave("Queue_For_You", 100);

        ventSetup.myWavesMap.set("Zero", wave);
        ventSetup.myNextWavesMap.set("Zero", nextWavesSetup);
    }

    {
        let wave = new IAmHereWaveSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 3], [1, 5], 10, 70, true);
        wave.myWaveStartAngle = new RangeValueOverTime([10, 30], [10, 50], 10, 70, false);
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.myMinAngleBetweenClones = 10;
        wave.myTimeBetweenClones = new RangeValueOverTime([2, 3], [1, 2], 10, 70, false);
        wave.myDoneDelay = new RangeValueOverTime([2, 4], [2, 2.75], 10, 70, false);
        wave.myFirstCloneInTheMiddle = true;

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
        nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 100);
        nextWavesSetup.addWave("Queue_For_You", 100);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 30, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 100, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 83, 93);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 60, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 150, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 100, 110);

        ventSetup.myWavesMap.set("I_Am_Here_Front", wave);
        ventSetup.myNextWavesMap.set("I_Am_Here_Front", nextWavesSetup);
    }

    {
        let wave = new IAmHereWaveSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 3], [1, 5], 10, 70, true);
        wave.myWaveStartAngle = new RangeValueOverTime([70, 110], [60, 150], 10, 70, false);
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.myMinAngleBetweenClones = 10;
        wave.myTimeBetweenClones = new RangeValueOverTime([2, 3], [1, 2], 10, 70, false);
        wave.myDoneDelay = new RangeValueOverTime([2, 4], [2, 2.75], 10, 70, false);
        wave.myFirstCloneInTheMiddle = true;

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
        nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 100);
        nextWavesSetup.addWave("Queue_For_You", 100);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 30, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 100, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 83, 93);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 60, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 150, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 100, 110);

        ventSetup.myWavesMap.set("I_Am_Here_Side", wave);
        ventSetup.myNextWavesMap.set("I_Am_Here_Side", nextWavesSetup);
    }

    {
        let wave = new IAmEverywhereWaveSetup();

        wave.myWavesCount = new RangeValueOverTime([3, 4], [3, 5], 10, 70, true);
        wave.myAngleBetweenWaves = new RangeValueOverTime([60, 110], [60, 150], 10, 70, false);
        wave.myTimeBetweenWaves = new RangeValueOverTime([2, 3], [1.5, 2.25], 10, 70, false);
        wave.myDoneDelay = new RangeValueOverTime([3, 4], [2.5, 3], 10, 70, false);
        wave.myWaveStartAngle = new RangeValueOverTime([60, 110], [60, 150], 10, 70, false);

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
        nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("Queue_For_You", 100);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 30, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 100, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 83, 93);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 60, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 150, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 100, 110);

        ventSetup.myWavesMap.set("I_Am_Everywhere", wave);
        ventSetup.myNextWavesMap.set("I_Am_Everywhere", nextWavesSetup);
    }

    {
        let wave = new MerryGoRoundSetup();

        wave.myWavesCount = new RangeValueOverTime([3, 5], [4, 7], 10, 60, true);
        wave.myAngleBetweenWaves = new RangeValue([15, 25]);
        wave.myTimeBetweenWaves = new RangeValueOverTime([2, 3], [0.75, 1.25], 10, 70, false);
        wave.myWaveStartAngle = new RangeValueOverTime([10, 60], [10, 140], 10, 70, false);
        wave.mySameTimeBetweenWaves = 1;
        wave.myDoneDelay = new RangeValueOverTime([2, 4], [2, 2.75], 10, 70, false);
        wave.myWaveDirection = 1;

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 100);
        nextWavesSetup.addWave("Queue_For_You", 100);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 30, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 100, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 83, 93);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 60, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 150, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 100, 110);

        ventSetup.myWavesMap.set("Merry_Go_Round_Left", wave);
        ventSetup.myNextWavesMap.set("Merry_Go_Round_Left", nextWavesSetup);
    }

    {
        let wave = new MerryGoRoundSetup();

        wave.myWavesCount = new RangeValueOverTime([3, 5], [4, 7], 10, 60, true);
        wave.myAngleBetweenWaves = new RangeValue([15, 25]);
        wave.myTimeBetweenWaves = new RangeValueOverTime([2, 3], [0.75, 1.25], 10, 70, false);
        wave.myWaveStartAngle = new RangeValueOverTime([10, 60], [10, 140], 10, 70, false);
        wave.mySameTimeBetweenWaves = 1;
        wave.myDoneDelay = new RangeValueOverTime([2, 4], [2, 2.75], 10, 70, false);
        wave.myWaveDirection = -1;

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 100);
        nextWavesSetup.addWave("Queue_For_You", 100);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 30, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 100, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 83, 93);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 60, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 150, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 100, 110);

        ventSetup.myWavesMap.set("Merry_Go_Round_Right", wave);
        ventSetup.myNextWavesMap.set("Merry_Go_Round_Right", nextWavesSetup);
    }

    {
        let wave = new QueueForYouWaveSetup();

        wave.myClonesCount = new RangeValueOverTime([2, 3], [2, 5], 10, 70, true);
        wave.myWaveStartAngle = new RangeValueOverTime([10, 60], [10, 140], 10, 70, false);
        wave.myTimeBetweenClones = new RangeValueOverTime([2, 3], [1, 2], 10, 70, false);
        wave.myDoneDelay = new RangeValueOverTime([2, 4], [2, 2.75], 10, 70, false);
        wave.mySameTimeBetweenClones = new RangeValueOverTime([1, 1], [-0.5, 1], 10, 70, false); // >= 0 means true

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
        nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 100);
        nextWavesSetup.addWave("Queue_For_You", 100);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 30, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 100, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 83, 93);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 60, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 150, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 100, 110);

        ventSetup.myWavesMap.set("Queue_For_You", wave);
        ventSetup.myNextWavesMap.set("Queue_For_You", nextWavesSetup);
    }

    {
        let wave = new GiveUsAHugSetup();

        wave.myClonesCount = new RangeValueOverTime([1, 1], [2, 3], 40, 50, true);
        wave.mySpawnConeAngle = new RangeValue([20, 40]);
        wave.myMinAngleBetweenClones = 10;
        wave.myWaveStartAngle = new RangeValueOverTime([0, 0], [10, 80], 40, 70, false);
        wave.myTimeBetweenClones = new RangeValueOverTime([2, 3], [2, 3], 10, 70, false);
        wave.myDoneDelay = new RangeValueOverTime([2.5, 4], [2.5, 3], 10, 70, false);
        wave.myFirstCloneInTheMiddle = true;

        wave.myHugSize = new RangeValueOverTime([2, 2], [2, 2], 40, 50, true);
        wave.myHugAngle = new RangeValueOverTime([30, 40], [30, 50], 40, 60, false);

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
        nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 100);
        nextWavesSetup.addWave("Queue_For_You", 100);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 60, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 150, 70);
        nextWavesSetup.addWave("Man_In_The_Middle", 1000000, 100, 110);

        ventSetup.myWavesMap.set("Give_Us_A_Hug", wave);
        ventSetup.myNextWavesMap.set("Give_Us_A_Hug", nextWavesSetup);
    }

    {
        let wave = new ManInTheMiddleSetup();

        wave.myWavesCount = new RangeValueOverTime([3, 3], [3, 4], 70, 85, true);
        wave.myTimeBeforeStart = new RangeValueOverTime([1.5, 2], [1.5, 2], 70, 85, false);
        wave.myTimeBetweenWaves = new RangeValueOverTime([1.5, 2], [1, 1.5], 70, 85, false);
        wave.myWaveStartAngle = new RangeValueOverTime([10, 140], [10, 140], 70, 85, false);
        wave.myDoneDelay = new RangeValueOverTime([3, 4], [2.5, 3], 10, 70, false);

        let nextWavesSetup = new NextWavesSetup();
        nextWavesSetup.addWave("Merry_Go_Round_Right", 100);
        nextWavesSetup.addWave("Merry_Go_Round_Left", 100);
        nextWavesSetup.addWave("I_Am_Here_Front", 50);
        nextWavesSetup.addWave("I_Am_Here_Side", 100);
        nextWavesSetup.addWave("I_Am_Everywhere", 100);
        nextWavesSetup.addWave("Queue_For_You", 100);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 30, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 100, 40);
        nextWavesSetup.addWave("Give_Us_A_Hug", 1000000, 83, 93);

        ventSetup.myWavesMap.set("Man_In_The_Middle", wave);
        ventSetup.myNextWavesMap.set("Man_In_The_Middle", nextWavesSetup);
    }

    ventSetup.myFirstWave = "Zero";

    return ventSetup;
};
//# sourceMappingURL=enough IS enough-bundle.js.map